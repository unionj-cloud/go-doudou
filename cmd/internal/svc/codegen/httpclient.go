package codegen

import (
	"bufio"
	"bytes"
	"github.com/iancoleman/strcase"
	"github.com/sirupsen/logrus"
	"github.com/unionj-cloud/go-doudou/v2/toolkit/astutils"
	"github.com/unionj-cloud/go-doudou/v2/toolkit/copier"
	v3helper "github.com/unionj-cloud/go-doudou/v2/toolkit/openapi/v3"
	"github.com/unionj-cloud/go-doudou/v2/version"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var clientTmpl = `/**
* Generated by go-doudou {{.Version}}.
* Don't edit!
*/
package client

import (
	"context"
	"encoding/json"
	"github.com/go-resty/resty/v2"
	"github.com/pkg/errors"
	"github.com/klauspost/compress/gzip"
	"github.com/unionj-cloud/go-doudou/v2/toolkit/fileutils"
	"github.com/unionj-cloud/go-doudou/v2/toolkit/stringutils"
	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
	v3 "github.com/unionj-cloud/go-doudou/v2/toolkit/openapi/v3"
	"github.com/opentracing-contrib/go-stdlib/nethttp"
	"github.com/opentracing/opentracing-go"
	"io"
	"net/http"
	"mime/multipart"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"{{.VoPackage}}"
	"{{.DtoPackage}}"
)

type {{.Meta.Name}}Client struct {
	provider registry.IServiceProvider
	client   *resty.Client
	rootPath string
}

func (receiver *{{.Meta.Name}}Client) SetRootPath(rootPath string) {
	receiver.rootPath = rootPath
}

func (receiver *{{.Meta.Name}}Client) SetProvider(provider registry.IServiceProvider) {
	receiver.provider = provider
}

func (receiver *{{.Meta.Name}}Client) SetClient(client *resty.Client) {
	receiver.client = client
}

{{- range $m := .Meta.Methods }}
	func (receiver *{{$.Meta.Name}}Client) {{$m.Name}}(ctx context.Context, _headers map[string]string, {{- range $i, $p := $m.Params}}
	{{- if ne $p.Type "context.Context" }}
	{{- $p.Name}} {{$p.Type}},
	{{- end }}
    {{- end }} options Options) (_resp *resty.Response, {{- range $i, $r := $m.Results}}
                     {{- if $i}},{{end}}
                     {{- $r.Name}} {{$r.Type}}
                     {{- end }}) {
		var _err error
		_urlValues := url.Values{}
		_req := receiver.client.R()
		if len(_headers) > 0 {
			_req.SetHeaders(_headers)
		}
		_req.SetContext(ctx)
		{{- range $p := $m.Params }}
		{{- if $p.IsPathVariable }}
		{{- if IsEnum $p }}
		_req.SetPathParam("{{$p.Name}}", {{$p.Name}}.StringGetter())
		{{- else }}
		_req.SetPathParam("{{$p.Name}}", fmt.Sprintf("%v", {{$p.Name}}))
		{{- end }}
		{{- else if or (eq $p.Type "*multipart.FileHeader") (eq $p.Type "[]*multipart.FileHeader") }}
		{{- if contains $p.Type "["}}
		for _, _fh := range {{$p.Name}} {
			_f, _err := _fh.Open()
			if _err != nil {
				{{- range $r := $m.Results }}
					{{- if eq $r.Type "error" }}
				{{ $r.Name }} = errors.Wrap(_err, "error")
					{{- end }}
				{{- end }}
				return
			}
			_req.SetFileReader("{{$p.Name}}", _fh.Filename, _f)
		}
		{{- else}}
		if _f, _err := {{$p.Name}}.Open(); _err != nil {
			{{- range $r := $m.Results }}
				{{- if eq $r.Type "error" }}
			{{ $r.Name }} = errors.Wrap(_err, "error")
				{{- end }}
			{{- end }}
			return
		} else {
			_req.SetFileReader("{{$p.Name}}", {{$p.Name}}.Filename, _f)
		}
		{{- end}}
		{{- else if or (eq $p.Type "v3.FileModel") (eq $p.Type "*v3.FileModel") (eq $p.Type "[]v3.FileModel") (eq $p.Type "*[]v3.FileModel") (eq $p.Type "...v3.FileModel") }}
		{{- if isSlice $p.Type }}
		{{- if isOptional $p.Type }}
		if {{$p.Name}} != nil {
			{{- if isVarargs $p.Type }}
			for _, _f := range {{$p.Name}} {
			{{- else }}
			for _, _f := range *{{$p.Name}} {
			{{- end }}
				_req.SetFileReader("{{$p.Name}}", _f.Filename, _f.Reader)
			}
		}
		{{- else }}
		if len({{$p.Name}}) == 0 {
			{{- range $r := $m.Results }}
				{{- if eq $r.Type "error" }}
			{{ $r.Name }} = errors.New("at least one file should be uploaded for parameter {{$p.Name}}")
				{{- end }}
			{{- end }}
			return
		}
		for _, _f := range {{$p.Name}} {
			_req.SetFileReader("{{$p.Name}}", _f.Filename, _f.Reader)
		}
		{{- end }}
		{{- else }}
		{{- if isOptional $p.Type }}
		if {{$p.Name}} != nil { 
			_req.SetFileReader("{{$p.Name}}", {{$p.Name}}.Filename, {{$p.Name}}.Reader)
		}
		{{- else }}
		_req.SetFileReader("{{$p.Name}}", {{$p.Name}}.Filename, {{$p.Name}}.Reader)
		{{- end }}
		{{- end }}
		{{- else if eq $p.Type "context.Context" }}
		{{- else if not (isBuiltin $p)}}
		{{- if and (eq $m.HttpMethod "GET") (not $.Config.AllowGetWithReqBody) }}
		{{$p.Name}}UrlValues, _err := rest.EncodeForm(&{{$p.Name}})
		if _err != nil {
			{{- range $r := $m.Results }}
				{{- if eq $r.Type "error" }}
			{{ $r.Name }} = errors.Wrap(_err, "error")
				{{- end }}
			{{- end }}
			return
		}
		_req.SetQueryParamsFromValues({{$p.Name}}UrlValues)
		{{- else }}
		if options.GzipReqBody {
			pr, pw := io.Pipe()
			go func() {
				gw := gzip.NewWriter(pw)
				_err = json.NewEncoder(gw).Encode({{$p.Name}})
				if _err != nil {
					{{- range $r := $m.Results }}
						{{- if eq $r.Type "error" }}
					{{ $r.Name }} = errors.Wrap(_err, "error")
						{{- end }}
					{{- end }}
					return
				}
				_err = gw.Close()
				if _err != nil {
					{{- range $r := $m.Results }}
						{{- if eq $r.Type "error" }}
					{{ $r.Name }} = errors.Wrap(_err, "error")
						{{- end }}
					{{- end }}
					return
				}
				{{- range $r := $m.Results }}
					{{- if eq $r.Type "error" }}
				defer pw.CloseWithError({{ $r.Name }})
					{{- end }}
				{{- end }}
			}()
			_req.SetHeader("Content-Type", "application/json")
			_req.SetHeader("Content-Encoding", "gzip")
			_req.SetBody(pr)
		} else {
			_req.SetBody({{$p.Name}})
		}
		{{- end }}
		{{- else if isSlice $p.Type }}
		{{- if isOptional $p.Type }}
		if {{$p.Name}} != nil { 
			{{- if isVarargs $p.Type }}
			for _, _item := range {{$p.Name}} {
			{{- else }}
			for _, _item := range *{{$p.Name}} {
			{{- end }}
				{{- if IsEnum $p }}
				_urlValues.Add("{{$p.Name}}", _item.StringGetter())
				{{- else }}
				_urlValues.Add("{{$p.Name}}", fmt.Sprintf("%v", _item))
				{{- end }}
			}
		}
		{{- else }}
		if len({{$p.Name}}) == 0 {
			{{- range $r := $m.Results }}
				{{- if eq $r.Type "error" }}
			{{ $r.Name }} = errors.New("size of parameter {{$p.Name}} should be greater than zero")
				{{- end }}
			{{- end }}
			return
		}
		for _, _item := range {{$p.Name}} {
			{{- if IsEnum $p }}
			_urlValues.Add("{{$p.Name}}", _item.StringGetter())
			{{- else }}
			_urlValues.Add("{{$p.Name}}", fmt.Sprintf("%v", _item))
			{{- end }}
		}
		{{- end}}
		{{- else }}
		{{- if isOptional $p.Type }}
		if {{$p.Name}} != nil { 
            {{- if IsEnum $p }}
			_urlValues.Set("{{$p.Name}}", {{$p.Name}}.StringGetter())
			{{- else }}
			_urlValues.Set("{{$p.Name}}", fmt.Sprintf("%v", *{{$p.Name}}))
			{{- end }}
		}
		{{- else }}
		{{- if IsEnum $p }}
		_urlValues.Set("{{$p.Name}}", {{$p.Name}}.StringGetter())
		{{- else }}
		_urlValues.Set("{{$p.Name}}", fmt.Sprintf("%v", {{$p.Name}}))
		{{- end }}
		{{- end }}
		{{- end }}
		{{- end }}

		{{- range $r := $m.Results }}
			{{- if eq $r.Type "*os.File" }}
				_req.SetDoNotParseResponse(true)
			{{- end }}
		{{- end }}

		{{- if eq $.Config.RoutePatternStrategy 1}}
		_path := "/{{$.Meta.Name | lower}}/{{$m.Name | noSplitPattern}}"
		{{- else }}
		_path := "/{{$m.Name | pattern}}"
		{{- end }}

		{{- if eq $m.HttpMethod "GET" }}
		_req.SetQueryParamsFromValues(_urlValues)
		{{- else }}
		if _req.Body != nil {
			_req.SetQueryParamsFromValues(_urlValues)
		} else {
			_req.SetFormDataFromValues(_urlValues)
		}
		{{- end }}
		_resp, _err = _req.{{$m.Name | restyMethod}}(_path)
		if _err != nil {
			{{- range $r := $m.Results }}
				{{- if eq $r.Type "error" }}
			{{ $r.Name }} = errors.Wrap(_err, "error")
				{{- end }}
			{{- end }}
			return
		}
		if _resp.IsError() {
			{{- range $r := $m.Results }}
				{{- if eq $r.Type "error" }}
			{{ $r.Name }} = errors.New(_resp.String())
				{{- end }}
			{{- end }}
			return
		}
		{{- $done := false }}
		{{- range $r := $m.Results }}
			{{- if eq $r.Type "*os.File" }}
				_disp := _resp.Header().Get("Content-Disposition")
				_file := strings.TrimPrefix(_disp, "attachment; filename=")
				_output := os.TempDir()
				if stringutils.IsNotEmpty(_output) {
					_file = _output + string(filepath.Separator) + _file
				}
				_file = filepath.Clean(_file)
				if _err = fileutils.CreateDirectory(filepath.Dir(_file)); _err != nil {
					{{- range $r := $m.Results }}
						{{- if eq $r.Type "error" }}
					{{ $r.Name }} = errors.Wrap(_err, "error")
						{{- end }}
					{{- end }}
					return
				}
				_outFile, _err := os.Create(_file)
				if _err != nil {
					{{- range $r := $m.Results }}
						{{- if eq $r.Type "error" }}
					{{ $r.Name }} = errors.Wrap(_err, "error")
						{{- end }}
					{{- end }}
					return
				}
				defer _outFile.Close()
				defer _resp.RawBody().Close()
				_, _err = io.Copy(_outFile, _resp.RawBody())
				if _err != nil {
					{{- range $r := $m.Results }}
						{{- if eq $r.Type "error" }}
					{{ $r.Name }} = errors.Wrap(_err, "error")
						{{- end }}
					{{- end }}
					return
				}
				{{ $r.Name }} = _outFile
				return
				{{- $done = true }}	
			{{- end }}
		{{- end }}
		{{- if not $done }}
			var _result struct {
				{{- range $r := $m.Results }}
				{{- if ne $r.Type "error" }}
				{{ $r.Name | toCamel }} {{ $r.Type }} ` + "`" + `json:"{{ $r.Name | convertCase }}"` + "`" + `
				{{- end }}
				{{- end }}
			}
			if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
				{{- range $r := $m.Results }}
					{{- if eq $r.Type "error" }}
				{{ $r.Name }} = errors.Wrap(_err, "error")
					{{- end }}
				{{- end }}
				return
			}
			return _resp, {{range $i, $r := $m.Results }}{{- if $i}},{{end}}{{ if eq $r.Type "error" }}nil{{else}}_result.{{ $r.Name | toCamel }}{{end}}{{- end }}
		{{- end }}    
	}
{{- end }}

func New{{.Meta.Name}}Client(opts ...restclient.RestClientOption) *{{.Meta.Name}}Client {
	{{- if .Config.Env }}
	defaultProvider := restclient.NewServiceProvider("{{.Config.Env}}")
	{{- else }}
	defaultProvider := restclient.NewServiceProvider("{{.Meta.Name | toUpper}}")
	{{- end }}
	defaultClient := restclient.NewClient()

	svcClient := &{{.Meta.Name}}Client{
		provider: defaultProvider,
		client:   defaultClient,
	}

	for _, opt := range opts {
		opt(svcClient)
	}

	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
		return nil
	})

	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
		*request = *traceReq
		return nil
	})

	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
		return nil
	})

	return svcClient
}
`

func restyMethod(method string) string {
	hm, _ := astutils.Pattern(method)
	return strings.Title(strings.ToLower(hm))
}

type GenGoClientConfig struct {
	Env                  string
	RoutePatternStrategy int
	AllowGetWithReqBody  bool
	CaseConvertor        func(string) string
}

// GenGoClient generates golang http client code from result of parsing svc.go file in project root path
func GenGoClient(dir string, ic astutils.InterfaceCollector, config GenGoClientConfig) {
	var (
		err        error
		clientfile string
		f          *os.File
		tpl        *template.Template
		sqlBuf     bytes.Buffer
		clientDir  string
		fi         os.FileInfo
		source     string
		modfile    string
		modName    string
		firstLine  string
		modf       *os.File
		meta       astutils.InterfaceMeta
	)
	clientDir = filepath.Join(dir, "client")
	if err = MkdirAll(clientDir, os.ModePerm); err != nil {
		panic(err)
	}

	clientfile = filepath.Join(clientDir, "client.go")
	fi, err = Stat(clientfile)
	if err != nil && !os.IsNotExist(err) {
		panic(err)
	}
	if fi != nil {
		logrus.Warningln("file client.go will be overwritten")
	}
	if f, err = Create(clientfile); err != nil {
		panic(err)
	}
	defer f.Close()

	_ = copier.DeepCopy(ic.Interfaces[0], &meta)

	modfile = filepath.Join(dir, "go.mod")
	if modf, err = Open(modfile); err != nil {
		panic(err)
	}
	reader := bufio.NewReader(modf)
	firstLine, _ = reader.ReadString('\n')
	modName = strings.TrimSpace(strings.TrimPrefix(firstLine, "module"))

	funcMap := make(map[string]interface{})
	funcMap["toLowerCamel"] = strcase.ToLowerCamel
	funcMap["toCamel"] = strcase.ToCamel
	funcMap["pattern"] = apiPattern
	funcMap["lower"] = strings.ToLower
	funcMap["contains"] = strings.Contains
	funcMap["isBuiltin"] = v3helper.IsBuiltin
	funcMap["restyMethod"] = restyMethod
	funcMap["toUpper"] = strings.ToUpper
	funcMap["noSplitPattern"] = noSplitPattern
	funcMap["isOptional"] = v3helper.IsOptional
	funcMap["convertCase"] = config.CaseConvertor
	funcMap["isSlice"] = v3helper.IsSlice
	funcMap["isVarargs"] = v3helper.IsVarargs
	funcMap["IsEnum"] = v3helper.IsEnum
	if tpl, err = template.New("client.go.tmpl").Funcs(funcMap).Parse(clientTmpl); err != nil {
		panic(err)
	}
	if err = tpl.Execute(&sqlBuf, struct {
		VoPackage  string
		DtoPackage string
		Meta       astutils.InterfaceMeta
		Config     GenGoClientConfig
		Version    string
	}{
		VoPackage:  modName + "/vo",
		DtoPackage: modName + "/dto",
		Meta:       meta,
		Config:     config,
		Version:    version.Release,
	}); err != nil {
		panic(err)
	}
	source = strings.TrimSpace(sqlBuf.String())
	astutils.FixImport([]byte(source), clientfile)
}
