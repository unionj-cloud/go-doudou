You are a senior software architect. You produce optimized, maintainable code that follows best practices. 

Your task is to review the current codebase and suggest improvements or optimizations.

Rules:
- Keep your suggestions concise and focused. Avoid unnecessary explanations or fluff. 
- Your output should be a series of specific, actionable changes.

When approaching this task:
1. Carefully review the provided code.
2. Identify areas that could be improved in terms of efficiency, readability, or maintainability.
3. Consider best practices for the specific programming language used.
4. Think about potential optimizations that could enhance performance.
5. Look for opportunities to refactor or restructure the code for better organization.

For each suggested change, provide:
1. A short description of the change (one line maximum).
2. The modified code block.

Use the following format for your output:

[Short Description]
```[language]:[path/to/file]
[code block]
```

Begin your analysis and provide your suggestions now.

My current codebase:
<current_codebase>
Project Structure:
├── LICENSE
├── README.md
├── README_zh.md
├── app.yml.example
├── benchmark.png
├── cmd
│   ├── client.go
│   ├── client_test.go
│   ├── crud.go
│   ├── ddl.go
│   ├── ddl_test.go
│   ├── deploy.go
│   ├── enum.go
│   ├── enum_test.go
│   ├── grpc.go
│   ├── http.go
│   ├── httptest.go
│   ├── init.go
│   ├── internal
│   │   ├── ddl
│   │   │   ├── codegen
│   │   │   │   ├── dao.go
│   │   │   │   ├── daosql.go
│   │   │   │   ├── dto.go
│   │   │   │   ├── entity.go
│   │   │   │   └── idao.go
│   │   │   ├── columnenum
│   │   │   │   └── columnenum.go
│   │   │   ├── config
│   │   │   │   └── config.go
│   │   │   ├── ddlast
│   │   │   │   └── ast.go
│   │   │   ├── exec.go
│   │   │   ├── extraenum
│   │   │   │   └── extraenum.go
│   │   │   ├── keyenum
│   │   │   │   └── keyenum.go
│   │   │   ├── nullenum
│   │   │   │   └── nullenum.go
│   │   │   ├── sortenum
│   │   │   │   └── sortenum.go
│   │   │   ├── table
│   │   │   │   ├── ddl.go
│   │   │   │   ├── ddl_test.go
│   │   │   │   ├── table.go
│   │   │   │   └── table_test.go
│   │   │   └── testdata
│   │   │       ├── entity
│   │   │       │   ├── base.go
│   │   │       │   ├── order.go
│   │   │       │   └── user.go
│   │   │       ├── entity2
│   │   │       │   ├── base.go
│   │   │       │   ├── book.go
│   │   │       │   ├── publisher.go
│   │   │       │   └── user.go
│   │   │       ├── entity3
│   │   │       │   ├── base.go
│   │   │       │   ├── book.go
│   │   │       │   ├── publisher.go
│   │   │       │   └── user.go
│   │   │       ├── entity4
│   │   │       │   ├── base.go
│   │   │       │   ├── book.go
│   │   │       │   ├── publisher.go
│   │   │       │   └── user.go
│   │   │       ├── go.mod
│   │   │       └── sql
│   │   │           └── test_ddl_user.sql
│   │   ├── enum
│   │   │   ├── generator.go
│   │   │   ├── generator_test.go
│   │   │   └── testdata
│   │   │       ├── dto.go
│   │   │       └── enums_gen.go
│   │   ├── modular
│   │   │   └── work.go
│   │   ├── name
│   │   │   ├── exec.go
│   │   │   ├── exec_test.go
│   │   │   └── testdata
│   │   │       ├── vo.go
│   │   │       ├── vo1.go
│   │   │       └── vo2
│   │   ├── openapi
│   │   │   └── v3
│   │   │       └── codegen
│   │   │           ├── client
│   │   │           │   ├── go.go
│   │   │           │   ├── go_test.go
│   │   │           │   └── testdata
│   │   │           ├── common.go
│   │   │           ├── common_test.go
│   │   │           ├── server
│   │   │           │   ├── svc.go
│   │   │           │   └── svc_test.go
│   │   │           ├── server.go
│   │   │           └── testdata
│   │   │               ├── api-docs.json
│   │   │               ├── mytest
│   │   │               │   ├── Dockerfile
│   │   │               │   ├── client
│   │   │               │   │   ├── client.go
│   │   │               │   │   ├── clientproxy.go
│   │   │               │   │   └── iclient.go
│   │   │               │   ├── cmd
│   │   │               │   │   └── main.go
│   │   │               │   ├── config
│   │   │               │   │   └── config.go
│   │   │               │   ├── db
│   │   │               │   │   └── db.go
│   │   │               │   ├── dto
│   │   │               │   │   └── dto.go
│   │   │               │   ├── go.mod
│   │   │               │   ├── go.sum
│   │   │               │   ├── mytest_openapi3.go
│   │   │               │   ├── mytest_openapi3.json
│   │   │               │   ├── svc.go
│   │   │               │   ├── svcimpl.go
│   │   │               │   └── transport
│   │   │               │       ├── grpc
│   │   │               │       │   ├── annotation.go
│   │   │               │       │   ├── mytest.pb.go
│   │   │               │       │   ├── mytest.proto
│   │   │               │       │   └── mytest_grpc.pb.go
│   │   │               │       └── httpsrv
│   │   │               │           ├── handler.go
│   │   │               │           ├── handlerimpl.go
│   │   │               │           └── middleware.go
│   │   │               ├── petstore3.json
│   │   │               ├── prometheus_openapi3.json
│   │   │               ├── swagger.json
│   │   │               ├── test
│   │   │               │   ├── customerclient.go
│   │   │               │   ├── downloadclient.go
│   │   │               │   ├── pageclient.go
│   │   │               │   ├── petclient.go
│   │   │               │   ├── signclient.go
│   │   │               │   ├── storeclient.go
│   │   │               │   ├── textclient.go
│   │   │               │   ├── unipayclient.go
│   │   │               │   ├── uploadclient.go
│   │   │               │   ├── userclient.go
│   │   │               │   └── vo.go
│   │   │               ├── test1.json
│   │   │               ├── test2.json
│   │   │               ├── test3.json
│   │   │               ├── test4.json
│   │   │               └── test5.json
│   │   ├── svc
│   │   │   ├── codegen
│   │   │   │   ├── config.go
│   │   │   │   ├── config_test.go
│   │   │   │   ├── database
│   │   │   │   │   ├── common.go
│   │   │   │   │   ├── gorm.go
│   │   │   │   │   ├── gorm_test.go
│   │   │   │   │   └── testdata
│   │   │   │   ├── db.go
│   │   │   │   ├── db_test.go
│   │   │   │   ├── grpcannotation.go
│   │   │   │   ├── grpchttpmain.go
│   │   │   │   ├── grpcmain.go
│   │   │   │   ├── grpcmod.go
│   │   │   │   ├── grpcproto.go
│   │   │   │   ├── http.go
│   │   │   │   ├── http2grpc.go
│   │   │   │   ├── httpclient.go
│   │   │   │   ├── httpclient_test.go
│   │   │   │   ├── httpclientproxy.go
│   │   │   │   ├── httpclientproxy_test.go
│   │   │   │   ├── httphandler.go
│   │   │   │   ├── httphandler_test.go
│   │   │   │   ├── httphandlerimpl.go
│   │   │   │   ├── httphandlerimpl_test.go
│   │   │   │   ├── httpiclient.go
│   │   │   │   ├── httpiclient_test.go
│   │   │   │   ├── httpintegrationtesting.go
│   │   │   │   ├── httpintegrationtesting_test.go
│   │   │   │   ├── httpmiddleware.go
│   │   │   │   ├── httpmiddleware_test.go
│   │   │   │   ├── init.go
│   │   │   │   ├── init_test.go
│   │   │   │   ├── k8sdeployment.go
│   │   │   │   ├── k8sdeployment_test.go
│   │   │   │   ├── k8sstatefulset.go
│   │   │   │   ├── k8sstatefulset_test.go
│   │   │   │   ├── main.go
│   │   │   │   ├── main_test.go
│   │   │   │   ├── mainmodule.go
│   │   │   │   ├── plugin.go
│   │   │   │   ├── svcimpl.go
│   │   │   │   └── testdata
│   │   │   │       ├── client
│   │   │   │       │   ├── client.go
│   │   │   │       │   ├── clientproxy.go
│   │   │   │       │   └── iclient.go
│   │   │   │       ├── cmd
│   │   │   │       │   └── main.go
│   │   │   │       ├── config
│   │   │   │       │   └── config.go
│   │   │   │       ├── corpus_deployment.yaml
│   │   │   │       ├── corpus_statefulset.yaml
│   │   │   │       ├── dto
│   │   │   │       │   └── dto.go
│   │   │   │       ├── entity
│   │   │   │       │   ├── base.go
│   │   │   │       │   └── user.go
│   │   │   │       ├── go.mod
│   │   │   │       ├── integrationtest
│   │   │   │       ├── k8s.yaml
│   │   │   │       ├── svc.go
│   │   │   │       ├── svcimpl.go
│   │   │   │       ├── svcp.go
│   │   │   │       ├── testcode.postman_collection.json
│   │   │   │       ├── transport
│   │   │   │       │   ├── grpc
│   │   │   │       │   │   └── usersvc.proto
│   │   │   │       │   └── httpsrv
│   │   │   │       │       └── handlerimpl.go
│   │   │   │       ├── usersvc_openapi3.go
│   │   │   │       ├── usersvc_openapi3.json
│   │   │   │       ├── vo
│   │   │   │       │   ├── enum.go
│   │   │   │       │   ├── vo.go
│   │   │   │       │   ├── vo1.go
│   │   │   │       │   └── vo2.go
│   │   │   │       └── vop
│   │   │   │           ├── vo3.go
│   │   │   │           └── vo4.go
│   │   │   ├── parser
│   │   │   │   └── parser.go
│   │   │   ├── svc.go
│   │   │   ├── svc_test.go
│   │   │   ├── testdata
│   │   │   │   ├── change
│   │   │   │   │   └── change.go
│   │   │   │   ├── checkIc2
│   │   │   │   │   └── svc.go
│   │   │   │   ├── inputanonystruct
│   │   │   │   │   └── svc.go
│   │   │   │   ├── nosvc
│   │   │   │   │   └── svc.go
│   │   │   │   ├── novo
│   │   │   │   │   └── svc.go
│   │   │   │   ├── openapi
│   │   │   │   │   └── testfilesdoc1_openapi3.json
│   │   │   │   ├── outputanonystruct
│   │   │   │   │   ├── dto
│   │   │   │   │   │   └── dto.go
│   │   │   │   │   ├── svc.go
│   │   │   │   │   └── transport
│   │   │   │   │       └── grpc
│   │   │   │   │           ├── usersvc.pb.go
│   │   │   │   │           ├── usersvc.pb.json.go
│   │   │   │   │           ├── usersvc.proto
│   │   │   │   │           └── usersvc_grpc.pb.go
│   │   │   │   ├── svc.go
│   │   │   │   ├── svcp.go
│   │   │   │   ├── testfilesdoc1_openapi3.json
│   │   │   │   ├── usersvc_deployment.yaml
│   │   │   │   ├── usersvc_statefulset.yaml
│   │   │   │   └── vo
│   │   │   │       └── vo.go
│   │   │   └── validate
│   │   │       └── validate.go
│   │   └── templates
│   │       ├── header.go
│   │       ├── mainmain.go
│   │       ├── mainmodule.go
│   │       ├── mainpkgmod.go
│   │       └── plugin.go
│   ├── mock
│   │   ├── mock_executils_runner.go
│   │   ├── mock_promptui_select_interface.go
│   │   └── mock_svc.go
│   ├── modular
│   │   ├── init.go
│   │   └── work.go
│   ├── name.go
│   ├── name_test.go
│   ├── promptui_select_interface.go
│   ├── push.go
│   ├── root.go
│   ├── root_test.go
│   ├── run.go
│   ├── shutdown.go
│   ├── shutdown_test.go
│   ├── svc.go
│   ├── svc_test.go
│   ├── testdata
│   │   └── testsvc
│   │       ├── Dockerfile
│   │       ├── client
│   │       │   ├── client.go
│   │       │   ├── clientproxy.go
│   │       │   └── iclient.go
│   │       ├── cmd
│   │       │   └── main.go
│   │       ├── config
│   │       │   └── config.go
│   │       ├── db
│   │       │   └── db.go
│   │       ├── svc.go
│   │       ├── svcimpl.go
│   │       ├── testsvc_openapi3.go
│   │       ├── testsvc_openapi3.json
│   │       ├── transport
│   │       │   └── httpsrv
│   │       │       ├── handler.go
│   │       │       ├── handlerimpl.go
│   │       │       └── middleware.go
│   │       └── vo
│   │           ├── enums_gen.go
│   │           └── vo.go
│   ├── version.go
│   └── version_test.go
├── framework
│   ├── buildinfo
│   │   └── buildinfo.go
│   ├── cache
│   │   ├── 2qcache.go
│   │   ├── arccache.go
│   │   ├── base.go
│   │   ├── cachemanager.go
│   │   ├── item.go
│   │   └── lrucache.go
│   ├── config
│   │   ├── config.go
│   │   ├── config_test.go
│   │   ├── default.go
│   │   └── dynamic.go
│   ├── configmgr
│   │   ├── apollo.go
│   │   ├── apollo_test.go
│   │   ├── mock
│   │   │   ├── apollo_client_interface.go
│   │   │   ├── mock_apollo_client_interface.go
│   │   │   └── mock_config_client_interface.go
│   │   ├── nacos.go
│   │   └── nacos_test.go
│   ├── database
│   │   ├── cacheradapter.go
│   │   ├── database.go
│   │   └── marshaler.go
│   ├── framework.go
│   ├── grpcx
│   │   ├── grpc_resolver_nacos
│   │   │   ├── LICENSE
│   │   │   ├── README.md
│   │   │   ├── api.go
│   │   │   ├── balancer.go
│   │   │   ├── config.go
│   │   │   └── nacos.go
│   │   ├── grpc_resolver_zk
│   │   │   ├── LICENSE
│   │   │   ├── README.md
│   │   │   ├── balancer.go
│   │   │   ├── config.go
│   │   │   └── zk.go
│   │   ├── interceptors
│   │   │   ├── grpcx_auth
│   │   │   │   └── auth.go
│   │   │   └── grpcx_ratelimit
│   │   │       └── ratelimit.go
│   │   └── server.go
│   ├── logger
│   │   ├── configure.go
│   │   └── entry.go
│   ├── plugin
│   │   └── plugin.go
│   ├── ratelimit
│   │   ├── limit.go
│   │   ├── limit_test.go
│   │   ├── limiter.go
│   │   ├── memrate
│   │   │   ├── LICENSE
│   │   │   ├── memorystore.go
│   │   │   ├── memorystore_test.go
│   │   │   ├── rate.go
│   │   │   └── rate_test.go
│   │   └── redisrate
│   │       ├── LICENSE
│   │       ├── gcralimiter.go
│   │       └── lua.go
│   ├── registry
│   │   ├── constants
│   │   │   └── constants.go
│   │   ├── etcd
│   │   │   ├── balancer.go
│   │   │   └── node.go
│   │   ├── interfaces
│   │   │   └── interfaces.go
│   │   ├── memberlist
│   │   │   ├── balancer.go
│   │   │   ├── config.go
│   │   │   ├── config_test.go
│   │   │   ├── delegate.go
│   │   │   ├── delegate_test.go
│   │   │   ├── eventdelegate.go
│   │   │   ├── eventdelegate_test.go
│   │   │   ├── node.go
│   │   │   ├── resolver.go
│   │   │   ├── serviceprovider.go
│   │   │   └── serviceprovider_test.go
│   │   ├── nacos
│   │   │   ├── mock
│   │   │   │   └── mock_naming_client_interface.go
│   │   │   ├── naming_client_interface.go
│   │   │   ├── node.go
│   │   │   └── node_test.go
│   │   ├── node.go
│   │   ├── node_test.go
│   │   ├── pipe
│   │   │   └── node.go
│   │   ├── serversets
│   │   │   ├── LICENSE
│   │   │   ├── endpoint.go
│   │   │   ├── endpoint_test.go
│   │   │   ├── serverset.go
│   │   │   ├── serverset_test.go
│   │   │   ├── watch.go
│   │   │   └── watch_test.go
│   │   ├── utils
│   │   │   └── utils.go
│   │   └── zk
│   │       └── node.go
│   ├── rest
│   │   ├── bizerror.go
│   │   ├── bizerror_test.go
│   │   ├── confighandler.go
│   │   ├── dochandler.go
│   │   ├── docindex.go
│   │   ├── form.go
│   │   ├── gateway.go
│   │   ├── httprouter
│   │   │   ├── LICENSE
│   │   │   ├── README.md
│   │   │   ├── routegroup.go
│   │   │   ├── routegroup_test.go
│   │   │   ├── router.go
│   │   │   └── router_test.go
│   │   ├── lazyregexp
│   │   │   └── lazyre.go
│   │   ├── memberlistuihandler.go
│   │   ├── memberlistuiindex.go
│   │   ├── middleware.go
│   │   ├── middleware_test.go
│   │   ├── mock
│   │   │   ├── goresilience_runner_interface.go
│   │   │   └── mock_goresilience_runner_interface.go
│   │   ├── model.go
│   │   ├── pprof.go
│   │   ├── profile
│   │   │   ├── encode.go
│   │   │   ├── filter.go
│   │   │   ├── legacy_profile.go
│   │   │   ├── merge.go
│   │   │   ├── profile.go
│   │   │   ├── profile_test.go
│   │   │   ├── proto.go
│   │   │   ├── proto_test.go
│   │   │   └── prune.go
│   │   ├── promhandler.go
│   │   ├── prommiddleware.go
│   │   ├── server.go
│   │   └── validate.go
│   ├── restclient
│   │   ├── restclient.go
│   │   └── restclient_test.go
│   ├── testdata
│   │   ├── change
│   │   │   └── change.go
│   │   ├── checkIc2
│   │   │   └── svc.go
│   │   ├── inputanonystruct
│   │   │   └── svc.go
│   │   ├── nosvc
│   │   │   └── svc.go
│   │   ├── novo
│   │   │   └── svc.go
│   │   ├── openapi
│   │   │   └── testfilesdoc1_openapi3.json
│   │   ├── outputanonystruct
│   │   │   └── svc.go
│   │   ├── svc.go
│   │   ├── svcp.go
│   │   ├── testfilesdoc1_openapi3.json
│   │   ├── usersvc_deployment.yaml
│   │   ├── usersvc_statefulset.yaml
│   │   └── vo
│   │       └── vo.go
│   └── tracing
│       └── tracer.go
├── go-doudou-qq-group.png
├── go-doudou-wechat-group.png
├── go.mod
├── go.sum
├── main.go
├── qrcode.png
└── version
    └── version.go


app.yml.example
```
1 | example:
2 |   db:
3 |     driver: mysql
4 |     dsn: root:1234@tcp(127.0.0.1:3306)/tutorial?charset=utf8mb4&parseTime=True&loc=Local
5 |     log:
6 |       level: info
7 |       slow-threshold: 200ms
8 |       ignore-record-not-found-error: false
9 |       parameterized-queries: false
10 |     mysql:
11 |       skip-initialize-with-version: false
12 |       default-string-size: 0
13 |       disable-with-returning: false
14 |       disable-datetime-precision: false
15 |       dont-support-rename-index: false
16 |       dont-support-rename-column: false
17 |       dont-support-for-share-clause: false
18 |       dont-support-null-as-default-value: false
19 |       dont-support-rename-column-unique: false
20 |     postgres:
21 |       prefer-simple-protocol: false
22 |       without-returning: false
23 |     pool:
24 |       max-idle-conns: 2
25 |       max-open-conns: -1
26 |       conn-max-lifetime: ""
27 |       conn-max-idle-time: ""
28 |   biz:
29 |     api:
30 |       secret: "my_secret"
```

go.mod
```
1 | module github.com/unionj-cloud/go-doudou/v2
2 | 
3 | go 1.22.2
4 | 
5 | require (
6 | 	github.com/Jeffail/gabs/v2 v2.6.1
7 | 	github.com/ascarter/requestid v0.0.0-20170313220838-5b76ab3d4aee
8 | 	github.com/common-nighthawk/go-figure v0.0.0-20200609044655-c4b36f998cf2
9 | 	github.com/deckarep/golang-set v1.8.0
10 | 	github.com/felixge/httpsnoop v1.0.4
11 | 	github.com/go-git/go-billy/v5 v5.4.1 // indirect
12 | 	github.com/go-git/go-git/v5 v5.6.1 // indirect
13 | 	github.com/go-resty/resty/v2 v2.7.0
14 | 	github.com/go-sql-driver/mysql v1.8.1
15 | 	github.com/goccy/go-yaml v1.11.0
16 | 	github.com/hyperjumptech/jiffy v1.0.0 // indirect
17 | 	github.com/iancoleman/strcase v0.3.0
18 | 	github.com/jeremywohl/flatten v1.0.1 // indirect
19 | 	github.com/jmoiron/sqlx v1.3.5
20 | 	github.com/joho/godotenv v1.5.1
21 | 	github.com/olekukonko/tablewriter v0.0.5
22 | 	github.com/opentracing-contrib/go-stdlib v1.0.0
23 | 	github.com/opentracing/opentracing-go v1.2.0
24 | 	github.com/pkg/errors v0.9.1
25 | 	github.com/prometheus/client_golang v1.19.0
26 | 	github.com/radovskyb/watcher v1.0.7
27 | 	github.com/sirupsen/logrus v1.9.3
28 | 	github.com/spf13/cobra v1.7.0
29 | 	github.com/stretchr/testify v1.10.0
30 | 	github.com/testcontainers/testcontainers-go v0.33.0
31 | 	github.com/uber/jaeger-client-go v2.30.0+incompatible
32 | 	github.com/uber/jaeger-lib v2.4.1+incompatible
33 | 	github.com/unionj-cloud/toolkit v0.0.6
34 | 	github.com/wubin1989/dbresolver v0.0.2 // indirect
35 | 	github.com/wubin1989/gen v0.0.5
36 | 	github.com/wubin1989/gorm v0.0.5
37 | 	golang.org/x/tools v0.26.0 // indirect
38 | )
39 | 
40 | require (
41 | 	github.com/bytedance/sonic v1.12.1
42 | 	github.com/deckarep/golang-set/v2 v2.6.0
43 | 	github.com/dgraph-io/ristretto v0.1.1
44 | 	github.com/elliotchance/orderedmap/v2 v2.2.0
45 | 	github.com/go-redis/redis/v8 v8.11.5
46 | 	github.com/go-zookeeper/zk v1.0.3
47 | 	github.com/gobwas/glob v0.2.3
48 | 	github.com/goccy/go-reflect v1.2.0
49 | 	github.com/google/go-github/v42 v42.0.0
50 | 	github.com/gorilla/handlers v1.5.1
51 | 	github.com/hashicorp/go-sockaddr v1.0.2
52 | 	github.com/hashicorp/golang-lru v0.5.4
53 | 	github.com/manifoldco/promptui v0.9.0
54 | 	github.com/patrickmn/go-cache v2.1.0+incompatible
55 | 	github.com/rs/cors v1.9.0
56 | 	github.com/samber/lo v1.39.0
57 | 	github.com/slok/goresilience v0.2.0
58 | 	github.com/wubin1989/clickhouse v0.0.3
59 | 	github.com/wubin1989/gorm-dameng v0.5.1
60 | 	github.com/wubin1989/mysql v0.0.2
61 | 	github.com/wubin1989/prometheus v0.0.2-0.20240611143457-960b4a499cef
62 | 	github.com/wubin1989/sqlite v0.0.3
63 | 	github.com/wubin1989/sqlserver v0.0.2
64 | )
65 | 
66 | require (
67 | 	dario.cat/mergo v1.0.0 // indirect
68 | 	filippo.io/edwards25519 v1.1.0 // indirect
69 | 	github.com/ClickHouse/ch-go v0.61.5 // indirect
70 | 	github.com/ClickHouse/clickhouse-go/v2 v2.29.0 // indirect
71 | 	github.com/auxten/postgresql-parser v1.0.1 // indirect
72 | 	github.com/bytedance/sonic/loader v0.2.0 // indirect
73 | 	github.com/cenkalti/backoff/v4 v4.2.1 // indirect
74 | 	github.com/certifi/gocertifi v0.0.0-20200922220541-2c3bb06c6054 // indirect
75 | 	github.com/cloudwego/base64x v0.1.4 // indirect
76 | 	github.com/cloudwego/iasm v0.2.0 // indirect
77 | 	github.com/cockroachdb/apd v1.1.1-0.20181017181144-bced77f817b4 // indirect
78 | 	github.com/cockroachdb/errors v1.8.2 // indirect
79 | 	github.com/cockroachdb/logtags v0.0.0-20190617123548-eb05cc24525f // indirect
80 | 	github.com/cockroachdb/redact v1.0.8 // indirect
81 | 	github.com/cockroachdb/sentry-go v0.6.1-cockroachdb.2 // indirect
82 | 	github.com/containerd/log v0.1.0 // indirect
83 | 	github.com/containerd/platforms v0.2.1 // indirect
84 | 	github.com/cpuguy83/dockercfg v0.3.1 // indirect
85 | 	github.com/distribution/reference v0.6.0 // indirect
86 | 	github.com/dustin/go-humanize v1.0.1 // indirect
87 | 	github.com/getsentry/raven-go v0.2.0 // indirect
88 | 	github.com/go-faster/city v1.0.1 // indirect
89 | 	github.com/go-faster/errors v0.7.1 // indirect
90 | 	github.com/go-logr/logr v1.4.1 // indirect
91 | 	github.com/go-logr/stdr v1.2.2 // indirect
92 | 	github.com/gobuffalo/flect v1.0.3 // indirect
93 | 	github.com/golang/glog v1.2.0 // indirect
94 | 	github.com/grpc-ecosystem/grpc-gateway v1.16.0 // indirect
95 | 	github.com/jackc/puddle/v2 v2.2.1 // indirect
96 | 	github.com/klauspost/cpuid/v2 v2.0.9 // indirect
97 | 	github.com/kr/pretty v0.3.1 // indirect
98 | 	github.com/kr/text v0.2.0 // indirect
99 | 	github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect
100 | 	github.com/mholt/archiver/v3 v3.5.1 // indirect
101 | 	github.com/moby/docker-image-spec v1.3.1 // indirect
102 | 	github.com/moby/patternmatcher v0.6.0 // indirect
103 | 	github.com/moby/sys/sequential v0.5.0 // indirect
104 | 	github.com/moby/sys/user v0.1.0 // indirect
105 | 	github.com/moby/sys/userns v0.1.0 // indirect
106 | 	github.com/paulmach/orb v0.11.1 // indirect
107 | 	github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect
108 | 	github.com/rogpeppe/go-internal v1.11.0 // indirect
109 | 	github.com/segmentio/asm v1.2.0 // indirect
110 | 	github.com/shirou/gopsutil/v3 v3.23.12 // indirect
111 | 	github.com/shoenig/go-m1cpu v0.1.6 // indirect
112 | 	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
113 | 	github.com/wubin1989/datatypes v0.0.2 // indirect
114 | 	github.com/wubin1989/hints v0.0.2 // indirect
115 | 	github.com/xwb1989/sqlparser v0.0.0-20180606152119-120387863bf2 // indirect
116 | 	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 // indirect
117 | 	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.19.0 // indirect
118 | 	go.opentelemetry.io/otel/metric v1.26.0 // indirect
119 | 	go.opentelemetry.io/proto/otlp v1.0.0 // indirect
120 | 	go.uber.org/mock v0.4.0 // indirect
121 | 	golang.org/x/arch v0.1.0 // indirect
122 | 	google.golang.org/genproto/googleapis/api v0.0.0-20240318140521-94a12d6c2237 // indirect
123 | 	google.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237 // indirect
124 | 	gopkg.in/yaml.v3 v3.0.1 // indirect
125 | )
126 | 
127 | require (
128 | 	github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect
129 | 	github.com/Microsoft/go-winio v0.6.2 // indirect
130 | 	github.com/ProtonMail/go-crypto v0.0.0-20230217124315-7d5c6f04bbb8 // indirect
131 | 	github.com/acomagu/bufpipe v1.0.4 // indirect
132 | 	github.com/aliyun/alibaba-cloud-sdk-go v1.61.1704 // indirect
133 | 	github.com/andybalholm/brotli v1.1.0 // indirect
134 | 	github.com/antlr/antlr4 v0.0.0-20200124162019-2d7f727a00b7 // indirect
135 | 	github.com/beorn7/perks v1.0.1 // indirect
136 | 	github.com/buger/jsonparser v1.1.1 // indirect
137 | 	github.com/cespare/xxhash/v2 v2.2.0 // indirect
138 | 	github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e // indirect
139 | 	github.com/cloudflare/circl v1.1.0 // indirect
140 | 	github.com/coreos/go-semver v0.3.0 // indirect
141 | 	github.com/coreos/go-systemd/v22 v22.5.0 // indirect
142 | 	github.com/davecgh/go-spew v1.1.1 // indirect
143 | 	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
144 | 	github.com/docker/go-connections v0.5.0 // indirect
145 | 	github.com/docker/go-units v0.5.0 // indirect
146 | 	github.com/dsnet/compress v0.0.2-0.20210315054119-f66993602bf5 // indirect
147 | 	github.com/emirpasic/gods v1.18.1 // indirect
148 | 	github.com/fsnotify/fsnotify v1.6.0 // indirect
149 | 	github.com/go-git/gcfg v1.5.0 // indirect
150 | 	github.com/go-ole/go-ole v1.2.6 // indirect
151 | 	github.com/go-openapi/jsonpointer v0.19.5 // indirect
152 | 	github.com/go-openapi/swag v0.19.14 // indirect
153 | 	github.com/go-playground/locales v0.14.1 // indirect
154 | 	github.com/gogo/protobuf v1.3.2 // indirect
155 | 	github.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 // indirect
156 | 	github.com/golang-sql/sqlexp v0.1.0 // indirect
157 | 	github.com/golang/protobuf v1.5.4 // indirect
158 | 	github.com/golang/snappy v0.0.4 // indirect
159 | 	github.com/google/go-querystring v1.1.0 // indirect
160 | 	github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1 // indirect
161 | 	github.com/gorilla/websocket v1.5.0 // indirect
162 | 	github.com/hashicorp/hcl v1.0.0 // indirect
163 | 	github.com/imdario/mergo v0.3.13 // indirect
164 | 	github.com/inconshreveable/mousetrap v1.1.0 // indirect
165 | 	github.com/invopop/yaml v0.1.0 // indirect
166 | 	github.com/jackc/pgpassfile v1.0.0 // indirect
167 | 	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
168 | 	github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect
169 | 	github.com/jinzhu/inflection v1.0.0 // indirect
170 | 	github.com/jinzhu/now v1.1.5 // indirect
171 | 	github.com/jmespath/go-jmespath v0.4.0 // indirect
172 | 	github.com/josharian/intern v1.0.0 // indirect
173 | 	github.com/json-iterator/go v1.1.12 // indirect
174 | 	github.com/jtolds/gls v4.20.0+incompatible // indirect
175 | 	github.com/kevinburke/ssh_config v1.2.0 // indirect
176 | 	github.com/klauspost/compress v1.17.8
177 | 	github.com/klauspost/pgzip v1.2.6 // indirect
178 | 	github.com/leodido/go-urn v1.2.1 // indirect
179 | 	github.com/magiconair/properties v1.8.7 // indirect
180 | 	github.com/mailru/easyjson v0.7.7 // indirect
181 | 	github.com/mattn/go-isatty v0.0.17 // indirect
182 | 	github.com/mitchellh/mapstructure v1.1.2 // indirect
183 | 	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
184 | 	github.com/modern-go/reflect2 v1.0.2 // indirect
185 | 	github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826 // indirect
186 | 	github.com/nwaples/rardecode v1.1.3 // indirect
187 | 	github.com/opencontainers/go-digest v1.0.0 // indirect
188 | 	github.com/opencontainers/image-spec v1.1.0 // indirect
189 | 	github.com/pelletier/go-toml v1.9.5 // indirect
190 | 	github.com/perimeterx/marshmallow v1.1.4 // indirect
191 | 	github.com/pierrec/lz4/v4 v4.1.21 // indirect
192 | 	github.com/pjbgf/sha1cd v0.3.0 // indirect
193 | 	github.com/pmezard/go-difflib v1.0.0 // indirect
194 | 	github.com/prometheus/client_model v0.5.0 // indirect
195 | 	github.com/prometheus/common v0.48.0 // indirect
196 | 	github.com/prometheus/procfs v0.12.0 // indirect
197 | 	github.com/redis/go-redis/v9 v9.1.0
198 | 	github.com/rivo/uniseg v0.1.0 // indirect
199 | 	github.com/skeema/knownhosts v1.1.0 // indirect
200 | 	github.com/smartystreets/assertions v1.2.0 // indirect
201 | 	github.com/spf13/afero v1.9.2 // indirect
202 | 	github.com/spf13/cast v1.3.0
203 | 	github.com/spf13/jwalterweatherman v1.0.0 // indirect
204 | 	github.com/spf13/pflag v1.0.5 // indirect
205 | 	github.com/spf13/viper v1.7.1 // indirect
206 | 	github.com/subosito/gotenv v1.2.0 // indirect
207 | 	github.com/tklauser/go-sysconf v0.3.12 // indirect
208 | 	github.com/tklauser/numcpus v0.6.1 // indirect
209 | 	github.com/ulikunitz/xz v0.5.11 // indirect
210 | 	github.com/vmihailenco/go-tinylfu v0.2.2 // indirect
211 | 	github.com/vmihailenco/msgpack/v5 v5.3.5 // indirect
212 | 	github.com/vmihailenco/tagparser/v2 v2.0.0 // indirect
213 | 	github.com/xanzy/ssh-agent v0.3.3 // indirect
214 | 	github.com/xi2/xz v0.0.0-20171230120015-48954b6210f8 // indirect
215 | 	github.com/yusufpapurcu/wmi v1.2.3 // indirect
216 | 	go.etcd.io/etcd/api/v3 v3.5.14 // indirect
217 | 	go.etcd.io/etcd/client/pkg/v3 v3.5.14 // indirect
218 | 	go.opentelemetry.io/otel v1.26.0 // indirect
219 | 	go.opentelemetry.io/otel/trace v1.26.0 // indirect
220 | 	go.uber.org/atomic v1.11.0 // indirect
221 | 	go.uber.org/multierr v1.11.0 // indirect
222 | 	go.uber.org/zap v1.27.0 // indirect
223 | 	golang.org/x/mod v0.21.0 // indirect
224 | 	golang.org/x/net v0.30.0 // indirect
225 | 	golang.org/x/sync v0.10.0 // indirect
226 | 	golang.org/x/sys v0.26.0 // indirect
227 | 	golang.org/x/time v0.3.0 // indirect
228 | 	golang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2 // indirect
229 | 	google.golang.org/protobuf v1.33.0 // indirect
230 | 	gopkg.in/ini.v1 v1.66.2 // indirect
231 | 	gopkg.in/natefinch/lumberjack.v2 v2.0.0 // indirect
232 | 	gopkg.in/warnings.v0 v0.1.2 // indirect
233 | 	gopkg.in/yaml.v2 v2.4.0 // indirect
234 | )
235 | 
236 | require (
237 | 	github.com/apolloconfig/agollo/v4 v4.1.1-0.20220323095621-60ed86180f24
238 | 	github.com/arl/statsviz v0.6.0
239 | 	github.com/armon/go-metrics v0.4.1 // indirect
240 | 	github.com/docker/docker v27.3.0+incompatible // indirect
241 | 	github.com/fatih/color v1.12.0 // indirect
242 | 	github.com/getkin/kin-openapi v0.115.0 // indirect
243 | 	github.com/ghodss/yaml v1.0.0 // indirect
244 | 	github.com/go-playground/universal-translator v0.18.1
245 | 	github.com/go-playground/validator/v10 v10.11.2
246 | 	github.com/golang/mock v1.6.0
247 | 	github.com/google/btree v1.1.2 // indirect
248 | 	github.com/google/uuid v1.6.0 // indirect
249 | 	github.com/grpc-ecosystem/go-grpc-middleware v1.4.0
250 | 	github.com/hako/durafmt v0.0.0-20210608085754-5c1018a4e16b
251 | 	github.com/hashicorp/errwrap v1.1.0 // indirect
252 | 	github.com/hashicorp/go-immutable-radix v1.3.1 // indirect
253 | 	github.com/hashicorp/go-msgpack v1.1.5
254 | 	github.com/hashicorp/go-multierror v1.1.1 // indirect
255 | 	github.com/hashicorp/go-version v1.6.0
256 | 	github.com/hashicorp/logutils v1.0.0
257 | 	github.com/jackc/pgx/v5 v5.5.5 // indirect
258 | 	github.com/lib/pq v1.10.9 // indirect
259 | 	github.com/lithammer/shortuuid/v4 v4.0.0
260 | 	github.com/mattn/go-colorable v0.1.13
261 | 	github.com/mattn/go-runewidth v0.0.10 // indirect
262 | 	github.com/mattn/go-sqlite3 v1.14.22 // indirect
263 | 	github.com/microsoft/go-mssqldb v1.7.2 // indirect
264 | 	github.com/miekg/dns v1.1.54 // indirect
265 | 	github.com/moby/term v0.5.0 // indirect
266 | 	github.com/morikuni/aec v1.0.0 // indirect
267 | 	github.com/rbretecher/go-postman-collection v0.9.0
268 | 	github.com/rs/zerolog v1.28.0
269 | 	github.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529 // indirect
270 | 	github.com/sergi/go-diff v1.2.0 // indirect
271 | 	github.com/shirou/gopsutil v3.21.11+incompatible // indirect
272 | 	github.com/shopspring/decimal v1.4.0 // indirect
273 | 	github.com/smartystreets/goconvey v1.7.2
274 | 	github.com/ucarion/urlpath v0.0.0-20200424170820-7ccc79b76bbb
275 | 	github.com/wubin1989/nacos-sdk-go/v2 v2.1.2-0.20221024120645-0288f53fdaa8
276 | 	github.com/wubin1989/postgres v0.0.2
277 | 	go.etcd.io/etcd/client/v3 v3.5.14
278 | 	go.uber.org/automaxprocs v1.5.2
279 | 	golang.org/x/crypto v0.28.0 // indirect
280 | 	golang.org/x/exp v0.0.0-20230713183714-613f0c0eb8a1
281 | 	golang.org/x/text v0.21.0
282 | 	google.golang.org/genproto v0.0.0-20230920204549-e6e6cdab5c13 // indirect
283 | 	google.golang.org/grpc v1.64.1
284 | )
```

go.sum
```
1 | cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
2 | cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
3 | cloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=
4 | cloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=
5 | cloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
6 | cloud.google.com/go v0.44.3/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
7 | cloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=
8 | cloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=
9 | cloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=
10 | cloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=
11 | cloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=
12 | cloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=
13 | cloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=
14 | cloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=
15 | cloud.google.com/go v0.62.0/go.mod h1:jmCYTdRCQuc1PHIIJ/maLInMho30T/Y0M4hTdTShOYc=
16 | cloud.google.com/go v0.65.0/go.mod h1:O5N8zS7uWy9vkA9vayVHs65eM1ubvY4h553ofrNHObY=
17 | cloud.google.com/go v0.72.0/go.mod h1:M+5Vjvlc2wnp6tjzE102Dw08nGShTscUx2nZMufOKPI=
18 | cloud.google.com/go v0.74.0/go.mod h1:VV1xSbzvo+9QJOxLDaJfTjx5e+MePCpCWwvftOeQmWk=
19 | cloud.google.com/go v0.75.0/go.mod h1:VGuuCn7PG0dwsd5XPVm2Mm3wlh3EL55/79EKB6hlPTY=
20 | cloud.google.com/go v0.78.0/go.mod h1:QjdrLG0uq+YwhjoVOLsS1t7TW8fs36kLs4XO5R5ECHg=
21 | cloud.google.com/go v0.79.0/go.mod h1:3bzgcEeQlzbuEAYu4mrWhKqWjmpprinYgKJLgKHnbb8=
22 | cloud.google.com/go v0.81.0/go.mod h1:mk/AM35KwGk/Nm2YSeZbxXdrNK3KZOYHmLkOqC2V6E0=
23 | cloud.google.com/go v0.83.0/go.mod h1:Z7MJUsANfY0pYPdw0lbnivPx4/vhy/e2FEkSkF7vAVY=
24 | cloud.google.com/go v0.84.0/go.mod h1:RazrYuxIK6Kb7YrzzhPoLmCVzl7Sup4NrbKPg8KHSUM=
25 | cloud.google.com/go v0.87.0/go.mod h1:TpDYlFy7vuLzZMMZ+B6iRiELaY7z/gJPaqbMx6mlWcY=
26 | cloud.google.com/go v0.90.0/go.mod h1:kRX0mNRHe0e2rC6oNakvwQqzyDmg57xJ+SZU1eT2aDQ=
27 | cloud.google.com/go v0.93.3/go.mod h1:8utlLll2EF5XMAV15woO4lSbWQlk8rer9aLOfLh7+YI=
28 | cloud.google.com/go v0.94.1/go.mod h1:qAlAugsXlC+JWO+Bke5vCtc9ONxjQT3drlTTnAplMW4=
29 | cloud.google.com/go v0.97.0/go.mod h1:GF7l59pYBVlXQIBLx3a761cZ41F9bBH3JUlihCt2Udc=
30 | cloud.google.com/go v0.99.0/go.mod h1:w0Xx2nLzqWJPuozYQX+hFfCSI8WioryfRDzkoI/Y2ZA=
31 | cloud.google.com/go v0.100.1/go.mod h1:fs4QogzfH5n2pBXBP9vRiU+eCny7lD2vmFZy79Iuw1U=
32 | cloud.google.com/go v0.100.2/go.mod h1:4Xra9TjzAeYHrl5+oeLlzbM2k3mjVhZh4UqTZ//w99A=
33 | cloud.google.com/go v0.102.0/go.mod h1:oWcCzKlqJ5zgHQt9YsaeTY9KzIvjyy0ArmiBUgpQ+nc=
34 | cloud.google.com/go v0.102.1/go.mod h1:XZ77E9qnTEnrgEOvr4xzfdX5TRo7fB4T2F4O6+34hIU=
35 | cloud.google.com/go v0.104.0/go.mod h1:OO6xxXdJyvuJPcEPBLN9BJPD+jep5G1+2U5B5gkRYtA=
36 | cloud.google.com/go v0.105.0/go.mod h1:PrLgOJNe5nfE9UMxKxgXj4mD3voiP+YQ6gdt6KMFOKM=
37 | cloud.google.com/go v0.107.0/go.mod h1:wpc2eNrD7hXUTy8EKS10jkxpZBjASrORK7goS+3YX2I=
38 | cloud.google.com/go v0.110.0/go.mod h1:SJnCLqQ0FCFGSZMUNUf84MV3Aia54kn7pi8st7tMzaY=
39 | cloud.google.com/go v0.110.2/go.mod h1:k04UEeEtb6ZBRTv3dZz4CeJC3jKGxyhl0sAiVVquxiw=
40 | cloud.google.com/go/accessapproval v1.4.0/go.mod h1:zybIuC3KpDOvotz59lFe5qxRZx6C75OtwbisN56xYB4=
41 | cloud.google.com/go/accessapproval v1.5.0/go.mod h1:HFy3tuiGvMdcd/u+Cu5b9NkO1pEICJ46IR82PoUdplw=
42 | cloud.google.com/go/accessapproval v1.6.0/go.mod h1:R0EiYnwV5fsRFiKZkPHr6mwyk2wxUJ30nL4j2pcFY2E=
43 | cloud.google.com/go/accesscontextmanager v1.3.0/go.mod h1:TgCBehyr5gNMz7ZaH9xubp+CE8dkrszb4oK9CWyvD4o=
44 | cloud.google.com/go/accesscontextmanager v1.4.0/go.mod h1:/Kjh7BBu/Gh83sv+K60vN9QE5NJcd80sU33vIe2IFPE=
45 | cloud.google.com/go/accesscontextmanager v1.6.0/go.mod h1:8XCvZWfYw3K/ji0iVnp+6pu7huxoQTLmxAbVjbloTtM=
46 | cloud.google.com/go/accesscontextmanager v1.7.0/go.mod h1:CEGLewx8dwa33aDAZQujl7Dx+uYhS0eay198wB/VumQ=
47 | cloud.google.com/go/aiplatform v1.22.0/go.mod h1:ig5Nct50bZlzV6NvKaTwmplLLddFx0YReh9WfTO5jKw=
48 | cloud.google.com/go/aiplatform v1.24.0/go.mod h1:67UUvRBKG6GTayHKV8DBv2RtR1t93YRu5B1P3x99mYY=
49 | cloud.google.com/go/aiplatform v1.27.0/go.mod h1:Bvxqtl40l0WImSb04d0hXFU7gDOiq9jQmorivIiWcKg=
50 | cloud.google.com/go/aiplatform v1.35.0/go.mod h1:7MFT/vCaOyZT/4IIFfxH4ErVg/4ku6lKv3w0+tFTgXQ=
51 | cloud.google.com/go/aiplatform v1.36.1/go.mod h1:WTm12vJRPARNvJ+v6P52RDHCNe4AhvjcIZ/9/RRHy/k=
52 | cloud.google.com/go/aiplatform v1.37.0/go.mod h1:IU2Cv29Lv9oCn/9LkFiiuKfwrRTq+QQMbW+hPCxJGZw=
53 | cloud.google.com/go/analytics v0.11.0/go.mod h1:DjEWCu41bVbYcKyvlws9Er60YE4a//bK6mnhWvQeFNI=
54 | cloud.google.com/go/analytics v0.12.0/go.mod h1:gkfj9h6XRf9+TS4bmuhPEShsh3hH8PAZzm/41OOhQd4=
55 | cloud.google.com/go/analytics v0.17.0/go.mod h1:WXFa3WSym4IZ+JiKmavYdJwGG/CvpqiqczmL59bTD9M=
56 | cloud.google.com/go/analytics v0.18.0/go.mod h1:ZkeHGQlcIPkw0R/GW+boWHhCOR43xz9RN/jn7WcqfIE=
57 | cloud.google.com/go/analytics v0.19.0/go.mod h1:k8liqf5/HCnOUkbawNtrWWc+UAzyDlW89doe8TtoDsE=
58 | cloud.google.com/go/apigateway v1.3.0/go.mod h1:89Z8Bhpmxu6AmUxuVRg/ECRGReEdiP3vQtk4Z1J9rJk=
59 | cloud.google.com/go/apigateway v1.4.0/go.mod h1:pHVY9MKGaH9PQ3pJ4YLzoj6U5FUDeDFBllIz7WmzJoc=
60 | cloud.google.com/go/apigateway v1.5.0/go.mod h1:GpnZR3Q4rR7LVu5951qfXPJCHquZt02jf7xQx7kpqN8=
61 | cloud.google.com/go/apigeeconnect v1.3.0/go.mod h1:G/AwXFAKo0gIXkPTVfZDd2qA1TxBXJ3MgMRBQkIi9jc=
62 | cloud.google.com/go/apigeeconnect v1.4.0/go.mod h1:kV4NwOKqjvt2JYR0AoIWo2QGfoRtn/pkS3QlHp0Ni04=
63 | cloud.google.com/go/apigeeconnect v1.5.0/go.mod h1:KFaCqvBRU6idyhSNyn3vlHXc8VMDJdRmwDF6JyFRqZ8=
64 | cloud.google.com/go/apigeeregistry v0.4.0/go.mod h1:EUG4PGcsZvxOXAdyEghIdXwAEi/4MEaoqLMLDMIwKXY=
65 | cloud.google.com/go/apigeeregistry v0.5.0/go.mod h1:YR5+s0BVNZfVOUkMa5pAR2xGd0A473vA5M7j247o1wM=
66 | cloud.google.com/go/apigeeregistry v0.6.0/go.mod h1:BFNzW7yQVLZ3yj0TKcwzb8n25CFBri51GVGOEUcgQsc=
67 | cloud.google.com/go/apikeys v0.4.0/go.mod h1:XATS/yqZbaBK0HOssf+ALHp8jAlNHUgyfprvNcBIszU=
68 | cloud.google.com/go/apikeys v0.5.0/go.mod h1:5aQfwY4D+ewMMWScd3hm2en3hCj+BROlyrt3ytS7KLI=
69 | cloud.google.com/go/apikeys v0.6.0/go.mod h1:kbpXu5upyiAlGkKrJgQl8A0rKNNJ7dQ377pdroRSSi8=
70 | cloud.google.com/go/appengine v1.4.0/go.mod h1:CS2NhuBuDXM9f+qscZ6V86m1MIIqPj3WC/UoEuR1Sno=
71 | cloud.google.com/go/appengine v1.5.0/go.mod h1:TfasSozdkFI0zeoxW3PTBLiNqRmzraodCWatWI9Dmak=
72 | cloud.google.com/go/appengine v1.6.0/go.mod h1:hg6i0J/BD2cKmDJbaFSYHFyZkgBEfQrDg/X0V5fJn84=
73 | cloud.google.com/go/appengine v1.7.0/go.mod h1:eZqpbHFCqRGa2aCdope7eC0SWLV1j0neb/QnMJVWx6A=
74 | cloud.google.com/go/appengine v1.7.1/go.mod h1:IHLToyb/3fKutRysUlFO0BPt5j7RiQ45nrzEJmKTo6E=
75 | cloud.google.com/go/area120 v0.5.0/go.mod h1:DE/n4mp+iqVyvxHN41Vf1CR602GiHQjFPusMFW6bGR4=
76 | cloud.google.com/go/area120 v0.6.0/go.mod h1:39yFJqWVgm0UZqWTOdqkLhjoC7uFfgXRC8g/ZegeAh0=
77 | cloud.google.com/go/area120 v0.7.0/go.mod h1:a3+8EUD1SX5RUcCs3MY5YasiO1z6yLiNLRiFrykbynY=
78 | cloud.google.com/go/area120 v0.7.1/go.mod h1:j84i4E1RboTWjKtZVWXPqvK5VHQFJRF2c1Nm69pWm9k=
79 | cloud.google.com/go/artifactregistry v1.6.0/go.mod h1:IYt0oBPSAGYj/kprzsBjZ/4LnG/zOcHyFHjWPCi6SAQ=
80 | cloud.google.com/go/artifactregistry v1.7.0/go.mod h1:mqTOFOnGZx8EtSqK/ZWcsm/4U8B77rbcLP6ruDU2Ixk=
81 | cloud.google.com/go/artifactregistry v1.8.0/go.mod h1:w3GQXkJX8hiKN0v+at4b0qotwijQbYUqF2GWkZzAhC0=
82 | cloud.google.com/go/artifactregistry v1.9.0/go.mod h1:2K2RqvA2CYvAeARHRkLDhMDJ3OXy26h3XW+3/Jh2uYc=
83 | cloud.google.com/go/artifactregistry v1.11.1/go.mod h1:lLYghw+Itq9SONbCa1YWBoWs1nOucMH0pwXN1rOBZFI=
84 | cloud.google.com/go/artifactregistry v1.11.2/go.mod h1:nLZns771ZGAwVLzTX/7Al6R9ehma4WUEhZGWV6CeQNQ=
85 | cloud.google.com/go/artifactregistry v1.12.0/go.mod h1:o6P3MIvtzTOnmvGagO9v/rOjjA0HmhJ+/6KAXrmYDCI=
86 | cloud.google.com/go/artifactregistry v1.13.0/go.mod h1:uy/LNfoOIivepGhooAUpL1i30Hgee3Cu0l4VTWHUC08=
87 | cloud.google.com/go/asset v1.5.0/go.mod h1:5mfs8UvcM5wHhqtSv8J1CtxxaQq3AdBxxQi2jGW/K4o=
88 | cloud.google.com/go/asset v1.7.0/go.mod h1:YbENsRK4+xTiL+Ofoj5Ckf+O17kJtgp3Y3nn4uzZz5s=
89 | cloud.google.com/go/asset v1.8.0/go.mod h1:mUNGKhiqIdbr8X7KNayoYvyc4HbbFO9URsjbytpUaW0=
90 | cloud.google.com/go/asset v1.9.0/go.mod h1:83MOE6jEJBMqFKadM9NLRcs80Gdw76qGuHn8m3h8oHQ=
91 | cloud.google.com/go/asset v1.10.0/go.mod h1:pLz7uokL80qKhzKr4xXGvBQXnzHn5evJAEAtZiIb0wY=
92 | cloud.google.com/go/asset v1.11.1/go.mod h1:fSwLhbRvC9p9CXQHJ3BgFeQNM4c9x10lqlrdEUYXlJo=
93 | cloud.google.com/go/asset v1.12.0/go.mod h1:h9/sFOa4eDIyKmH6QMpm4eUK3pDojWnUhTgJlk762Hg=
94 | cloud.google.com/go/asset v1.13.0/go.mod h1:WQAMyYek/b7NBpYq/K4KJWcRqzoalEsxz/t/dTk4THw=
95 | cloud.google.com/go/assuredworkloads v1.5.0/go.mod h1:n8HOZ6pff6re5KYfBXcFvSViQjDwxFkAkmUFffJRbbY=
96 | cloud.google.com/go/assuredworkloads v1.6.0/go.mod h1:yo2YOk37Yc89Rsd5QMVECvjaMKymF9OP+QXWlKXUkXw=
97 | cloud.google.com/go/assuredworkloads v1.7.0/go.mod h1:z/736/oNmtGAyU47reJgGN+KVoYoxeLBoj4XkKYscNI=
98 | cloud.google.com/go/assuredworkloads v1.8.0/go.mod h1:AsX2cqyNCOvEQC8RMPnoc0yEarXQk6WEKkxYfL6kGIo=
99 | cloud.google.com/go/assuredworkloads v1.9.0/go.mod h1:kFuI1P78bplYtT77Tb1hi0FMxM0vVpRC7VVoJC3ZoT0=
100 | cloud.google.com/go/assuredworkloads v1.10.0/go.mod h1:kwdUQuXcedVdsIaKgKTp9t0UJkE5+PAVNhdQm4ZVq2E=
101 | cloud.google.com/go/automl v1.5.0/go.mod h1:34EjfoFGMZ5sgJ9EoLsRtdPSNZLcfflJR39VbVNS2M0=
102 | cloud.google.com/go/automl v1.6.0/go.mod h1:ugf8a6Fx+zP0D59WLhqgTDsQI9w07o64uf/Is3Nh5p8=
103 | cloud.google.com/go/automl v1.7.0/go.mod h1:RL9MYCCsJEOmt0Wf3z9uzG0a7adTT1fe+aObgSpkCt8=
104 | cloud.google.com/go/automl v1.8.0/go.mod h1:xWx7G/aPEe/NP+qzYXktoBSDfjO+vnKMGgsApGJJquM=
105 | cloud.google.com/go/automl v1.12.0/go.mod h1:tWDcHDp86aMIuHmyvjuKeeHEGq76lD7ZqfGLN6B0NuU=
106 | cloud.google.com/go/baremetalsolution v0.3.0/go.mod h1:XOrocE+pvK1xFfleEnShBlNAXf+j5blPPxrhjKgnIFc=
107 | cloud.google.com/go/baremetalsolution v0.4.0/go.mod h1:BymplhAadOO/eBa7KewQ0Ppg4A4Wplbn+PsFKRLo0uI=
108 | cloud.google.com/go/baremetalsolution v0.5.0/go.mod h1:dXGxEkmR9BMwxhzBhV0AioD0ULBmuLZI8CdwalUxuss=
109 | cloud.google.com/go/batch v0.3.0/go.mod h1:TR18ZoAekj1GuirsUsR1ZTKN3FC/4UDnScjT8NXImFE=
110 | cloud.google.com/go/batch v0.4.0/go.mod h1:WZkHnP43R/QCGQsZ+0JyG4i79ranE2u8xvjq/9+STPE=
111 | cloud.google.com/go/batch v0.7.0/go.mod h1:vLZN95s6teRUqRQ4s3RLDsH8PvboqBK+rn1oevL159g=
112 | cloud.google.com/go/beyondcorp v0.2.0/go.mod h1:TB7Bd+EEtcw9PCPQhCJtJGjk/7TC6ckmnSFS+xwTfm4=
113 | cloud.google.com/go/beyondcorp v0.3.0/go.mod h1:E5U5lcrcXMsCuoDNyGrpyTm/hn7ne941Jz2vmksAxW8=
114 | cloud.google.com/go/beyondcorp v0.4.0/go.mod h1:3ApA0mbhHx6YImmuubf5pyW8srKnCEPON32/5hj+RmM=
115 | cloud.google.com/go/beyondcorp v0.5.0/go.mod h1:uFqj9X+dSfrheVp7ssLTaRHd2EHqSL4QZmH4e8WXGGU=
116 | cloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=
117 | cloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=
118 | cloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=
119 | cloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=
120 | cloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=
121 | cloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=
122 | cloud.google.com/go/bigquery v1.42.0/go.mod h1:8dRTJxhtG+vwBKzE5OseQn/hiydoQN3EedCaOdYmxRA=
123 | cloud.google.com/go/bigquery v1.43.0/go.mod h1:ZMQcXHsl+xmU1z36G2jNGZmKp9zNY5BUua5wDgmNCfw=
124 | cloud.google.com/go/bigquery v1.44.0/go.mod h1:0Y33VqXTEsbamHJvJHdFmtqHvMIY28aK1+dFsvaChGc=
125 | cloud.google.com/go/bigquery v1.47.0/go.mod h1:sA9XOgy0A8vQK9+MWhEQTY6Tix87M/ZurWFIxmF9I/E=
126 | cloud.google.com/go/bigquery v1.48.0/go.mod h1:QAwSz+ipNgfL5jxiaK7weyOhzdoAy1zFm0Nf1fysJac=
127 | cloud.google.com/go/bigquery v1.49.0/go.mod h1:Sv8hMmTFFYBlt/ftw2uN6dFdQPzBlREY9yBh7Oy7/4Q=
128 | cloud.google.com/go/bigquery v1.50.0/go.mod h1:YrleYEh2pSEbgTBZYMJ5SuSr0ML3ypjRB1zgf7pvQLU=
129 | cloud.google.com/go/billing v1.4.0/go.mod h1:g9IdKBEFlItS8bTtlrZdVLWSSdSyFUZKXNS02zKMOZY=
130 | cloud.google.com/go/billing v1.5.0/go.mod h1:mztb1tBc3QekhjSgmpf/CV4LzWXLzCArwpLmP2Gm88s=
131 | cloud.google.com/go/billing v1.6.0/go.mod h1:WoXzguj+BeHXPbKfNWkqVtDdzORazmCjraY+vrxcyvI=
132 | cloud.google.com/go/billing v1.7.0/go.mod h1:q457N3Hbj9lYwwRbnlD7vUpyjq6u5U1RAOArInEiD5Y=
133 | cloud.google.com/go/billing v1.12.0/go.mod h1:yKrZio/eu+okO/2McZEbch17O5CB5NpZhhXG6Z766ss=
134 | cloud.google.com/go/billing v1.13.0/go.mod h1:7kB2W9Xf98hP9Sr12KfECgfGclsH3CQR0R08tnRlRbc=
135 | cloud.google.com/go/binaryauthorization v1.1.0/go.mod h1:xwnoWu3Y84jbuHa0zd526MJYmtnVXn0syOjaJgy4+dM=
136 | cloud.google.com/go/binaryauthorization v1.2.0/go.mod h1:86WKkJHtRcv5ViNABtYMhhNWRrD1Vpi//uKEy7aYEfI=
137 | cloud.google.com/go/binaryauthorization v1.3.0/go.mod h1:lRZbKgjDIIQvzYQS1p99A7/U1JqvqeZg0wiI5tp6tg0=
138 | cloud.google.com/go/binaryauthorization v1.4.0/go.mod h1:tsSPQrBd77VLplV70GUhBf/Zm3FsKmgSqgm4UmiDItk=
139 | cloud.google.com/go/binaryauthorization v1.5.0/go.mod h1:OSe4OU1nN/VswXKRBmciKpo9LulY41gch5c68htf3/Q=
140 | cloud.google.com/go/certificatemanager v1.3.0/go.mod h1:n6twGDvcUBFu9uBgt4eYvvf3sQ6My8jADcOVwHmzadg=
141 | cloud.google.com/go/certificatemanager v1.4.0/go.mod h1:vowpercVFyqs8ABSmrdV+GiFf2H/ch3KyudYQEMM590=
142 | cloud.google.com/go/certificatemanager v1.6.0/go.mod h1:3Hh64rCKjRAX8dXgRAyOcY5vQ/fE1sh8o+Mdd6KPgY8=
143 | cloud.google.com/go/channel v1.8.0/go.mod h1:W5SwCXDJsq/rg3tn3oG0LOxpAo6IMxNa09ngphpSlnk=
144 | cloud.google.com/go/channel v1.9.0/go.mod h1:jcu05W0my9Vx4mt3/rEHpfxc9eKi9XwsdDL8yBMbKUk=
145 | cloud.google.com/go/channel v1.11.0/go.mod h1:IdtI0uWGqhEeatSB62VOoJ8FSUhJ9/+iGkJVqp74CGE=
146 | cloud.google.com/go/channel v1.12.0/go.mod h1:VkxCGKASi4Cq7TbXxlaBezonAYpp1GCnKMY6tnMQnLU=
147 | cloud.google.com/go/cloudbuild v1.3.0/go.mod h1:WequR4ULxlqvMsjDEEEFnOG5ZSRSgWOywXYDb1vPE6U=
148 | cloud.google.com/go/cloudbuild v1.4.0/go.mod h1:5Qwa40LHiOXmz3386FrjrYM93rM/hdRr7b53sySrTqA=
149 | cloud.google.com/go/cloudbuild v1.6.0/go.mod h1:UIbc/w9QCbH12xX+ezUsgblrWv+Cv4Tw83GiSMHOn9M=
150 | cloud.google.com/go/cloudbuild v1.7.0/go.mod h1:zb5tWh2XI6lR9zQmsm1VRA+7OCuve5d8S+zJUul8KTg=
151 | cloud.google.com/go/cloudbuild v1.9.0/go.mod h1:qK1d7s4QlO0VwfYn5YuClDGg2hfmLZEb4wQGAbIgL1s=
152 | cloud.google.com/go/clouddms v1.3.0/go.mod h1:oK6XsCDdW4Ib3jCCBugx+gVjevp2TMXFtgxvPSee3OM=
153 | cloud.google.com/go/clouddms v1.4.0/go.mod h1:Eh7sUGCC+aKry14O1NRljhjyrr0NFC0G2cjwX0cByRk=
154 | cloud.google.com/go/clouddms v1.5.0/go.mod h1:QSxQnhikCLUw13iAbffF2CZxAER3xDGNHjsTAkQJcQA=
155 | cloud.google.com/go/cloudtasks v1.5.0/go.mod h1:fD92REy1x5woxkKEkLdvavGnPJGEn8Uic9nWuLzqCpY=
156 | cloud.google.com/go/cloudtasks v1.6.0/go.mod h1:C6Io+sxuke9/KNRkbQpihnW93SWDU3uXt92nu85HkYI=
157 | cloud.google.com/go/cloudtasks v1.7.0/go.mod h1:ImsfdYWwlWNJbdgPIIGJWC+gemEGTBK/SunNQQNCAb4=
158 | cloud.google.com/go/cloudtasks v1.8.0/go.mod h1:gQXUIwCSOI4yPVK7DgTVFiiP0ZW/eQkydWzwVMdHxrI=
159 | cloud.google.com/go/cloudtasks v1.9.0/go.mod h1:w+EyLsVkLWHcOaqNEyvcKAsWp9p29dL6uL9Nst1cI7Y=
160 | cloud.google.com/go/cloudtasks v1.10.0/go.mod h1:NDSoTLkZ3+vExFEWu2UJV1arUyzVDAiZtdWcsUyNwBs=
161 | cloud.google.com/go/compute v0.1.0/go.mod h1:GAesmwr110a34z04OlxYkATPBEfVhkymfTBXtfbBFow=
162 | cloud.google.com/go/compute v1.3.0/go.mod h1:cCZiE1NHEtai4wiufUhW8I8S1JKkAnhnQJWM7YD99wM=
163 | cloud.google.com/go/compute v1.5.0/go.mod h1:9SMHyhJlzhlkJqrPAc839t2BZFTSk6Jdj6mkzQJeu0M=
164 | cloud.google.com/go/compute v1.6.0/go.mod h1:T29tfhtVbq1wvAPo0E3+7vhgmkOYeXjhFvz/FMzPu0s=
165 | cloud.google.com/go/compute v1.6.1/go.mod h1:g85FgpzFvNULZ+S8AYq87axRKuf2Kh7deLqV/jJ3thU=
166 | cloud.google.com/go/compute v1.7.0/go.mod h1:435lt8av5oL9P3fv1OEzSbSUe+ybHXGMPQHHZWZxy9U=
167 | cloud.google.com/go/compute v1.10.0/go.mod h1:ER5CLbMxl90o2jtNbGSbtfOpQKR0t15FOtRsugnLrlU=
168 | cloud.google.com/go/compute v1.12.0/go.mod h1:e8yNOBcBONZU1vJKCvCoDw/4JQsA0dpM4x/6PIIOocU=
169 | cloud.google.com/go/compute v1.12.1/go.mod h1:e8yNOBcBONZU1vJKCvCoDw/4JQsA0dpM4x/6PIIOocU=
170 | cloud.google.com/go/compute v1.13.0/go.mod h1:5aPTS0cUNMIc1CE546K+Th6weJUNQErARyZtRXDJ8GE=
171 | cloud.google.com/go/compute v1.14.0/go.mod h1:YfLtxrj9sU4Yxv+sXzZkyPjEyPBZfXHUvjxega5vAdo=
172 | cloud.google.com/go/compute v1.15.1/go.mod h1:bjjoF/NtFUrkD/urWfdHaKuOPDR5nWIs63rR+SXhcpA=
173 | cloud.google.com/go/compute v1.18.0/go.mod h1:1X7yHxec2Ga+Ss6jPyjxRxpu2uu7PLgsOVXvgU0yacs=
174 | cloud.google.com/go/compute v1.19.0/go.mod h1:rikpw2y+UMidAe9tISo04EHNOIf42RLYF/q8Bs93scU=
175 | cloud.google.com/go/compute v1.19.3/go.mod h1:qxvISKp/gYnXkSAD1ppcSOveRAmzxicEv/JlizULFrI=
176 | cloud.google.com/go/compute v1.20.1/go.mod h1:4tCnrn48xsqlwSAiLf1HXMQk8CONslYbdiEZc9FEIbM=
177 | cloud.google.com/go/compute/metadata v0.1.0/go.mod h1:Z1VN+bulIf6bt4P/C37K4DyZYZEXYonfTBHHFPO/4UU=
178 | cloud.google.com/go/compute/metadata v0.2.0/go.mod h1:zFmK7XCadkQkj6TtorcaGlCW1hT1fIilQDwofLpJ20k=
179 | cloud.google.com/go/compute/metadata v0.2.1/go.mod h1:jgHgmJd2RKBGzXqF5LR2EZMGxBkeanZ9wwa75XHJgOM=
180 | cloud.google.com/go/compute/metadata v0.2.3/go.mod h1:VAV5nSsACxMJvgaAuX6Pk2AawlZn8kiOGuCv6gTkwuA=
181 | cloud.google.com/go/contactcenterinsights v1.3.0/go.mod h1:Eu2oemoePuEFc/xKFPjbTuPSj0fYJcPls9TFlPNnHHY=
182 | cloud.google.com/go/contactcenterinsights v1.4.0/go.mod h1:L2YzkGbPsv+vMQMCADxJoT9YiTTnSEd6fEvCeHTYVck=
183 | cloud.google.com/go/contactcenterinsights v1.6.0/go.mod h1:IIDlT6CLcDoyv79kDv8iWxMSTZhLxSCofVV5W6YFM/w=
184 | cloud.google.com/go/container v1.6.0/go.mod h1:Xazp7GjJSeUYo688S+6J5V+n/t+G5sKBTFkKNudGRxg=
185 | cloud.google.com/go/container v1.7.0/go.mod h1:Dp5AHtmothHGX3DwwIHPgq45Y8KmNsgN3amoYfxVkLo=
186 | cloud.google.com/go/container v1.13.1/go.mod h1:6wgbMPeQRw9rSnKBCAJXnds3Pzj03C4JHamr8asWKy4=
187 | cloud.google.com/go/container v1.14.0/go.mod h1:3AoJMPhHfLDxLvrlVWaK57IXzaPnLaZq63WX59aQBfM=
188 | cloud.google.com/go/container v1.15.0/go.mod h1:ft+9S0WGjAyjDggg5S06DXj+fHJICWg8L7isCQe9pQA=
189 | cloud.google.com/go/containeranalysis v0.5.1/go.mod h1:1D92jd8gRR/c0fGMlymRgxWD3Qw9C1ff6/T7mLgVL8I=
190 | cloud.google.com/go/containeranalysis v0.6.0/go.mod h1:HEJoiEIu+lEXM+k7+qLCci0h33lX3ZqoYFdmPcoO7s4=
191 | cloud.google.com/go/containeranalysis v0.7.0/go.mod h1:9aUL+/vZ55P2CXfuZjS4UjQ9AgXoSw8Ts6lemfmxBxI=
192 | cloud.google.com/go/containeranalysis v0.9.0/go.mod h1:orbOANbwk5Ejoom+s+DUCTTJ7IBdBQJDcSylAx/on9s=
193 | cloud.google.com/go/datacatalog v1.3.0/go.mod h1:g9svFY6tuR+j+hrTw3J2dNcmI0dzmSiyOzm8kpLq0a0=
194 | cloud.google.com/go/datacatalog v1.5.0/go.mod h1:M7GPLNQeLfWqeIm3iuiruhPzkt65+Bx8dAKvScX8jvs=
195 | cloud.google.com/go/datacatalog v1.6.0/go.mod h1:+aEyF8JKg+uXcIdAmmaMUmZ3q1b/lKLtXCmXdnc0lbc=
196 | cloud.google.com/go/datacatalog v1.7.0/go.mod h1:9mEl4AuDYWw81UGc41HonIHH7/sn52H0/tc8f8ZbZIE=
197 | cloud.google.com/go/datacatalog v1.8.0/go.mod h1:KYuoVOv9BM8EYz/4eMFxrr4DUKhGIOXxZoKYF5wdISM=
198 | cloud.google.com/go/datacatalog v1.8.1/go.mod h1:RJ58z4rMp3gvETA465Vg+ag8BGgBdnRPEMMSTr5Uv+M=
199 | cloud.google.com/go/datacatalog v1.12.0/go.mod h1:CWae8rFkfp6LzLumKOnmVh4+Zle4A3NXLzVJ1d1mRm0=
200 | cloud.google.com/go/datacatalog v1.13.0/go.mod h1:E4Rj9a5ZtAxcQJlEBTLgMTphfP11/lNaAshpoBgemX8=
201 | cloud.google.com/go/dataflow v0.6.0/go.mod h1:9QwV89cGoxjjSR9/r7eFDqqjtvbKxAK2BaYU6PVk9UM=
[TRUNCATED]
```

main.go
```
1 | /*
2 | Copyright © 2021 wubin1989 <328454505@qq.com>
3 | 
4 | Permission is hereby granted, free of charge, to any person obtaining a copy
5 | of this software and associated documentation files (the "Software"), to deal
6 | in the Software without restriction, including without limitation the rights
7 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
8 | copies of the Software, and to permit persons to whom the Software is
9 | furnished to do so, subject to the following conditions:
10 | 
11 | The above copyright notice and this permission notice shall be included in
12 | all copies or substantial portions of the Software.
13 | 
14 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
15 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
16 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
17 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
18 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
19 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
20 | THE SOFTWARE.
21 | */
22 | package main
23 | 
24 | import "github.com/unionj-cloud/go-doudou/v2/cmd"
25 | 
26 | func main() {
27 | 	cmd.Execute()
28 | }
```

framework/framework.go
```
1 | package framework
2 | 
3 | import (
4 | 	"sync"
5 | 
6 | 	"github.com/common-nighthawk/go-figure"
7 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
8 | )
9 | 
10 | type Annotation struct {
11 | 	Name   string
12 | 	Params []string
13 | }
14 | 
15 | type AnnotationStore map[string][]Annotation
16 | 
17 | func (receiver AnnotationStore) HasAnnotation(key string, annotationName string) bool {
18 | 	for _, item := range receiver[key] {
19 | 		if item.Name == annotationName {
20 | 			return true
21 | 		}
22 | 	}
23 | 	return false
24 | }
25 | 
26 | func (receiver AnnotationStore) GetParams(key string, annotationName string) []string {
27 | 	for _, item := range receiver[key] {
28 | 		if item.Name == annotationName {
29 | 			return item.Params
30 | 		}
31 | 	}
32 | 	return nil
33 | }
34 | 
35 | var PrintLock sync.Mutex
36 | 
37 | var once sync.Once
38 | 
39 | func PrintBanner() {
40 | 	once.Do(func() {
41 | 		if !config.CheckDev() {
42 | 			return
43 | 		}
44 | 		if config.GddConfig.Banner {
45 | 			figure.NewColorFigure(config.GddConfig.BannerText, "doom", "green", true).Print()
46 | 		}
47 | 	})
48 | }
```

cmd/client.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
5 | 
6 | 	"github.com/spf13/cobra"
7 | )
8 | 
9 | var docfile string
10 | var baseURLEnv string
11 | var clientpkg string
12 | 
13 | // clientCmd generates http client code
14 | var clientCmd = &cobra.Command{
15 | 	Use:   "client",
16 | 	Short: "generate http client from openapi 3.0 spec json file",
17 | 	Long:  ``,
18 | 	Run: func(cmd *cobra.Command, args []string) {
19 | 		s := svc.Svc{
20 | 			DocPath:   docfile,
21 | 			Omitempty: omitempty,
22 | 			Env:       baseURLEnv,
23 | 			ClientPkg: clientpkg,
24 | 		}
25 | 		s.GenClient()
26 | 	},
27 | }
28 | 
29 | func init() {
30 | 	httpCmd.AddCommand(clientCmd)
31 | 
32 | 	clientCmd.Flags().StringVarP(&docfile, "file", "f", "", `OpenAPI 3.0 or Swagger 2.0 spec json file path or download link`)
33 | 	clientCmd.Flags().StringVarP(&baseURLEnv, "env", "e", "", `base url environment variable name`)
34 | 	clientCmd.Flags().StringVarP(&clientpkg, "pkg", "p", "client", `client package name`)
35 | 	clientCmd.Flags().BoolVarP(&omitempty, "omit", "o", false, `json tag omitempty`)
36 | }
```

cmd/client_test.go
```
1 | package cmd_test
2 | 
3 | import (
4 | 	"os"
5 | 	"testing"
6 | 
7 | 	"github.com/unionj-cloud/go-doudou/v2/cmd"
8 | )
9 | 
10 | func TestClientCmd(t *testing.T) {
11 | 	defer os.RemoveAll("client")
12 | 	// go-doudou svc http client --file testdata/testsvc/testsvc_openapi3.json
13 | 	_, _, err := ExecuteCommandC(cmd.GetRootCmd(), []string{"svc", "http", "client", "--file", "testdata/testsvc/testsvc_openapi3.json"}...)
14 | 	if err != nil {
15 | 		t.Error(err)
16 | 		return
17 | 	}
18 | }
```

cmd/crud.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/iancoleman/strcase"
5 | 	"github.com/sirupsen/logrus"
6 | 	"github.com/spf13/cobra"
7 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
8 | 	"github.com/unionj-cloud/toolkit/pathutils"
9 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
10 | 	"github.com/unionj-cloud/toolkit/stringutils"
11 | )
12 | 
13 | var dbDriver string
14 | var dbDsn string
15 | var dbOrm string
16 | var dbSoft string
17 | var dbService string
18 | var dbTablePrefix string
19 | var dbTableGlob string
20 | var dbTableExcludeGlob string
21 | var dbGenGenGo bool
22 | var dbOmitempty bool
23 | var dbTypeMapping string
24 | 
25 | var crudCmd = &cobra.Command{
26 | 	Use:   "crud",
27 | 	Short: "generate universal crud code from database",
28 | 	Long:  ``,
29 | 	Run: func(cmd *cobra.Command, args []string) {
30 | 		if stringutils.IsEmpty(dbDriver) || stringutils.IsEmpty(dbDsn) {
31 | 			logrus.Warn("Parameters db_driver and db_dsn must be specified")
32 | 			return
33 | 		}
34 | 		var options []svc.SvcOption
35 | 		options = append(options, svc.WithDbConfig(&svc.DbConfig{
36 | 			Driver:           dbDriver,
37 | 			Dsn:              dbDsn,
38 | 			TablePrefix:      dbTablePrefix,
39 | 			TableGlob:        dbTableGlob,
40 | 			TableExcludeGlob: dbTableExcludeGlob,
41 | 			GenGenGo:         dbGenGenGo,
42 | 			Orm:              dbOrm,
43 | 			Soft:             dbSoft,
44 | 			Service:          dbService,
45 | 			Omitempty:        dbOmitempty,
46 | 			TypeMapping:      dbTypeMapping,
47 | 		}))
48 | 		fn := strcase.ToLowerCamel
49 | 		switch naming {
50 | 		case "snake":
51 | 			fn = strcase.ToSnake
52 | 		}
53 | 		options = append(options, svc.WithJsonCase(naming), svc.WithCaseConverter(fn), svc.WithProtoGenerator(v3.NewProtoGenerator(v3.WithFieldNamingFunc(fn), v3.WithProtocCmd(protocCmd))))
54 | 		svcdir, _ := pathutils.FixPath("", "")
55 | 		s := svc.NewSvc(svcdir, options...)
56 | 		s.Crud()
57 | 	},
58 | }
59 | 
60 | func init() {
61 | 	svcCmd.AddCommand(crudCmd)
62 | 
63 | 	crudCmd.Flags().StringVar(&dbOrm, "db_orm", "gorm", `Specify your preferable orm, currently only support gorm`)
64 | 	crudCmd.Flags().StringVar(&dbDriver, "db_driver", "", `Choose one database driver from "mysql", "postgres", "sqlite", "sqlserver", "tidb"`)
65 | 	crudCmd.Flags().StringVar(&dbDsn, "db_dsn", "", `Specify database connection url`)
66 | 	crudCmd.Flags().StringVar(&dbSoft, "db_soft", "deleted_at", `Specify database soft delete column name`)
67 | 	crudCmd.Flags().StringVar(&dbService, "db_service", "", `Generate grpc or rest service, accept values: grpc or rest`)
68 | 	crudCmd.Flags().BoolVar(&dbGenGenGo, "db_gen_gen", false, `whether generate gen.go file`)
69 | 	crudCmd.Flags().StringVar(&dbTablePrefix, "db_table_prefix", "", `table prefix or schema name for pg`)
70 | 	crudCmd.Flags().StringVar(&dbTableGlob, "db_table_glob", "", `used to filter glob-matched tables`)
71 | 	crudCmd.Flags().StringVar(&dbTableExcludeGlob, "db_table_exclude_glob", "", `used to filter glob-matched tables`)
72 | 	crudCmd.Flags().StringVar(&naming, "case", "lowerCamel", `protobuf message field and json tag case, only support "lowerCamel" and "snake"`)
73 | 	crudCmd.Flags().StringVar(&dbTypeMapping, "db_type_mapping", "", `Specify custom column type to go type mapping, multiple mappings can be joined by comma, eg. bigint:string,tinyint:bool`)
74 | 	crudCmd.Flags().StringVar(&protocCmd, "grpc_gen_cmd", "protoc --proto_path=. --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative --go-json_out=. --go-json_opt=paths=source_relative,allow_unknown=true", `command to generate grpc service and message code`)
75 | 	crudCmd.Flags().BoolVar(&dbOmitempty, "db_omitempty", false, `whether add omitempty json tag to generated model field"`)
76 | }
```

cmd/ddl.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/sirupsen/logrus"
5 | 	"github.com/spf13/cobra"
6 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl"
7 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/config"
8 | 	"github.com/unionj-cloud/toolkit/dotenv"
9 | 	"github.com/unionj-cloud/toolkit/envconfig"
10 | 	"github.com/unionj-cloud/toolkit/pathutils"
11 | 	"github.com/unionj-cloud/toolkit/yaml"
12 | )
13 | 
14 | var dir string
15 | var reverse bool
16 | var dao bool
17 | var pre string
18 | var df string
19 | var env string
20 | 
21 | // ddlCmd generates entity and dao layer source code from database tables and update tables from entity code
22 | var ddlCmd = &cobra.Command{
23 | 	Use:   "ddl",
24 | 	Short: "migration tool between database table structure and golang struct",
25 | 	Long:  ``,
26 | 	Run: func(cmd *cobra.Command, args []string) {
27 | 		yaml.Load(env)
28 | 		dotenv.Load(env)
29 | 		var conf config.DbConfig
30 | 		err := envconfig.Process("db", &conf)
31 | 		if err != nil {
32 | 			logrus.Panicln("Error processing env", err)
33 | 		}
34 | 		if dir, err = pathutils.FixPath(dir, "entity"); err != nil {
35 | 			logrus.Panicln(err)
36 | 		}
37 | 		d := ddl.Ddl{dir, reverse, dao, pre, df, conf}
38 | 		d.Exec()
39 | 	},
40 | }
41 | 
42 | func init() {
43 | 	rootCmd.AddCommand(ddlCmd)
44 | 
45 | 	// Here you will define your flags and configuration settings.
46 | 
47 | 	// Cobra supports Persistent Flags which will work for this command
48 | 	// and all subcommands, e.g.:
49 | 	// ddlCmd.PersistentFlags().String("foo", "", "A help for foo")
50 | 
51 | 	// Cobra supports local flags which will only run when this command
52 | 	// is called directly, e.g.:
53 | 	ddlCmd.Flags().StringVar(&dir, "entity", "entity", "Path of entity folder.")
54 | 	ddlCmd.Flags().StringVar(&pre, "pre", "", "Table name prefix. e.g.: prefix biz_ for biz_product.")
55 | 	ddlCmd.Flags().StringVar(&df, "df", "dao", "Name of dao folder.")
56 | 	ddlCmd.Flags().StringVar(&env, "env", "dev", "Environment name such as dev, uat, test, prod, default is dev")
57 | 	ddlCmd.Flags().BoolVarP(&reverse, "reverse", "r", false, "If true, generate entity code from database. If false, update or create database tables from entity code.")
58 | 	ddlCmd.Flags().BoolVarP(&dao, "dao", "d", false, "If true, generate dao code.")
59 | }
```

cmd/ddl_test.go
```
1 | package cmd_test
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"os/exec"
7 | 
8 | 	"github.com/spf13/cobra"
9 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
10 | 	"github.com/unionj-cloud/toolkit/pathutils"
11 | )
12 | 
13 | var testDir string
14 | 
15 | func init() {
16 | 	testDir = pathutils.Abs("testdata")
17 | }
18 | 
19 | func ExecuteCommandC(root *cobra.Command, args ...string) (c *cobra.Command, output string, err error) {
20 | 	buf := new(bytes.Buffer)
21 | 	root.SetOut(buf)
22 | 	root.SetErr(buf)
23 | 	root.SetArgs(args)
24 | 
25 | 	c, err = root.ExecuteC()
26 | 
27 | 	return c, buf.String(), err
28 | }
29 | 
30 | // NewMockSvc new Svc instance for unit test purpose
31 | func NewMockSvc(dir string, opts ...svc.SvcOption) svc.ISvc {
32 | 	return svc.NewSvc(dir, svc.WithRunner(mockRunner{}))
33 | }
34 | 
35 | type mockRunner struct {
36 | }
37 | 
38 | func (r mockRunner) Output(command string, args ...string) ([]byte, error) {
39 | 	return []byte("go version go1.17.8 darwin/amd64"), nil
40 | }
41 | 
42 | func (r mockRunner) Run(command string, args ...string) error {
43 | 	cs := []string{"-test.run=TestHelperProcess", "--"}
44 | 	cs = append(cs, args...)
45 | 	c := exec.Command(os.Args[0], cs...)
46 | 	c.Env = []string{"GO_WANT_HELPER_PROCESS=1"}
47 | 	c.Stdout = os.Stdout
48 | 	c.Stderr = os.Stderr
49 | 	if err := c.Run(); err != nil {
50 | 		panic(err)
51 | 	}
52 | 	return nil
53 | }
54 | 
55 | func (r mockRunner) Start(command string, args ...string) (*exec.Cmd, error) {
56 | 	cs := []string{"-test.run=TestHelperProcess", "--"}
57 | 	cs = append(cs, args...)
58 | 	cmd := exec.Command(os.Args[0], cs...)
59 | 	cmd.Env = []string{"GO_WANT_HELPER_PROCESS=1"}
60 | 	cmd.Stdout = os.Stdout
61 | 	cmd.Stderr = os.Stderr
62 | 	if err := cmd.Start(); err != nil {
63 | 		panic(err)
64 | 	}
65 | 	return cmd, nil
66 | }
```

cmd/deploy.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/spf13/cobra"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
6 | )
7 | 
8 | // deployCmd deploy service to k8s
9 | var deployCmd = &cobra.Command{
10 | 	Use:   "deploy",
11 | 	Short: "wrap command kubectl apply to deploy service to k8s",
12 | 	Long:  ``,
13 | 	Run: func(cmd *cobra.Command, args []string) {
14 | 		s := svc.NewSvc("")
15 | 		s.Deploy(k8sfile)
16 | 	},
17 | }
18 | 
19 | func init() {
20 | 	svcCmd.AddCommand(deployCmd)
21 | }
```

cmd/enum.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/spf13/cobra"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/enum"
6 | )
7 | 
8 | // enumCmd updates json tag of struct fields
9 | var enumCmd = &cobra.Command{
10 | 	Use:   "enum",
11 | 	Short: "Generate functions for constants to implement IEnum interface",
12 | 	Long:  ``,
13 | 	Run: func(cmd *cobra.Command, args []string) {
14 | 		n := enum.Generator{
15 | 			File: file,
16 | 		}
17 | 		n.Generate()
18 | 	},
19 | }
20 | 
21 | func init() {
22 | 	rootCmd.AddCommand(enumCmd)
23 | 	enumCmd.Flags().StringVarP(&file, "file", "f", "", "absolute path of dto file")
24 | }
```

cmd/enum_test.go
```
1 | package cmd_test
2 | 
3 | import (
4 | 	"path/filepath"
5 | 	"testing"
6 | 
7 | 	"github.com/unionj-cloud/go-doudou/v2/cmd"
8 | )
9 | 
10 | func TestEnumCmd(t *testing.T) {
11 | 	_, _, err := ExecuteCommandC(cmd.GetRootCmd(), []string{"enum", "-f", filepath.Join("testdata", "testsvc", "vo", "vo.go")}...)
12 | 	if err != nil {
13 | 		t.Fatal(err)
14 | 	}
15 | }
```

cmd/grpc.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/iancoleman/strcase"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
6 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
7 | 
8 | 	"github.com/spf13/cobra"
9 | )
10 | 
11 | var naming string
12 | var http2grpc bool
13 | var annotatedOnly bool
14 | var protocCmd string
15 | 
16 | var grpcCmd = &cobra.Command{
17 | 	Use:   "grpc",
18 | 	Short: "generate grpc service",
19 | 	Long:  ``,
20 | 	Run: func(cmd *cobra.Command, args []string) {
21 | 		fn := strcase.ToLowerCamel
22 | 		switch naming {
23 | 		case "snake":
24 | 			fn = strcase.ToSnake
25 | 		}
26 | 		s := svc.NewSvc("",
27 | 			svc.WithProtoGenerator(v3.NewProtoGenerator(v3.WithFieldNamingFunc(fn), v3.WithAnnotatedOnly(annotatedOnly), v3.WithProtocCmd(protocCmd))),
28 | 			svc.WithHttp2Grpc(http2grpc),
29 | 			svc.WithAllowGetWithReqBody(allowGetWithReqBody),
30 | 			svc.WithCaseConverter(fn),
31 | 			svc.WithOmitempty(omitempty),
32 | 		)
33 | 		s.Grpc()
34 | 	},
35 | }
36 | 
37 | func init() {
38 | 	svcCmd.AddCommand(grpcCmd)
39 | 	grpcCmd.Flags().BoolVarP(&omitempty, "omitempty", "o", false, `if true, ",omitempty" will be appended to json tag of fields in every generated anonymous struct in handlers`)
40 | 	grpcCmd.Flags().StringVar(&naming, "case", "lowerCamel", `protobuf message field naming strategy, only support "lowerCamel" and "snake"`)
41 | 	grpcCmd.Flags().StringVar(&protocCmd, "grpc_gen_cmd", "protoc --proto_path=. --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative --go-json_out=. --go-json_opt=paths=source_relative,allow_unknown=true", `command to generate grpc service and message code`)
42 | 	grpcCmd.Flags().BoolVar(&http2grpc, "http2grpc", false, `whether need RESTful api for your grpc service`)
43 | 	grpcCmd.Flags().BoolVar(&allowGetWithReqBody, "allow_get_body", false, "Whether allow get http request with request body.")
44 | 	grpcCmd.Flags().BoolVar(&annotatedOnly, "annotated_only", false, "Whether generate grpc api only for method annotated with @grpc or not")
45 | }
```

cmd/http.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/iancoleman/strcase"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
6 | 
7 | 	"github.com/spf13/cobra"
8 | )
9 | 
10 | var handler bool
11 | var client bool
12 | var doc bool
13 | var jsonCase string
14 | var routePatternStrategy int
15 | var allowGetWithReqBody bool
16 | 
17 | // httpCmd generates scaffold code of restful service
18 | var httpCmd = &cobra.Command{
19 | 	Use:   "http",
20 | 	Short: "generate http routes and handlers",
21 | 	Long:  ``,
22 | 	Run: func(cmd *cobra.Command, args []string) {
23 | 		fn := strcase.ToLowerCamel
24 | 		switch jsonCase {
25 | 		case "snake":
26 | 			fn = strcase.ToSnake
27 | 		}
28 | 		s := svc.Svc{
29 | 			Handler:              handler,
30 | 			Client:               client,
31 | 			Omitempty:            omitempty,
32 | 			Doc:                  doc,
33 | 			CaseConverter:        fn,
34 | 			Env:                  baseURLEnv,
35 | 			RoutePatternStrategy: routePatternStrategy,
36 | 			AllowGetWithReqBody:  allowGetWithReqBody,
37 | 		}
38 | 		s.Http()
39 | 	},
40 | }
41 | 
42 | func init() {
43 | 	svcCmd.AddCommand(httpCmd)
44 | 
45 | 	httpCmd.Flags().BoolVar(&handler, "handler", false, "Whether generate default handler implementation or not")
46 | 	httpCmd.Flags().BoolVarP(&client, "client", "c", false, `Whether generate default golang http client code or not`)
47 | 	httpCmd.Flags().BoolVarP(&omitempty, "omitempty", "o", false, `if true, ",omitempty" will be appended to json tag of fields in every generated anonymous struct in handlers`)
48 | 	httpCmd.Flags().StringVar(&jsonCase, "case", "lowerCamel", `apply to json tag of fields in every generated anonymous struct in handlers. optional values: lowerCamel, snake`)
49 | 	httpCmd.Flags().BoolVar(&doc, "doc", false, `whether generate openapi 3.0 json document or not`)
50 | 	httpCmd.Flags().StringVarP(&baseURLEnv, "env", "e", "", `base url environment variable name`)
51 | 	httpCmd.Flags().IntVarP(&routePatternStrategy, "routePattern", "r", 0, "route pattern generate strategy. 0 means splitting each methods of service interface by slash / after converting to snake case. 1 means no splitting, only lowercase. recommend default value.")
52 | 	httpCmd.Flags().BoolVar(&allowGetWithReqBody, "allowGetWithReqBody", false, "Whether allow get http request with request body.")
53 | }
```

cmd/httptest.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/spf13/cobra"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
6 | )
7 | 
8 | var postmanCollectionPath string
9 | var dotenvPath string
10 | 
11 | // testCmd generates http client code
12 | var testCmd = &cobra.Command{
13 | 	Use:   "test",
14 | 	Short: "generates integration testing code from postman collection v2.1 compatible file",
15 | 	Long:  ``,
16 | 	Run: func(cmd *cobra.Command, args []string) {
17 | 		s := svc.Svc{
18 | 			PostmanCollectionPath: postmanCollectionPath,
19 | 			DotenvPath:            dotenvPath,
20 | 		}
21 | 		s.GenIntegrationTestingCode()
22 | 	},
23 | }
24 | 
25 | func init() {
26 | 	httpCmd.AddCommand(testCmd)
27 | 
28 | 	testCmd.Flags().StringVar(&postmanCollectionPath, "collection", "", `postman collection v2.1 compatible file disk path`)
29 | 	testCmd.Flags().StringVar(&dotenvPath, "dotenv", "", `dotenv format config file disk path only for integration testing purpose`)
30 | 	testCmd.MarkFlagRequired("collection")
31 | 	testCmd.MarkFlagRequired("dotenv")
32 | }
```

cmd/init.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/iancoleman/strcase"
5 | 	"github.com/sirupsen/logrus"
6 | 	"github.com/spf13/cobra"
7 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
8 | 	"github.com/unionj-cloud/toolkit/pathutils"
9 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
10 | )
11 | 
12 | var modName string
13 | var module bool
14 | var projectType string
15 | 
16 | // initCmd initializes the service
17 | var initCmd = &cobra.Command{
18 | 	Use:   "init",
19 | 	Short: "init a project folder",
20 | 	Long:  ``,
21 | 	Run: func(cmd *cobra.Command, args []string) {
22 | 		var svcdir string
23 | 		if len(args) > 0 {
24 | 			svcdir = args[0]
25 | 		}
26 | 		var err error
27 | 		if svcdir, err = pathutils.FixPath(svcdir, ""); err != nil {
28 | 			logrus.Panicln(err)
29 | 		}
30 | 		options := []svc.SvcOption{svc.WithModName(modName), svc.WithDocPath(docfile), svc.WithModule(module)}
31 | 		fn := strcase.ToLowerCamel
32 | 		switch naming {
33 | 		case "snake":
34 | 			fn = strcase.ToSnake
35 | 		}
36 | 		options = append(options, svc.WithJsonCase(naming), svc.WithCaseConverter(fn), svc.WithProjectType(projectType),
37 | 			svc.WithProtoGenerator(v3.NewProtoGenerator(v3.WithFieldNamingFunc(fn), v3.WithProtocCmd(protocCmd))))
38 | 		s := svc.NewSvc(svcdir, options...)
39 | 		s.Init()
40 | 	},
41 | }
42 | 
43 | func init() {
44 | 	svcCmd.AddCommand(initCmd)
45 | 
46 | 	initCmd.Flags().BoolVar(&module, "module", false, `If true, a module will be initialized for building modular application`)
47 | 	initCmd.Flags().StringVarP(&modName, "mod", "m", "", `Module name`)
48 | 	initCmd.Flags().StringVarP(&docfile, "file", "f", "", `OpenAPI 3.0 or Swagger 2.0 spec json file path or download link`)
49 | 	initCmd.Flags().StringVar(&protocCmd, "grpc_gen_cmd", "protoc --proto_path=. --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative --go-json_out=. --go-json_opt=paths=source_relative,allow_unknown=true", `command to generate grpc service and message code`)
50 | 	initCmd.Flags().StringVar(&naming, "case", "lowerCamel", `protobuf message field and json tag case, only support "lowerCamel" and "snake"`)
51 | 	initCmd.Flags().StringVarP(&projectType, "type", "t", "grpc", `Indicate project type, accept values: grpc or rest`)
52 | }
```

cmd/name.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/spf13/cobra"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/name"
6 | )
7 | 
8 | var file string
9 | var strategy string
10 | var omitempty bool
11 | var form bool
12 | 
13 | // nameCmd updates json tag of struct fields
14 | var nameCmd = &cobra.Command{
15 | 	Use:   "name",
16 | 	Short: "bulk add or update json tag of struct fields",
17 | 	Long:  ``,
18 | 	Run: func(cmd *cobra.Command, args []string) {
19 | 		n := name.Name{file, strategy, omitempty, form}
20 | 		n.Exec()
21 | 	},
22 | }
23 | 
24 | func init() {
25 | 	rootCmd.AddCommand(nameCmd)
26 | 
27 | 	// Here you will define your flags and configuration settings.
28 | 
29 | 	// Cobra supports Persistent Flags which will work for this command
30 | 	// and all subcommands, e.g.:
31 | 	// nameCmd.PersistentFlags().String("foo", "", "A help for foo")
32 | 
33 | 	// Cobra supports local flags which will only run when this command
34 | 	// is called directly, e.g.:
35 | 	nameCmd.Flags().StringVarP(&file, "file", "f", "", "absolute path of dto file")
36 | 	//  use case flag instead
37 | 	nameCmd.Flags().StringVarP(&strategy, "strategy", "s", "lowerCamel", `name of strategy, currently only support "lowerCamel" and "snake"`)
38 | 	nameCmd.Flags().StringVar(&strategy, "case", "lowerCamel", `name of strategy, currently only support "lowerCamel" and "snake"`)
39 | 	nameCmd.Flags().BoolVarP(&omitempty, "omitempty", "o", false, "whether omit empty value or not")
40 | 	nameCmd.Flags().BoolVar(&form, "form", false, "whether need form tag for https://github.com/go-playground/form")
41 | }
```

cmd/name_test.go
```
1 | package cmd_test
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/unionj-cloud/go-doudou/v2/cmd"
9 | 	"github.com/unionj-cloud/toolkit/astutils"
10 | )
11 | 
12 | func TestNameCmd(t *testing.T) {
13 | 	dir := testDir + "/namecmd"
14 | 	receiver := NewMockSvc(dir)
15 | 	receiver.Init()
16 | 	defer os.RemoveAll(dir)
17 | 	err := os.Chdir(dir)
18 | 	if err != nil {
19 | 		t.Fatal(err)
20 | 	}
21 | 	_, _, err = ExecuteCommandC(cmd.GetRootCmd(), []string{"name", "-f", filepath.Join(dir, "dto", "dto.go"), "-o"}...)
22 | 	if err != nil {
23 | 		t.Fatal(err)
24 | 	}
25 | }
26 | 
27 | func TestGetImportPath(t *testing.T) {
28 | 	dir := testDir + "/importpath"
29 | 	receiver := NewMockSvc(dir)
30 | 	receiver.Init()
31 | 	defer os.RemoveAll(dir)
32 | 	err := os.Chdir(dir)
33 | 	if err != nil {
34 | 		t.Fatal(err)
35 | 	}
36 | 	type args struct {
37 | 		file string
38 | 	}
39 | 	tests := []struct {
40 | 		name string
41 | 		args args
42 | 		want string
43 | 	}{
44 | 		{
45 | 			name: "1",
46 | 			args: args{
47 | 				file: filepath.Join(dir, "/entity"),
48 | 			},
49 | 			want: "importpath/entity",
50 | 		},
51 | 	}
52 | 	for _, tt := range tests {
53 | 		t.Run(tt.name, func(t *testing.T) {
54 | 			if got := astutils.GetImportPath(tt.args.file); got != tt.want {
55 | 				t.Errorf("GetImportPath() = %v, want %v", got, tt.want)
56 | 			}
57 | 		})
58 | 	}
59 | }
```

cmd/promptui_select_interface.go
```
1 | package cmd
2 | 
3 | //go:generate mockgen -destination ./mock/mock_promptui_select_interface.go -package mock -source=./promptui_select_interface.go
4 | 
5 | type ISelect interface {
6 | 	Run() (int, string, error)
7 | 	RunCursorAt(cursorPos, scroll int) (int, string, error)
8 | 	ScrollPosition() int
9 | }
```

cmd/push.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/spf13/cobra"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
6 | )
7 | 
8 | var imagePrefix string
9 | var imageVer string
10 | 
11 | // pushCmd pushes image to remote docker image repository
12 | var pushCmd = &cobra.Command{
13 | 	Use:   "push",
14 | 	Short: "wrap docker build, docker tag, docker push commands and generate or update k8s deploy yaml file",
15 | 	Long:  ``,
16 | 	Run: func(cmd *cobra.Command, args []string) {
17 | 		s := svc.NewSvc("")
18 | 		s.Push(svc.PushConfig{
19 | 			Repo:   imageRepo,
20 | 			Prefix: imagePrefix,
21 | 			Ver:    imageVer,
22 | 		})
23 | 	},
24 | }
25 | 
26 | func init() {
27 | 	svcCmd.AddCommand(pushCmd)
28 | 
29 | 	pushCmd.Flags().StringVar(&imagePrefix, "pre", "", `image name prefix string used for building and pushing docker image`)
30 | 	pushCmd.Flags().StringVar(&imageVer, "ver", "", `docker image version`)
31 | }
```

cmd/root.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/sirupsen/logrus"
5 | 	"github.com/spf13/cobra"
6 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/modular"
7 | 	"github.com/unionj-cloud/go-doudou/v2/version"
8 | )
9 | 
10 | // rootCmd is the base command when called without any subcommands
11 | var rootCmd = &cobra.Command{
12 | 	Version: version.Release,
13 | 	Use:     "go-doudou",
14 | 	Short:   "go-doudou is microservice rapid develop framework based on openapi 3.0 spec and gossip protocol",
15 | 	Long: `go-doudou works like a scaffolding tool but more than that. 
16 | it lets api providers design their apis and help them code less. 
17 | it generates openapi 3.0 spec json document for frontend developers or other api consumers to understand what apis there, 
18 | consumers can import it into postman to debug and test, or upload it into some code generators to download client sdk.
19 | it provides some useful components and middleware for constructing microservice cluster like service register and discovering, 
20 | load balancing and so on. it just begins, more features will come out soon.`,
21 | 	Run: func(cmd *cobra.Command, args []string) {
22 | 	},
23 | }
24 | 
25 | // Execute adds all child commands to the root command and sets flags appropriately.
26 | // This is called by main.main(). It only needs to happen once to the rootCmd.
27 | func Execute() {
28 | 	cobra.CheckErr(rootCmd.Execute())
29 | }
30 | 
31 | func init() {
32 | 	customFormatter := new(logrus.TextFormatter)
33 | 	customFormatter.TimestampFormat = "2006-01-02 15:04:05"
34 | 	customFormatter.FullTimestamp = true
35 | 	logrus.SetFormatter(customFormatter)
36 | 
37 | 	rootCmd.AddCommand(modular.GetWorkCmd())
38 | }
39 | 
40 | func GetRootCmd() *cobra.Command {
41 | 	return rootCmd
42 | }
```

cmd/root_test.go
```
1 | package cmd_test
2 | 
3 | import (
4 | 	"testing"
5 | 	"time"
6 | 
7 | 	"github.com/unionj-cloud/go-doudou/v2/cmd"
8 | )
9 | 
10 | func TestRootCmd(t *testing.T) {
11 | 	go cmd.GetRootCmd().Run(nil, nil)
12 | 	time.Sleep(2 * time.Second)
13 | }
```

cmd/run.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
5 | 
6 | 	"github.com/spf13/cobra"
7 | )
8 | 
9 | var watch bool
10 | 
11 | var RunSvc = svc.NewSvc
12 | 
13 | // runCmd runs the service
14 | var runCmd = &cobra.Command{
15 | 	Use:   "run",
16 | 	Short: "run go-doudou program",
17 | 	Long:  ``,
18 | 	Run: func(cmd *cobra.Command, args []string) {
19 | 		s := RunSvc("")
20 | 		s.Run(watch)
21 | 	},
22 | }
23 | 
24 | func init() {
25 | 	svcCmd.AddCommand(runCmd)
26 | 
27 | 	// Here you will define your flags and configuration settings.
28 | 
29 | 	// Cobra supports Persistent Flags which will work for this command
30 | 	// and all subcommands, e.g.:
31 | 	// runCmd.PersistentFlags().String("foo", "", "A help for foo")
32 | 
33 | 	// Cobra supports local flags which will only run when this command
34 | 	// is called directly, e.g.:
35 | 	runCmd.Flags().BoolVarP(&watch, "watch", "w", false, "enable watch mode")
36 | }
```

cmd/shutdown.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/spf13/cobra"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
6 | )
7 | 
8 | // shutdownCmd shutdowns k8s service
9 | var shutdownCmd = &cobra.Command{
10 | 	Use:   "shutdown",
11 | 	Short: "wrap kubectl delete command to shutdown service",
12 | 	Long:  ``,
13 | 	Run: func(cmd *cobra.Command, args []string) {
14 | 		s := svc.NewSvc("")
15 | 		s.Shutdown(k8sfile)
16 | 	},
17 | }
18 | 
19 | func init() {
20 | 	svcCmd.AddCommand(shutdownCmd)
21 | }
```

cmd/shutdown_test.go
```
1 | package cmd_test
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/stretchr/testify/assert"
9 | 	"github.com/unionj-cloud/go-doudou/v2/cmd"
10 | )
11 | 
12 | func TestShutdownCmd(t *testing.T) {
13 | 	dir := filepath.Join(testDir, "testsvc")
14 | 	err := os.Chdir(dir)
15 | 	if err != nil {
16 | 		t.Fatal(err)
17 | 	}
18 | 	assert.Panics(t, func() {
19 | 		ExecuteCommandC(cmd.GetRootCmd(), []string{"svc", "shutdown"}...)
20 | 	})
21 | }
```

cmd/svc.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"github.com/spf13/cobra"
5 | )
6 | 
7 | var k8sfile string
8 | var imageRepo string
9 | 
10 | // svcCmd is the base command for generation or update
11 | var svcCmd = &cobra.Command{
12 | 	Use:   "svc",
13 | 	Short: "generate or update service",
14 | 	Long:  ``,
15 | 	Run: func(cmd *cobra.Command, args []string) {
16 | 	},
17 | }
18 | 
19 | func init() {
20 | 	rootCmd.AddCommand(svcCmd)
21 | 
22 | 	deployCmd.Flags().StringVarP(&k8sfile, "k8sfile", "k", "", `k8s yaml file for deploying service`)
23 | 	shutdownCmd.Flags().StringVarP(&k8sfile, "k8sfile", "k", "", `k8s yaml file for deploying service`)
24 | 	pushCmd.Flags().StringVarP(&imageRepo, "repo", "r", "", `your private docker image repository`)
25 | }
```

cmd/svc_test.go
```
1 | package cmd_test
2 | 
3 | import (
4 | 	"testing"
5 | 
6 | 	. "github.com/smartystreets/goconvey/convey"
7 | 	"github.com/unionj-cloud/go-doudou/v2/cmd"
8 | )
9 | 
10 | func Test_svcCmd(t *testing.T) {
11 | 	Convey("Should not panic when run svc command", t, func() {
12 | 		So(func() {
13 | 			ExecuteCommandC(cmd.GetRootCmd(), []string{"svc"}...)
14 | 		}, ShouldNotPanic)
15 | 	})
16 | }
```

cmd/version.go
```
1 | package cmd
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"os"
7 | 	"time"
8 | 
9 | 	"github.com/google/go-github/v42/github"
10 | 	goversion "github.com/hashicorp/go-version"
11 | 	"github.com/manifoldco/promptui"
12 | 	"github.com/spf13/cobra"
13 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
14 | 	"github.com/unionj-cloud/go-doudou/v2/version"
15 | )
16 | 
17 | func LatestReleaseVer() string {
18 | 	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
19 | 	defer cancel()
20 | 	release, _, err := github.NewClient(nil).Repositories.GetLatestRelease(ctx, "unionj-cloud", "go-doudou")
21 | 	if err != nil {
22 | 		panic(err)
23 | 	}
24 | 	return release.GetTagName()
25 | }
26 | 
27 | var Prompt ISelect = &promptui.Select{
28 | 	Label:  "Do you want to upgrade?",
29 | 	Items:  []string{"Yes", "No"},
30 | 	Stdin:  os.Stdin,
31 | 	Stdout: os.Stdout,
32 | }
33 | 
34 | var VersionSvc = svc.NewSvc
35 | var LatestReleaseVerFunc = LatestReleaseVer
36 | 
37 | var versionCmd = &cobra.Command{
38 | 	Use:   "version",
39 | 	Short: "Print the version number of go-doudou",
40 | 	Long:  `You can get information about latest release version besides version number of installed go-doudou`,
41 | 	Run: func(cmd *cobra.Command, args []string) {
42 | 		fmt.Printf("Installed version is %s\n", version.Release)
43 | 		latest := LatestReleaseVerFunc()
44 | 		currentVersion, _ := goversion.NewVersion(version.Release)
45 | 		latestVersion, _ := goversion.NewVersion(latest)
46 | 		if currentVersion.LessThan(latestVersion) {
47 | 			fmt.Printf("Latest release version is %s\n", latest)
48 | 			_, result, err := Prompt.Run()
49 | 			if err != nil {
50 | 				panic(err)
51 | 			}
52 | 			if result == "Yes" {
53 | 				s := VersionSvc("")
54 | 				s.Upgrade(latest)
55 | 				fmt.Println("DONE")
56 | 			}
57 | 		}
58 | 	},
59 | }
60 | 
61 | func init() {
62 | 	rootCmd.AddCommand(versionCmd)
63 | }
```

cmd/version_test.go
```
1 | package cmd_test
2 | 
3 | import (
4 | 	"testing"
5 | 
6 | 	"github.com/golang/mock/gomock"
7 | 	"github.com/pkg/errors"
8 | 	. "github.com/smartystreets/goconvey/convey"
9 | 	"github.com/unionj-cloud/go-doudou/v2/cmd"
10 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
11 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/mock"
12 | )
13 | 
14 | func Test_versionCmd_Yes(t *testing.T) {
15 | 	Convey("Should not panic and succeed to upgrade when run version command", t, func() {
16 | 		ctrl := gomock.NewController(t)
17 | 		defer ctrl.Finish()
18 | 		prompt := mock.NewMockISelect(ctrl)
19 | 		prompt.
20 | 			EXPECT().
21 | 			Run().
22 | 			AnyTimes().
23 | 			Return(0, "Yes", nil)
24 | 
25 | 		cmd.Prompt = prompt
26 | 
27 | 		runner := mock.NewMockRunner(ctrl)
28 | 		runner.
29 | 			EXPECT().
30 | 			Run(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
31 | 			AnyTimes().
32 | 			Return(nil)
33 | 
34 | 		cmd.VersionSvc = func(dir string, opts ...svc.SvcOption) svc.ISvc {
35 | 			return svc.NewSvc("", svc.WithRunner(runner))
36 | 		}
37 | 
38 | 		cmd.LatestReleaseVerFunc = func() string {
39 | 			return "v999999.0.0"
40 | 		}
41 | 		defer func() {
42 | 			cmd.LatestReleaseVerFunc = cmd.LatestReleaseVer
43 | 		}()
44 | 
45 | 		So(func() {
46 | 			ExecuteCommandC(cmd.GetRootCmd(), []string{"version"}...)
47 | 		}, ShouldNotPanic)
48 | 	})
49 | }
50 | 
51 | func Test_versionCmd_Yes_Panic(t *testing.T) {
52 | 	Convey("Should panic and fail to upgrade when run version command", t, func() {
53 | 		ctrl := gomock.NewController(t)
54 | 		defer ctrl.Finish()
55 | 		prompt := mock.NewMockISelect(ctrl)
56 | 		prompt.
57 | 			EXPECT().
58 | 			Run().
59 | 			AnyTimes().
60 | 			Return(0, "Yes", nil)
61 | 
62 | 		cmd.Prompt = prompt
63 | 
64 | 		runner := mock.NewMockRunner(ctrl)
65 | 		runner.
66 | 			EXPECT().
67 | 			Run(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).
68 | 			AnyTimes().
69 | 			Return(errors.New("mock runner error"))
70 | 
71 | 		cmd.VersionSvc = func(dir string, opts ...svc.SvcOption) svc.ISvc {
72 | 			return svc.NewSvc("", svc.WithRunner(runner))
73 | 		}
74 | 
75 | 		cmd.LatestReleaseVerFunc = func() string {
76 | 			return "v999999.0.0"
77 | 		}
78 | 		defer func() {
79 | 			cmd.LatestReleaseVerFunc = cmd.LatestReleaseVer
80 | 		}()
81 | 
82 | 		So(func() {
83 | 			ExecuteCommandC(cmd.GetRootCmd(), []string{"version"}...)
84 | 		}, ShouldPanic)
85 | 	})
86 | }
```

version/version.go
```
1 | package version
2 | 
3 | const Release = "v2.5.8"
```

.github/codecov.yml
```
1 | ignore:
2 |   - "**/mock_*.go"
```

.github/dependabot.yml
```
1 | # To get started with Dependabot version updates, you'll need to specify which
2 | # package ecosystems to update and where the package manifests are located.
3 | # Please see the documentation for all configuration options:
4 | # https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates
5 | 
6 | version: 2
7 | updates:
8 |   - package-ecosystem: "gomod" # See documentation for possible values
9 |     directory: "/" # Location of package manifests
10 |     schedule:
11 |       interval: "daily"
```

framework/buildinfo/buildinfo.go
```
1 | package buildinfo
2 | 
3 | var (
4 | 	// BuildUser stores user who built the program
5 | 	BuildUser string
6 | 	// BuildTime stores time at which the program is built
7 | 	BuildTime string
8 | 	// GddVer stores go-doudou version when program is being built
9 | 	GddVer string
10 | )
```

framework/config/config.go
```
1 | package config
2 | 
3 | import (
4 | 	"fmt"
5 | 	"log"
6 | 	"net"
7 | 	"net/url"
8 | 	"os"
9 | 	"path/filepath"
10 | 	"strconv"
11 | 	"strings"
12 | 	"sync"
13 | 	"time"
14 | 
15 | 	"github.com/unionj-cloud/toolkit/constants"
16 | 	"github.com/unionj-cloud/toolkit/fileutils"
17 | 
18 | 	"github.com/apolloconfig/agollo/v4"
19 | 	"github.com/apolloconfig/agollo/v4/env/config"
20 | 	"github.com/pkg/errors"
21 | 	"github.com/rs/zerolog"
22 | 	"github.com/sirupsen/logrus"
23 | 	"github.com/wubin1989/nacos-sdk-go/v2/common/constant"
24 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
25 | 	_ "go.uber.org/automaxprocs"
26 | 
27 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr"
28 | 	"github.com/unionj-cloud/toolkit/cast"
29 | 	"github.com/unionj-cloud/toolkit/dotenv"
30 | 	"github.com/unionj-cloud/toolkit/envconfig"
31 | 	"github.com/unionj-cloud/toolkit/stringutils"
32 | 	"github.com/unionj-cloud/toolkit/yaml"
33 | 	"github.com/unionj-cloud/toolkit/zlogger"
34 | )
35 | 
36 | var GddConfig = &gddConfig{}
37 | 
38 | func LoadConfigFromLocal() {
39 | 	env := os.Getenv("GDD_ENV")
40 | 	if "" == env {
41 | 		env = "dev"
42 | 	}
43 | 	yaml.Load(env)
44 | 	dotenv.Load(env)
45 | }
46 | 
47 | func LoadConfigFromRemote() {
48 | 	configType := GddConfigRemoteType.LoadOrDefault(DefaultGddConfigRemoteType)
49 | 	switch configType {
50 | 	case "":
51 | 		return
52 | 	case NacosConfigType:
53 | 		nacosConfigFormat := GddNacosConfigFormat.LoadOrDefault(string(DefaultGddNacosConfigFormat))
54 | 		nacosConfigGroup := GddNacosConfigGroup.LoadOrDefault(DefaultGddNacosConfigGroup)
55 | 		nacosConfigDataid := GddNacosConfigDataid.LoadOrDefault(DefaultGddNacosConfigDataid)
56 | 		if stringutils.IsEmpty(nacosConfigDataid) {
57 | 			panic(errors.New("[go-doudou] nacos config dataId is required"))
58 | 		}
59 | 		err := configmgr.LoadFromNacos(GetNacosClientParam(), nacosConfigDataid, nacosConfigFormat, nacosConfigGroup)
60 | 		if err != nil {
61 | 			panic(errors.Wrap(err, "[go-doudou] fail to load config from Nacos"))
62 | 		}
63 | 	case ApolloConfigType:
64 | 		if stringutils.IsEmpty(GddServiceName.Load()) {
65 | 			panic(errors.New("[go-doudou] service name is required"))
66 | 		}
67 | 		apolloCluster := GddApolloCluster.LoadOrDefault(DefaultGddApolloCluster)
68 | 		apolloAddr := GddApolloAddr.LoadOrDefault(DefaultGddApolloAddr)
69 | 		if stringutils.IsEmpty(apolloAddr) {
70 | 			panic(errors.New("[go-doudou] apollo config service address is required"))
71 | 		}
72 | 		apolloNamespace := GddApolloNamespace.LoadOrDefault(DefaultGddApolloNamespace)
73 | 		apolloBackup := cast.ToBoolOrDefault(GddApolloBackupEnable.Load(), DefaultGddApolloBackupEnable)
74 | 		apolloBackupPath := GddApolloBackupPath.LoadOrDefault(DefaultGddApolloBackupPath)
75 | 		apolloSecret := GddApolloSecret.LoadOrDefault(DefaultGddApolloSecret)
76 | 		apolloMustStart := cast.ToBoolOrDefault(GddApolloMuststart.Load(), DefaultGddApolloMuststart)
77 | 		apolloLogEnable := cast.ToBoolOrDefault(GddApolloLogEnable.Load(), DefaultGddApolloLogEnable)
78 | 		if apolloLogEnable {
79 | 			agollo.SetLogger(logrus.StandardLogger())
80 | 		}
81 | 		c := &config.AppConfig{
82 | 			AppID:            GddServiceName.Load(),
83 | 			Cluster:          apolloCluster,
84 | 			IP:               apolloAddr,
85 | 			NamespaceName:    apolloNamespace,
86 | 			IsBackupConfig:   apolloBackup,
87 | 			Secret:           apolloSecret,
88 | 			BackupConfigPath: apolloBackupPath,
89 | 			MustStart:        apolloMustStart,
90 | 		}
91 | 		configmgr.LoadFromApollo(c)
92 | 	default:
93 | 		panic(fmt.Errorf("[go-doudou] unknown config type: %s\n", configType))
94 | 	}
95 | }
96 | 
97 | func CheckDev() bool {
98 | 	return stringutils.IsEmpty(os.Getenv("GDD_ENV")) || os.Getenv("GDD_ENV") == "dev"
99 | }
100 | 
101 | var G_LogFile *os.File
102 | var lock sync.Mutex
103 | 
104 | func Shutdown() {
105 | 	lock.Lock()
106 | 	defer lock.Unlock()
107 | 	if G_LogFile != nil {
108 | 		G_LogFile.Close()
109 | 		G_LogFile = nil
110 | 	}
111 | }
112 | 
113 | func init() {
114 | 	LoadConfigFromLocal()
115 | 	LoadConfigFromRemote()
116 | 	err := envconfig.Process("gdd", GddConfig)
117 | 	if err != nil {
118 | 		zlogger.Panic().Msgf("Error processing environment variables: %v", err)
119 | 	}
120 | 	zl, _ := zerolog.ParseLevel(GddLogLevel.LoadOrDefault(DefaultGddLogLevel))
121 | 	opts := []zlogger.LoggerConfigOption{
122 | 		zlogger.WithDev(CheckDev()),
123 | 		zlogger.WithCaller(cast.ToBoolOrDefault(GddLogCaller.Load(), DefaultGddLogCaller)),
124 | 		zlogger.WithDiscard(cast.ToBoolOrDefault(GddLogDiscard.Load(), DefaultGddLogDiscard)),
125 | 		zlogger.WithZeroLogLevel(zl),
126 | 	}
127 | 	logPath := GddLogPath.LoadOrDefault(DefaultGddLogPath)
128 | 	if stringutils.IsNotEmpty(logPath) {
129 | 		fileutils.CreateDirectory(logPath)
130 | 		logFile := filepath.Join(logPath, "app.log")
131 | 		G_LogFile, err = os.OpenFile(
132 | 			logFile,
133 | 			os.O_APPEND|os.O_CREATE|os.O_WRONLY,
134 | 			0664,
135 | 		)
136 | 		if err != nil {
137 | 			panic(err)
138 | 		}
139 | 		logStyle := GddLogStyle.LoadOrDefault(DefaultGddLogStyle)
140 | 		switch logStyle {
141 | 		case "console":
142 | 			output := zerolog.ConsoleWriter{Out: G_LogFile, TimeFormat: constants.FORMAT, NoColor: true}
143 | 			opts = append(opts, zlogger.WithWriter(output))
144 | 		default:
145 | 			opts = append(opts, zlogger.WithWriter(G_LogFile))
146 | 		}
147 | 		log.Printf("GDD_LOG_PATH is configured. Please view app log from %s", logFile)
148 | 	}
149 | 	zlogger.InitEntry(zlogger.NewLoggerConfig(opts...))
150 | }
151 | 
152 | type envVariable string
153 | 
154 | func (receiver envVariable) MarshalJSON() ([]byte, error) {
155 | 	return []byte(strconv.Quote(receiver.Load())), nil
156 | }
157 | 
158 | const (
159 | 	NacosConfigType  = "nacos"
160 | 	ApolloConfigType = "apollo"
161 | )
162 | 
163 | const (
164 | 	// GddBanner indicates banner enabled or not
165 | 	GddBanner envVariable = "GDD_BANNER"
166 | 	// GddBannerText sets text content of banner
167 | 	GddBannerText envVariable = "GDD_BANNER_TEXT"
168 | 	// GddLogLevel accepts panic, fatal, error, warn, warning, info, debug, trace, disabled. please reference zerolog.ParseLevel
169 | 	GddLogLevel envVariable = "GDD_LOG_LEVEL"
170 | 	// GddLogFormat text or json
171 | 	// Deprecated: move to zerolog
172 | 	GddLogFormat envVariable = "GDD_LOG_FORMAT"
173 | 	// GddLogReqEnable enables request and response logging
174 | 	GddLogReqEnable envVariable = "GDD_LOG_REQ_ENABLE"
175 | 	GddLogCaller    envVariable = "GDD_LOG_CALLER"
176 | 	GddLogDiscard   envVariable = "GDD_LOG_DISCARD"
177 | 	GddLogPath      envVariable = "GDD_LOG_PATH"
178 | 	// GddLogStyle is only valid when GDD_LOG_PATH is specified, accepts json or console.
179 | 	// Default is json
180 | 	GddLogStyle envVariable = "GDD_LOG_STYLE"
181 | 	// GddGraceTimeout sets graceful shutdown timeout
182 | 	GddGraceTimeout envVariable = "GDD_GRACE_TIMEOUT"
183 | 	// GddWriteTimeout sets http connection write timeout
184 | 	GddWriteTimeout envVariable = "GDD_WRITE_TIMEOUT"
185 | 	// GddReadTimeout sets http connection read timeout
186 | 	GddReadTimeout envVariable = "GDD_READ_TIMEOUT"
187 | 	// GddIdleTimeout sets http connection idle timeout
188 | 	GddIdleTimeout envVariable = "GDD_IDLE_TIMEOUT"
189 | 	// GddRouteRootPath sets root path for all routes
190 | 	GddRouteRootPath envVariable = "GDD_ROUTE_ROOT_PATH"
191 | 	// GddServiceName sets service name
192 | 	GddServiceName    envVariable = "GDD_SERVICE_NAME"
193 | 	GddServiceGroup   envVariable = "GDD_SERVICE_GROUP"
194 | 	GddServiceVersion envVariable = "GDD_SERVICE_VERSION"
195 | 	// GddHost sets bind host for http server
196 | 	GddHost envVariable = "GDD_HOST"
197 | 	// GddPort sets bind port for http server
198 | 	GddPort envVariable = "GDD_PORT"
199 | 	// GddGrpcPort sets bind port for grpc server
200 | 	GddGrpcPort envVariable = "GDD_GRPC_PORT"
201 | 	// GddManage if true, it will add built-in apis with /go-doudou path prefix for online api document and service status monitor etc.
202 | 	GddManage envVariable = "GDD_MANAGE_ENABLE"
203 | 	// GddManageUser manage api endpoint http basic auth user
204 | 	GddManageUser envVariable = "GDD_MANAGE_USER"
205 | 	// GddManagePass manage api endpoint http basic auth password
206 | 	GddManagePass envVariable = "GDD_MANAGE_PASS"
207 | 
208 | 	GddEnableResponseGzip envVariable = "GDD_ENABLE_RESPONSE_GZIP"
209 | 	// Deprecated: move to GddFallbackContentType
210 | 	GddAppType envVariable = "GDD_APP_TYPE"
211 | 	// GddFallbackContentType fallback response content-type header value
212 | 	GddFallbackContentType        envVariable = "GDD_FALLBACK_CONTENTTYPE"
213 | 	GddRouterSaveMatchedRoutePath envVariable = "GDD_ROUTER_SAVEMATCHEDROUTEPATH"
214 | 
215 | 	// GddConfigRemoteType has two options available: nacos, apollo
216 | 	GddConfigRemoteType envVariable = "GDD_CONFIG_REMOTE_TYPE"
217 | 
218 | 	GddRetryCount         envVariable = "GDD_RETRY_COUNT"
219 | 	GddTracingMetricsRoot envVariable = "GDD_TRACING_METRICS_ROOT"
220 | 
221 | 	GddServiceDiscoveryMode envVariable = "GDD_SERVICE_DISCOVERY_MODE"
222 | 
223 | 	GddNacosNamespaceId         envVariable = "GDD_NACOS_NAMESPACE_ID"
224 | 	GddNacosTimeoutMs           envVariable = "GDD_NACOS_TIMEOUT_MS"
225 | 	GddNacosNotLoadCacheAtStart envVariable = "GDD_NACOS_NOTLOADCACHEATSTART"
226 | 	GddNacosLogDir              envVariable = "GDD_NACOS_LOG_DIR"
227 | 	GddNacosCacheDir            envVariable = "GDD_NACOS_CACHE_DIR"
228 | 	GddNacosLogLevel            envVariable = "GDD_NACOS_LOG_LEVEL"
229 | 	GddNacosLogDiscard          envVariable = "GDD_NACOS_LOG_DISCARD"
230 | 	GddNacosServerAddr          envVariable = "GDD_NACOS_SERVER_ADDR"
231 | 	GddNacosRegisterHost        envVariable = "GDD_NACOS_REGISTER_HOST"
232 | 	GddNacosClusterName         envVariable = "GDD_NACOS_CLUSTER_NAME"
233 | 	GddNacosGroupName           envVariable = "GDD_NACOS_GROUP_NAME"
234 | 	// GddNacosConfigFormat has two options available: dotenv, yaml
235 | 	GddNacosConfigFormat envVariable = "GDD_NACOS_CONFIG_FORMAT"
236 | 	GddNacosConfigGroup  envVariable = "GDD_NACOS_CONFIG_GROUP"
237 | 	GddNacosConfigDataid envVariable = "GDD_NACOS_CONFIG_DATAID"
238 | 
239 | 	// GddWeight node weight
240 | 	GddWeight envVariable = "GDD_WEIGHT"
241 | 
242 | 	GddApolloCluster      envVariable = "GDD_APOLLO_CLUSTER"
243 | 	GddApolloAddr         envVariable = "GDD_APOLLO_ADDR"
244 | 	GddApolloNamespace    envVariable = "GDD_APOLLO_NAMESPACE"
245 | 	GddApolloBackupEnable envVariable = "GDD_APOLLO_BACKUP_ENABLE"
246 | 	GddApolloBackupPath   envVariable = "GDD_APOLLO_BACKUP_PATH"
247 | 	GddApolloMuststart    envVariable = "GDD_APOLLO_MUSTSTART"
248 | 	GddApolloSecret       envVariable = "GDD_APOLLO_SECRET"
249 | 	GddApolloLogEnable    envVariable = "GDD_APOLLO_LOG_ENABLE"
250 | 
251 | 	// GddSqlLogEnable only for doc purpose
252 | 	GddSqlLogEnable envVariable = "GDD_SQL_LOG_ENABLE"
253 | 
254 | 	GddStatsFreq envVariable = "GDD_STATS_FREQ"
255 | 
256 | 	GddRegisterHost  envVariable = "GDD_REGISTER_HOST"
257 | 	GddEtcdEndpoints envVariable = "GDD_ETCD_ENDPOINTS"
258 | 	GddEtcdLease     envVariable = "GDD_ETCD_LEASE"
259 | 
260 | 	// configs for memberlist component
261 | 	// GddMemSeed sets cluster seeds for joining
262 | 	GddMemSeed envVariable = "GDD_MEM_SEED"
263 | 	// GddMemName unique name of this node in cluster. if empty or not set, hostname will be used instead
264 | 	GddMemName envVariable = "GDD_MEM_NAME"
265 | 	// GddMemHost specify AdvertiseAddr attribute of memberlist config struct.
266 | 	// if GddMemHost starts with dot such as .seed-svc-headless.default.svc.cluster.local,
267 | 	// it will be prefixed by hostname such as seed-2.seed-svc-headless.default.svc.cluster.local
268 | 	// for supporting k8s stateful service
269 | 	// if empty or not set, private ip will be used instead.
270 | 	GddMemHost envVariable = "GDD_MEM_HOST"
271 | 	// GddMemPort if empty or not set, an available port will be chosen randomly. recommend specifying a port
272 | 	GddMemPort envVariable = "GDD_MEM_PORT"
273 | 	// GddMemDeadTimeout dead node will be removed from node map if not received refute messages from it in GddMemDeadTimeout second
274 | 	// expose GossipToTheDeadTime property of memberlist.Config
275 | 	GddMemDeadTimeout envVariable = "GDD_MEM_DEAD_TIMEOUT"
276 | 	// GddMemSyncInterval local node will synchronize states from other random node every GddMemSyncInterval second
277 | 	// expose PushPullInterval property of memberlist.Config
278 | 	GddMemSyncInterval envVariable = "GDD_MEM_SYNC_INTERVAL"
279 | 	// GddMemReclaimTimeout dead node will be replaced with new node with the same name but different full address in GddMemReclaimTimeout second
280 | 	// expose DeadNodeReclaimTime property of memberlist.Config
281 | 	GddMemReclaimTimeout envVariable = "GDD_MEM_RECLAIM_TIMEOUT"
282 | 	// GddMemProbeInterval probe interval
283 | 	// expose ProbeInterval property of memberlist.Config
284 | 	GddMemProbeInterval envVariable = "GDD_MEM_PROBE_INTERVAL"
285 | 	// GddMemProbeTimeout probe timeout
286 | 	// expose ProbeTimeout property of memberlist.Config
287 | 	GddMemProbeTimeout envVariable = "GDD_MEM_PROBE_TIMEOUT"
288 | 	// GddMemSuspicionMult is the multiplier for determining the time an inaccessible node is considered suspect before declaring it dead.
289 | 	// expose SuspicionMult property of memberlist.Config
290 | 	GddMemSuspicionMult  envVariable = "GDD_MEM_SUSPICION_MULT"
291 | 	GddMemRetransmitMult envVariable = "GDD_MEM_RETRANSMIT_MULT"
292 | 	// GddMemGossipNodes how many remote nodes you want to gossip messages
293 | 	// expose GossipNodes property of memberlist.Config
294 | 	GddMemGossipNodes envVariable = "GDD_MEM_GOSSIP_NODES"
295 | 	// GddMemGossipInterval gossip interval
296 | 	// expose GossipInterval property of memberlist.Config
297 | 	GddMemGossipInterval envVariable = "GDD_MEM_GOSSIP_INTERVAL"
298 | 	// GddMemTCPTimeout tcp timeout
299 | 	// expose TCPTimeout property of memberlist.Config
300 | 	GddMemTCPTimeout envVariable = "GDD_MEM_TCP_TIMEOUT"
301 | 	// GddMemWeight node weight
302 | 	GddMemWeight envVariable = "GDD_MEM_WEIGHT"
303 | 	// GddMemWeightInterval node weight will be calculated every GddMemWeightInterval
304 | 	GddMemWeightInterval envVariable = "GDD_MEM_WEIGHT_INTERVAL"
305 | 	GddMemIndirectChecks envVariable = "GDD_MEM_INDIRECT_CHECKS"
306 | 	GddMemLogDisable     envVariable = "GDD_MEM_LOG_DISABLE"
307 | 	// GddMemCIDRsAllowed If not set, allow any connection (default), otherwise specify all networks
308 | 	// allowed connecting (you must specify IPv6/IPv4 separately)
309 | 	GddMemCIDRsAllowed envVariable = "GDD_MEM_CIDRS_ALLOWED"
310 | 
311 | 	GddDBDisableAutoConfigure   envVariable = "GDD_DB_DISABLEAUTOCONFIGURE"
312 | 	GddDBDriver                 envVariable = "GDD_DB_DRIVER"
313 | 	GddDBDsn                    envVariable = "GDD_DB_DSN"
314 | 	GddDBTablePrefix            envVariable = "GDD_DB_TABLE_PREFIX"
315 | 	GddDBSkipDefaultTransaction envVariable = "GDD_DB_SKIPDEFAULTTRANSACTION"
316 | 	GddDBMaxIdleConns           envVariable = "GDD_DB_POOL_MAXIDLECONNS"
317 | 	GddDBMaxOpenConns           envVariable = "GDD_DB_POOL_MAXOPENCONNS"
318 | 	GddDBConnMaxLifetime        envVariable = "GDD_DB_POOL_CONNMAXLIFETIME"
319 | 	GddDBConnMaxIdleTime        envVariable = "GDD_DB_POOL_CONNMAXIDLETIME"
320 | 	GddDBPrepareStmt            envVariable = "GDD_DB_PREPARESTMT"
321 | 
322 | 	GddDBLogSlowThreshold             envVariable = "GDD_DB_LOG_SLOWTHRESHOLD"
323 | 	GddDBLogIgnoreRecordNotFoundError envVariable = "GDD_DB_LOG_IGNORERECORDNOTFOUNDERROR"
324 | 	GddDBLogParameterizedQueries      envVariable = "GDD_DB_LOG_PARAMETERIZEDQUERIES"
325 | 	GddDBLogLevel                     envVariable = "GDD_DB_LOG_LEVEL"
326 | 
327 | 	GddDBMysqlSkipInitializeWithVersion envVariable = "GDD_DB_MYSQL_SKIPINITIALIZEWITHVERSION"
328 | 	GddDBMysqlDefaultStringSize         envVariable = "GDD_DB_MYSQL_DEFAULTSTRINGSIZE"
329 | 	//GddDBMysqlDefaultDatetimePrecision      envVariable = "GDD_DB_MYSQL_DEFAULTDATETIMEPRECISION"
330 | 	GddDBMysqlDisableWithReturning          envVariable = "GDD_DB_MYSQL_DISABLEWITHRETURNING"
331 | 	GddDBMysqlDisableDatetimePrecision      envVariable = "GDD_DB_MYSQL_DISABLEDATETIMEPRECISION"
332 | 	GddDBMysqlDontSupportRenameIndex        envVariable = "GDD_DB_MYSQL_DONTSUPPORTRENAMEINDEX"
333 | 	GddDBMysqlDontSupportRenameColumn       envVariable = "GDD_DB_MYSQL_DONTSUPPORTRENAMECOLUMN"
334 | 	GddDBMysqlDontSupportForShareClause     envVariable = "GDD_DB_MYSQL_DONTSUPPORTFORSHARECLAUSE"
335 | 	GddDBMysqlDontSupportNullAsDefaultValue envVariable = "GDD_DB_MYSQL_DONTSUPPORTNULLASDEFAULTVALUE"
336 | 	GddDBMysqlDontSupportRenameColumnUnique envVariable = "GDD_DB_MYSQL_DONTSUPPORTRENAMECOLUMNUNIQUE"
337 | 
338 | 	GddDBPostgresPreferSimpleProtocol envVariable = "GDD_DB_POSTGRES_PREFERSIMPLEPROTOCOL"
339 | 	GddDBPostgresWithoutReturning     envVariable = "GDD_DB_POSTGRES_WITHOUTRETURNING"
340 | 
341 | 	GddDbPrometheusEnable          envVariable = "GDD_DB_PROMETHEUS_ENABLE"
342 | 	GddDbPrometheusRefreshInterval envVariable = "GDD_DB_PROMETHEUS_REFRESHINTERVAL"
343 | 	GddDbPrometheusDBName          envVariable = "GDD_DB_PROMETHEUS_DBNAME"
344 | 
345 | 	GddDbCacheEnable envVariable = "GDD_DB_CACHE_ENABLE"
346 | 	GddCacheTTL      envVariable = "GDD_CACHE_TTL"
347 | 	GddCacheStores   envVariable = "GDD_CACHE_STORES"
348 | 
349 | 	GddCacheRedisAddr           envVariable = "GDD_CACHE_REDIS_ADDR"
350 | 	GddCacheRedisUser           envVariable = "GDD_CACHE_REDIS_USER"
351 | 	GddCacheRedisPass           envVariable = "GDD_CACHE_REDIS_PASS"
352 | 	GddCacheRedisRouteByLatency envVariable = "GDD_CACHE_REDIS_ROUTEBYLATENCY"
353 | 	GddCacheRedisRouteRandomly  envVariable = "GDD_CACHE_REDIS_ROUTERANDOMLY"
354 | 
355 | 	GddCacheRistrettoNumCounters envVariable = "GDD_CACHE_RISTRETTO_NUMCOUNTERS"
356 | 	GddCacheRistrettoMaxCost     envVariable = "GDD_CACHE_RISTRETTO_MAXCOST"
357 | 	GddCacheRistrettoBufferItems envVariable = "GDD_CACHE_RISTRETTO_BUFFERITEMS"
358 | 
359 | 	GddCacheGocacheExpiration      envVariable = "GDD_CACHE_GOCACHE_EXPIRATION"
360 | 	GddCacheGocacheCleanupInterval envVariable = "GDD_CACHE_GOCACHE_CLEANUP_INTERVAL"
361 | 
362 | 	GddZkServers          envVariable = "GDD_ZK_SERVERS"
363 | 	GddZkSequence         envVariable = "GDD_ZK_SEQUENCE"
364 | 	GddZkDirectoryPattern envVariable = "GDD_ZK_DIRECTORY_PATTERN"
365 | )
366 | 
367 | // Load loads value from environment variable
368 | func (receiver envVariable) Load() string {
369 | 	return os.Getenv(string(receiver))
370 | }
371 | 
372 | func (receiver envVariable) LoadOrDefault(d string) string {
373 | 	val := d
374 | 	if stringutils.IsNotEmpty(receiver.Load()) {
375 | 		val = receiver.Load()
376 | 	}
377 | 	return val
378 | }
379 | 
380 | func (receiver envVariable) LoadDurationOrDefault(d string) time.Duration {
381 | 	val, _ := time.ParseDuration(d)
382 | 	if stringutils.IsNotEmpty(receiver.Load()) {
383 | 		var err error
384 | 		val, err = time.ParseDuration(receiver.Load())
385 | 		if err != nil {
386 | 			panic(err)
387 | 		}
388 | 	}
389 | 	return val
390 | }
391 | 
392 | // String return string representation for receiver
393 | func (receiver envVariable) String() string {
394 | 	return receiver.Load()
395 | }
396 | 
397 | // Write sets the environment variable to value
398 | func (receiver envVariable) Write(value string) error {
399 | 	return os.Setenv(string(receiver), value)
400 | }
401 | 
402 | func GetNacosClientParam() vo.NacosClientParam {
403 | 	namespaceId := DefaultGddNacosNamespaceId
404 | 	if stringutils.IsNotEmpty(GddNacosNamespaceId.Load()) {
405 | 		namespaceId = GddNacosNamespaceId.Load()
406 | 	}
407 | 	timeoutMs := DefaultGddNacosTimeoutMs
408 | 	if stringutils.IsNotEmpty(GddNacosTimeoutMs.Load()) {
409 | 		if t, err := cast.ToIntE(GddNacosTimeoutMs.Load()); err == nil {
410 | 			timeoutMs = t
411 | 		}
412 | 	}
413 | 	notLoadCacheAtStart := DefaultGddNacosNotLoadCacheAtStart
414 | 	if stringutils.IsNotEmpty(GddNacosNotLoadCacheAtStart.Load()) {
415 | 		notLoadCacheAtStart, _ = cast.ToBoolE(GddNacosNotLoadCacheAtStart.Load())
416 | 	}
417 | 	logDir := DefaultGddNacosLogDir
418 | 	if stringutils.IsNotEmpty(GddNacosLogDir.Load()) {
419 | 		logDir = GddNacosLogDir.Load()
420 | 	}
421 | 	cacheDir := DefaultGddNacosCacheDir
422 | 	if stringutils.IsNotEmpty(GddNacosCacheDir.Load()) {
423 | 		cacheDir = GddNacosCacheDir.Load()
424 | 	}
425 | 	logLevel := DefaultGddNacosLogLevel
426 | 	if stringutils.IsNotEmpty(GddNacosLogLevel.Load()) {
427 | 		logLevel = GddNacosLogLevel.Load()
428 | 	}
429 | 	logDiscard := DefaultGddNacosLogDiscard
430 | 	if stringutils.IsNotEmpty(GddNacosLogDiscard.Load()) {
431 | 		logDiscard, _ = cast.ToBoolE(GddNacosLogDiscard.Load())
432 | 	}
433 | 	clientConfig := *constant.NewClientConfig(
434 | 		constant.WithNamespaceId(namespaceId),
435 | 		constant.WithTimeoutMs(uint64(timeoutMs)),
436 | 		constant.WithNotLoadCacheAtStart(notLoadCacheAtStart),
[TRUNCATED]
```

framework/config/config_test.go
```
1 | package config_test
2 | 
3 | import (
4 | 	"testing"
5 | 
6 | 	"github.com/apolloconfig/agollo/v4"
7 | 	"github.com/apolloconfig/agollo/v4/agcache/memory"
8 | 	apolloConfig "github.com/apolloconfig/agollo/v4/env/config"
9 | 	"github.com/golang/mock/gomock"
10 | 	"github.com/pkg/errors"
11 | 	. "github.com/smartystreets/goconvey/convey"
12 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
13 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr/mock"
15 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/cache"
16 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/config_client"
17 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
18 | )
19 | 
20 | func Test_envVariable_String(t *testing.T) {
21 | 	Convey("Should be on", t, func() {
22 | 		config.GddBanner.Write("on")
23 | 		So(config.GddBanner.String(), ShouldEqual, "on")
24 | 		So(config.GddBanner.Load(), ShouldEqual, "on")
25 | 	})
26 | }
27 | 
28 | func TestMain(m *testing.M) {
29 | 	config.GddNacosServerAddr.Write("http://localhost:8848")
30 | 	m.Run()
31 | }
32 | 
33 | func TestLoadConfigFromRemote_Apollo(t *testing.T) {
34 | 	Convey("Should not panic to load config from apollo", t, func() {
35 | 		ctrl := gomock.NewController(t)
36 | 		defer ctrl.Finish()
37 | 		config.GddApolloAddr.Write("http://apollo-config-dev-svc:8080")
38 | 		config.GddConfigRemoteType.Write(config.ApolloConfigType)
39 | 		config.GddServiceName.Write("configmgr")
40 | 		configClient := mock.NewMockClient(ctrl)
41 | 		factory := &memory.DefaultCacheFactory{}
42 | 		cache := factory.Create()
43 | 		cache.Set("gdd.retry.count", "3", 0)
44 | 		cache.Set("gdd.weight", "5", 0)
45 | 		configClient.
46 | 			EXPECT().
47 | 			GetConfigCache(config.DefaultGddApolloNamespace).
48 | 			AnyTimes().
49 | 			Return(cache)
50 | 
51 | 		configmgr.StartWithConfig = func(loadAppConfig func() (*apolloConfig.AppConfig, error)) (agollo.Client, error) {
52 | 			_, _ = loadAppConfig()
53 | 			return configClient, nil
54 | 		}
55 | 
56 | 		if configmgr.ApolloClient != nil {
57 | 			configmgr.ApolloClient = configClient
58 | 		}
59 | 
60 | 		So(func() {
61 | 			config.LoadConfigFromRemote()
62 | 		}, ShouldNotPanic)
63 | 	})
64 | }
65 | 
66 | func TestLoadConfigFromRemote_Apollo_Panic(t *testing.T) {
67 | 	Convey("Should panic to load config from apollo", t, func() {
68 | 		ctrl := gomock.NewController(t)
69 | 		defer ctrl.Finish()
70 | 		config.GddApolloAddr.Write("http://apollo-config-dev-svc:8080")
71 | 		config.GddConfigRemoteType.Write(config.ApolloConfigType)
72 | 		config.GddServiceName.Write("")
73 | 		configClient := mock.NewMockClient(ctrl)
74 | 		factory := &memory.DefaultCacheFactory{}
75 | 		cache := factory.Create()
76 | 		cache.Set("gdd.retry.count", "3", 0)
77 | 		cache.Set("gdd.weight", "5", 0)
78 | 		configClient.
79 | 			EXPECT().
80 | 			GetConfigCache(config.DefaultGddApolloNamespace).
81 | 			AnyTimes().
82 | 			Return(cache)
83 | 
84 | 		configmgr.StartWithConfig = func(loadAppConfig func() (*apolloConfig.AppConfig, error)) (agollo.Client, error) {
85 | 			_, _ = loadAppConfig()
86 | 			return configClient, nil
87 | 		}
88 | 
89 | 		if configmgr.ApolloClient != nil {
90 | 			configmgr.ApolloClient = configClient
91 | 		}
92 | 
93 | 		So(func() {
94 | 			config.LoadConfigFromRemote()
95 | 		}, ShouldPanic)
96 | 	})
97 | }
98 | 
99 | func TestLoadConfigFromRemote_Apollo_Panic2(t *testing.T) {
100 | 	Convey("Should panic to load config from apollo", t, func() {
101 | 		ctrl := gomock.NewController(t)
102 | 		defer ctrl.Finish()
103 | 		config.GddConfigRemoteType.Write(config.ApolloConfigType)
104 | 		config.GddServiceName.Write("configmgr")
105 | 		config.GddApolloAddr.Write("")
106 | 		configClient := mock.NewMockClient(ctrl)
107 | 		factory := &memory.DefaultCacheFactory{}
108 | 		cache := factory.Create()
109 | 		cache.Set("gdd.retry.count", "3", 0)
110 | 		cache.Set("gdd.weight", "5", 0)
111 | 		configClient.
112 | 			EXPECT().
113 | 			GetConfigCache(config.DefaultGddApolloNamespace).
114 | 			AnyTimes().
115 | 			Return(cache)
116 | 
117 | 		configmgr.StartWithConfig = func(loadAppConfig func() (*apolloConfig.AppConfig, error)) (agollo.Client, error) {
118 | 			_, _ = loadAppConfig()
119 | 			return configClient, nil
120 | 		}
121 | 
122 | 		if configmgr.ApolloClient != nil {
123 | 			configmgr.ApolloClient = configClient
124 | 		}
125 | 
126 | 		So(func() {
127 | 			config.LoadConfigFromRemote()
128 | 		}, ShouldPanic)
129 | 	})
130 | }
131 | 
132 | func TestLoadConfigFromRemote_Apollo_Log(t *testing.T) {
133 | 	Convey("Should panic to load config from apollo", t, func() {
134 | 		ctrl := gomock.NewController(t)
135 | 		defer ctrl.Finish()
136 | 		config.GddConfigRemoteType.Write(config.ApolloConfigType)
137 | 		config.GddServiceName.Write("configmgr")
138 | 		config.GddApolloAddr.Write("http://apollo-config-dev-svc:8080")
139 | 		config.GddApolloLogEnable.Write("true")
140 | 		configClient := mock.NewMockClient(ctrl)
141 | 		factory := &memory.DefaultCacheFactory{}
142 | 		cache := factory.Create()
143 | 		cache.Set("gdd.retry.count", "3", 0)
144 | 		cache.Set("gdd.weight", "5", 0)
145 | 		configClient.
146 | 			EXPECT().
147 | 			GetConfigCache(config.DefaultGddApolloNamespace).
148 | 			AnyTimes().
149 | 			Return(cache)
150 | 
151 | 		configmgr.StartWithConfig = func(loadAppConfig func() (*apolloConfig.AppConfig, error)) (agollo.Client, error) {
152 | 			_, _ = loadAppConfig()
153 | 			return configClient, nil
154 | 		}
155 | 
156 | 		if configmgr.ApolloClient != nil {
157 | 			configmgr.ApolloClient = configClient
158 | 		}
159 | 
160 | 		So(func() {
161 | 			config.LoadConfigFromRemote()
162 | 		}, ShouldNotPanic)
163 | 	})
164 | }
165 | 
166 | func TestLoadConfigFromRemote_Nacos(t *testing.T) {
167 | 	Convey("Should not panic to load config from nacos", t, func() {
168 | 		config.GddConfigRemoteType.Write(config.NacosConfigType)
169 | 		config.GddNacosConfigDataid.Write(".env")
170 | 		ctrl := gomock.NewController(t)
171 | 		defer ctrl.Finish()
172 | 		dataId := ".env"
173 | 		configClient := mock.NewMockIConfigClient(ctrl)
174 | 		configClient.
175 | 			EXPECT().
176 | 			GetConfig(vo.ConfigParam{
177 | 				DataId: dataId,
178 | 				Group:  config.DefaultGddNacosConfigGroup,
179 | 			}).
180 | 			AnyTimes().
181 | 			Return("GDD_SERVICE_NAME=configmgr\n\nGDD_READ_TIMEOUT=60s\nGDD_WRITE_TIMEOUT=60s\nGDD_IDLE_TIMEOUT=120s", nil)
182 | 
183 | 		configClient.
184 | 			EXPECT().
185 | 			ListenConfig(gomock.Any()).
186 | 			AnyTimes().
187 | 			Return(nil)
188 | 
189 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
190 | 			return configClient, nil
191 | 		}
192 | 
193 | 		if configmgr.NacosClient != nil {
194 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
195 | 				config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
196 | 		}
197 | 
198 | 		So(func() {
199 | 			config.LoadConfigFromRemote()
200 | 		}, ShouldNotPanic)
201 | 	})
202 | }
203 | 
204 | func TestLoadConfigFromRemote_Nacos_Panic(t *testing.T) {
205 | 	Convey("Should panic to load config from nacos", t, func() {
206 | 		config.GddConfigRemoteType.Write(config.NacosConfigType)
207 | 		config.GddNacosConfigDataid.Write("")
208 | 		ctrl := gomock.NewController(t)
209 | 		defer ctrl.Finish()
210 | 		dataId := ".env"
211 | 		configClient := mock.NewMockIConfigClient(ctrl)
212 | 		configClient.
213 | 			EXPECT().
214 | 			GetConfig(vo.ConfigParam{
215 | 				DataId: dataId,
216 | 				Group:  config.DefaultGddNacosConfigGroup,
217 | 			}).
218 | 			AnyTimes().
219 | 			Return("GDD_SERVICE_NAME=configmgr\n\nGDD_READ_TIMEOUT=60s\nGDD_WRITE_TIMEOUT=60s\nGDD_IDLE_TIMEOUT=120s", nil)
220 | 
221 | 		configClient.
222 | 			EXPECT().
223 | 			ListenConfig(gomock.Any()).
224 | 			AnyTimes().
225 | 			Return(nil)
226 | 
227 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
228 | 			return configClient, nil
229 | 		}
230 | 
231 | 		if configmgr.NacosClient != nil {
232 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
233 | 				config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
234 | 		}
235 | 
236 | 		So(func() {
237 | 			config.LoadConfigFromRemote()
238 | 		}, ShouldPanic)
239 | 	})
240 | }
241 | 
242 | func TestLoadConfigFromRemote_Nacos_Panic2(t *testing.T) {
243 | 	Convey("Should panic to load config from nacos", t, func() {
244 | 		config.GddConfigRemoteType.Write(config.NacosConfigType)
245 | 		config.GddNacosConfigDataid.Write(".env")
246 | 		ctrl := gomock.NewController(t)
247 | 		defer ctrl.Finish()
248 | 		dataId := ".env"
249 | 		configClient := mock.NewMockIConfigClient(ctrl)
250 | 		configClient.
251 | 			EXPECT().
252 | 			GetConfig(vo.ConfigParam{
253 | 				DataId: dataId,
254 | 				Group:  config.DefaultGddNacosConfigGroup,
255 | 			}).
256 | 			AnyTimes().
257 | 			Return("", errors.New("mock error from GetConfig"))
258 | 
259 | 		configClient.
260 | 			EXPECT().
261 | 			ListenConfig(gomock.Any()).
262 | 			AnyTimes().
263 | 			Return(nil)
264 | 
265 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
266 | 			return configClient, nil
267 | 		}
268 | 
269 | 		if configmgr.NacosClient != nil {
270 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
271 | 				config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
272 | 		}
273 | 
274 | 		So(func() {
275 | 			config.LoadConfigFromRemote()
276 | 		}, ShouldPanic)
277 | 	})
278 | }
279 | 
280 | func TestLoadConfigFromRemote_Panic(t *testing.T) {
281 | 	Convey("Should panic to load config from remote", t, func() {
282 | 		config.GddConfigRemoteType.Write("Unknown remote config type")
283 | 		So(func() {
284 | 			config.LoadConfigFromRemote()
285 | 		}, ShouldPanic)
286 | 	})
287 | }
288 | 
289 | func TestGetNacosClientParam(t *testing.T) {
290 | 	Convey("Should panic because of invalid url", t, func() {
291 | 		config.GddNacosNamespaceId.Write("test namespace")
292 | 		config.GddNacosTimeoutMs.Write("300")
293 | 		config.GddNacosNotLoadCacheAtStart.Write("true")
294 | 		config.GddNacosLogDir.Write("/tmp")
295 | 		config.GddNacosCacheDir.Write("/tmp")
296 | 		config.GddNacosLogLevel.Write("debug")
297 | 		So(func() {
298 | 			config.GetNacosClientParam()
299 | 		}, ShouldNotPanic)
300 | 	})
301 | }
302 | 
303 | func TestGetNacosClientParam_Panic(t *testing.T) {
304 | 	Convey("Should panic because of invalid url", t, func() {
305 | 		config.GddNacosNamespaceId.Write("test namespace")
306 | 		config.GddNacosTimeoutMs.Write("300")
307 | 		config.GddNacosNotLoadCacheAtStart.Write("true")
308 | 		config.GddNacosLogDir.Write("/tmp")
309 | 		config.GddNacosCacheDir.Write("/tmp")
310 | 		config.GddNacosLogLevel.Write("debug")
311 | 		config.GddNacosServerAddr.Write("invalid url")
312 | 		So(func() {
313 | 			config.GetNacosClientParam()
314 | 		}, ShouldPanic)
315 | 	})
316 | }
317 | 
318 | func TestGetNacosClientParam_Panic1(t *testing.T) {
319 | 	Convey("Should panic because of invalid url", t, func() {
320 | 		config.GddNacosNamespaceId.Write("test namespace")
321 | 		config.GddNacosTimeoutMs.Write("300")
322 | 		config.GddNacosNotLoadCacheAtStart.Write("true")
323 | 		config.GddNacosLogDir.Write("/tmp")
324 | 		config.GddNacosCacheDir.Write("/tmp")
325 | 		config.GddNacosLogLevel.Write("debug")
326 | 		config.GddNacosServerAddr.Write("#$@$%^&$@@")
327 | 		So(func() {
328 | 			config.GetNacosClientParam()
329 | 		}, ShouldPanic)
330 | 	})
331 | }
332 | 
333 | func Test_envVariable_MarshalJSON(t *testing.T) {
334 | 	Convey("Should be equal to ", t, func() {
335 | 		config.GddPort.Write("8080")
336 | 		data, err := config.GddPort.MarshalJSON()
337 | 		So(err, ShouldBeNil)
338 | 		So(string(data), ShouldEqual, `"8080"`)
339 | 	})
340 | }
```

framework/config/default.go
```
1 | package config
2 | 
3 | import (
4 | 	"github.com/wubin1989/gorm/logger"
5 | 
6 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr"
7 | )
8 | 
9 | const FrameworkName = "go-doudou"
10 | 
11 | const (
12 | 	// Default configs for framework component
13 | 	DefaultGddBanner             = true
14 | 	DefaultGddBannerText         = FrameworkName
15 | 	DefaultGddLogLevel           = "info"
16 | 	DefaultGddLogFormat          = "text"
17 | 	DefaultGddLogReqEnable       = false
18 | 	DefaultGddLogCaller          = true
19 | 	DefaultGddLogDiscard         = false
20 | 	DefaultGddLogPath            = ""
21 | 	DefaultGddLogStyle           = "json"
22 | 	DefaultGddGraceTimeout       = "15s"
23 | 	DefaultGddWriteTimeout       = "15s"
24 | 	DefaultGddReadTimeout        = "15s"
25 | 	DefaultGddIdleTimeout        = "60s"
26 | 	DefaultGddServiceName        = ""
27 | 	DefaultGddServiceGroup       = ""
28 | 	DefaultGddServiceVersion     = ""
29 | 	DefaultGddRouteRootPath      = ""
30 | 	DefaultGddHost               = ""
31 | 	DefaultGddPort               = 6060
32 | 	DefaultGddGrpcPort           = 50051
33 | 	DefaultGddRetryCount         = 0
34 | 	DefaultGddManage             = true
35 | 	DefaultGddManageUser         = "admin"
36 | 	DefaultGddManagePass         = "admin"
37 | 	DefaultGddTracingMetricsRoot = "tracing"
38 | 	DefaultGddWeight             = 1
39 | 
40 | 	DefaultGddServiceDiscoveryMode = ""
41 | 
42 | 	DefaultGddNacosNamespaceId         = "public"
43 | 	DefaultGddNacosTimeoutMs           = 10000
44 | 	DefaultGddNacosNotLoadCacheAtStart = false
45 | 	DefaultGddNacosLogDir              = "/tmp/nacos/log"
46 | 	DefaultGddNacosCacheDir            = "/tmp/nacos/cache"
47 | 	DefaultGddNacosLogLevel            = "info"
48 | 	DefaultGddNacosLogDiscard          = false
49 | 	DefaultGddNacosServerAddr          = ""
50 | 	DefaultGddNacosRegisterHost        = ""
51 | 	DefaultGddNacosClusterName         = "DEFAULT"
52 | 	DefaultGddNacosGroupName           = "DEFAULT_GROUP"
53 | 
54 | 	DefaultGddNacosConfigFormat = configmgr.DotenvConfigFormat
55 | 	DefaultGddNacosConfigGroup  = "DEFAULT_GROUP"
56 | 	DefaultGddNacosConfigDataid = ""
57 | 
58 | 	DefaultGddEnableResponseGzip         = true
59 | 	DefaultGddAppType                    = "rest"
60 | 	DefaultGddFallbackContentType        = "application/json; charset=UTF-8"
61 | 	DefaultGddRouterSaveMatchedRoutePath = true
62 | 	DefaultGddConfigRemoteType           = ""
63 | 
64 | 	DefaultGddApolloCluster      = "default"
65 | 	DefaultGddApolloAddr         = ""
66 | 	DefaultGddApolloNamespace    = "application.properties"
67 | 	DefaultGddApolloBackupEnable = true
68 | 	DefaultGddApolloBackupPath   = ""
69 | 	DefaultGddApolloSecret       = ""
70 | 	DefaultGddApolloMuststart    = false
71 | 	DefaultGddApolloLogEnable    = false
72 | 
73 | 	// DefaultGddSqlLogEnable only for doc purpose
74 | 	DefaultGddSqlLogEnable = false
75 | 
76 | 	DefaultGddStatsFreq = "1s"
77 | 
78 | 	DefaultGddRegisterHost        = ""
79 | 	DefaultGddEtcdEndpoints       = ""
80 | 	DefaultGddEtcdLease     int64 = 5
81 | 
82 | 	// Default configs for memberlist component
83 | 	DefaultGddMemSeed           = ""
84 | 	DefaultGddMemPort           = 7946
85 | 	DefaultGddMemDeadTimeout    = "60s"
86 | 	DefaultGddMemSyncInterval   = "60s"
87 | 	DefaultGddMemReclaimTimeout = "3s"
88 | 	DefaultGddMemProbeInterval  = "5s"
89 | 	DefaultGddMemProbeTimeout   = "3s"
90 | 	DefaultGddMemSuspicionMult  = 6
91 | 	DefaultGddMemRetransmitMult = 4
92 | 	DefaultGddMemGossipNodes    = 4
93 | 	DefaultGddMemGossipInterval = "500ms"
94 | 	DefaultGddMemTCPTimeout     = "30s"
95 | 	DefaultGddMemIndirectChecks = 3
96 | 	DefaultGddMemWeight         = 1
97 | 	DefaultGddMemWeightInterval = 0
98 | 	DefaultGddMemName           = ""
99 | 	DefaultGddMemHost           = ""
100 | 	DefaultGddMemCIDRsAllowed   = ""
101 | 	DefaultGddMemLogDisable     = false
102 | 
103 | 	DefaultGddDBDisableAutoConfigure = false
104 | 	DefaultGddDBDriver               = ""
105 | 	DefaultGddDBDsn                  = ""
106 | 	DefaultGddDBTablePrefix          = ""
107 | 	DefaultGddDBMaxIdleConns         = 2
108 | 	DefaultGddDBMaxOpenConns         = -1
109 | 	DefaultGddDBConnMaxLifetime      = -1
110 | 	DefaultGddDBConnMaxIdleTime      = -1
111 | 
112 | 	DefaultGddDBLogSlowThreshold             = "200ms"
113 | 	DefaultGddDBLogIgnoreRecordNotFoundError = false
114 | 	DefaultGddDBLogParameterizedQueries      = false
115 | 	DefaultGddDBLogLevel                     = logger.Warn
116 | 
117 | 	DefaultGddDBMysqlSkipInitializeWithVersion = false
118 | 	DefaultGddDBMysqlDefaultStringSize         = 0
119 | 	//DefaultGddDBMysqlDefaultDatetimePrecision      envVariable = "GDD_DB_MYSQL_DEFAULTDATETIMEPRECISION"
120 | 	DefaultGddDBMysqlDisableWithReturning          = false
121 | 	DefaultGddDBMysqlDisableDatetimePrecision      = false
122 | 	DefaultGddDBMysqlDontSupportRenameIndex        = false
123 | 	DefaultGddDBMysqlDontSupportRenameColumn       = false
124 | 	DefaultGddDBMysqlDontSupportForShareClause     = false
125 | 	DefaultGddDBMysqlDontSupportNullAsDefaultValue = false
126 | 	DefaultGddDBMysqlDontSupportRenameColumnUnique = false
127 | 
128 | 	DefaultGddDBPostgresPreferSimpleProtocol = false
129 | 	DefaultGddDBPostgresWithoutReturning     = false
130 | 
131 | 	DefaultGddZkServers          = ""
132 | 	DefaultGddZkSequence         = false
133 | 	DefaultGddZkDirectoryPattern = "/registry/%s/providers"
134 | 
135 | 	DefaultGddDbPrometheusEnable          = false
136 | 	DefaultGddDbPrometheusRefreshInterval = 15
137 | 	DefaultGddDbPrometheusDBName          = ""
138 | 
139 | 	DefaultGddDbCacheEnable            = false
140 | 	DefaultGddCacheRedisAddr           = ""
141 | 	DefaultGddCacheRedisUser           = ""
142 | 	DefaultGddCacheRedisPass           = ""
143 | 	DefaultGddCacheRedisRouteByLatency = true
144 | 	DefaultGddCacheRedisRouteRandomly  = false
145 | 	DefaultGddCacheTTL                 = 0
146 | 	DefaultGddCacheStores              = ""
147 | 
148 | 	DefaultGddCacheRistrettoNumCounters = 1000
149 | 	DefaultGddCacheRistrettoMaxCost     = 100
150 | 	DefaultGddCacheRistrettoBufferItems = 64
151 | 
152 | 	DefaultGddCacheGocacheExpiration      = "5m"
153 | 	DefaultGddCacheGocacheCleanupInterval = "10m"
154 | 
155 | 	DefaultGddDBSkipDefaultTransaction = false
156 | 	DefaultGddDBPrepareStmt            = false
157 | )
```

framework/config/dynamic.go
```
1 | package config
2 | 
3 | //GddManageUser envVariable = "GDD_MANAGE_USER"
4 | //GddManagePass envVariable = "GDD_MANAGE_PASS"
```

framework/cache/2qcache.go
```
1 | package cache
2 | 
3 | import (
4 | 	"time"
5 | 
6 | 	lru "github.com/hashicorp/golang-lru"
7 | 	"github.com/pkg/errors"
8 | 	"github.com/unionj-cloud/toolkit/caller"
9 | )
10 | 
11 | type TwoQueueCache struct {
12 | 	*base
13 | 	recentRatio, ghostRatio float64
14 | }
15 | 
16 | type TwoQueueCacheOption func(*TwoQueueCache)
17 | 
18 | func WithRecentRatio(recentRatio float64) TwoQueueCacheOption {
19 | 	return func(tqc *TwoQueueCache) {
20 | 		tqc.recentRatio = recentRatio
21 | 	}
22 | }
23 | 
24 | func WithGhostRatio(ghostRatio float64) TwoQueueCacheOption {
25 | 	return func(tqc *TwoQueueCache) {
26 | 		tqc.ghostRatio = ghostRatio
27 | 	}
28 | }
29 | 
30 | func NewTwoQueueCache(size int, ttl time.Duration, options ...TwoQueueCacheOption) *TwoQueueCache {
31 | 	tqc := &TwoQueueCache{
32 | 		recentRatio: lru.Default2QRecentRatio,
33 | 		ghostRatio:  lru.Default2QGhostEntries,
34 | 	}
35 | 	for _, opt := range options {
36 | 		opt(tqc)
37 | 	}
38 | 	store, err := lru.New2QParams(size, tqc.recentRatio, tqc.ghostRatio)
39 | 	if err != nil {
40 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
41 | 	}
42 | 	tqc.base = newBase(store, ttl)
43 | 	return tqc
44 | }
```

framework/cache/arccache.go
```
1 | package cache
2 | 
3 | import (
4 | 	"time"
5 | 
6 | 	lru "github.com/hashicorp/golang-lru"
7 | 	"github.com/pkg/errors"
8 | 	"github.com/unionj-cloud/toolkit/caller"
9 | )
10 | 
11 | type ARCCache struct {
12 | 	*base
13 | }
14 | 
15 | func NewARCCache(size int, ttl time.Duration) *ARCCache {
16 | 	store, err := lru.NewARC(size)
17 | 	if err != nil {
18 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
19 | 	}
20 | 	return &ARCCache{
21 | 		newBase(store, ttl),
22 | 	}
23 | }
```

framework/cache/base.go
```
1 | package cache
2 | 
3 | import (
4 | 	"time"
5 | 
6 | 	"golang.org/x/exp/rand"
7 | )
8 | 
9 | type IStore interface {
10 | 	Get(key interface{}) (value interface{}, ok bool)
11 | 	Add(key, value interface{})
12 | 	Remove(key interface{})
13 | }
14 | 
15 | type base struct {
16 | 	store  IStore
17 | 	ttl    time.Duration
18 | 	offset time.Duration
19 | 	rand   *rand.Rand
20 | }
21 | 
22 | func (l *base) Set(key string, data []byte) {
23 | 	ttl := l.ttl
24 | 	if l.offset > 0 {
25 | 		ttl += time.Duration(l.rand.Int63n(int64(l.offset)))
26 | 	}
27 | 	l.store.Add(key, &Item{
28 | 		Key:      key,
29 | 		Value:    data,
30 | 		ExpireAt: time.Now().Add(ttl),
31 | 	})
32 | }
33 | 
34 | func (l *base) Get(key string) ([]byte, bool) {
35 | 	value, ok := l.store.Get(key)
36 | 	if !ok {
37 | 		return nil, false
38 | 	}
39 | 	item := value.(*Item)
40 | 	if item.expired() {
41 | 		l.store.Remove(key)
42 | 		return nil, false
43 | 	}
44 | 	return item.Value.([]byte), true
45 | }
46 | 
47 | func (l *base) Del(key string) {
48 | 	l.store.Remove(key)
49 | }
50 | 
51 | const maxOffset = 10 * time.Second
52 | 
53 | func newBase(store IStore, ttl time.Duration) *base {
54 | 	offset := ttl / 10
55 | 	if offset > maxOffset {
56 | 		offset = maxOffset
57 | 	}
58 | 	return &base{
59 | 		store:  store,
60 | 		ttl:    ttl,
61 | 		offset: offset,
62 | 		rand:   rand.New(rand.NewSource(uint64(time.Now().UnixNano()))),
63 | 	}
64 | }
```

framework/cache/cachemanager.go
```
1 | package cache
2 | 
3 | import (
4 | 	"strings"
5 | 	"time"
6 | 	"unsafe"
7 | 
8 | 	"github.com/dgraph-io/ristretto"
9 | 	go_cache "github.com/patrickmn/go-cache"
10 | 	"github.com/redis/go-redis/v9"
11 | 	gocache "github.com/unionj-cloud/toolkit/gocache/lib/cache"
12 | 	"github.com/unionj-cloud/toolkit/gocache/lib/metrics"
13 | 	"github.com/unionj-cloud/toolkit/gocache/lib/store"
14 | 	go_cache_store "github.com/unionj-cloud/toolkit/gocache/store/go_cache"
15 | 	redis_store "github.com/unionj-cloud/toolkit/gocache/store/redis"
16 | 	ristretto_store "github.com/unionj-cloud/toolkit/gocache/store/ristretto"
17 | 
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
19 | 	"github.com/unionj-cloud/toolkit/cast"
20 | 	"github.com/unionj-cloud/toolkit/sliceutils"
21 | 	"github.com/unionj-cloud/toolkit/stringutils"
22 | )
23 | 
24 | var CacheManager gocache.CacheInterface[any]
25 | 
26 | const (
27 | 	// CacheStoreRistretto TODO
28 | 	// There is a bug for CacheStoreRistretto, do not use it.
29 | 	// Use CacheStoreGoCache or CacheStoreRedis or both.
30 | 	CacheStoreRistretto = "ristretto"
31 | 	CacheStoreGoCache   = "go-cache"
32 | 	CacheStoreRedis     = "redis"
33 | )
34 | 
35 | func init() {
36 | 	conf := config.Config{
37 | 		Cache: struct {
38 | 			TTL    int
39 | 			Stores string
40 | 			Redis  struct {
41 | 				Addr           string
42 | 				Username       string
43 | 				Password       string
44 | 				RouteByLatency bool `default:"true"`
45 | 				RouteRandomly  bool
46 | 				DB             int
47 | 				Sentinel       struct {
48 | 					Master   string
49 | 					Nodes    string
50 | 					Password string
51 | 				}
52 | 			}
53 | 			Ristretto struct {
54 | 				NumCounters int64 `default:"1000"`
55 | 				MaxCost     int64 `default:"100"`
56 | 				BufferItems int64 `default:"64"`
57 | 			}
58 | 			GoCache struct {
59 | 				Expiration      time.Duration `default:"5m"`
60 | 				CleanupInterval time.Duration `default:"10m"`
61 | 			}
62 | 		}{
63 | 			TTL:    cast.ToIntOrDefault(config.GddCacheTTL.Load(), config.DefaultGddCacheTTL),
64 | 			Stores: config.GddCacheStores.LoadOrDefault(config.DefaultGddCacheStores),
65 | 			Ristretto: struct {
66 | 				NumCounters int64 `default:"1000"`
67 | 				MaxCost     int64 `default:"100"`
68 | 				BufferItems int64 `default:"64"`
69 | 			}{
70 | 				NumCounters: cast.ToInt64OrDefault(config.GddCacheRistrettoNumCounters.Load(), config.DefaultGddCacheRistrettoNumCounters),
71 | 				MaxCost:     cast.ToInt64OrDefault(config.GddCacheRistrettoMaxCost.Load(), config.DefaultGddCacheRistrettoMaxCost),
72 | 				BufferItems: cast.ToInt64OrDefault(config.GddCacheRistrettoBufferItems.Load(), config.DefaultGddCacheRistrettoBufferItems),
73 | 			},
74 | 			Redis: struct {
75 | 				Addr           string
76 | 				Username       string
77 | 				Password       string
78 | 				RouteByLatency bool `default:"true"`
79 | 				RouteRandomly  bool
80 | 				DB             int
81 | 				Sentinel       struct {
82 | 					Master   string
83 | 					Nodes    string
84 | 					Password string
85 | 				}
86 | 			}{
87 | 				Addr:           config.GddCacheRedisAddr.LoadOrDefault(config.DefaultGddCacheRedisAddr),
88 | 				Username:       config.GddCacheRedisUser.LoadOrDefault(config.DefaultGddCacheRedisUser),
89 | 				Password:       config.GddCacheRedisPass.LoadOrDefault(config.DefaultGddCacheRedisPass),
90 | 				RouteByLatency: cast.ToBoolOrDefault(config.GddCacheRedisRouteByLatency.Load(), config.DefaultGddCacheRedisRouteByLatency),
91 | 				RouteRandomly:  cast.ToBoolOrDefault(config.GddCacheRedisRouteRandomly.Load(), config.DefaultGddCacheRedisRouteRandomly),
92 | 			},
93 | 			GoCache: struct {
94 | 				Expiration      time.Duration `default:"5m"`
95 | 				CleanupInterval time.Duration `default:"10m"`
96 | 			}{
97 | 				Expiration:      config.GddCacheGocacheExpiration.LoadDurationOrDefault(config.DefaultGddCacheGocacheExpiration),
98 | 				CleanupInterval: config.GddCacheGocacheCleanupInterval.LoadDurationOrDefault(config.DefaultGddCacheGocacheCleanupInterval),
99 | 			},
100 | 		},
101 | 		Service: struct{ Name string }{
102 | 			Name: config.GddServiceName.LoadOrDefault(config.DefaultGddServiceName),
103 | 		},
104 | 	}
105 | 
106 | 	CacheManager = NewCacheManager(conf)
107 | }
108 | 
109 | func NewCacheManager(conf config.Config) gocache.CacheInterface[any] {
110 | 	storesStr := conf.Cache.Stores
111 | 	if stringutils.IsEmpty(storesStr) {
112 | 		return nil
113 | 	}
114 | 	stores := strings.Split(storesStr, ",")
115 | 
116 | 	var setterCaches []gocache.SetterCacheInterface[any]
117 | 	ttl := conf.Cache.TTL
118 | 
119 | 	if sliceutils.StringContains(stores, CacheStoreRistretto) {
120 | 		ristrettoCache, err := ristretto.NewCache(&ristretto.Config{
121 | 			NumCounters: conf.Cache.Ristretto.NumCounters,
122 | 			MaxCost:     conf.Cache.Ristretto.MaxCost,
123 | 			BufferItems: conf.Cache.Ristretto.BufferItems,
124 | 			Cost: func(value interface{}) int64 {
125 | 				return int64(unsafe.Sizeof(value))
126 | 			},
127 | 		})
128 | 		if err != nil {
129 | 			panic(err)
130 | 		}
131 | 		var ristrettoStore *ristretto_store.RistrettoStore
132 | 		if ttl > 0 {
133 | 			ristrettoStore = ristretto_store.NewRistretto(ristrettoCache, store.WithExpiration(time.Duration(ttl)*time.Second), store.WithSynchronousSet())
134 | 		} else {
135 | 			ristrettoStore = ristretto_store.NewRistretto(ristrettoCache, store.WithSynchronousSet())
136 | 		}
137 | 		setterCaches = append(setterCaches, gocache.New[any](ristrettoStore))
138 | 	}
139 | 
140 | 	if sliceutils.StringContains(stores, CacheStoreGoCache) {
141 | 		gocacheClient := go_cache.New(conf.Cache.GoCache.Expiration, conf.Cache.GoCache.CleanupInterval)
142 | 		setterCaches = append(setterCaches, gocache.New[any](go_cache_store.NewGoCache(gocacheClient)))
143 | 	}
144 | 
145 | 	if sliceutils.StringContains(stores, CacheStoreRedis) {
146 | 		var redisClient redis_store.RedisClientInterface
147 | 		if stringutils.IsNotEmpty(conf.Cache.Redis.Sentinel.Nodes) {
148 | 			redisClient = redis.NewFailoverClusterClient(&redis.FailoverOptions{
149 | 				MasterName:       conf.Cache.Redis.Sentinel.Master,
150 | 				SentinelAddrs:    strings.Split(conf.Cache.Redis.Sentinel.Nodes, ","),
151 | 				SentinelPassword: conf.Cache.Redis.Sentinel.Password,
152 | 				Password:         conf.Cache.Redis.Password,
153 | 				DB:               conf.Cache.Redis.DB,
154 | 			})
155 | 		} else if stringutils.IsNotEmpty(conf.Cache.Redis.Addr) {
156 | 			redisAddr := conf.Cache.Redis.Addr
157 | 			addrs := strings.Split(redisAddr, ",")
158 | 			if len(addrs) > 1 {
159 | 				redisClient = redis.NewClusterClient(&redis.ClusterOptions{
160 | 					Addrs:          addrs,
161 | 					Username:       conf.Cache.Redis.Username,
162 | 					Password:       conf.Cache.Redis.Password,
163 | 					RouteByLatency: conf.Cache.Redis.RouteByLatency,
164 | 					RouteRandomly:  conf.Cache.Redis.RouteRandomly,
165 | 				})
166 | 			} else {
167 | 				redisClient = redis.NewClient(&redis.Options{
168 | 					Addr:     addrs[0],
169 | 					Username: conf.Cache.Redis.Username,
170 | 					Password: conf.Cache.Redis.Password,
171 | 					DB:       conf.Cache.Redis.DB,
172 | 				})
173 | 			}
174 | 		}
175 | 		var redisStore *redis_store.RedisStore
176 | 		if ttl > 0 {
177 | 			redisStore = redis_store.NewRedis(redisClient, store.WithExpiration(time.Duration(ttl)*time.Second))
178 | 		} else {
179 | 			redisStore = redis_store.NewRedis(redisClient)
180 | 		}
181 | 		setterCaches = append(setterCaches, gocache.New[any](redisStore))
182 | 	}
183 | 
184 | 	var cacheManager gocache.CacheInterface[any]
185 | 
186 | 	// Initialize chained cache
187 | 	cacheManager = gocache.NewChain[any](setterCaches...)
188 | 
189 | 	serviceName := conf.Service.Name
190 | 	if stringutils.IsNotEmpty(serviceName) {
191 | 		// Initializes Prometheus metrics service
192 | 		promMetrics := metrics.NewPrometheus(serviceName)
193 | 
194 | 		// Initialize chained cache
195 | 		cacheManager = gocache.NewMetric[any](promMetrics, cacheManager)
196 | 	}
197 | 
198 | 	return cacheManager
199 | }
```

framework/cache/item.go
```
1 | package cache
2 | 
3 | import "time"
4 | 
5 | type Item struct {
6 | 	Key      string
7 | 	Value    interface{}
8 | 	ExpireAt time.Time
9 | }
10 | 
11 | func (item Item) expired() bool {
12 | 	return !item.ExpireAt.IsZero() && time.Now().After(item.ExpireAt)
13 | }
```

framework/cache/lrucache.go
```
1 | package cache
2 | 
3 | import (
4 | 	"time"
5 | 
6 | 	lru "github.com/hashicorp/golang-lru"
7 | 	"github.com/pkg/errors"
8 | 	"github.com/unionj-cloud/toolkit/caller"
9 | )
10 | 
11 | type LruCache struct {
12 | 	*base
13 | }
14 | 
15 | func NewLruCache(size int, ttl time.Duration) *LruCache {
16 | 	store, err := lru.New(size)
17 | 	if err != nil {
18 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
19 | 	}
20 | 	return &LruCache{
21 | 		newBase(&LruCacheAdapter{store}, ttl),
22 | 	}
23 | }
24 | 
25 | type LruCacheAdapter struct {
26 | 	store *lru.Cache
27 | }
28 | 
29 | func (l *LruCacheAdapter) Get(key interface{}) (value interface{}, ok bool) {
30 | 	return l.store.Get(key)
31 | }
32 | 
33 | func (l *LruCacheAdapter) Add(key, value interface{}) {
34 | 	l.store.Add(key, value)
35 | }
36 | 
37 | func (l *LruCacheAdapter) Remove(key interface{}) {
38 | 	l.store.Remove(key)
39 | }
```

framework/configmgr/apollo.go
```
1 | package configmgr
2 | 
3 | import (
4 | 	"fmt"
5 | 	"os"
6 | 	"strings"
7 | 	"sync"
8 | 
9 | 	"github.com/apolloconfig/agollo/v4"
10 | 	"github.com/apolloconfig/agollo/v4/env/config"
11 | 	"github.com/apolloconfig/agollo/v4/storage"
12 | 	"github.com/pkg/errors"
13 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
14 | )
15 | 
16 | var onceApollo sync.Once
17 | var ApolloClient agollo.Client
18 | var StartWithConfig = agollo.StartWithConfig
19 | 
20 | func InitialiseApolloConfig(appConfig *config.AppConfig) {
21 | 	var err error
22 | 	ApolloClient, err = StartWithConfig(func() (*config.AppConfig, error) {
23 | 		return appConfig, nil
24 | 	})
25 | 	if err != nil {
26 | 		panic(errors.Wrap(err, "[go-doudou] failed to initialise apollo client"))
27 | 	}
28 | 	logger.Info().Msg("[go-doudou] initialise apollo client successfully")
29 | }
30 | 
31 | func LoadFromApollo(appConfig *config.AppConfig) {
32 | 	onceApollo.Do(func() {
33 | 		InitialiseApolloConfig(appConfig)
34 | 	})
35 | 	currentEnv := map[string]bool{}
36 | 	namespaces := strings.Split(appConfig.NamespaceName, ",")
37 | 	for _, item := range namespaces {
38 | 		rawEnv := os.Environ()
39 | 		for _, rawEnvLine := range rawEnv {
40 | 			key := strings.Split(rawEnvLine, "=")[0]
41 | 			currentEnv[key] = true
42 | 		}
43 | 		cache := ApolloClient.GetConfigCache(item)
44 | 		cache.Range(func(key, value interface{}) bool {
45 | 			logger.Debug().Msgf("[go-doudou] key: %s, value: %s\n", key, value)
46 | 			upperK := strings.ToUpper(strings.ReplaceAll(key.(string), ".", "_"))
47 | 			if !currentEnv[upperK] {
48 | 				_ = os.Setenv(upperK, fmt.Sprint(value))
49 | 			}
50 | 			return true
51 | 		})
52 | 	}
53 | }
54 | 
55 | type BaseApolloListener struct {
56 | 	SkippedFirstEvent bool
57 | 	Lock              sync.Mutex
58 | }
59 | 
60 | func (c *BaseApolloListener) OnNewestChange(event *storage.FullChangeEvent) {
61 | }
```

framework/configmgr/apollo_test.go
```
1 | package configmgr_test
2 | 
3 | import (
4 | 	"testing"
5 | 
6 | 	"github.com/apolloconfig/agollo/v4"
7 | 	"github.com/apolloconfig/agollo/v4/agcache/memory"
8 | 	apolloConfig "github.com/apolloconfig/agollo/v4/env/config"
9 | 	"github.com/golang/mock/gomock"
10 | 	"github.com/pkg/errors"
11 | 	. "github.com/smartystreets/goconvey/convey"
12 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
13 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr/mock"
15 | )
16 | 
17 | func TestLoadFromApollo(t *testing.T) {
18 | 	Convey("Should not have error", t, func() {
19 | 		ctrl := gomock.NewController(t)
20 | 		defer ctrl.Finish()
21 | 		configClient := mock.NewMockClient(ctrl)
22 | 		factory := &memory.DefaultCacheFactory{}
23 | 		cache := factory.Create()
24 | 		cache.Set("gdd.retry.count", "3", 0)
25 | 		cache.Set("gdd.weight", "5", 0)
26 | 		configClient.
27 | 			EXPECT().
28 | 			GetConfigCache(config.DefaultGddApolloNamespace).
29 | 			AnyTimes().
30 | 			Return(cache)
31 | 
32 | 		configmgr.StartWithConfig = func(loadAppConfig func() (*apolloConfig.AppConfig, error)) (agollo.Client, error) {
33 | 			_, _ = loadAppConfig()
34 | 			return configClient, nil
35 | 		}
36 | 
37 | 		if configmgr.ApolloClient != nil {
38 | 			configmgr.ApolloClient = configClient
39 | 		}
40 | 
41 | 		apolloCluster := config.DefaultGddApolloCluster
42 | 		apolloAddr := config.GddApolloAddr.Load()
43 | 		apolloNamespace := config.DefaultGddApolloNamespace
44 | 		apolloBackupPath := config.DefaultGddApolloBackupPath
45 | 		c := &apolloConfig.AppConfig{
46 | 			AppID:            config.GddServiceName.Load(),
47 | 			Cluster:          apolloCluster,
48 | 			IP:               apolloAddr,
49 | 			NamespaceName:    apolloNamespace,
50 | 			IsBackupConfig:   false,
51 | 			BackupConfigPath: apolloBackupPath,
52 | 			MustStart:        false,
53 | 		}
54 | 		So(func() {
55 | 			configmgr.LoadFromApollo(c)
56 | 		}, ShouldNotPanic)
57 | 	})
58 | }
59 | 
60 | func TestInitialiseApolloConfig(t *testing.T) {
61 | 	Convey("Should have error", t, func() {
62 | 		configmgr.StartWithConfig = func(loadAppConfig func() (*apolloConfig.AppConfig, error)) (agollo.Client, error) {
63 | 			return nil, errors.New("mock test error")
64 | 		}
65 | 		So(func() {
66 | 			configmgr.InitialiseApolloConfig(nil)
67 | 		}, ShouldPanic)
68 | 	})
69 | }
```

framework/configmgr/nacos.go
```
1 | package configmgr
2 | 
3 | import (
4 | 	"fmt"
5 | 	"io"
6 | 	"os"
7 | 	"strings"
8 | 	"sync"
9 | 
10 | 	"github.com/joho/godotenv"
11 | 	"github.com/pkg/errors"
12 | 	"github.com/unionj-cloud/toolkit/dotenv"
13 | 	"github.com/unionj-cloud/toolkit/maputils"
14 | 	"github.com/unionj-cloud/toolkit/yaml"
15 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
16 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients"
17 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/cache"
18 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/config_client"
19 | 	"github.com/wubin1989/nacos-sdk-go/v2/util"
20 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
21 | )
22 | 
23 | type nacosConfigType string
24 | 
25 | const (
26 | 	DotenvConfigFormat nacosConfigType = "dotenv"
27 | 	YamlConfigFormat   nacosConfigType = "yaml"
28 | )
29 | 
30 | type NacosConfigMgr struct {
31 | 	dataIds     []string
32 | 	group       string
33 | 	format      nacosConfigType
34 | 	namespaceId string
35 | 	client      config_client.IConfigClient
36 | 	listeners   cache.ConcurrentMap
37 | }
38 | 
39 | func (m *NacosConfigMgr) Listeners() cache.ConcurrentMap {
40 | 	return m.listeners
41 | }
42 | 
43 | func NewNacosConfigMgr(dataIds []string, group string, format nacosConfigType, namespaceId string, client config_client.IConfigClient, listeners cache.ConcurrentMap) *NacosConfigMgr {
44 | 	return &NacosConfigMgr{dataIds: dataIds, group: group, format: format, namespaceId: namespaceId, client: client, listeners: listeners}
45 | }
46 | 
47 | var NacosClient *NacosConfigMgr
48 | 
49 | type NacosChangeEvent struct {
50 | 	Namespace, Group, DataId string
51 | 	Changes                  map[string]maputils.Change
52 | }
53 | 
54 | type NacosConfigListenerParam struct {
55 | 	DataId   string
56 | 	OnChange func(event *NacosChangeEvent)
57 | }
58 | 
59 | func (m *NacosConfigMgr) fetchConfig(dataId string) (string, error) {
60 | 	content, err := m.client.GetConfig(vo.ConfigParam{
61 | 		DataId: dataId,
62 | 		Group:  m.group,
63 | 	})
64 | 	if err != nil {
65 | 		return "", err
66 | 	}
67 | 	return content, nil
68 | }
69 | 
70 | func (m *NacosConfigMgr) loadDotenv(dataId string) error {
71 | 	content, err := m.fetchConfig(dataId)
72 | 	if err != nil {
73 | 		return err
74 | 	}
75 | 	envMap, err := godotenv.Parse(StringReader(content))
76 | 	if err != nil {
77 | 		return err
78 | 	}
79 | 	currentEnv := map[string]bool{}
80 | 	rawEnv := os.Environ()
81 | 	for _, rawEnvLine := range rawEnv {
82 | 		key := strings.Split(rawEnvLine, "=")[0]
83 | 		currentEnv[key] = true
84 | 	}
85 | 	for key, value := range envMap {
86 | 		if !currentEnv[key] {
87 | 			_ = os.Setenv(key, value)
88 | 		}
89 | 	}
90 | 	return nil
91 | }
92 | 
93 | func (m *NacosConfigMgr) loadYaml(dataId string) error {
94 | 	content, err := m.fetchConfig(dataId)
95 | 	if err != nil {
96 | 		return err
97 | 	}
98 | 	return yaml.LoadReader(strings.NewReader(content))
99 | }
100 | 
101 | var onceNacos sync.Once
102 | var NewConfigClient = clients.NewConfigClient
103 | 
104 | func InitialiseNacosConfig(param vo.NacosClientParam, dataId, format, group string) {
105 | 	client, err := NewConfigClient(param)
106 | 	if err != nil {
107 | 		panic(errors.Wrap(err, "[go-doudou] failed to create nacos config client"))
108 | 	}
109 | 	dataIds := strings.Split(dataId, ",")
110 | 	NacosClient = &NacosConfigMgr{
111 | 		dataIds:     dataIds,
112 | 		group:       group,
113 | 		format:      nacosConfigType(format),
114 | 		namespaceId: param.ClientConfig.NamespaceId,
115 | 		client:      client,
116 | 		listeners:   cache.NewConcurrentMap(),
117 | 	}
118 | }
119 | 
120 | func LoadFromNacos(param vo.NacosClientParam, dataId, format, group string) error {
121 | 	onceNacos.Do(func() {
122 | 		InitialiseNacosConfig(param, dataId, format, group)
123 | 	})
124 | 	switch nacosConfigType(format) {
125 | 	case YamlConfigFormat:
126 | 		for _, item := range NacosClient.dataIds {
127 | 			if err := NacosClient.loadYaml(item); err != nil {
128 | 				return errors.Wrap(err, "[go-doudou] failed to load yaml config")
129 | 			}
130 | 		}
131 | 	case DotenvConfigFormat:
132 | 		for _, item := range NacosClient.dataIds {
133 | 			if err := NacosClient.loadDotenv(item); err != nil {
134 | 				return errors.Wrap(err, "[go-doudou] failed to load dotenv config")
135 | 			}
136 | 		}
137 | 	default:
138 | 		return fmt.Errorf("[go-doudou] unknown config format: %s\n", format)
139 | 	}
140 | 	NacosClient.listenConfig()
141 | 	return nil
142 | }
143 | 
144 | var StringReader = func(s string) io.Reader {
145 | 	return strings.NewReader(s)
146 | }
147 | 
148 | func (m *NacosConfigMgr) CallbackOnChange(namespace, group, dataId, data, old string) {
149 | 	var newData, oldData map[string]interface{}
150 | 	var err error
151 | 	switch m.format {
152 | 	case YamlConfigFormat:
153 | 		if newData, err = yaml.LoadReaderAsMap(StringReader(data)); err != nil {
154 | 			logger.Error().Err(err).Msg("[go-doudou] error from nacos config listener")
155 | 			return
156 | 		}
157 | 		if oldData, err = yaml.LoadReaderAsMap(StringReader(old)); err != nil {
158 | 			logger.Error().Err(err).Msg("[go-doudou] error from nacos config listener")
159 | 			return
160 | 		}
161 | 	case DotenvConfigFormat:
162 | 		if newData, err = dotenv.LoadAsMap(StringReader(data)); err != nil {
163 | 			logger.Error().Err(err).Msg("[go-doudou] error from nacos config listener")
164 | 			return
165 | 		}
166 | 		if oldData, err = dotenv.LoadAsMap(StringReader(old)); err != nil {
167 | 			logger.Error().Err(err).Msg("[go-doudou] error from nacos config listener")
168 | 			return
169 | 		}
170 | 	}
171 | 	changes := maputils.Diff(newData, oldData)
172 | 	m.onChange("__"+dataId+"__"+"rest", group, namespace, changes)
173 | 	m.onChange(dataId, group, namespace, changes)
174 | }
175 | 
176 | func (m *NacosConfigMgr) listenConfig() {
177 | 	for _, dataId := range m.dataIds {
178 | 		if err := m.client.ListenConfig(vo.ConfigParam{
179 | 			DataId:   dataId,
180 | 			Group:    m.group,
181 | 			OnChange: m.CallbackOnChange,
182 | 		}); err != nil {
183 | 			panic(err)
184 | 		}
185 | 	}
186 | }
187 | 
188 | func (m *NacosConfigMgr) onChange(dataId, group, namespace string, changes map[string]maputils.Change) {
189 | 	key := util.GetConfigCacheKey(dataId, group, namespace)
190 | 	if v, ok := m.listeners.Get(key); ok {
191 | 		listener := v.(NacosConfigListenerParam)
192 | 		listener.OnChange(&NacosChangeEvent{
193 | 			Namespace: namespace,
194 | 			Group:     group,
195 | 			DataId:    dataId,
196 | 			Changes:   changes,
197 | 		})
198 | 	}
199 | }
200 | 
201 | func (m *NacosConfigMgr) AddChangeListener(param NacosConfigListenerParam) {
202 | 	key := util.GetConfigCacheKey(param.DataId, m.group, m.namespaceId)
203 | 	if _, ok := m.listeners.Get(key); ok {
204 | 		logger.Warn().Msgf("[go-doudou] you have already add a config change listener for dataId: %s, you cannot override it", param.DataId)
205 | 		return
206 | 	}
207 | 	m.listeners.Set(key, param)
208 | }
```

framework/configmgr/nacos_test.go
```
1 | package configmgr_test
2 | 
3 | import (
4 | 	"fmt"
5 | 	"io"
6 | 	"strings"
7 | 	"testing"
8 | 
9 | 	"github.com/golang/mock/gomock"
10 | 	"github.com/pkg/errors"
11 | 	. "github.com/smartystreets/goconvey/convey"
12 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
13 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr/mock"
15 | 	"github.com/unionj-cloud/toolkit/stringutils"
16 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/cache"
17 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/config_client"
18 | 	"github.com/wubin1989/nacos-sdk-go/v2/util"
19 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
20 | )
21 | 
22 | func TestMain(m *testing.M) {
23 | 	config.GddServiceName.Write("configmgr")
24 | 	config.GddApolloAddr.Write("http://apollo-config-dev-svc:8080")
25 | 	config.GddNacosServerAddr.Write("http://localhost:8848")
26 | 	m.Run()
27 | }
28 | 
29 | func TestNacosConfigMgr_AddChangeListener(t *testing.T) {
30 | 	Convey("Add listener to Nacos config client", t, func() {
31 | 		ctrl := gomock.NewController(t)
32 | 		defer ctrl.Finish()
33 | 		configClient := mock.NewMockIConfigClient(ctrl)
34 | 		nacosClient := configmgr.NewNacosConfigMgr([]string{".env"},
35 | 			"DEFAULT_GROUP", "dotenv", "public", configClient, cache.NewConcurrentMap())
36 | 		nacosClient.AddChangeListener(configmgr.NacosConfigListenerParam{
37 | 			DataId:   ".env",
38 | 			OnChange: nil,
39 | 		})
40 | 		nacosClient.AddChangeListener(configmgr.NacosConfigListenerParam{
41 | 			DataId:   ".env",
42 | 			OnChange: nil,
43 | 		})
44 | 		listener, exists := nacosClient.Listeners().Get(util.GetConfigCacheKey(".env", "DEFAULT_GROUP", "public"))
45 | 		So(exists, ShouldBeTrue)
46 | 		So(listener, ShouldNotBeZeroValue)
47 | 	})
48 | }
49 | 
50 | func TestNacosConfigMgr_LoadFromNacos_Dotenv(t *testing.T) {
51 | 	Convey("Should not have error", t, func() {
52 | 		ctrl := gomock.NewController(t)
53 | 		defer ctrl.Finish()
54 | 		dataId := ".env"
55 | 		configClient := mock.NewMockIConfigClient(ctrl)
56 | 		configClient.
57 | 			EXPECT().
58 | 			GetConfig(vo.ConfigParam{
59 | 				DataId: dataId,
60 | 				Group:  config.DefaultGddNacosConfigGroup,
61 | 			}).
62 | 			AnyTimes().
63 | 			Return("GDD_SERVICE_NAME=configmgr\n\nGDD_READ_TIMEOUT=60s\nGDD_WRITE_TIMEOUT=60s\nGDD_IDLE_TIMEOUT=120s", nil)
64 | 
65 | 		configClient.
66 | 			EXPECT().
67 | 			ListenConfig(gomock.Any()).
68 | 			AnyTimes().
69 | 			Return(nil)
70 | 
71 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
72 | 			return configClient, nil
73 | 		}
74 | 
75 | 		if configmgr.NacosClient != nil {
76 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
77 | 				config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
78 | 		}
79 | 
80 | 		err := configmgr.LoadFromNacos(config.GetNacosClientParam(), dataId, string(config.DefaultGddNacosConfigFormat), config.DefaultGddNacosConfigGroup)
81 | 		So(err, ShouldBeNil)
82 | 	})
83 | }
84 | 
85 | func TestNacosConfigMgr_LoadFromNacos_Yaml(t *testing.T) {
86 | 	Convey("Should not have error", t, func() {
87 | 		ctrl := gomock.NewController(t)
88 | 		defer ctrl.Finish()
89 | 		dataId := "app.yml"
90 | 		configClient := mock.NewMockIConfigClient(ctrl)
91 | 		configClient.
92 | 			EXPECT().
93 | 			GetConfig(vo.ConfigParam{
94 | 				DataId: dataId,
95 | 				Group:  config.DefaultGddNacosConfigGroup,
96 | 			}).
97 | 			AnyTimes().
98 | 			Return("gdd:\n  port: 8088", nil)
99 | 
100 | 		configClient.
101 | 			EXPECT().
102 | 			ListenConfig(gomock.Any()).
103 | 			AnyTimes().
104 | 			Return(nil)
105 | 
106 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
107 | 			return configClient, nil
108 | 		}
109 | 
110 | 		if configmgr.NacosClient != nil {
111 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
112 | 				config.DefaultGddNacosConfigGroup, configmgr.YamlConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
113 | 		}
114 | 
115 | 		err := configmgr.LoadFromNacos(config.GetNacosClientParam(), dataId, string(configmgr.YamlConfigFormat), config.DefaultGddNacosConfigGroup)
116 | 		So(err, ShouldBeNil)
117 | 	})
118 | }
119 | 
120 | func TestNacosConfigMgr_CallbackOnChange_Dotenv(t *testing.T) {
121 | 	Convey("Should react to dotenv config change", t, func() {
122 | 		ctrl := gomock.NewController(t)
123 | 		defer ctrl.Finish()
124 | 		dataId := ".env"
125 | 		configClient := mock.NewMockIConfigClient(ctrl)
126 | 		nacosClient := configmgr.NewNacosConfigMgr([]string{dataId},
127 | 			config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
128 | 		nacosClient.AddChangeListener(configmgr.NacosConfigListenerParam{
129 | 			DataId: dataId,
130 | 			OnChange: func(event *configmgr.NacosChangeEvent) {
131 | 				So(len(event.Changes), ShouldEqual, 4)
132 | 			},
133 | 		})
134 | 		nacosClient.CallbackOnChange(config.DefaultGddNacosNamespaceId, config.DefaultGddNacosConfigGroup, dataId, "GDD_SERVICE_NAME=configmgr\n\nGDD_READ_TIMEOUT=60s\nGDD_WRITE_TIMEOUT=60s\nGDD_IDLE_TIMEOUT=120s", "")
135 | 	})
136 | }
137 | 
138 | func TestNacosConfigMgr_CallbackOnChange_Yaml(t *testing.T) {
139 | 	Convey("Should react to yaml config change", t, func() {
140 | 		ctrl := gomock.NewController(t)
141 | 		defer ctrl.Finish()
142 | 		dataId := "app.yml"
143 | 		configClient := mock.NewMockIConfigClient(ctrl)
144 | 		nacosClient := configmgr.NewNacosConfigMgr([]string{dataId},
145 | 			config.DefaultGddNacosConfigGroup, configmgr.YamlConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
146 | 		nacosClient.AddChangeListener(configmgr.NacosConfigListenerParam{
147 | 			DataId: dataId,
148 | 			OnChange: func(event *configmgr.NacosChangeEvent) {
149 | 				So(len(event.Changes), ShouldEqual, 2)
150 | 			},
151 | 		})
152 | 		nacosClient.CallbackOnChange(config.DefaultGddNacosNamespaceId, config.DefaultGddNacosConfigGroup, dataId, "gdd:\n  port: 6060\n  tracing:\n    metrics:\n      root: \"go-doudou\"", "")
153 | 	})
154 | }
155 | 
156 | func ErrReader(err error) io.Reader {
157 | 	return &errReader{err: err}
158 | }
159 | 
160 | type errReader struct {
161 | 	err error
162 | }
163 | 
164 | func (r *errReader) Read(p []byte) (int, error) {
165 | 	return 0, r.err
166 | }
167 | 
168 | func TestNacosConfigMgr_CallbackOnChange_Yaml_Error(t *testing.T) {
169 | 	Convey("Should fail to react to yaml config change", t, func() {
170 | 		ctrl := gomock.NewController(t)
171 | 		defer ctrl.Finish()
172 | 		dataId := "app.yml"
173 | 		configClient := mock.NewMockIConfigClient(ctrl)
174 | 		nacosClient := configmgr.NewNacosConfigMgr([]string{dataId},
175 | 			config.DefaultGddNacosConfigGroup, configmgr.YamlConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
176 | 		configmgr.StringReader = func(s string) io.Reader {
177 | 			return ErrReader(errors.New("mock read error"))
178 | 		}
179 | 		nacosClient.CallbackOnChange(config.DefaultGddNacosNamespaceId, config.DefaultGddNacosConfigGroup, dataId, "gdd:\n  port: 6060\n  tracing:\n    metrics:\n      root: \"go-doudou\"", "")
180 | 	})
181 | }
182 | 
183 | func TestNacosConfigMgr_CallbackOnChange_Yaml_Error2(t *testing.T) {
184 | 	Convey("Should fail to react to yaml config change", t, func() {
185 | 		ctrl := gomock.NewController(t)
186 | 		defer ctrl.Finish()
187 | 		dataId := "app.yml"
188 | 		configClient := mock.NewMockIConfigClient(ctrl)
189 | 		nacosClient := configmgr.NewNacosConfigMgr([]string{dataId},
190 | 			config.DefaultGddNacosConfigGroup, configmgr.YamlConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
191 | 		configmgr.StringReader = func(s string) io.Reader {
192 | 			if stringutils.IsEmpty(s) {
193 | 				return ErrReader(errors.New("mock read error"))
194 | 			} else {
195 | 				return strings.NewReader(s)
196 | 			}
197 | 		}
198 | 		nacosClient.CallbackOnChange(config.DefaultGddNacosNamespaceId, config.DefaultGddNacosConfigGroup, dataId, "gdd:\n  port: 6060\n  tracing:\n    metrics:\n      root: \"go-doudou\"", "")
199 | 	})
200 | }
201 | 
202 | func TestNacosConfigMgr_CallbackOnChange_Dotenv_Error(t *testing.T) {
203 | 	Convey("Should fail to react to dotenv config change", t, func() {
204 | 		ctrl := gomock.NewController(t)
205 | 		defer ctrl.Finish()
206 | 		dataId := ".env"
207 | 		configClient := mock.NewMockIConfigClient(ctrl)
208 | 		nacosClient := configmgr.NewNacosConfigMgr([]string{dataId},
209 | 			config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
210 | 		configmgr.StringReader = func(s string) io.Reader {
211 | 			return ErrReader(errors.New("mock read error"))
212 | 		}
213 | 		nacosClient.CallbackOnChange(config.DefaultGddNacosNamespaceId, config.DefaultGddNacosConfigGroup, dataId, "GDD_SERVICE_NAME=configmgr\n\nGDD_READ_TIMEOUT=60s\nGDD_WRITE_TIMEOUT=60s\nGDD_IDLE_TIMEOUT=120s", "")
214 | 	})
215 | }
216 | 
217 | func TestNacosConfigMgr_CallbackOnChange_Dotenv_Error2(t *testing.T) {
218 | 	Convey("Should fail to react to dotenv config change", t, func() {
219 | 		ctrl := gomock.NewController(t)
220 | 		defer ctrl.Finish()
221 | 		dataId := ".env"
222 | 		configClient := mock.NewMockIConfigClient(ctrl)
223 | 		nacosClient := configmgr.NewNacosConfigMgr([]string{dataId},
224 | 			config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
225 | 		configmgr.StringReader = func(s string) io.Reader {
226 | 			if stringutils.IsEmpty(s) {
227 | 				return ErrReader(errors.New("mock read error"))
228 | 			} else {
229 | 				return strings.NewReader(s)
230 | 			}
231 | 		}
232 | 		nacosClient.CallbackOnChange(config.DefaultGddNacosNamespaceId, config.DefaultGddNacosConfigGroup, dataId, "GDD_SERVICE_NAME=configmgr\n\nGDD_READ_TIMEOUT=60s\nGDD_WRITE_TIMEOUT=60s\nGDD_IDLE_TIMEOUT=120s", "")
233 | 	})
234 | }
235 | 
236 | func TestNacosConfigMgr_LoadFromNacos_Panic(t *testing.T) {
237 | 	Convey("Should panic from listenConfig", t, func() {
238 | 		ctrl := gomock.NewController(t)
239 | 		defer ctrl.Finish()
240 | 		dataId := "app.yml"
241 | 		configClient := mock.NewMockIConfigClient(ctrl)
242 | 		configClient.
243 | 			EXPECT().
244 | 			GetConfig(vo.ConfigParam{
245 | 				DataId: dataId,
246 | 				Group:  config.DefaultGddNacosConfigGroup,
247 | 			}).
248 | 			AnyTimes().
249 | 			Return("gdd:\n  port: 8088", nil)
250 | 
251 | 		configClient.
252 | 			EXPECT().
253 | 			ListenConfig(gomock.Any()).
254 | 			AnyTimes().
255 | 			Return(errors.New("mock returned error"))
256 | 
257 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
258 | 			return configClient, nil
259 | 		}
260 | 
261 | 		if configmgr.NacosClient != nil {
262 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
263 | 				config.DefaultGddNacosConfigGroup, configmgr.YamlConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
264 | 		}
265 | 
266 | 		So(func() {
267 | 			configmgr.LoadFromNacos(config.GetNacosClientParam(), dataId, string(configmgr.YamlConfigFormat), config.DefaultGddNacosConfigGroup)
268 | 		}, ShouldPanic)
269 | 	})
270 | }
271 | 
272 | func TestNacosConfigMgr_LoadFromNacos_UnknownFormat(t *testing.T) {
273 | 	Convey("Should return error", t, func() {
274 | 		ctrl := gomock.NewController(t)
275 | 		defer ctrl.Finish()
276 | 		dataId := "app.yml"
277 | 		configClient := mock.NewMockIConfigClient(ctrl)
278 | 		configClient.
279 | 			EXPECT().
280 | 			GetConfig(vo.ConfigParam{
281 | 				DataId: dataId,
282 | 				Group:  config.DefaultGddNacosConfigGroup,
283 | 			}).
284 | 			AnyTimes().
285 | 			Return("gdd:\n  port: 8088", nil)
286 | 
287 | 		configClient.
288 | 			EXPECT().
289 | 			ListenConfig(gomock.Any()).
290 | 			AnyTimes().
291 | 			Return(nil)
292 | 
293 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
294 | 			return configClient, nil
295 | 		}
296 | 
297 | 		unknownFormat := "Unknown format"
298 | 
299 | 		if configmgr.NacosClient != nil {
300 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
301 | 				config.DefaultGddNacosConfigGroup, "Unknown format", config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
302 | 		}
303 | 
304 | 		err := configmgr.LoadFromNacos(config.GetNacosClientParam(), dataId, unknownFormat, config.DefaultGddNacosConfigGroup)
305 | 		So(err, ShouldResemble, fmt.Errorf("[go-doudou] unknown config format: %s\n", unknownFormat))
306 | 	})
307 | }
308 | 
309 | func TestNacosConfigMgr_LoadFromNacos_Yaml_Error(t *testing.T) {
310 | 	Convey("Should return error from GetConfig", t, func() {
311 | 		ctrl := gomock.NewController(t)
312 | 		defer ctrl.Finish()
313 | 		dataId := "app.yml"
314 | 		configClient := mock.NewMockIConfigClient(ctrl)
315 | 		configClient.
316 | 			EXPECT().
317 | 			GetConfig(vo.ConfigParam{
318 | 				DataId: dataId,
319 | 				Group:  config.DefaultGddNacosConfigGroup,
320 | 			}).
321 | 			AnyTimes().
322 | 			Return("", errors.New("mock error from GetConfig"))
323 | 
324 | 		configClient.
325 | 			EXPECT().
326 | 			ListenConfig(gomock.Any()).
327 | 			AnyTimes().
328 | 			Return(nil)
329 | 
330 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
331 | 			return configClient, nil
332 | 		}
333 | 
334 | 		if configmgr.NacosClient != nil {
335 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
336 | 				config.DefaultGddNacosConfigGroup, configmgr.YamlConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
337 | 		}
338 | 
339 | 		err := configmgr.LoadFromNacos(config.GetNacosClientParam(), dataId, string(configmgr.YamlConfigFormat), config.DefaultGddNacosConfigGroup)
340 | 		So(err, ShouldNotBeNil)
341 | 	})
342 | }
343 | 
344 | func TestNacosConfigMgr_LoadFromNacos_Dotenv_Error(t *testing.T) {
345 | 	Convey("Should return error from GetConfig", t, func() {
346 | 		ctrl := gomock.NewController(t)
347 | 		defer ctrl.Finish()
348 | 		dataId := ".env"
349 | 		configClient := mock.NewMockIConfigClient(ctrl)
350 | 		configClient.
351 | 			EXPECT().
352 | 			GetConfig(vo.ConfigParam{
353 | 				DataId: dataId,
354 | 				Group:  config.DefaultGddNacosConfigGroup,
355 | 			}).
356 | 			AnyTimes().
357 | 			Return("", errors.New("mock error from GetConfig"))
358 | 
359 | 		configClient.
360 | 			EXPECT().
361 | 			ListenConfig(gomock.Any()).
362 | 			AnyTimes().
363 | 			Return(nil)
364 | 
365 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
366 | 			return configClient, nil
367 | 		}
368 | 
369 | 		if configmgr.NacosClient != nil {
370 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
371 | 				config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
372 | 		}
373 | 
374 | 		err := configmgr.LoadFromNacos(config.GetNacosClientParam(), dataId, string(configmgr.DotenvConfigFormat), config.DefaultGddNacosConfigGroup)
375 | 		So(err, ShouldNotBeNil)
376 | 	})
377 | }
378 | 
379 | func TestNacosConfigMgr_LoadFromNacos_Dotenv_Error2(t *testing.T) {
380 | 	Convey("Should return error from GetConfig", t, func() {
381 | 		ctrl := gomock.NewController(t)
382 | 		defer ctrl.Finish()
383 | 		dataId := ".env"
384 | 		configClient := mock.NewMockIConfigClient(ctrl)
385 | 		configClient.
386 | 			EXPECT().
387 | 			GetConfig(vo.ConfigParam{
388 | 				DataId: dataId,
389 | 				Group:  config.DefaultGddNacosConfigGroup,
390 | 			}).
391 | 			AnyTimes().
392 | 			Return("GDD_SERVICE_NAME=configmgr\n\nGDD_READ_TIMEOUT=60s\nGDD_WRITE_TIMEOUT=60s\nGDD_IDLE_TIMEOUT=120s", nil)
393 | 
394 | 		configClient.
395 | 			EXPECT().
396 | 			ListenConfig(gomock.Any()).
397 | 			AnyTimes().
398 | 			Return(nil)
399 | 
400 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
401 | 			return configClient, nil
402 | 		}
403 | 
404 | 		if configmgr.NacosClient != nil {
405 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
406 | 				config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
407 | 		}
408 | 
409 | 		configmgr.StringReader = func(s string) io.Reader {
410 | 			return ErrReader(errors.New("mock read error"))
411 | 		}
412 | 
413 | 		err := configmgr.LoadFromNacos(config.GetNacosClientParam(), dataId, string(configmgr.DotenvConfigFormat), config.DefaultGddNacosConfigGroup)
414 | 		So(err, ShouldNotBeNil)
415 | 	})
416 | }
417 | 
418 | func TestNacosConfigMgr_InitialiseNacosConfig(t *testing.T) {
419 | 	Convey("Should panic", t, func() {
420 | 		dataId := ".env"
421 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
422 | 			return nil, errors.New("mock error from NewConfigClient")
423 | 		}
424 | 		So(func() {
425 | 			configmgr.InitialiseNacosConfig(config.GetNacosClientParam(), dataId, string(config.DefaultGddNacosConfigFormat), config.DefaultGddNacosConfigGroup)
426 | 		}, ShouldPanic)
427 | 	})
428 | }
```

framework/database/cacheradapter.go
```
1 | package database
2 | 
3 | import (
4 | 	"context"
5 | 	"github.com/unionj-cloud/toolkit/zlogger"
6 | 
7 | 	"github.com/pkg/errors"
8 | 	"github.com/unionj-cloud/toolkit/caches"
9 | 	"github.com/unionj-cloud/toolkit/gocache/lib/cache"
10 | 	"github.com/unionj-cloud/toolkit/gocache/lib/store"
11 | )
12 | 
13 | var _ caches.Cacher = (*CacherAdapter)(nil)
14 | 
15 | type CacherAdapterConfig struct {
16 | 	MarshalerConfig
17 | }
18 | 
19 | type CacherAdapter struct {
20 | 	marshaler *Marshaler
21 | 	conf      CacherAdapterConfig
22 | }
23 | 
24 | func (c *CacherAdapter) Delete(tag string, tags ...string) error {
25 | 	invalidateTags := []string{tag}
26 | 	invalidateTags = append(invalidateTags, tags...)
27 | 	if err := c.marshaler.Invalidate(context.Background(), store.WithInvalidateTags(invalidateTags)); err != nil {
28 | 		return errors.WithStack(err)
29 | 	}
30 | 	return nil
31 | }
32 | 
33 | func (c *CacherAdapter) Get(key string) *caches.Query {
34 | 	result := new(caches.Query)
35 | 	_, err := c.marshaler.Get(context.Background(), key, result)
36 | 	if err != nil {
37 | 		zlogger.Info().Msgf("Cache missing: key %s %s\n", key, err.Error())
38 | 		return nil
39 | 	}
40 | 	return result
41 | }
42 | 
43 | func (c *CacherAdapter) Store(key string, val *caches.Query) error {
44 | 	if err := c.marshaler.Set(context.Background(), key, val, store.WithTags(val.Tags)); err != nil {
45 | 		return errors.WithStack(err)
46 | 	}
47 | 	return nil
48 | }
49 | 
50 | func NewCacherAdapter(cacheManager cache.CacheInterface[any], config CacherAdapterConfig) *CacherAdapter {
51 | 	return &CacherAdapter{
52 | 		marshaler: NewMarshaler(cacheManager, config.MarshalerConfig),
53 | 	}
54 | }
```

framework/database/database.go
```
1 | package database
2 | 
3 | import (
4 | 	"log"
5 | 	"os"
6 | 	"strings"
7 | 	"time"
8 | 
9 | 	gocache "github.com/unionj-cloud/toolkit/gocache/lib/cache"
10 | 	"github.com/wubin1989/clickhouse"
11 | 	"github.com/wubin1989/sqlite"
12 | 	"github.com/wubin1989/sqlserver"
13 | 
14 | 	"github.com/wubin1989/gorm"
15 | 	"github.com/wubin1989/gorm/logger"
16 | 	"github.com/wubin1989/gorm/schema"
17 | 	"github.com/wubin1989/mysql"
18 | 	"github.com/wubin1989/postgres"
19 | 	"github.com/wubin1989/prometheus"
20 | 
21 | 	"github.com/unionj-cloud/go-doudou/v2/framework/cache"
22 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
23 | 	"github.com/unionj-cloud/toolkit/caches"
24 | 	"github.com/unionj-cloud/toolkit/cast"
25 | 	"github.com/unionj-cloud/toolkit/errorx"
26 | 	"github.com/unionj-cloud/toolkit/stringutils"
27 | 	"github.com/unionj-cloud/toolkit/zlogger"
28 | 	"github.com/wubin1989/gorm-dameng"
29 | )
30 | 
31 | const (
32 | 	DriverMysql      = "mysql"
33 | 	DriverPostgres   = "postgres"
34 | 	DriverSqlite     = "sqlite"
35 | 	DriverSqlserver  = "sqlserver"
36 | 	DriverTidb       = "tidb"
37 | 	DriverClickhouse = "clickhouse"
38 | 	DriverDm         = "dm"
39 | )
40 | 
41 | var Db *gorm.DB
42 | 
43 | func init() {
44 | 	if cast.ToBoolOrDefault(config.GddDBDisableAutoConfigure.Load(), config.DefaultGddDBDisableAutoConfigure) {
45 | 		return
46 | 	}
47 | 	slowThreshold, err := time.ParseDuration(config.GddDBLogSlowThreshold.Load())
48 | 	if err != nil {
49 | 		zlogger.Debug().Msgf("Parse %s %s as time.Duration failed: %s, use default %s instead.\n", string(config.GddDBLogSlowThreshold), config.GddDBLogSlowThreshold.Load(), err.Error(), config.DefaultGddDBLogSlowThreshold)
50 | 		slowThreshold, _ = time.ParseDuration(config.DefaultGddDBLogSlowThreshold)
51 | 	}
52 | 	logLevel := config.DefaultGddDBLogLevel
53 | 	if stringutils.IsNotEmpty(config.GddDBLogLevel.Load()) {
54 | 		switch strings.ToLower(config.GddDBLogLevel.Load()) {
55 | 		case "silent":
56 | 			logLevel = logger.Silent
57 | 		case "error":
58 | 			logLevel = logger.Error
59 | 		case "warn":
60 | 			logLevel = logger.Warn
61 | 		case "info":
62 | 			logLevel = logger.Info
63 | 		}
64 | 	}
65 | 	newLogger := logger.New(
66 | 		log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
67 | 		logger.Config{
68 | 			SlowThreshold:             slowThreshold,
69 | 			LogLevel:                  logLevel,
70 | 			IgnoreRecordNotFoundError: cast.ToBoolOrDefault(config.GddDBLogIgnoreRecordNotFoundError.Load(), config.DefaultGddDBLogIgnoreRecordNotFoundError),
71 | 			ParameterizedQueries:      cast.ToBoolOrDefault(config.GddDBLogParameterizedQueries.Load(), config.DefaultGddDBLogParameterizedQueries),
72 | 			Colorful:                  false,
73 | 		},
74 | 	)
75 | 	gormConf := &gorm.Config{
76 | 		PrepareStmt:                              cast.ToBoolOrDefault(config.GddDBPrepareStmt.Load(), config.DefaultGddDBPrepareStmt),
77 | 		Logger:                                   newLogger,
78 | 		DisableForeignKeyConstraintWhenMigrating: true,
79 | 		SkipDefaultTransaction:                   cast.ToBoolOrDefault(config.GddDBSkipDefaultTransaction.Load(), config.DefaultGddDBSkipDefaultTransaction),
80 | 	}
81 | 	tablePrefix := strings.TrimSuffix(config.GddDBTablePrefix.LoadOrDefault(config.DefaultGddDBTablePrefix), ".")
82 | 	if stringutils.IsNotEmpty(tablePrefix) {
83 | 		gormConf.NamingStrategy = schema.NamingStrategy{
84 | 			TablePrefix: tablePrefix + ".",
85 | 		}
86 | 	}
87 | 	dsn := config.GddDBDsn.Load()
88 | 	if stringutils.IsEmpty(dsn) {
89 | 		return
90 | 	}
91 | 	driver := config.GddDBDriver.Load()
92 | 	if stringutils.IsEmpty(driver) {
93 | 		errorx.Panic("Database driver is missing")
94 | 	}
95 | 	switch driver {
96 | 	case DriverMysql, DriverTidb:
97 | 		conf := mysql.Config{
98 | 			DSN:                           dsn, // data source name
99 | 			SkipInitializeWithVersion:     cast.ToBoolOrDefault(config.GddDBMysqlSkipInitializeWithVersion.Load(), config.DefaultGddDBMysqlSkipInitializeWithVersion),
100 | 			DefaultStringSize:             uint(cast.ToIntOrDefault(config.GddDBMysqlDefaultStringSize.Load(), config.DefaultGddDBMysqlDefaultStringSize)),
101 | 			DisableWithReturning:          cast.ToBoolOrDefault(config.GddDBMysqlDisableWithReturning.Load(), config.DefaultGddDBMysqlDisableWithReturning),
102 | 			DisableDatetimePrecision:      cast.ToBoolOrDefault(config.GddDBMysqlDisableDatetimePrecision.Load(), config.DefaultGddDBMysqlDisableDatetimePrecision),
103 | 			DontSupportRenameIndex:        cast.ToBoolOrDefault(config.GddDBMysqlDontSupportRenameIndex.Load(), config.DefaultGddDBMysqlDontSupportRenameIndex),
104 | 			DontSupportRenameColumn:       cast.ToBoolOrDefault(config.GddDBMysqlDontSupportRenameColumn.Load(), config.DefaultGddDBMysqlDontSupportRenameColumn),
105 | 			DontSupportForShareClause:     cast.ToBoolOrDefault(config.GddDBMysqlDontSupportForShareClause.Load(), config.DefaultGddDBMysqlDontSupportForShareClause),
106 | 			DontSupportNullAsDefaultValue: cast.ToBoolOrDefault(config.GddDBMysqlDontSupportNullAsDefaultValue.Load(), config.DefaultGddDBMysqlDontSupportNullAsDefaultValue),
107 | 			DontSupportRenameColumnUnique: cast.ToBoolOrDefault(config.GddDBMysqlDontSupportRenameColumnUnique.Load(), config.DefaultGddDBMysqlDontSupportRenameColumnUnique),
108 | 		}
109 | 		Db, err = gorm.Open(mysql.New(conf), gormConf)
110 | 	case DriverPostgres:
111 | 		conf := postgres.Config{
112 | 			DSN:                  dsn,
113 | 			PreferSimpleProtocol: cast.ToBoolOrDefault(config.GddDBPostgresPreferSimpleProtocol.Load(), config.DefaultGddDBPostgresPreferSimpleProtocol),
114 | 			WithoutReturning:     cast.ToBoolOrDefault(config.GddDBPostgresWithoutReturning.Load(), config.DefaultGddDBPostgresWithoutReturning),
115 | 		}
116 | 		Db, err = gorm.Open(postgres.New(conf), gormConf)
117 | 	case DriverSqlite:
118 | 		Db, err = gorm.Open(sqlite.Open(dsn), gormConf)
119 | 	case DriverSqlserver:
120 | 		Db, err = gorm.Open(sqlserver.Open(dsn), gormConf)
121 | 	case DriverClickhouse:
122 | 		Db, err = gorm.Open(clickhouse.Open(dsn), gormConf)
123 | 	case DriverDm:
124 | 		Db, err = gorm.Open(dameng.Open(dsn), gormConf)
125 | 	default:
126 | 		errorx.Panic("Not support driver")
127 | 	}
128 | 	if err != nil {
129 | 		errorx.Panic(err.Error())
130 | 	}
131 | 	sqlDB, err := Db.DB()
132 | 	if err != nil {
133 | 		errorx.Panic(err.Error())
134 | 	}
135 | 	// SetMaxIdleConns sets the maximum number of connections in the idle connection pool.
136 | 	sqlDB.SetMaxIdleConns(cast.ToIntOrDefault(config.GddDBMaxIdleConns.Load(), config.DefaultGddDBMaxIdleConns))
137 | 
138 | 	// SetMaxOpenConns sets the maximum number of open connections to the database.
139 | 	sqlDB.SetMaxOpenConns(cast.ToIntOrDefault(config.GddDBMaxOpenConns.Load(), config.DefaultGddDBMaxOpenConns))
140 | 
141 | 	maxLifetime, err := time.ParseDuration(config.GddDBConnMaxLifetime.Load())
142 | 	if err != nil {
143 | 		zlogger.Debug().Msgf("Parse %s %s as time.Duration failed: %s, use default %d instead.\n", string(config.GddDBConnMaxLifetime), config.GddDBConnMaxLifetime.Load(), err.Error(), config.DefaultGddDBConnMaxLifetime)
144 | 		maxLifetime = config.DefaultGddDBConnMaxLifetime
145 | 	}
146 | 	// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
147 | 	sqlDB.SetConnMaxLifetime(maxLifetime)
148 | 
149 | 	maxIdleTime, err := time.ParseDuration(config.GddDBConnMaxIdleTime.Load())
150 | 	if err != nil {
151 | 		zlogger.Debug().Msgf("Parse %s %s as time.Duration failed: %s, use default %d instead.\n", string(config.GddDBConnMaxIdleTime), config.GddDBConnMaxIdleTime.Load(), err.Error(), config.DefaultGddDBConnMaxIdleTime)
152 | 		maxIdleTime = config.DefaultGddDBConnMaxIdleTime
153 | 	}
154 | 	sqlDB.SetConnMaxIdleTime(maxIdleTime)
155 | 	if cast.ToBoolOrDefault(config.GddDbPrometheusEnable.Load(), config.DefaultGddDbPrometheusEnable) &&
156 | 		stringutils.IsNotEmpty(config.GddDbPrometheusDBName.LoadOrDefault(config.DefaultGddDbPrometheusDBName)) {
157 | 		var collectors []prometheus.MetricsCollector
158 | 		switch driver {
159 | 		case DriverMysql, DriverTidb:
160 | 			collectors = append(collectors, &prometheus.MySQL{})
161 | 		case DriverPostgres:
162 | 			collectors = append(collectors, &prometheus.Postgres{})
163 | 		}
164 | 		ConfigureMetrics(Db, config.GddDbPrometheusDBName.LoadOrDefault(config.DefaultGddDbPrometheusDBName),
165 | 			cast.ToUInt32OrDefault(config.GddDbPrometheusRefreshInterval.Load(), config.DefaultGddDbPrometheusRefreshInterval),
166 | 			nil, collectors...)
167 | 	}
168 | 	if cast.ToBoolOrDefault(config.GddDbCacheEnable.Load(), config.DefaultGddDbCacheEnable) && cache.CacheManager != nil {
169 | 		ConfigureDBCache(Db, cache.CacheManager, CacherAdapterConfig{})
170 | 	}
171 | }
172 | 
173 | func NewDb(conf config.Config) (db *gorm.DB) {
174 | 	slowThreshold, err := time.ParseDuration(conf.Db.Log.SlowThreshold)
175 | 	if err != nil {
176 | 		errorx.Panic(err.Error())
177 | 	}
178 | 	logLevel := logger.Warn
179 | 	if stringutils.IsNotEmpty(conf.Db.Log.Level) {
180 | 		switch strings.ToLower(conf.Db.Log.Level) {
181 | 		case "silent":
182 | 			logLevel = logger.Silent
183 | 		case "error":
184 | 			logLevel = logger.Error
185 | 		case "warn":
186 | 			logLevel = logger.Warn
187 | 		case "info":
188 | 			logLevel = logger.Info
189 | 		}
190 | 	}
191 | 	newLogger := logger.New(
192 | 		log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
193 | 		logger.Config{
194 | 			SlowThreshold:             slowThreshold,
195 | 			LogLevel:                  logLevel,
196 | 			IgnoreRecordNotFoundError: conf.Db.Log.IgnoreRecordNotFoundError,
197 | 			ParameterizedQueries:      conf.Db.Log.ParameterizedQueries,
198 | 			Colorful:                  false,
199 | 		},
200 | 	)
201 | 	gormConf := &gorm.Config{
202 | 		PrepareStmt:                              conf.Db.PrepareStmt,
203 | 		Logger:                                   newLogger,
204 | 		DisableForeignKeyConstraintWhenMigrating: true,
205 | 		SkipDefaultTransaction:                   conf.Db.SkipDefaultTransaction,
206 | 		DisableNestedTransaction:                 conf.Db.DisableNestedTransaction,
207 | 	}
208 | 	tablePrefix := strings.TrimSuffix(conf.Db.Table.Prefix, ".")
209 | 	if stringutils.IsNotEmpty(tablePrefix) {
210 | 		gormConf.NamingStrategy = schema.NamingStrategy{
211 | 			TablePrefix: tablePrefix + ".",
212 | 		}
213 | 	}
214 | 	dsn := conf.Db.Dsn
215 | 	if stringutils.IsEmpty(dsn) {
216 | 		return
217 | 	}
218 | 	driver := conf.Db.Driver
219 | 	if stringutils.IsEmpty(driver) {
220 | 		errorx.Panic("Database driver is missing")
221 | 	}
222 | 	switch driver {
223 | 	case DriverMysql, DriverTidb:
224 | 		conf := mysql.Config{
225 | 			DSN:                           dsn, // data source name
226 | 			SkipInitializeWithVersion:     conf.Db.Mysql.SkipInitializeWithVersion,
227 | 			DefaultStringSize:             uint(conf.Db.Mysql.DefaultStringSize),
228 | 			DisableWithReturning:          conf.Db.Mysql.DisableWithReturning,
229 | 			DisableDatetimePrecision:      conf.Db.Mysql.DisableDatetimePrecision,
230 | 			DontSupportRenameIndex:        conf.Db.Mysql.DontSupportRenameIndex,
231 | 			DontSupportRenameColumn:       conf.Db.Mysql.DontSupportRenameColumn,
232 | 			DontSupportForShareClause:     conf.Db.Mysql.DontSupportForShareClause,
233 | 			DontSupportNullAsDefaultValue: conf.Db.Mysql.DontSupportNullAsDefaultValue,
234 | 			DontSupportRenameColumnUnique: conf.Db.Mysql.DontSupportRenameColumnUnique,
235 | 		}
236 | 		db, err = gorm.Open(mysql.New(conf), gormConf)
237 | 	case DriverPostgres:
238 | 		conf := postgres.Config{
239 | 			DSN:                  dsn,
240 | 			PreferSimpleProtocol: conf.Db.Postgres.PreferSimpleProtocol,
241 | 			WithoutReturning:     conf.Db.Postgres.WithoutReturning,
242 | 			WithoutQuotingCheck:  conf.Db.Postgres.WithoutQuotingCheck,
243 | 		}
244 | 		db, err = gorm.Open(postgres.New(conf), gormConf)
245 | 	case DriverSqlite:
246 | 		db, err = gorm.Open(sqlite.Open(dsn), gormConf)
247 | 	case DriverSqlserver:
248 | 		db, err = gorm.Open(sqlserver.Open(dsn), gormConf)
249 | 	case DriverClickhouse:
250 | 		db, err = gorm.Open(clickhouse.Open(dsn), gormConf)
251 | 	case DriverDm:
252 | 		db, err = gorm.Open(dameng.Open(dsn), gormConf)
253 | 	default:
254 | 		errorx.Panic("Not support driver")
255 | 	}
256 | 	if err != nil {
257 | 		errorx.Panic(err.Error())
258 | 	}
259 | 	sqlDB, err := db.DB()
260 | 	if err != nil {
261 | 		errorx.Panic(err.Error())
262 | 	}
263 | 	// SetMaxIdleConns sets the maximum number of connections in the idle connection pool.
264 | 	sqlDB.SetMaxIdleConns(conf.Db.Pool.MaxIdleConns)
265 | 
266 | 	// SetMaxOpenConns sets the maximum number of open connections to the database.
267 | 	sqlDB.SetMaxOpenConns(conf.Db.Pool.MaxOpenConns)
268 | 
269 | 	maxLifetime := time.Duration(-1)
270 | 	if stringutils.IsNotEmpty(conf.Db.Pool.ConnMaxLifetime) {
271 | 		if value, err := time.ParseDuration(conf.Db.Pool.ConnMaxLifetime); err == nil {
272 | 			maxLifetime = value
273 | 		} else {
274 | 			zlogger.Error().Err(err).Msg(err.Error())
275 | 		}
276 | 	}
277 | 	// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
278 | 	sqlDB.SetConnMaxLifetime(maxLifetime)
279 | 
280 | 	maxIdleTime := time.Duration(-1)
281 | 	if stringutils.IsNotEmpty(conf.Db.Pool.ConnMaxIdleTime) {
282 | 		if value, err := time.ParseDuration(conf.Db.Pool.ConnMaxIdleTime); err == nil {
283 | 			maxIdleTime = value
284 | 		} else {
285 | 			zlogger.Error().Err(err).Msg(err.Error())
286 | 		}
287 | 	}
288 | 	sqlDB.SetConnMaxIdleTime(maxIdleTime)
289 | 
290 | 	if conf.Db.Prometheus.Enable &&
291 | 		stringutils.IsNotEmpty(conf.Db.Prometheus.DBName) {
292 | 		var collectors []prometheus.MetricsCollector
293 | 		switch driver {
294 | 		case DriverMysql, DriverTidb:
295 | 			collectors = append(collectors, &prometheus.MySQL{})
296 | 		case DriverPostgres:
297 | 			collectors = append(collectors, &prometheus.Postgres{})
298 | 		}
299 | 		ConfigureMetrics(db, conf.Db.Prometheus.DBName, uint32(conf.Db.Prometheus.RefreshInterval),
300 | 			nil, collectors...)
301 | 	}
302 | 	if conf.Db.Cache.Enable && stringutils.IsNotEmpty(conf.Cache.Stores) && !conf.Db.Cache.ManualConfigure {
303 | 		cacherAdapterConfig := CacherAdapterConfig{
304 | 			MarshalerConfig: MarshalerConfig{
305 | 				CompactMap: conf.Db.Cache.CompactMap,
306 | 			},
307 | 		}
308 | 		ConfigureDBCache(db, cache.NewCacheManager(conf), cacherAdapterConfig)
309 | 	}
310 | 	return
311 | }
312 | 
313 | func ConfigureMetrics(db *gorm.DB, dbName string, refreshInterval uint32, labels map[string]string, collectors ...prometheus.MetricsCollector) {
314 | 	db.Use(prometheus.New(prometheus.Config{
315 | 		DBName:           dbName,          // `DBName` as metrics label
316 | 		RefreshInterval:  refreshInterval, // refresh metrics interval (default 15 seconds)
317 | 		MetricsCollector: collectors,
318 | 		Labels:           labels,
319 | 	}))
320 | }
321 | 
322 | func ConfigureDBCache(db *gorm.DB, cacheManager gocache.CacheInterface[any], conf CacherAdapterConfig) {
323 | 	db.Use(&caches.Caches{Conf: &caches.Config{
324 | 		Easer:  true,
325 | 		Cacher: NewCacherAdapter(cacheManager, conf),
326 | 	}})
327 | }
```

framework/database/marshaler.go
```
1 | package database
2 | 
3 | import (
4 | 	"bytes"
5 | 	"context"
6 | 	"fmt"
7 | 	"github.com/bytedance/sonic/decoder"
8 | 	"github.com/pkg/errors"
9 | 	"reflect"
10 | 
11 | 	"github.com/bytedance/sonic"
12 | 	"github.com/lithammer/shortuuid/v4"
13 | 	"github.com/samber/lo"
14 | 	"github.com/spf13/cast"
15 | 	"github.com/unionj-cloud/toolkit/caches"
16 | 	"github.com/unionj-cloud/toolkit/gocache/lib/cache"
17 | 	"github.com/unionj-cloud/toolkit/gocache/lib/store"
18 | 	"github.com/unionj-cloud/toolkit/reflectutils"
19 | )
20 | 
21 | var json = sonic.ConfigDefault
22 | 
23 | type MarshalerConfig struct {
24 | 	CompactMap bool
25 | }
26 | 
27 | // Marshaler is the struct that marshal and unmarshal cache values
28 | type Marshaler struct {
29 | 	cache cache.CacheInterface[any]
30 | 	conf  MarshalerConfig
31 | }
32 | 
33 | // NewMarshaler creates a new marshaler that marshals/unmarshals cache values
34 | func NewMarshaler(cache cache.CacheInterface[any], config MarshalerConfig) *Marshaler {
35 | 	return &Marshaler{
36 | 		cache: cache,
37 | 		conf:  config,
38 | 	}
39 | }
40 | 
41 | type idecoder interface {
42 | 	UseInt64()
43 | 	Decode(val interface{}) (err error)
44 | }
45 | 
46 | // Get obtains a value from cache and unmarshal value with given object
47 | func (c *Marshaler) Get(ctx context.Context, key any, returnObj any) (any, error) {
48 | 	key = c.shortenKey(key)
49 | 	result, err := c.cache.Get(ctx, key)
50 | 	if err != nil {
51 | 		return nil, errors.WithStack(err)
52 | 	}
53 | 
54 | 	var dec idecoder
55 | 	switch v := result.(type) {
56 | 	case []byte:
57 | 		dec = decoder.NewStreamDecoder(bytes.NewBuffer(v))
58 | 	case string:
59 | 		dec = decoder.NewDecoder(v)
60 | 	}
61 | 
62 | 	dec.UseInt64()
63 | 	if err = dec.Decode(returnObj); err != nil {
64 | 		return nil, errors.WithStack(err)
65 | 	}
66 | 
67 | 	return returnObj, nil
68 | }
69 | 
70 | // Set sets a value in cache by marshaling value
71 | func (c *Marshaler) Set(ctx context.Context, key, object any, options ...store.Option) error {
72 | 	key = c.shortenKey(key)
73 | 	query := object.(*caches.Query)
74 | 
75 | 	if c.conf.CompactMap {
76 | 		source := reflectutils.ValueOf(query.Dest).Interface()
77 | 		t := fmt.Sprintf("%T", source)
78 | 		if t == "map[string]interface {}" {
79 | 			compactMap := lo.OmitBy[string, interface{}](source.(map[string]interface{}), func(key string, value interface{}) bool {
80 | 				return value == nil || reflect.ValueOf(value).IsZero()
81 | 			})
82 | 			query.Dest = compactMap
83 | 		} else if t == "[]map[string]interface {}" {
84 | 			rows := source.([]map[string]interface{})
85 | 			_rows := make([]map[string]interface{}, len(rows))
86 | 			lo.ForEach[map[string]interface{}](rows, func(item map[string]interface{}, index int) {
87 | 				compactMap := lo.OmitBy[string, interface{}](item, func(key string, value interface{}) bool {
88 | 					return value == nil || reflect.ValueOf(value).IsZero()
89 | 				})
90 | 				_rows[index] = compactMap
91 | 			})
92 | 			query.Dest = _rows
93 | 		}
94 | 	}
95 | 
96 | 	bytes, err := json.Marshal(query)
97 | 	if err != nil {
98 | 		return err
99 | 	}
100 | 
101 | 	return c.cache.Set(ctx, key, bytes, options...)
102 | }
103 | 
104 | // Delete removes a value from the cache
105 | func (c *Marshaler) Delete(ctx context.Context, key any) error {
106 | 	key = c.shortenKey(key)
107 | 	return c.cache.Delete(ctx, key)
108 | }
109 | 
110 | // Invalidate invalidate cache values using given options
111 | func (c *Marshaler) Invalidate(ctx context.Context, options ...store.InvalidateOption) error {
112 | 	return c.cache.Invalidate(ctx, options...)
113 | }
114 | 
115 | // Clear reset all cache data
116 | func (c *Marshaler) Clear(ctx context.Context) error {
117 | 	return c.cache.Clear(ctx)
118 | }
119 | 
120 | func (c *Marshaler) shortenKey(key any) string {
121 | 	_key := cast.ToString(key)
122 | 	if len(_key) > 1000 {
123 | 		return shortuuid.NewWithNamespace(_key)
124 | 	}
125 | 	return _key
126 | }
```

framework/grpcx/server.go
```
1 | package grpcx
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"net"
7 | 	"os"
8 | 	"os/signal"
9 | 	"strings"
10 | 	"sync"
11 | 	"time"
12 | 
13 | 	"github.com/olekukonko/tablewriter"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework"
15 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
16 | 	register "github.com/unionj-cloud/go-doudou/v2/framework/registry"
17 | 	"github.com/unionj-cloud/toolkit/timeutils"
18 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
19 | 	"google.golang.org/grpc"
20 | 	"google.golang.org/grpc/reflection"
21 | )
22 | 
23 | var startAt time.Time
24 | var reflectionRegisterOnce sync.Once
25 | 
26 | func init() {
27 | 	startAt = time.Now()
28 | }
29 | 
30 | type GrpcServer struct {
31 | 	*grpc.Server
32 | 	data map[string]interface{}
33 | }
34 | 
35 | func NewGrpcServer(opt ...grpc.ServerOption) *GrpcServer {
36 | 	return &GrpcServer{
37 | 		Server: grpc.NewServer(opt...),
38 | 	}
39 | }
40 | 
41 | func NewEmptyGrpcServer() *GrpcServer {
42 | 	return &GrpcServer{}
43 | }
44 | 
45 | func NewGrpcServerWithData(data map[string]interface{}, opt ...grpc.ServerOption) *GrpcServer {
46 | 	server := GrpcServer{
47 | 		data: data,
48 | 	}
49 | 	server.Server = grpc.NewServer(opt...)
50 | 	return &server
51 | }
52 | 
53 | func (srv *GrpcServer) printServices() {
54 | 	if !config.CheckDev() {
55 | 		return
56 | 	}
57 | 	logger.Info().Msg("================ Registered Services ================")
58 | 	data := [][]string{}
59 | 	for k, v := range srv.GetServiceInfo() {
60 | 		for i, method := range v.Methods {
61 | 			if i == 0 {
62 | 				data = append(data, []string{k, method.Name})
63 | 			} else {
64 | 				data = append(data, []string{"", method.Name})
65 | 			}
66 | 		}
67 | 	}
68 | 
69 | 	tableString := &strings.Builder{}
70 | 	table := tablewriter.NewWriter(tableString)
71 | 	table.SetHeader([]string{"SERVICE", "RPC"})
72 | 	for _, v := range data {
73 | 		table.Append(v)
74 | 	}
75 | 	table.Render() // Send output
76 | 	rows := strings.Split(strings.TrimSpace(tableString.String()), "\n")
77 | 	for _, row := range rows {
78 | 		logger.Info().Msg(row)
79 | 	}
80 | 	logger.Info().Msg("===================================================")
81 | }
82 | 
83 | // Run runs grpc server
84 | func (srv *GrpcServer) Run() {
85 | 	srv.RunWithPipe(nil)
86 | }
87 | 
88 | // RunWithPipe runs grpc server
89 | func (srv *GrpcServer) RunWithPipe(pipe net.Listener) {
90 | 	ln, err := net.Listen("tcp", fmt.Sprintf(":%s", config.GddConfig.Grpc.Port))
91 | 	if err != nil {
92 | 		logger.Panic().Msgf("failed to listen: %v", err)
93 | 	}
94 | 	srv.ServeWithPipe(ln, pipe)
95 | 	defer func() {
96 | 		logger.Info().Msgf("Grpc server is gracefully shutting down in %s", config.GddConfig.GraceTimeout)
97 | 		// Make sure to set a deadline on exiting the process
98 | 		// after upg.Exit() is closed. No new upgrades can be
99 | 		// performed if the parent doesn't exit.
100 | 		time.AfterFunc(config.GddConfig.GraceTimeout, func() {
101 | 			logger.Error().Msg("Graceful shutdown timed out")
102 | 			config.Shutdown()
103 | 			os.Exit(1)
104 | 		})
105 | 		register.ShutdownGrpc()
106 | 		if err := timeutils.CallWithCtx(context.Background(), func() struct{} {
107 | 			srv.GracefulStop()
108 | 			return struct{}{}
109 | 		}); err != nil {
110 | 			logger.Error().Err(err).Msg("")
111 | 		}
112 | 	}()
113 | 
114 | 	c := make(chan os.Signal, 1)
115 | 	// We'll accept graceful shutdowns when quit via SIGINT (Ctrl+C)
116 | 	// SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.
117 | 	signal.Notify(c, os.Interrupt)
118 | 
119 | 	// Block until we receive our signal.
120 | 	<-c
121 | }
122 | 
123 | func (srv *GrpcServer) Serve(ln net.Listener) {
124 | 	srv.ServeWithPipe(ln, nil)
125 | }
126 | 
127 | func (srv *GrpcServer) ServeWithPipe(ln net.Listener, pipe net.Listener) {
128 | 	if srv.Server == nil {
129 | 		return
130 | 	}
131 | 	framework.PrintBanner()
132 | 	framework.PrintLock.Lock()
133 | 	register.NewGrpc(srv.data)
134 | 	reflection.Register(srv)
135 | 	srv.printServices()
136 | 	go func() {
137 | 		if err := srv.Server.Serve(ln); err != nil {
138 | 			logger.Error().Msgf("failed to serve: %v", err)
139 | 		}
140 | 	}()
141 | 	if pipe != nil {
142 | 		go func() {
143 | 			if err := srv.Server.Serve(pipe); err != nil {
144 | 				logger.Error().Msgf("failed to serve: %v", err)
145 | 			}
146 | 		}()
147 | 	}
148 | 	logger.Info().Msgf("Grpc server is listening at %v", ln.Addr())
149 | 	logger.Info().Msgf("Grpc server started in %s", time.Since(startAt))
150 | 	framework.PrintLock.Unlock()
151 | }
```

framework/logger/configure.go
```
1 | package logger
2 | 
3 | import (
4 | 	"io"
5 | 
6 | 	"github.com/mattn/go-colorable"
7 | 	"github.com/sirupsen/logrus"
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
9 | 	"github.com/unionj-cloud/toolkit/stringutils"
10 | )
11 | 
12 | type LoggerOption func(*logrus.Logger)
13 | 
14 | func WithWritter(writer io.Writer) LoggerOption {
15 | 	return func(log *logrus.Logger) {
16 | 		log.SetOutput(writer)
17 | 	}
18 | }
19 | 
20 | func WithFormatter(formatter logrus.Formatter) LoggerOption {
21 | 	return func(log *logrus.Logger) {
22 | 		log.SetFormatter(formatter)
23 | 	}
24 | }
25 | 
26 | func WithReportCaller(reportCaller bool) LoggerOption {
27 | 	return func(log *logrus.Logger) {
28 | 		log.SetReportCaller(reportCaller)
29 | 	}
30 | }
31 | 
32 | func defaultFormatter() logrus.Formatter {
33 | 	format := config.DefaultGddLogFormat
34 | 	if stringutils.IsNotEmpty(config.GddLogFormat.Load()) {
35 | 		format = config.GddLogFormat.Load()
36 | 	}
37 | 	var formatter logrus.Formatter
38 | 	switch format {
39 | 	case "json":
40 | 		jf := new(logrus.JSONFormatter)
41 | 		jf.TimestampFormat = "2006-01-02 15:04:05"
42 | 		jf.DisableHTMLEscape = true
43 | 		formatter = jf
44 | 	case "text":
45 | 		tf := new(logrus.TextFormatter)
46 | 		tf.TimestampFormat = "2006-01-02 15:04:05"
47 | 		tf.FullTimestamp = true
48 | 		tf.ForceColors = true
49 | 		formatter = tf
50 | 	default:
51 | 	}
52 | 	return formatter
53 | }
54 | 
55 | // LogLevel alias for logrus.Level
56 | type LogLevel logrus.Level
57 | 
58 | // Decode decodes value to LogLevel
59 | func (ll *LogLevel) Decode(value string) error {
60 | 	//if stringutils.IsEmpty(value) {
61 | 	//	value = DefaultGddLogLevel
62 | 	//}
63 | 	switch value {
64 | 	case "panic":
65 | 		*ll = LogLevel(logrus.PanicLevel)
66 | 	case "fatal":
67 | 		*ll = LogLevel(logrus.FatalLevel)
68 | 	case "error":
69 | 		*ll = LogLevel(logrus.ErrorLevel)
70 | 	case "warn":
71 | 		*ll = LogLevel(logrus.WarnLevel)
72 | 	case "debug":
73 | 		*ll = LogLevel(logrus.DebugLevel)
74 | 	case "trace":
75 | 		*ll = LogLevel(logrus.TraceLevel)
76 | 	default:
77 | 		*ll = LogLevel(logrus.InfoLevel)
78 | 	}
79 | 	return nil
80 | }
81 | 
82 | func Init(opts ...LoggerOption) {
83 | 	var loglevel LogLevel
84 | 	(&loglevel).Decode(config.GddLogLevel.Load())
85 | 
86 | 	logger := logrus.StandardLogger()
87 | 	logger.SetFormatter(defaultFormatter())
88 | 	logger.SetLevel(logrus.Level(loglevel))
89 | 	logrus.SetOutput(colorable.NewColorableStdout())
90 | 
91 | 	for _, opt := range opts {
92 | 		opt(logger)
93 | 	}
94 | }
```

framework/logger/entry.go
```
1 | package logger
2 | 
3 | import (
4 | 	"context"
5 | 	"os"
6 | 	"runtime"
7 | 	"time"
8 | 
9 | 	"github.com/sirupsen/logrus"
10 | 	"github.com/unionj-cloud/go-doudou/v2/framework/buildinfo"
11 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
12 | 	"github.com/unionj-cloud/toolkit/constants"
13 | 	"github.com/unionj-cloud/toolkit/stringutils"
14 | )
15 | 
16 | var (
17 | 	entry = New()
18 | )
19 | 
20 | func Entry() *logrus.Entry {
21 | 	return entry
22 | }
23 | 
24 | func CheckDev() bool {
25 | 	return stringutils.IsEmpty(os.Getenv("GDD_ENV")) || os.Getenv("GDD_ENV") == "dev"
26 | }
27 | 
28 | // Deprecated: move to zerolog
29 | func New() *logrus.Entry {
30 | 	hostname, _ := os.Hostname()
31 | 	buildTime := buildinfo.BuildTime
32 | 	if stringutils.IsNotEmpty(buildinfo.BuildTime) {
33 | 		if t, err := time.Parse(constants.FORMAT15, buildinfo.BuildTime); err == nil {
34 | 			buildTime = t.Local().Format(constants.FORMAT8)
35 | 		}
36 | 	}
37 | 	if CheckDev() {
38 | 		return logrus.NewEntry(logrus.StandardLogger())
39 | 	}
40 | 	return logrus.StandardLogger().WithFields(logrus.Fields{
41 | 		"__meta_service":          config.GddServiceName,
42 | 		"__meta_hostname":         hostname,
43 | 		"__meta_go_version":       runtime.Version(),
44 | 		"__meta_godoudou_version": buildinfo.GddVer,
45 | 		"__meta_build_user":       buildinfo.BuildUser,
46 | 		"__meta_build_time":       buildTime,
47 | 	})
48 | }
49 | 
50 | // WithError creates an entry from the standard logger and adds an error to it, using the value defined in ErrorKey as key.
51 | func WithError(err error) *logrus.Entry {
52 | 	return entry.WithField(logrus.ErrorKey, err)
53 | }
54 | 
55 | // WithContext creates an entry from the standard logger and adds a context to it.
56 | func WithContext(ctx context.Context) *logrus.Entry {
57 | 	return entry.WithContext(ctx)
58 | }
59 | 
60 | // WithField creates an entry from the standard logger and adds a field to
61 | // it. If you want multiple fields, use `WithFields`.
62 | //
63 | // Note that it doesn't log until you call Debug, Print, Info, Warn, Fatal
64 | // or Panic on the Entry it returns.
65 | func WithField(key string, value interface{}) *logrus.Entry {
66 | 	return entry.WithField(key, value)
67 | }
68 | 
69 | // WithFields creates an entry from the standard logger and adds multiple
70 | // fields to it. This is simply a helper for `WithField`, invoking it
71 | // once for each field.
72 | //
73 | // Note that it doesn't log until you call Debug, Print, Info, Warn, Fatal
74 | // or Panic on the Entry it returns.
75 | func WithFields(fields logrus.Fields) *logrus.Entry {
76 | 	if CheckDev() {
77 | 		return entry
78 | 	}
79 | 	return entry.WithFields(fields)
80 | }
81 | 
82 | // WithTime creates an entry from the standard logger and overrides the time of
83 | // logs generated with it.
84 | //
85 | // Note that it doesn't log until you call Debug, Print, Info, Warn, Fatal
86 | // or Panic on the Entry it returns.
87 | func WithTime(t time.Time) *logrus.Entry {
88 | 	return entry.WithTime(t)
89 | }
90 | 
91 | // Trace logs a message at level Trace on the standard logger.
92 | func Trace(args ...interface{}) {
93 | 	entry.Trace(args...)
94 | }
95 | 
96 | // Debug logs a message at level Debug on the standard logger.
97 | func Debug(args ...interface{}) {
98 | 	entry.Debug(args...)
99 | }
100 | 
101 | // Print logs a message at level Info on the standard logger.
102 | func Print(args ...interface{}) {
103 | 	entry.Print(args...)
104 | }
105 | 
106 | // Info logs a message at level Info on the standard logger.
107 | func Info(args ...interface{}) {
108 | 	entry.Info(args...)
109 | }
110 | 
111 | // Warn logs a message at level Warn on the standard logger.
112 | func Warn(args ...interface{}) {
113 | 	entry.Warn(args...)
114 | }
115 | 
116 | // Warning logs a message at level Warn on the standard logger.
117 | func Warning(args ...interface{}) {
118 | 	entry.Warning(args...)
119 | }
120 | 
121 | // Error logs a message at level Error on the standard logger.
122 | func Error(args ...interface{}) {
123 | 	entry.Error(args...)
124 | }
125 | 
126 | // Panic logs a message at level Panic on the standard logger.
127 | func Panic(args ...interface{}) {
128 | 	entry.Panic(args...)
129 | }
130 | 
131 | // Fatal logs a message at level Fatal on the standard logger then the process will exit with status set to 1.
132 | func Fatal(args ...interface{}) {
133 | 	entry.Fatal(args...)
134 | }
135 | 
136 | // Tracef logs a message at level Trace on the standard logger.
137 | func Tracef(format string, args ...interface{}) {
138 | 	entry.Tracef(format, args...)
139 | }
140 | 
141 | // Debugf logs a message at level Debug on the standard logger.
142 | func Debugf(format string, args ...interface{}) {
143 | 	entry.Debugf(format, args...)
144 | }
145 | 
146 | // Printf logs a message at level Info on the standard logger.
147 | func Printf(format string, args ...interface{}) {
148 | 	entry.Printf(format, args...)
149 | }
150 | 
151 | // Infof logs a message at level Info on the standard logger.
152 | func Infof(format string, args ...interface{}) {
153 | 	entry.Infof(format, args...)
154 | }
155 | 
156 | // Warnf logs a message at level Warn on the standard logger.
157 | func Warnf(format string, args ...interface{}) {
158 | 	entry.Warnf(format, args...)
159 | }
160 | 
161 | // Warningf logs a message at level Warn on the standard logger.
162 | func Warningf(format string, args ...interface{}) {
163 | 	entry.Warningf(format, args...)
164 | }
165 | 
166 | // Errorf logs a message at level Error on the standard logger.
167 | func Errorf(format string, args ...interface{}) {
168 | 	entry.Errorf(format, args...)
169 | }
170 | 
171 | // Panicf logs a message at level Panic on the standard logger.
172 | func Panicf(format string, args ...interface{}) {
173 | 	entry.Panicf(format, args...)
174 | }
175 | 
176 | // Fatalf logs a message at level Fatal on the standard logger then the process will exit with status set to 1.
177 | func Fatalf(format string, args ...interface{}) {
178 | 	entry.Fatalf(format, args...)
179 | }
180 | 
181 | // Traceln logs a message at level Trace on the standard logger.
182 | func Traceln(args ...interface{}) {
183 | 	entry.Traceln(args...)
184 | }
185 | 
186 | // Debugln logs a message at level Debug on the standard logger.
187 | func Debugln(args ...interface{}) {
188 | 	entry.Debugln(args...)
189 | }
190 | 
191 | // Println logs a message at level Info on the standard logger.
192 | func Println(args ...interface{}) {
193 | 	entry.Println(args...)
194 | }
195 | 
196 | // Infoln logs a message at level Info on the standard logger.
197 | func Infoln(args ...interface{}) {
198 | 	entry.Infoln(args...)
199 | }
200 | 
201 | // Warnln logs a message at level Warn on the standard logger.
202 | func Warnln(args ...interface{}) {
203 | 	entry.Warnln(args...)
204 | }
205 | 
206 | // Warningln logs a message at level Warn on the standard logger.
207 | func Warningln(args ...interface{}) {
208 | 	entry.Warningln(args...)
209 | }
210 | 
211 | // Errorln logs a message at level Error on the standard logger.
212 | func Errorln(args ...interface{}) {
213 | 	entry.Errorln(args...)
214 | }
215 | 
216 | // Panicln logs a message at level Panic on the standard logger.
217 | func Panicln(args ...interface{}) {
218 | 	entry.Panicln(args...)
219 | }
220 | 
221 | // Fatalln logs a message at level Fatal on the standard logger then the process will exit with status set to 1.
222 | func Fatalln(args ...interface{}) {
223 | 	entry.Fatalln(args...)
224 | }
```

framework/plugin/plugin.go
```
1 | package plugin
2 | 
3 | import (
4 | 	"github.com/elliotchance/orderedmap/v2"
5 | 	"github.com/unionj-cloud/go-doudou/v2/framework/grpcx"
6 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
7 | 	"github.com/unionj-cloud/toolkit/pipeconn"
8 | )
9 | 
10 | var servicePlugins = orderedmap.NewOrderedMap[string, ServicePlugin]()
11 | 
12 | type ServicePlugin interface {
13 | 	Initialize(restServer *rest.RestServer, grpcServer *grpcx.GrpcServer, dialCtx pipeconn.DialContextFunc)
14 | 	GetName() string
15 | 	Close()
16 | 	GoDoudouServicePlugin()
17 | }
18 | 
19 | func RegisterServicePlugin(plugin ServicePlugin) {
20 | 	servicePlugins.Set(plugin.GetName(), plugin)
21 | }
22 | 
23 | func GetServicePlugins() *orderedmap.OrderedMap[string, ServicePlugin] {
24 | 	return servicePlugins
25 | }
```

framework/ratelimit/limit.go
```
1 | package ratelimit
2 | 
3 | import (
4 | 	"strconv"
5 | 	"strings"
6 | 	"time"
7 | 
8 | 	"github.com/pkg/errors"
9 | )
10 | 
11 | type Limit struct {
12 | 	Rate   float64
13 | 	Burst  int
14 | 	Period time.Duration
15 | }
16 | 
17 | type LimiterOption func(Limiter)
18 | 
19 | func PerSecond(rate float64) Limit {
20 | 	return Limit{
21 | 		Rate:   rate,
22 | 		Period: time.Second,
23 | 		Burst:  1,
24 | 	}
25 | }
26 | 
27 | func PerMinute(rate float64) Limit {
28 | 	return Limit{
29 | 		Rate:   rate,
30 | 		Period: time.Minute,
31 | 		Burst:  1,
32 | 	}
33 | }
34 | 
35 | func PerHour(rate float64) Limit {
36 | 	return Limit{
37 | 		Rate:   rate,
38 | 		Period: time.Hour,
39 | 		Burst:  1,
40 | 	}
41 | }
42 | 
43 | func PerDay(rate float64) Limit {
44 | 	return Limit{
45 | 		Rate:   rate,
46 | 		Period: time.Hour * 24,
47 | 		Burst:  1,
48 | 	}
49 | }
50 | 
51 | func PerSecondBurst(rate float64, burst int) Limit {
52 | 	return Limit{
53 | 		Rate:   rate,
54 | 		Period: time.Second,
55 | 		Burst:  burst,
56 | 	}
57 | }
58 | 
59 | func PerMinuteBurst(rate float64, burst int) Limit {
60 | 	return Limit{
61 | 		Rate:   rate,
62 | 		Period: time.Minute,
63 | 		Burst:  burst,
64 | 	}
65 | }
66 | 
67 | func PerHourBurst(rate float64, burst int) Limit {
68 | 	return Limit{
69 | 		Rate:   rate,
70 | 		Period: time.Hour,
71 | 		Burst:  burst,
72 | 	}
73 | }
74 | 
75 | func PerDayBurst(rate float64, burst int) Limit {
76 | 	return Limit{
77 | 		Rate:   rate,
78 | 		Period: time.Hour * 24,
79 | 		Burst:  burst,
80 | 	}
81 | }
82 | 
83 | // Parse is borrowed from https://github.com/ulule/limiter Copyright (c) 2015-2018 Ulule
84 | // You can use the simplified format "<limit>-<period>"(burst is 1 by default) or "<limit>-<period>-<burst>", with the given
85 | // periods:
86 | //
87 | // * "S": second
88 | // * "M": minute
89 | // * "H": hour
90 | // * "D": day
91 | //
92 | // Examples for "<limit>-<period>" format:
93 | //
94 | // * 5.5 reqs/second: "5.5-S"
95 | // * 10 reqs/minute: "10-M"
96 | // * 1000 reqs/hour: "1000-H"
97 | // * 2000 reqs/day: "2000-D"
98 | //
99 | // Examples:
100 | //
101 | // * 0.0055 reqs/second with burst 20: "0.0055-S-20" https://github.com/go-redis/redis_rate/issues/63
102 | // * 10 reqs/minute with burst 200: "10-M-200"
103 | // * 1000 reqs/hour with burst 500: "1000-H-500"
104 | // * 2000 reqs/day with burst 1000: "2000-D-1000"
105 | func Parse(value string) (Limit, error) {
106 | 	var l Limit
107 | 
108 | 	splits := strings.Split(value, "-")
109 | 	if len(splits) != 2 && len(splits) != 3 {
110 | 		return l, errors.Errorf("incorrect format '%s'", value)
111 | 	}
112 | 
113 | 	periods := map[string]time.Duration{
114 | 		"S": time.Second,    // Second
115 | 		"M": time.Minute,    // Minute
116 | 		"H": time.Hour,      // Hour
117 | 		"D": time.Hour * 24, // Day
118 | 	}
119 | 
120 | 	if len(splits) == 2 {
121 | 		r, period := splits[0], strings.ToUpper(splits[1])
122 | 
123 | 		p, ok := periods[period]
124 | 		if !ok {
125 | 			return l, errors.Errorf("incorrect period '%s'", period)
126 | 		}
127 | 
128 | 		rate, err := strconv.ParseFloat(r, 64)
129 | 		if err != nil {
130 | 			return l, errors.Errorf("incorrect rate '%s'", r)
131 | 		}
132 | 
133 | 		l = Limit{
134 | 			Rate:   rate,
135 | 			Burst:  1,
136 | 			Period: p,
137 | 		}
138 | 
139 | 		return l, nil
140 | 	}
141 | 
142 | 	r, period, b := splits[0], strings.ToUpper(splits[1]), splits[2]
143 | 
144 | 	p, ok := periods[period]
145 | 	if !ok {
146 | 		return l, errors.Errorf("incorrect period '%s'", period)
147 | 	}
148 | 
149 | 	rate, err := strconv.ParseFloat(r, 64)
150 | 	if err != nil {
151 | 		return l, errors.Errorf("incorrect rate '%s'", r)
152 | 	}
153 | 
154 | 	burst, err := strconv.Atoi(b)
155 | 	if err != nil {
156 | 		return l, errors.Errorf("incorrect burst '%s'", b)
157 | 	}
158 | 
159 | 	l = Limit{
160 | 		Rate:   rate,
161 | 		Burst:  burst,
162 | 		Period: p,
163 | 	}
164 | 
165 | 	return l, nil
166 | }
```

framework/ratelimit/limit_test.go
```
1 | package ratelimit
2 | 
3 | import (
4 | 	"reflect"
5 | 	"testing"
6 | 	"time"
7 | 
8 | 	. "github.com/smartystreets/goconvey/convey"
9 | )
10 | 
11 | func TestParse(t *testing.T) {
12 | 	type args struct {
13 | 		value string
14 | 	}
15 | 	tests := []struct {
16 | 		name    string
17 | 		args    args
18 | 		want    Limit
19 | 		wantErr bool
20 | 	}{
21 | 		{
22 | 			name: "",
23 | 			args: args{
24 | 				value: "0.0055-S-20",
25 | 			},
26 | 			want: Limit{
27 | 				Rate:   0.0055,
28 | 				Burst:  20,
29 | 				Period: time.Second,
30 | 			},
31 | 			wantErr: false,
32 | 		},
33 | 		{
34 | 			name: "",
35 | 			args: args{
36 | 				value: "1000-H",
37 | 			},
38 | 			want: Limit{
39 | 				Rate:   1000,
40 | 				Burst:  1,
41 | 				Period: time.Hour,
42 | 			},
43 | 			wantErr: false,
44 | 		},
45 | 		{
46 | 			name: "",
47 | 			args: args{
48 | 				value: "1000-H-1-1-1",
49 | 			},
50 | 			want:    Limit{},
51 | 			wantErr: true,
52 | 		},
53 | 		{
54 | 			name: "",
55 | 			args: args{
56 | 				value: "1000-Y",
57 | 			},
58 | 			want:    Limit{},
59 | 			wantErr: true,
60 | 		},
61 | 		{
62 | 			name: "",
63 | 			args: args{
64 | 				value: "a-H",
65 | 			},
66 | 			want:    Limit{},
67 | 			wantErr: true,
68 | 		},
69 | 		{
70 | 			name: "",
71 | 			args: args{
72 | 				value: "1000-Y-100",
73 | 			},
74 | 			want:    Limit{},
75 | 			wantErr: true,
76 | 		},
77 | 		{
78 | 			name: "",
79 | 			args: args{
80 | 				value: "a-H-100",
81 | 			},
82 | 			want:    Limit{},
83 | 			wantErr: true,
84 | 		},
85 | 		{
86 | 			name: "",
87 | 			args: args{
88 | 				value: "10-H-abc",
89 | 			},
90 | 			want:    Limit{},
91 | 			wantErr: true,
92 | 		},
93 | 	}
94 | 	for _, tt := range tests {
95 | 		t.Run(tt.name, func(t *testing.T) {
96 | 			got, err := Parse(tt.args.value)
97 | 			if (err != nil) != tt.wantErr {
98 | 				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
99 | 				return
100 | 			}
101 | 			if !reflect.DeepEqual(got, tt.want) {
102 | 				t.Errorf("Parse() got = %v, want %v", got, tt.want)
103 | 			}
104 | 		})
105 | 	}
106 | }
107 | 
108 | func TestPerSecond(t *testing.T) {
109 | 	Convey("Should equal to 10 in 1s", t, func() {
110 | 		So(PerSecond(10), ShouldResemble, Limit{
111 | 			Rate:   10,
112 | 			Period: time.Second,
113 | 			Burst:  1,
114 | 		})
115 | 	})
116 | 
117 | 	Convey("Should equal to 10 in 1s with 100 burst", t, func() {
118 | 		So(PerSecondBurst(10, 100), ShouldResemble, Limit{
119 | 			Rate:   10,
120 | 			Period: time.Second,
121 | 			Burst:  100,
122 | 		})
123 | 	})
124 | 
125 | 	Convey("Should equal to 10 in 1m", t, func() {
126 | 		So(PerMinute(10), ShouldResemble, Limit{
127 | 			Rate:   10,
128 | 			Period: time.Minute,
129 | 			Burst:  1,
130 | 		})
131 | 	})
132 | 
133 | 	Convey("Should equal to 10 in 1m with 100 burst", t, func() {
134 | 		So(PerMinuteBurst(10, 100), ShouldResemble, Limit{
135 | 			Rate:   10,
136 | 			Period: time.Minute,
137 | 			Burst:  100,
138 | 		})
139 | 	})
140 | 
141 | 	Convey("Should equal to 10 in 1h", t, func() {
142 | 		So(PerHour(10), ShouldResemble, Limit{
143 | 			Rate:   10,
144 | 			Period: time.Hour,
145 | 			Burst:  1,
146 | 		})
147 | 	})
148 | 
149 | 	Convey("Should equal to 10 in 1h with 100 burst", t, func() {
150 | 		So(PerHourBurst(10, 100), ShouldResemble, Limit{
151 | 			Rate:   10,
152 | 			Period: time.Hour,
153 | 			Burst:  100,
154 | 		})
155 | 	})
156 | 
157 | 	Convey("Should equal to 10 in 1d", t, func() {
158 | 		So(PerDay(10), ShouldResemble, Limit{
159 | 			Rate:   10,
160 | 			Period: time.Hour * 24,
161 | 			Burst:  1,
162 | 		})
163 | 	})
164 | 
165 | 	Convey("Should equal to 10 in 1d with 100 burst", t, func() {
166 | 		So(PerDayBurst(10, 100), ShouldResemble, Limit{
167 | 			Rate:   10,
168 | 			Period: time.Hour * 24,
169 | 			Burst:  100,
170 | 		})
171 | 	})
172 | }
```

framework/ratelimit/limiter.go
```
1 | package ratelimit
2 | 
3 | import (
4 | 	"context"
5 | 	"time"
6 | )
7 | 
8 | type Limiter interface {
9 | 	Allow() bool
10 | 	AllowE() (bool, error)
11 | 	AllowCtx(ctx context.Context) bool
12 | 	AllowECtx(ctx context.Context) (bool, error)
13 | 
14 | 	ReserveE() (time.Duration, bool, error)
15 | 	ReserveECtx(ctx context.Context) (time.Duration, bool, error)
16 | 
17 | 	Wait(ctx context.Context) error
18 | }
```

framework/registry/node.go
```
1 | package registry
2 | 
3 | import (
4 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
5 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/constants"
6 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/etcd"
7 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/memberlist"
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/nacos"
9 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/zk"
10 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
11 | )
12 | 
13 | type IServiceProvider interface {
14 | 	SelectServer() string
15 | 	Close()
16 | }
17 | 
18 | func NewRest(data ...map[string]interface{}) {
19 | 	for mode, _ := range config.ServiceDiscoveryMap() {
20 | 		switch mode {
21 | 		case constants.SD_NACOS:
22 | 			nacos.NewRest(data...)
23 | 		case constants.SD_ETCD:
24 | 			etcd.NewRest(data...)
25 | 		case constants.SD_MEMBERLIST:
26 | 			memberlist.NewRest(data...)
27 | 		case constants.SD_ZK:
28 | 			zk.NewRest(data...)
29 | 		default:
30 | 			logger.Warn().Msgf("[go-doudou] unknown service discovery mode: %s", mode)
31 | 		}
32 | 	}
33 | }
34 | 
35 | func NewGrpc(data ...map[string]interface{}) {
36 | 	for mode, _ := range config.ServiceDiscoveryMap() {
37 | 		switch mode {
38 | 		case constants.SD_NACOS:
39 | 			nacos.NewGrpc(data...)
40 | 		case constants.SD_ETCD:
41 | 			etcd.NewGrpc(data...)
42 | 		case constants.SD_MEMBERLIST:
43 | 			memberlist.NewGrpc(data...)
44 | 		case constants.SD_ZK:
45 | 			zk.NewGrpc(data...)
46 | 		default:
47 | 			logger.Warn().Msgf("[go-doudou] unknown service discovery mode: %s", mode)
48 | 		}
49 | 	}
50 | }
51 | 
52 | func ShutdownRest() {
53 | 	for mode, _ := range config.ServiceDiscoveryMap() {
54 | 		switch mode {
55 | 		case constants.SD_NACOS:
56 | 			nacos.ShutdownRest()
57 | 		case constants.SD_ETCD:
58 | 			etcd.ShutdownRest()
59 | 		case constants.SD_MEMBERLIST:
60 | 			memberlist.Shutdown()
61 | 		case constants.SD_ZK:
62 | 			zk.ShutdownRest()
63 | 		default:
64 | 			logger.Warn().Msgf("[go-doudou] unknown service discovery mode: %s", mode)
65 | 		}
66 | 	}
67 | }
68 | 
69 | func ShutdownGrpc() {
70 | 	for mode, _ := range config.ServiceDiscoveryMap() {
71 | 		switch mode {
72 | 		case constants.SD_NACOS:
73 | 			nacos.ShutdownGrpc()
74 | 		case constants.SD_ETCD:
75 | 			etcd.ShutdownGrpc()
76 | 		case constants.SD_MEMBERLIST:
77 | 			memberlist.Shutdown()
78 | 		case constants.SD_ZK:
79 | 			zk.ShutdownGrpc()
80 | 		default:
81 | 			logger.Warn().Msgf("[go-doudou] unknown service discovery mode: %s", mode)
82 | 		}
83 | 	}
84 | }
```

framework/registry/node_test.go
```
1 | package registry
2 | 
3 | import (
4 | 	"testing"
5 | 
6 | 	"github.com/apolloconfig/agollo/v4"
7 | 	"github.com/apolloconfig/agollo/v4/agcache/memory"
8 | 	apolloConfig "github.com/apolloconfig/agollo/v4/env/config"
9 | 	"github.com/golang/mock/gomock"
10 | 	. "github.com/smartystreets/goconvey/convey"
11 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
12 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr"
13 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr/mock"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/nacos"
15 | 	nmock "github.com/unionj-cloud/go-doudou/v2/framework/registry/nacos/mock"
16 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/cache"
17 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/config_client"
18 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/naming_client"
19 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
20 | )
21 | 
22 | func setup() {
23 | 	_ = config.GddServiceName.Write("seed")
24 | 	_ = config.GddLogLevel.Write("debug")
25 | 	_ = config.GddPort.Write("8088")
26 | 	_ = config.GddRouteRootPath.Write("/v1")
27 | 	_ = config.GddApolloAddr.Write("http://apollo-config-dev-svc:8080")
28 | 	_ = config.GddNacosServerAddr.Write("http://localhost:8848")
29 | }
30 | 
31 | func TestNewNode_NacosConfigType(t *testing.T) {
32 | 	Convey("Should not have error", t, func() {
33 | 		setup()
34 | 		_ = config.GddConfigRemoteType.Write("nacos")
35 | 		ctrl := gomock.NewController(t)
36 | 		defer ctrl.Finish()
37 | 		dataId := ".env"
38 | 		configClient := mock.NewMockIConfigClient(ctrl)
39 | 		configClient.
40 | 			EXPECT().
41 | 			GetConfig(vo.ConfigParam{
42 | 				DataId: dataId,
43 | 				Group:  config.DefaultGddNacosConfigGroup,
44 | 			}).
45 | 			AnyTimes().
46 | 			Return("GDD_READ_TIMEOUT=60s\nGDD_WRITE_TIMEOUT=60s\nGDD_IDLE_TIMEOUT=120s", nil)
47 | 
48 | 		configClient.
49 | 			EXPECT().
50 | 			ListenConfig(gomock.Any()).
51 | 			AnyTimes().
52 | 			Return(nil)
53 | 
54 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
55 | 			return configClient, nil
56 | 		}
57 | 
58 | 		if configmgr.NacosClient != nil {
59 | 			configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
60 | 				config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
61 | 		}
62 | 
63 | 		err := configmgr.LoadFromNacos(config.GetNacosClientParam(), dataId, string(config.DefaultGddNacosConfigFormat), config.DefaultGddNacosConfigGroup)
64 | 		So(err, ShouldBeNil)
65 | 		So(func() {
66 | 			NewRest()
67 | 		}, ShouldNotPanic)
68 | 		defer ShutdownRest()
69 | 	})
70 | }
71 | 
72 | func TestNewNode_ApolloConfigType(t *testing.T) {
73 | 	Convey("Should not have error", t, func() {
74 | 		setup()
75 | 		_ = config.GddConfigRemoteType.Write("apollo")
76 | 		ctrl := gomock.NewController(t)
77 | 		defer ctrl.Finish()
78 | 		configClient := mock.NewMockClient(ctrl)
79 | 		factory := &memory.DefaultCacheFactory{}
80 | 		cache := factory.Create()
81 | 		cache.Set("gdd.retry.count", "3", 0)
82 | 		cache.Set("gdd.weight", "5", 0)
83 | 		configClient.
84 | 			EXPECT().
85 | 			GetConfigCache(config.DefaultGddApolloNamespace).
86 | 			AnyTimes().
87 | 			Return(cache)
88 | 
89 | 		configClient.
90 | 			EXPECT().
91 | 			AddChangeListener(gomock.Any()).
92 | 			AnyTimes().
93 | 			Return()
94 | 
95 | 		configmgr.StartWithConfig = func(loadAppConfig func() (*apolloConfig.AppConfig, error)) (agollo.Client, error) {
96 | 			_, _ = loadAppConfig()
97 | 			return configClient, nil
98 | 		}
99 | 
100 | 		if configmgr.ApolloClient != nil {
101 | 			configmgr.ApolloClient = configClient
102 | 		}
103 | 
104 | 		apolloCluster := config.DefaultGddApolloCluster
105 | 		apolloAddr := config.GddApolloAddr.Load()
106 | 		apolloNamespace := config.DefaultGddApolloNamespace
107 | 		apolloBackupPath := config.DefaultGddApolloBackupPath
108 | 		c := &apolloConfig.AppConfig{
109 | 			AppID:            config.GddServiceName.Load(),
110 | 			Cluster:          apolloCluster,
111 | 			IP:               apolloAddr,
112 | 			NamespaceName:    apolloNamespace,
113 | 			IsBackupConfig:   false,
114 | 			BackupConfigPath: apolloBackupPath,
115 | 			MustStart:        false,
116 | 		}
117 | 		So(func() {
118 | 			configmgr.LoadFromApollo(c)
119 | 		}, ShouldNotPanic)
120 | 
121 | 		So(func() {
122 | 			NewRest()
123 | 		}, ShouldNotPanic)
124 | 		defer ShutdownRest()
125 | 	})
126 | }
127 | 
128 | func TestNewNode_Nacos(t *testing.T) {
129 | 	Convey("Should return nil", t, func() {
130 | 		setup()
131 | 		_ = config.GddServiceDiscoveryMode.Write("nacos")
132 | 		ctrl := gomock.NewController(t)
133 | 		defer ctrl.Finish()
134 | 		defer ShutdownRest()
135 | 
136 | 		namingClient := nmock.NewMockINamingClient(ctrl)
137 | 		namingClient.
138 | 			EXPECT().
139 | 			RegisterInstance(gomock.Any()).
140 | 			AnyTimes().
141 | 			Return(true, nil)
142 | 
143 | 		namingClient.
144 | 			EXPECT().
145 | 			DeregisterInstance(gomock.Any()).
146 | 			AnyTimes().
147 | 			Return(true, nil)
148 | 
149 | 		nacos.NewNamingClient = func(param vo.NacosClientParam) (iClient naming_client.INamingClient, err error) {
150 | 			return namingClient, nil
151 | 		}
152 | 
153 | 		if nacos.NamingClient == nil {
154 | 			nacos.NamingClient = namingClient
155 | 		}
156 | 
157 | 		So(func() {
158 | 			NewRest()
159 | 		}, ShouldNotPanic)
160 | 	})
161 | }
162 | 
163 | func TestNewNode_InvalidServiceDiscoveryMode(t *testing.T) {
164 | 	Convey("Should return nil", t, func() {
165 | 		setup()
166 | 		_ = config.GddServiceDiscoveryMode.Write("invalid")
167 | 		So(func() {
168 | 			NewRest()
169 | 		}, ShouldNotPanic)
170 | 	})
171 | }
```

framework/rest/bizerror.go
```
1 | package rest
2 | 
3 | import (
4 | 	"fmt"
5 | 	"net/http"
6 | 
7 | 	"github.com/pkg/errors"
8 | )
9 | 
10 | // BizError is used for business error implemented error interface
11 | // StatusCode will be set to http response status code
12 | // ErrCode is used for business error code
13 | // ErrMsg is custom error message
14 | type BizError struct {
15 | 	StatusCode int
16 | 	ErrCode    int
17 | 	ErrMsg     string
18 | 	Cause      error
19 | }
20 | 
21 | type BizErrorOption func(bizError *BizError)
22 | 
23 | func WithStatusCode(statusCode int) BizErrorOption {
24 | 	return func(bizError *BizError) {
25 | 		bizError.StatusCode = statusCode
26 | 	}
27 | }
28 | 
29 | func WithErrCode(errCode int) BizErrorOption {
30 | 	return func(bizError *BizError) {
31 | 		bizError.ErrCode = errCode
32 | 	}
33 | }
34 | 
35 | func WithCause(cause error) BizErrorOption {
36 | 	return func(bizError *BizError) {
37 | 		bizError.Cause = cause
38 | 	}
39 | }
40 | 
41 | // NewBizError is factory function for creating an instance of BizError struct
42 | func NewBizError(err error, opts ...BizErrorOption) BizError {
43 | 	bz := BizError{
44 | 		ErrCode:    1,
45 | 		StatusCode: http.StatusInternalServerError,
46 | 		ErrMsg:     err.Error(),
47 | 	}
48 | 	for _, fn := range opts {
49 | 		fn(&bz)
50 | 	}
51 | 	return bz
52 | }
53 | 
54 | // String function is used for printing string representation of a BizError instance
55 | func (b BizError) String() string {
56 | 	if b.ErrCode > 0 {
57 | 		return fmt.Sprintf("%d %s", b.ErrCode, b.ErrMsg)
58 | 	}
59 | 	return b.ErrMsg
60 | }
61 | 
62 | // Error is used for implementing error interface
63 | func (b BizError) Error() string {
64 | 	return b.ErrMsg
65 | }
66 | 
67 | func HandleBadRequestErr(err error) {
68 | 	panic(NewBizError(err, WithStatusCode(http.StatusBadRequest)))
69 | }
70 | 
71 | func HandleInternalServerError(err error) {
72 | 	panic(NewBizError(err))
73 | }
74 | 
75 | func PanicBadRequestErr(err error) {
76 | 	if err == nil {
77 | 		return
78 | 	}
79 | 	panic(NewBizError(err, WithStatusCode(http.StatusBadRequest)))
80 | }
81 | 
82 | func PanicInternalServerError(err error) {
83 | 	if err == nil {
84 | 		return
85 | 	}
86 | 	panic(NewBizError(err))
87 | }
88 | 
89 | func UnWrap(err error) error {
90 | 	var bizErr BizError
91 | 	if errors.As(err, &bizErr) {
92 | 		if bizErr.Cause != nil {
93 | 			return UnWrap(bizErr.Cause)
94 | 		}
95 | 	}
96 | 	return err
97 | }
```

framework/rest/bizerror_test.go
```
1 | package rest_test
2 | 
3 | import (
4 | 	"testing"
5 | 
6 | 	"github.com/pkg/errors"
7 | 	. "github.com/smartystreets/goconvey/convey"
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
9 | )
10 | 
11 | func TestWithStatusCode(t *testing.T) {
12 | 	Convey("Create a BizError with 401 http status code", t, func() {
13 | 		bizError := rest.NewBizError(errors.New("Unauthorised"), rest.WithStatusCode(401))
14 | 		So(bizError, ShouldNotBeZeroValue)
15 | 		So(bizError.StatusCode, ShouldEqual, 401)
16 | 
17 | 		Convey("Should output Unauthorised", func() {
18 | 			So(bizError.Error(), ShouldEqual, "Unauthorised")
19 | 		})
20 | 	})
21 | }
22 | 
23 | func TestWithErrCode(t *testing.T) {
24 | 	Convey("Create a BizError with 100401 business error code", t, func() {
25 | 		bizError := rest.NewBizError(errors.New("Unauthorised"), rest.WithErrCode(100401))
26 | 		So(bizError, ShouldNotBeZeroValue)
27 | 		So(bizError.ErrCode, ShouldEqual, 100401)
28 | 
29 | 		Convey("Should output 100401 Unauthorised", func() {
30 | 			So(bizError.String(), ShouldEqual, "100401 Unauthorised")
31 | 		})
32 | 	})
33 | }
```

framework/rest/confighandler.go
```
1 | package rest
2 | 
3 | import (
4 | 	"fmt"
5 | 	"net/http"
6 | 	"os"
7 | 	"strings"
8 | 
9 | 	"github.com/unionj-cloud/toolkit/stringutils"
10 | )
11 | 
12 | var ConfigRoutes = configRoutes
13 | 
14 | func configRoutes() []Route {
15 | 	return []Route{
16 | 		{
17 | 			Name:    "GetConfig",
18 | 			Method:  "GET",
19 | 			Pattern: "/go-doudou/config",
20 | 			HandlerFunc: func(_writer http.ResponseWriter, _req *http.Request) {
21 | 				pre := _req.FormValue("pre")
22 | 				var builder strings.Builder
23 | 				for _, pair := range os.Environ() {
24 | 					if stringutils.IsEmpty(pre) || strings.HasPrefix(pair, pre) {
25 | 						builder.WriteString(fmt.Sprintf("%s\n", pair))
26 | 					}
27 | 				}
28 | 				_writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
29 | 				_writer.Write([]byte(builder.String()))
30 | 			},
31 | 		},
32 | 	}
33 | }
```

framework/rest/dochandler.go
```
1 | package rest
2 | 
3 | import (
4 | 	"bytes"
5 | 	"fmt"
6 | 	"net/http"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/rs/cors"
11 | 	"github.com/unionj-cloud/toolkit/stringutils"
12 | )
13 | 
14 | //	 window.docs = [
15 | //	{
16 | //	  "label": "Banana",
17 | //	  "value": "http://localhost:6060/banana/go-doudou/doc",
18 | //	},
19 | //	{
20 | //	  "label": "Apple",
21 | //	  "value": "http://localhost:6060/apple/go-doudou/doc",
22 | //	}
23 | //
24 | // ]
25 | var Docs []DocItem
26 | var DocRoutes = docRoutes
27 | 
28 | type DocItem struct {
29 | 	Label string `json:"label"`
30 | 	Value string `json:"value"`
31 | }
32 | 
33 | func docRoutes(doc string) []Route {
34 | 	if stringutils.IsEmpty(doc) {
35 | 		doc = "{}"
36 | 	}
37 | 	routes := []Route{
38 | 		{
39 | 			Name:    "GetDoc",
40 | 			Method:  "GET",
41 | 			Pattern: "/go-doudou/doc",
42 | 			HandlerFunc: func(_writer http.ResponseWriter, _req *http.Request) {
43 | 				var (
44 | 					tpl *template.Template
45 | 					err error
46 | 					buf bytes.Buffer
47 | 				)
48 | 				if tpl, err = template.New("onlinedoc.tmpl").Parse(`window.doc = {{ .Doc }}
49 | window.docUrl = "{{ .DocUrl }}"
50 | window.docs = {{ .Docs }}`); err != nil {
51 | 					panic(err)
52 | 				}
53 | 				docUrl := "openapi.json"
54 | 				docs, _ := json.Marshal(Docs)
55 | 				if err = tpl.Execute(&buf, struct {
56 | 					Doc    string
57 | 					DocUrl string
58 | 					Docs   string
59 | 				}{
60 | 					Doc:    doc,
61 | 					DocUrl: docUrl,
62 | 					Docs:   string(docs),
63 | 				}); err != nil {
64 | 					panic(err)
65 | 				}
66 | 				_writer.Header().Set("Content-Type", "text/html; charset=utf-8")
67 | 				result := head + buf.String() + tail
68 | 				_writer.Write([]byte(result))
69 | 			},
70 | 		},
71 | 		{
72 | 			Name:    "GetOpenAPI",
73 | 			Method:  "GET",
74 | 			Pattern: "/go-doudou/openapi.json",
75 | 			HandlerFunc: func(_writer http.ResponseWriter, _req *http.Request) {
76 | 				_writer.Write([]byte(doc))
77 | 			},
78 | 		},
79 | 	}
80 | 	corsOpts := cors.New(cors.Options{
81 | 		AllowedMethods: []string{
82 | 			http.MethodGet,
83 | 			http.MethodPost,
84 | 			http.MethodPut,
85 | 			http.MethodPatch,
86 | 			http.MethodDelete,
87 | 			http.MethodOptions,
88 | 			http.MethodHead,
89 | 		},
90 | 
91 | 		AllowedHeaders: []string{
92 | 			"*",
93 | 		},
94 | 
95 | 		AllowOriginRequestFunc: func(r *http.Request, origin string) bool {
96 | 			if strings.Contains(r.URL.Path, fmt.Sprintf("%sopenapi.json", gddPathPrefix)) {
97 | 				return true
98 | 			}
99 | 			return false
100 | 		},
101 | 	})
102 | 	gddmiddlewares := []MiddlewareFunc{corsOpts.Handler, MiddlewareFunc(basicAuth())}
103 | 
104 | 	for k, item := range routes {
105 | 		h := http.Handler(item.HandlerFunc)
106 | 		for i := len(gddmiddlewares) - 1; i >= 0; i-- {
107 | 			h = gddmiddlewares[i].Middleware(h)
108 | 		}
109 | 		item.HandlerFunc = h.(http.HandlerFunc)
110 | 		routes[k] = item
111 | 	}
112 | 
113 | 	return routes
114 | }
```

framework/rest/docindex.go
```
1 | package rest
2 | 
[TRUNCATED]
```

framework/rest/form.go
```
1 | package rest
2 | 
3 | import (
4 | 	"github.com/goccy/go-reflect"
5 | 	"github.com/unionj-cloud/toolkit/form"
6 | 	"github.com/unionj-cloud/toolkit/stringutils"
7 | 	"net/url"
8 | )
9 | 
10 | var decoder = form.NewDecoder()
11 | var encoder = form.NewEncoder()
12 | 
13 | func tagNameFunc(fld reflect.StructField) string {
14 | 	name := fld.Tag.Get("form")
15 | 	if stringutils.IsEmpty(name) {
16 | 		name = fld.Tag.Get("json")
17 | 	}
18 | 	return name
19 | }
20 | 
21 | func init() {
22 | 	// frontend axios.js use [] by default
23 | 	decoder.SetNamespacePrefix("[")
24 | 	decoder.SetNamespaceSuffix("]")
25 | 	decoder.RegisterTagNameFunc(tagNameFunc)
26 | 	encoder.SetNamespacePrefix("[")
27 | 	encoder.SetNamespaceSuffix("]")
28 | 	encoder.RegisterTagNameFunc(tagNameFunc)
29 | }
30 | 
31 | func GetFormDecoder() *form.Decoder {
32 | 	return decoder
33 | }
34 | 
35 | func GetFormEncoder() *form.Encoder {
36 | 	return encoder
37 | }
38 | 
39 | func DecodeForm(v interface{}, values url.Values) (err error) {
40 | 	return decoder.Decode(v, values)
41 | }
42 | 
43 | func EncodeForm(v interface{}) (values url.Values, err error) {
44 | 	return encoder.Encode(v)
45 | }
46 | 
47 | func RegisterFormDecoderCustomTypeFunc(fn form.DecodeCustomTypeFunc, types ...interface{}) {
48 | 	decoder.RegisterCustomTypeFunc(fn, types...)
49 | }
50 | 
51 | func RegisterFormEncoderCustomTypeFunc(fn form.EncodeCustomTypeFunc, types ...interface{}) {
52 | 	encoder.RegisterCustomTypeFunc(fn, types...)
53 | }
```

framework/rest/gateway.go
```
1 | package rest
2 | 
3 | import (
4 | 	"fmt"
5 | 	"net/http"
6 | 	"net/http/httputil"
7 | 	"net/url"
8 | 	"os"
9 | 	"regexp"
10 | 	"strconv"
11 | 	"strings"
12 | 
13 | 	lru "github.com/hashicorp/golang-lru"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/cache"
15 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
16 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
17 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/constants"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/etcd"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/nacos"
20 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/zk"
21 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
22 | 	clientv3 "go.etcd.io/etcd/client/v3"
23 | )
24 | 
25 | // Headers borrowed from labstack/echo
26 | const (
27 | 	HeaderAccept              = "Accept"
28 | 	HeaderAcceptEncoding      = "Accept-Encoding"
29 | 	HeaderAllow               = "Allow"
30 | 	HeaderAuthorization       = "Authorization"
31 | 	HeaderContentDisposition  = "Content-Disposition"
32 | 	HeaderContentEncoding     = "Content-Encoding"
33 | 	HeaderContentLength       = "Content-Length"
34 | 	HeaderContentType         = "Content-Type"
35 | 	HeaderCookie              = "Cookie"
36 | 	HeaderSetCookie           = "Set-Cookie"
37 | 	HeaderIfModifiedSince     = "If-Modified-Since"
38 | 	HeaderLastModified        = "Last-Modified"
39 | 	HeaderLocation            = "Location"
40 | 	HeaderUpgrade             = "Upgrade"
41 | 	HeaderVary                = "Vary"
42 | 	HeaderWWWAuthenticate     = "WWW-Authenticate"
43 | 	HeaderXForwardedFor       = "X-Forwarded-For"
44 | 	HeaderXForwardedProto     = "X-Forwarded-Proto"
45 | 	HeaderXForwardedProtocol  = "X-Forwarded-Protocol"
46 | 	HeaderXForwardedSsl       = "X-Forwarded-Ssl"
47 | 	HeaderXUrlScheme          = "X-Url-Scheme"
48 | 	HeaderXHTTPMethodOverride = "X-HTTP-Method-Override"
49 | 	HeaderXRealIP             = "X-Real-IP"
50 | 	HeaderXRequestID          = "X-Request-ID"
51 | 	HeaderXRequestedWith      = "X-Requested-With"
52 | 	HeaderServer              = "Server"
53 | 	HeaderOrigin              = "Origin"
54 | 
55 | 	// Access control
56 | 	HeaderAccessControlRequestMethod    = "Access-Control-Request-Method"
57 | 	HeaderAccessControlRequestHeaders   = "Access-Control-Request-Headers"
58 | 	HeaderAccessControlAllowOrigin      = "Access-Control-Allow-Origin"
59 | 	HeaderAccessControlAllowMethods     = "Access-Control-Allow-Methods"
60 | 	HeaderAccessControlAllowHeaders     = "Access-Control-Allow-Headers"
61 | 	HeaderAccessControlAllowCredentials = "Access-Control-Allow-Credentials"
62 | 	HeaderAccessControlExposeHeaders    = "Access-Control-Expose-Headers"
63 | 	HeaderAccessControlMaxAge           = "Access-Control-Max-Age"
64 | 
65 | 	// Security
66 | 	HeaderStrictTransportSecurity         = "Strict-Transport-Security"
67 | 	HeaderXContentTypeOptions             = "X-Content-Type-Options"
68 | 	HeaderXXSSProtection                  = "X-XSS-Protection"
69 | 	HeaderXFrameOptions                   = "X-Frame-Options"
70 | 	HeaderContentSecurityPolicy           = "Content-Security-Policy"
71 | 	HeaderContentSecurityPolicyReportOnly = "Content-Security-Policy-Report-Only"
72 | 	HeaderXCSRFToken                      = "X-CSRF-Token"
73 | 	HeaderReferrerPolicy                  = "Referrer-Policy"
74 | )
75 | 
76 | type ProxyTarget struct {
77 | 	Name string
78 | 	URL  *url.URL
79 | }
80 | 
81 | type ProxyConfig struct {
82 | 	ProviderStore cache.IStore
83 | 	// To customize the transport to remote.
84 | 	// Examples: If custom TLS certificates are required.
85 | 	Transport http.RoundTripper
86 | 
87 | 	// ModifyResponse defines function to modify response from ProxyTarget.
88 | 	ModifyResponse func(*http.Response) error
89 | }
90 | 
91 | func captureTokens(pattern *regexp.Regexp, input string) *strings.Replacer {
92 | 	groups := pattern.FindAllStringSubmatch(input, -1)
93 | 	if groups == nil {
94 | 		return nil
95 | 	}
96 | 	values := groups[0][1:]
97 | 	replace := make([]string, 2*len(values))
98 | 	for i, v := range values {
99 | 		j := 2 * i
100 | 		replace[j] = "$" + strconv.Itoa(i+1)
101 | 		replace[j+1] = v
102 | 	}
103 | 	return strings.NewReplacer(replace...)
104 | }
105 | 
106 | func getPath(r *http.Request) string {
107 | 	path := r.URL.RawPath
108 | 	if path == "" {
109 | 		path = r.URL.Path
110 | 	}
111 | 	return path
112 | }
113 | 
114 | func isWebSocket(r *http.Request) bool {
115 | 	upgrade := r.Header.Get(HeaderUpgrade)
116 | 	return strings.ToLower(upgrade) == "websocket"
117 | }
118 | 
119 | func Proxy(proxyConfig ProxyConfig) func(inner http.Handler) http.Handler {
120 | 	if proxyConfig.ProviderStore == nil {
121 | 		arc, _ := lru.NewARC(128)
122 | 		proxyConfig.ProviderStore = arc
123 | 	}
124 | 	if proxyConfig.Transport == nil {
125 | 		proxyConfig.Transport = http.DefaultTransport
126 | 	}
127 | 	return func(inner http.Handler) http.Handler {
128 | 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
129 | 			if isWebSocket(r) || r.Header.Get(HeaderAccept) == "text/event-stream" {
130 | 				http.Error(w, "not support", http.StatusBadGateway)
131 | 				return
132 | 			}
133 | 			parts := strings.Split(r.URL.Path, "/")
134 | 			if len(parts) <= 1 {
135 | 				http.Error(w, "request url must be prefixed / + service name", http.StatusBadGateway)
136 | 				return
137 | 			}
138 | 			serviceName := parts[1]
139 | 			modes := strings.Split(os.Getenv("GDD_SERVICE_DISCOVERY_MODE"), ",")
140 | 			// TODO call Close method to release resource
141 | 			var provider registry.IServiceProvider
142 | 			for _, mode := range modes {
143 | 				switch mode {
144 | 				case constants.SD_NACOS:
145 | 					cluster := config.GddNacosClusterName.LoadOrDefault(config.DefaultGddNacosClusterName)
146 | 					group := config.GddNacosGroupName.LoadOrDefault(config.DefaultGddNacosGroupName)
147 | 					_, err := nacos.NamingClient.GetService(vo.GetServiceParam{
148 | 						Clusters:    []string{cluster},
149 | 						ServiceName: serviceName,
150 | 						GroupName:   group,
151 | 					})
152 | 					if err != nil {
153 | 						continue
154 | 					}
155 | 					if value, ok := proxyConfig.ProviderStore.Get(serviceName); ok {
156 | 						if provider, ok = value.(*nacos.WRRServiceProvider); ok {
157 | 							break
158 | 						}
159 | 					}
160 | 					provider = nacos.NewWRRServiceProvider(serviceName, nacos.WithNacosClusters([]string{cluster}), nacos.WithNacosGroupName(group))
161 | 					proxyConfig.ProviderStore.Add(serviceName, provider)
162 | 				case constants.SD_ETCD:
163 | 					getResponse, err := etcd.EtcdCli.Get(r.Context(), serviceName+"/", clientv3.WithPrefix())
164 | 					if err != nil || getResponse.Count == 0 {
165 | 						continue
166 | 					}
167 | 					if value, ok := proxyConfig.ProviderStore.Get(serviceName); ok {
168 | 						if provider, ok = value.(*etcd.SWRRServiceProvider); ok {
169 | 							break
170 | 						}
171 | 					}
172 | 					provider = etcd.NewSWRRServiceProvider(serviceName)
173 | 					proxyConfig.ProviderStore.Add(serviceName, provider)
174 | 				case constants.SD_ZK:
175 | 					if value, ok := proxyConfig.ProviderStore.Get(serviceName); ok {
176 | 						if provider, ok = value.(*zk.SWRRServiceProvider); ok {
177 | 							break
178 | 						}
179 | 					}
180 | 					group := config.GddServiceGroup.LoadOrDefault(config.DefaultGddServiceGroup)
181 | 					version := config.GddServiceVersion.LoadOrDefault(config.DefaultGddServiceVersion)
182 | 					provider = zk.NewSWRRServiceProvider(zk.ServiceConfig{
183 | 						Name:    serviceName,
184 | 						Group:   group,
185 | 						Version: version,
186 | 					})
187 | 					proxyConfig.ProviderStore.Add(serviceName, provider)
188 | 				default:
189 | 				}
190 | 				if provider != nil {
191 | 					break
192 | 				}
193 | 			}
194 | 			if provider == nil {
195 | 				http.Error(w, fmt.Sprintf("available server for service %s not found", serviceName), http.StatusBadGateway)
196 | 				return
197 | 			}
198 | 			k := regexp.MustCompile(strings.Replace(fmt.Sprintf("/%s/*", serviceName), "*", "(\\S*)", -1))
199 | 			replacer := captureTokens(k, getPath(r))
200 | 			if replacer != nil {
201 | 				r.URL.Path = replacer.Replace("/$1")
202 | 			}
203 | 			parsed, err := url.Parse(provider.SelectServer())
204 | 			if err != nil {
205 | 				http.Error(w, fmt.Sprintf("available server for service %s not found with error: %s", serviceName, err), http.StatusBadGateway)
206 | 				return
207 | 			}
208 | 			tgt := &ProxyTarget{
209 | 				Name: serviceName,
210 | 				URL:  parsed,
211 | 			}
212 | 			proxyHTTP(tgt, proxyConfig).ServeHTTP(w, r)
213 | 		})
214 | 	}
215 | }
216 | 
217 | func singleJoiningSlash(a, b string) string {
218 | 	aslash := strings.HasSuffix(a, "/")
219 | 	bslash := strings.HasPrefix(b, "/")
220 | 	switch {
221 | 	case aslash && bslash:
222 | 		return a + b[1:]
223 | 	case !aslash && !bslash:
224 | 		return a + "/" + b
225 | 	}
226 | 	return a + b
227 | }
228 | 
229 | func proxyHTTP(tgt *ProxyTarget, config ProxyConfig) http.Handler {
230 | 	target := tgt.URL
231 | 	targetQuery := target.RawQuery
232 | 	director := func(req *http.Request) {
233 | 		req.URL.Scheme = target.Scheme
234 | 		req.URL.Host = target.Host
235 | 		req.Host = target.Host
236 | 		req.URL.Path = singleJoiningSlash(target.Path, req.URL.Path)
237 | 		if targetQuery == "" || req.URL.RawQuery == "" {
238 | 			req.URL.RawQuery = targetQuery + req.URL.RawQuery
239 | 		} else {
240 | 			req.URL.RawQuery = targetQuery + "&" + req.URL.RawQuery
241 | 		}
242 | 		req.Header.Set("Host", target.Host)
243 | 		if _, ok := req.Header["User-Agent"]; !ok {
244 | 			// explicitly disable User-Agent so it's not set to default value
245 | 			req.Header.Set("User-Agent", "")
246 | 		}
247 | 	}
248 | 	proxy := &httputil.ReverseProxy{Director: director}
249 | 	proxy.ErrorHandler = func(w http.ResponseWriter, req *http.Request, err error) {
250 | 		desc := target.String()
251 | 		if tgt.Name != "" {
252 | 			desc = fmt.Sprintf("%s(%s)", tgt.Name, tgt.URL.String())
253 | 		}
254 | 		http.Error(w, fmt.Sprintf("remote %s unreachable, could not forward: %v", desc, err), http.StatusBadGateway)
255 | 	}
256 | 	proxy.Transport = config.Transport
257 | 	proxy.ModifyResponse = config.ModifyResponse
258 | 	return proxy
259 | }
```

framework/rest/memberlistuihandler.go
```
1 | package rest
2 | 
3 | import (
4 | 	"bytes"
5 | 	"net/http"
6 | 	"text/template"
7 | 	"time"
8 | 
9 | 	"github.com/hako/durafmt"
10 | 	registry "github.com/unionj-cloud/go-doudou/v2/framework/registry/memberlist"
11 | 	"github.com/unionj-cloud/toolkit/memberlist"
12 | )
13 | 
14 | type Row struct {
15 | 	Index     int                    `json:"index"`
16 | 	SvcName   string                 `json:"svcName"`
17 | 	Hostname  string                 `json:"hostname"`
18 | 	BaseUrl   string                 `json:"baseUrl"`
19 | 	Status    string                 `json:"status"`
20 | 	Uptime    string                 `json:"uptime"`
21 | 	GoVer     string                 `json:"goVer"`
22 | 	GddVer    string                 `json:"gddVer"`
23 | 	BuildUser string                 `json:"buildUser"`
24 | 	BuildTime string                 `json:"buildTime"`
25 | 	Data      map[string]interface{} `json:"data"`
26 | 	Host      string                 `json:"host"`
27 | 	SvcPort   int                    `json:"svcPort"`
28 | 	MemPort   int                    `json:"memPort"`
29 | }
30 | 
31 | func NewRow(index int, service registry.Service, uptime string, meta registry.NodeMeta, node *memberlist.Node) Row {
32 | 	status := "up"
33 | 	if node.State == memberlist.StateSuspect {
34 | 		status = "suspect"
35 | 	}
36 | 	return Row{
37 | 		Index:     index,
38 | 		SvcName:   service.Name,
39 | 		Hostname:  node.Name,
40 | 		BaseUrl:   service.BaseUrl(),
41 | 		Status:    status,
42 | 		Uptime:    uptime,
43 | 		GoVer:     meta.GoVer,
44 | 		GddVer:    meta.GddVer,
45 | 		BuildUser: meta.BuildUser,
46 | 		BuildTime: meta.BuildTime,
47 | 		Data:      service.Data,
48 | 		Host:      service.Host,
49 | 		SvcPort:   service.Port,
50 | 		MemPort:   int(node.Port),
51 | 	}
52 | }
53 | 
54 | func MemberlistUIRoutes() []Route {
55 | 	return []Route{
56 | 		{
57 | 			Name:    "GetRegistry",
58 | 			Method:  "GET",
59 | 			Pattern: "/go-doudou/registry",
60 | 			HandlerFunc: func(writer http.ResponseWriter, request *http.Request) {
61 | 				var (
62 | 					tpl   *template.Template
63 | 					err   error
64 | 					buf   bytes.Buffer
65 | 					nodes []*memberlist.Node
66 | 					rows  []Row
67 | 					ret   []byte
68 | 				)
69 | 				if nodes, err = registry.AllNodes(); err != nil {
70 | 					http.Error(writer, err.Error(), http.StatusInternalServerError)
71 | 					return
72 | 				}
73 | 				var i int
74 | 				for _, node := range nodes {
75 | 					meta, _ := registry.ParseMeta(node)
76 | 					var uptime string
77 | 					if meta.RegisterAt != nil {
78 | 						uptime = time.Since(*meta.RegisterAt).String()
79 | 						if duration, err := durafmt.ParseString(uptime); err == nil {
80 | 							uptime = duration.LimitFirstN(2).String()
81 | 						}
82 | 					}
83 | 					for _, service := range meta.Services {
84 | 						i++
85 | 						rows = append(rows, NewRow(i, service, uptime, meta, node))
86 | 					}
87 | 				}
88 | 				ret, _ = json.Marshal(rows)
89 | 				if tpl, err = template.New("registry.tmpl").Parse(memberlistUITmpl); err != nil {
90 | 					panic(err)
91 | 				}
92 | 				if err = tpl.Execute(&buf, struct {
93 | 					Rows string
94 | 				}{
95 | 					Rows: string(ret),
96 | 				}); err != nil {
97 | 					panic(err)
98 | 				}
99 | 				writer.Header().Set("Content-Type", "text/html; charset=utf-8")
100 | 				writer.Write(buf.Bytes())
101 | 			},
102 | 		},
103 | 	}
104 | }
```

framework/rest/memberlistuiindex.go
```
1 | package rest
2 | 
[TRUNCATED]
```

framework/rest/middleware.go
```
1 | package rest
2 | 
3 | import (
4 | 	"context"
5 | 	"crypto/subtle"
6 | 	"fmt"
7 | 	"io"
8 | 	"net/http"
9 | 	"net/http/httptest"
10 | 	"net/url"
11 | 	"os"
12 | 	"runtime/debug"
13 | 	"strings"
14 | 	"time"
15 | 
16 | 	"github.com/apolloconfig/agollo/v4/storage"
17 | 	"github.com/ascarter/requestid"
18 | 	"github.com/bytedance/sonic"
19 | 	"github.com/felixge/httpsnoop"
20 | 	"github.com/klauspost/compress/gzip"
21 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
22 | 	"github.com/opentracing/opentracing-go"
23 | 	"github.com/pkg/errors"
24 | 	"github.com/slok/goresilience"
25 | 	"github.com/slok/goresilience/bulkhead"
26 | 	"github.com/uber/jaeger-client-go"
27 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
28 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr"
29 | 	"github.com/unionj-cloud/toolkit/stringutils"
30 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
31 | )
32 | 
33 | var json = sonic.ConfigDefault
34 | 
35 | var (
36 | 	Tracing   = tracing
37 | 	Metrics   = metrics
38 | 	Log       = log
39 | 	BasicAuth = basicAuth
40 | 	Recovery  = recovery
41 | )
42 | 
43 | type httpConfigListener struct {
44 | 	configmgr.BaseApolloListener
45 | }
46 | 
47 | func NewHttpConfigListener() *httpConfigListener {
48 | 	return &httpConfigListener{}
49 | }
50 | 
51 | func (c *httpConfigListener) OnChange(event *storage.ChangeEvent) {
52 | 	c.Lock.Lock()
53 | 	defer c.Lock.Unlock()
54 | 	if !c.SkippedFirstEvent {
55 | 		c.SkippedFirstEvent = true
56 | 		return
57 | 	}
58 | 	for key, value := range event.Changes {
59 | 		upperKey := strings.ToUpper(strings.ReplaceAll(key, ".", "_"))
60 | 		if strings.HasPrefix(upperKey, "GDD_MANAGE_") {
61 | 			_ = os.Setenv(upperKey, fmt.Sprint(value.NewValue))
62 | 		}
63 | 	}
64 | }
65 | 
66 | func CallbackOnChange(listener *httpConfigListener) func(event *configmgr.NacosChangeEvent) {
67 | 	return func(event *configmgr.NacosChangeEvent) {
68 | 		changes := make(map[string]*storage.ConfigChange)
69 | 		for k, v := range event.Changes {
70 | 			changes[k] = &storage.ConfigChange{
71 | 				OldValue:   v.OldValue,
72 | 				NewValue:   v.NewValue,
73 | 				ChangeType: storage.ConfigChangeType(v.ChangeType),
74 | 			}
75 | 		}
76 | 		changeEvent := &storage.ChangeEvent{
77 | 			Changes: changes,
78 | 		}
79 | 		listener.OnChange(changeEvent)
80 | 	}
81 | }
82 | 
83 | func InitialiseRemoteConfigListener() {
84 | 	listener := &httpConfigListener{}
85 | 	configType := config.GddConfigRemoteType.LoadOrDefault(config.DefaultGddConfigRemoteType)
86 | 	switch configType {
87 | 	case "":
88 | 		return
89 | 	case config.NacosConfigType:
90 | 		dataIdStr := config.GddNacosConfigDataid.LoadOrDefault(config.DefaultGddNacosConfigDataid)
91 | 		dataIds := strings.Split(dataIdStr, ",")
92 | 		listener.SkippedFirstEvent = true
93 | 		for _, dataId := range dataIds {
94 | 			configmgr.NacosClient.AddChangeListener(configmgr.NacosConfigListenerParam{
95 | 				DataId:   "__" + dataId + "__" + "rest",
96 | 				OnChange: CallbackOnChange(listener),
97 | 			})
98 | 		}
99 | 	case config.ApolloConfigType:
100 | 		configmgr.ApolloClient.AddChangeListener(listener)
101 | 	default:
102 | 		logger.Warn().Msgf("[go-doudou] unknown config type: %s\n", configType)
103 | 	}
104 | }
105 | 
106 | func init() {
107 | 	InitialiseRemoteConfigListener()
108 | }
109 | 
110 | // metrics logs some metrics for http request
111 | func metrics(inner http.Handler) http.Handler {
112 | 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
113 | 		m := httpsnoop.CaptureMetrics(inner, w, r)
114 | 		logger.Info().
115 | 			Msgf("%s\t%s\t%s\t%d\t%d\t%s", r.RemoteAddr,
116 | 				r.Method,
117 | 				r.URL,
118 | 				m.Code,
119 | 				m.Written,
120 | 				m.Duration.String())
121 | 
122 | 	})
123 | }
124 | 
125 | // log logs http request body and response body for debugging
126 | func log(inner http.Handler) http.Handler {
127 | 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
128 | 		var (
129 | 			reqBodyCopy io.ReadCloser
130 | 			err         error
131 | 			traceId     string
132 | 		)
133 | 		if reqBodyCopy, r.Body, err = CopyReqBody(r.Body); err != nil {
134 | 			logger.Error().Err(err).Msg("call copyReqBody(r.Body) error")
135 | 		}
136 | 
137 | 		rec := httptest.NewRecorder()
138 | 		start := time.Now()
139 | 		inner.ServeHTTP(rec, r)
140 | 		elapsed := time.Since(start)
141 | 		reqBody := GetReqBody(reqBodyCopy, r)
142 | 		rid, _ := requestid.FromContext(r.Context())
143 | 		span := opentracing.SpanFromContext(r.Context())
144 | 		if jspan, ok := span.(*jaeger.Span); ok {
145 | 			traceId = jspan.SpanContext().TraceID().String()
146 | 		}
147 | 		respBody := GetRespBody(rec)
148 | 		reqQuery := r.URL.RawQuery
149 | 		if unescape, err := url.QueryUnescape(reqQuery); err == nil {
150 | 			reqQuery = unescape
151 | 		}
152 | 		fields := map[string]interface{}{
153 | 			"remoteAddr":        r.RemoteAddr,
154 | 			"httpMethod":        r.Method,
155 | 			"requestUrl":        r.URL.String(),
156 | 			"proto":             r.Proto,
157 | 			"host":              r.Host,
158 | 			"reqContentLength":  r.ContentLength,
159 | 			"reqHeader":         r.Header,
160 | 			"requestId":         rid,
161 | 			"reqQuery":          reqQuery,
162 | 			"reqBody":           reqBody,
163 | 			"respBody":          respBody,
164 | 			"statusCode":        rec.Result().StatusCode,
165 | 			"respHeader":        rec.Result().Header,
166 | 			"respContentLength": rec.Body.Len(),
167 | 			"elapsedTime":       elapsed.String(),
168 | 			"elapsed":           elapsed.Milliseconds(),
169 | 			"span":              span,
170 | 			"traceId":           traceId,
171 | 		}
172 | 		var reqLog string
173 | 		if reqLog, err = JsonMarshalIndent(fields, "", "    ", true); err != nil {
174 | 			reqLog = fmt.Sprintf("call jsonMarshalIndent(fields, \"\", \"    \", true) error: %s", err)
175 | 		}
176 | 		logger.Info().Fields(fields).Msg(reqLog)
177 | 		header := rec.Result().Header
178 | 		for k, v := range header {
179 | 			w.Header()[k] = v
180 | 		}
181 | 		w.WriteHeader(rec.Result().StatusCode)
182 | 		rec.Body.WriteTo(w)
183 | 	})
184 | }
185 | 
186 | // rest set Content-Type to application/json
187 | func rest(inner http.Handler) http.Handler {
188 | 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
189 | 		if stringutils.IsEmpty(w.Header().Get("Content-Type")) {
190 | 			w.Header().Set("Content-Type", "application/json; charset=UTF-8")
191 | 		}
192 | 		inner.ServeHTTP(w, r)
193 | 	})
194 | }
195 | 
196 | // basicAuth adds http basic auth validation
197 | func basicAuth() func(inner http.Handler) http.Handler {
198 | 	username := config.DefaultGddManageUser
199 | 	password := config.DefaultGddManagePass
200 | 	return func(inner http.Handler) http.Handler {
201 | 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
202 | 			if stringutils.IsNotEmpty(config.GddManageUser.Load()) {
203 | 				username = config.GddManageUser.Load()
204 | 			}
205 | 			if stringutils.IsNotEmpty(config.GddManagePass.Load()) {
206 | 				password = config.GddManagePass.Load()
207 | 			}
208 | 			user, pass, ok := r.BasicAuth()
209 | 			if !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {
210 | 				w.Header().Set("WWW-Authenticate", `Basic realm="Provide user name and password"`)
211 | 				w.WriteHeader(401)
212 | 				w.Write([]byte("Unauthorised.\n"))
213 | 				return
214 | 			}
215 | 			inner.ServeHTTP(w, r)
216 | 		})
217 | 	}
218 | }
219 | 
220 | // recovery handles panic from processing incoming http request
221 | func recovery(inner http.Handler) http.Handler {
222 | 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
223 | 		defer func() {
224 | 			if e := recover(); e != nil {
225 | 				statusCode := http.StatusInternalServerError
226 | 				errCode := 1 // 1 indicates there is an error
227 | 				message := fmt.Sprintf("%v", e)
228 | 				if err, ok := e.(error); ok {
229 | 					switch {
230 | 					case errors.Is(err, context.Canceled):
231 | 						statusCode = http.StatusBadRequest
232 | 					default:
233 | 						var bizError BizError
234 | 						if errors.As(err, &bizError) {
235 | 							statusCode = bizError.StatusCode
236 | 							errCode = bizError.ErrCode
237 | 							message = bizError.Error()
238 | 						}
239 | 					}
240 | 				}
241 | 				w.WriteHeader(statusCode)
242 | 				if stringutils.IsEmpty(message) {
243 | 					message = http.StatusText(statusCode)
244 | 				}
245 | 				logger.Error().Msgf("panic: %+v\n\nstacktrace from panic: %s\n", e, string(debug.Stack()))
246 | 				if _err := json.NewEncoder(w).Encode(struct {
247 | 					Code    int    `json:"code"`
248 | 					Message string `json:"message"`
249 | 				}{
250 | 					Code:    errCode,
251 | 					Message: message,
252 | 				}); _err != nil {
253 | 					http.Error(w, _err.Error(), http.StatusInternalServerError)
254 | 					return
255 | 				}
256 | 			}
257 | 		}()
258 | 		inner.ServeHTTP(w, r)
259 | 	})
260 | }
261 | 
262 | // gzipBody handles gzip-ed request body
263 | func gzipBody(inner http.Handler) http.Handler {
264 | 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
265 | 		// Handle gzip decoding of the body
266 | 		if r.Header.Get("Content-Encoding") == "gzip" {
267 | 			b, err := gzip.NewReader(r.Body)
268 | 			if err != nil {
269 | 				http.Error(w, err.Error(), http.StatusBadRequest)
270 | 				return
271 | 			}
272 | 			defer b.Close()
273 | 			r.Body = b
274 | 		}
275 | 		inner.ServeHTTP(w, r)
276 | 	})
277 | }
278 | 
279 | // tracing add jaeger tracing middleware
280 | func tracing(inner http.Handler) http.Handler {
281 | 	return nethttp.Middleware(
282 | 		opentracing.GlobalTracer(),
283 | 		inner,
284 | 		nethttp.OperationNameFunc(func(r *http.Request) string {
285 | 			return fmt.Sprintf("HTTP %s: %s", r.Method, r.URL.Path)
286 | 		}))
287 | }
288 | 
289 | var RunnerChain = goresilience.RunnerChain
290 | 
291 | // BulkHead add bulk head pattern middleware based on https://github.com/slok/goresilience
292 | // workers is the number of workers in the execution pool.
293 | // maxWaitTime is the max time an incoming request will wait to execute before being dropped its execution and return 429 response.
294 | func BulkHead(workers int, maxWaitTime time.Duration) func(inner http.Handler) http.Handler {
295 | 	runner := RunnerChain(
296 | 		bulkhead.NewMiddleware(bulkhead.Config{
297 | 			Workers:     workers,
298 | 			MaxWaitTime: maxWaitTime,
299 | 		}),
300 | 	)
301 | 	return func(inner http.Handler) http.Handler {
302 | 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
303 | 			err := runner.Run(r.Context(), func(_ context.Context) error {
304 | 				inner.ServeHTTP(w, r)
305 | 				return nil
306 | 			})
307 | 			if err != nil {
308 | 				http.Error(w, "too many requests", http.StatusTooManyRequests)
309 | 			}
310 | 		})
311 | 	}
312 | }
313 | 
314 | func BodyMaxBytes(n int64) func(inner http.Handler) http.Handler {
315 | 	return func(inner http.Handler) http.Handler {
316 | 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
317 | 			r2 := *r
318 | 			r2.Body = http.MaxBytesReader(w, r.Body, n)
319 | 			inner.ServeHTTP(w, &r2)
320 | 		})
321 | 	}
322 | }
```

framework/rest/middleware_test.go
```
1 | package rest_test
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"net/http"
7 | 	"os"
8 | 	"testing"
9 | 	"time"
10 | 
11 | 	"github.com/apolloconfig/agollo/v4"
12 | 	"github.com/apolloconfig/agollo/v4/agcache/memory"
13 | 	apolloConfig "github.com/apolloconfig/agollo/v4/env/config"
14 | 	"github.com/bytedance/sonic"
15 | 	"github.com/go-resty/resty/v2"
16 | 	"github.com/golang/mock/gomock"
17 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
18 | 	"github.com/opentracing/opentracing-go"
19 | 	"github.com/pkg/errors"
20 | 	"github.com/slok/goresilience"
21 | 	. "github.com/smartystreets/goconvey/convey"
22 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
23 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr"
24 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr/mock"
25 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
26 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
27 | 	httpMock "github.com/unionj-cloud/go-doudou/v2/framework/rest/mock"
28 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
29 | 	"github.com/unionj-cloud/toolkit/maputils"
30 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/cache"
31 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/config_client"
32 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
33 | )
34 | 
35 | var json = sonic.ConfigDefault
36 | 
37 | type IMocksvcHandler interface {
38 | 	GetUser(w http.ResponseWriter, r *http.Request)
39 | 	SaveUser(w http.ResponseWriter, r *http.Request)
40 | 	SignUp(w http.ResponseWriter, r *http.Request)
41 | 	GetPanic(w http.ResponseWriter, r *http.Request)
42 | }
43 | 
44 | type MocksvcHandler struct{}
45 | 
46 | func (m *MocksvcHandler) GetUser(w http.ResponseWriter, r *http.Request) {
47 | 	w.Header().Set("Content-Type", "text/plain")
48 | 	w.Write([]byte("go-doudou"))
49 | }
50 | 
51 | func (m *MocksvcHandler) SaveUser(w http.ResponseWriter, r *http.Request) {
52 | 	data := struct {
53 | 		Data string `json:"data"`
54 | 	}{
55 | 		Data: "OK",
56 | 	}
57 | 	resp, _ := json.Marshal(data)
58 | 	w.Write(resp)
59 | }
60 | 
61 | func (m *MocksvcHandler) SignUp(w http.ResponseWriter, r *http.Request) {
62 | 	data := struct {
63 | 		Data string `json:"data"`
64 | 	}{
65 | 		Data: "OK",
66 | 	}
67 | 	resp, _ := json.Marshal(data)
68 | 	w.Write(resp)
69 | }
70 | 
71 | func (m *MocksvcHandler) GetPanic(w http.ResponseWriter, r *http.Request) {
72 | 	panic(context.Canceled)
73 | }
74 | 
75 | func Routes(handler IMocksvcHandler) []rest.Route {
76 | 	return []rest.Route{
77 | 		{
78 | 			Name:        "GetUser",
79 | 			Method:      "GET",
80 | 			Pattern:     "/user",
81 | 			HandlerFunc: handler.GetUser,
82 | 		},
83 | 		{
84 | 			Name:        "SaveUser",
85 | 			Method:      "POST",
86 | 			Pattern:     "/save/user",
87 | 			HandlerFunc: handler.SaveUser,
88 | 		},
89 | 		{
90 | 			Name:        "SignUp",
91 | 			Method:      "POST",
92 | 			Pattern:     "/sign/up",
93 | 			HandlerFunc: handler.SignUp,
94 | 		},
95 | 		{
96 | 			Name:        "GetPanic",
97 | 			Method:      "GET",
98 | 			Pattern:     "/panic",
99 | 			HandlerFunc: handler.GetPanic,
100 | 		},
101 | 	}
102 | }
103 | 
104 | func NewMocksvcHandler() IMocksvcHandler {
105 | 	return &MocksvcHandler{}
106 | }
107 | 
108 | type UserVo struct {
109 | 	Username string
110 | 	Password string
111 | }
112 | 
113 | type IMockClient interface {
114 | 	GetUser(ctx context.Context, _headers map[string]string) (_resp *resty.Response, data string, err error)
115 | 	SaveUser(ctx context.Context, _headers map[string]string, payload UserVo) (_resp *resty.Response, data string, err error)
116 | 	SignUp(ctx context.Context, _headers map[string]string, username, password string) (_resp *resty.Response, data string, err error)
117 | 	GetPanic(ctx context.Context, _headers map[string]string) (_resp *resty.Response, data string, err error)
118 | }
119 | 
120 | type MockClient struct {
121 | 	provider registry.IServiceProvider
122 | 	client   *resty.Client
123 | 	rootPath string
124 | }
125 | 
126 | func (receiver *MockClient) SetRootPath(rootPath string) {
127 | 	receiver.rootPath = rootPath
128 | }
129 | 
130 | func (receiver *MockClient) SetProvider(provider registry.IServiceProvider) {
131 | 	receiver.provider = provider
132 | }
133 | 
134 | func (receiver *MockClient) SetClient(client *resty.Client) {
135 | 	receiver.client = client
136 | }
137 | 
138 | func (receiver *MockClient) GetUser(ctx context.Context, _headers map[string]string) (_resp *resty.Response, data string, err error) {
139 | 	var _err error
140 | 	_req := receiver.client.R()
141 | 	_req.SetContext(ctx)
142 | 	_path := "/user"
143 | 	_resp, _err = _req.Get(_path)
144 | 	if _err != nil {
145 | 		err = errors.Wrap(_err, "error")
146 | 		return
147 | 	}
148 | 	if _resp.IsError() {
149 | 		err = errors.New(_resp.String())
150 | 		return
151 | 	}
152 | 	return _resp, string(_resp.Body()), nil
153 | }
154 | 
155 | func (receiver *MockClient) GetPanic(ctx context.Context, _headers map[string]string) (_resp *resty.Response, data string, err error) {
156 | 	var _err error
157 | 	_req := receiver.client.R()
158 | 	_req.SetContext(ctx)
159 | 	_path := "/panic"
160 | 	_resp, _err = _req.Get(_path)
161 | 	if _err != nil {
162 | 		err = errors.Wrap(_err, "error")
163 | 		return
164 | 	}
165 | 	if _resp.IsError() {
166 | 		err = errors.New(_resp.String())
167 | 		return
168 | 	}
169 | 	return _resp, string(_resp.Body()), nil
170 | }
171 | 
172 | func (receiver *MockClient) SignUp(ctx context.Context, _headers map[string]string, username, password string) (_resp *resty.Response, data string, err error) {
173 | 	var _err error
174 | 	_req := receiver.client.R()
175 | 	_req.SetContext(ctx)
176 | 	formData := make(map[string]string)
177 | 	formData["username"] = fmt.Sprintf("%v", username)
178 | 	formData["password"] = fmt.Sprintf("%v", password)
179 | 	_path := "/sign/up"
180 | 	_req.SetMultipartFormData(formData)
181 | 	_resp, _err = _req.Post(_path)
182 | 	if _err != nil {
183 | 		err = errors.Wrap(_err, "error")
184 | 		return
185 | 	}
186 | 	if _resp.IsError() {
187 | 		err = errors.New(_resp.String())
188 | 		return
189 | 	}
190 | 	var _result struct {
191 | 		Data string `json:"data"`
192 | 	}
193 | 	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
194 | 		err = errors.Wrap(_err, "error")
195 | 		return
196 | 	}
197 | 	return _resp, _result.Data, nil
198 | }
199 | 
200 | func (receiver *MockClient) SaveUser(ctx context.Context, _headers map[string]string, payload UserVo) (_resp *resty.Response, data string, err error) {
201 | 	var _err error
202 | 	_req := receiver.client.R()
203 | 	_req.SetContext(ctx)
204 | 	_req.SetBody(payload)
205 | 	_path := "/save/user"
206 | 	_resp, _err = _req.Post(_path)
207 | 	if _err != nil {
208 | 		err = errors.Wrap(_err, "error")
209 | 		return
210 | 	}
211 | 	if _resp.IsError() {
212 | 		err = errors.New(_resp.String())
213 | 		return
214 | 	}
215 | 	var _result struct {
216 | 		Data string `json:"data"`
217 | 	}
218 | 	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
219 | 		err = errors.Wrap(_err, "error")
220 | 		return
221 | 	}
222 | 	return _resp, _result.Data, nil
223 | }
224 | 
225 | func NewMockClient(opts ...restclient.RestClientOption) *MockClient {
226 | 	defaultProvider := restclient.NewServiceProvider("RESTFUL")
227 | 	defaultClient := restclient.NewClient()
228 | 
229 | 	svcClient := &MockClient{
230 | 		provider: defaultProvider,
231 | 		client:   defaultClient,
232 | 	}
233 | 
234 | 	for _, opt := range opts {
235 | 		opt(svcClient)
236 | 	}
237 | 
238 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
239 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
240 | 		return nil
241 | 	})
242 | 
243 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
244 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
245 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
246 | 		*request = *traceReq
247 | 		return nil
248 | 	})
249 | 
250 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
251 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
252 | 		return nil
253 | 	})
254 | 
255 | 	return svcClient
256 | }
257 | 
258 | func Test_metrics(t *testing.T) {
259 | 	Convey("Should be equal to go-doudou", t, func() {
260 | 		go func() {
261 | 			srv := rest.NewRestServer()
262 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
263 | 			srv.Run()
264 | 		}()
265 | 		time.Sleep(10 * time.Millisecond)
266 | 		os.Setenv("RESTFUL", "http://localhost:6060")
267 | 		client := NewMockClient()
268 | 		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
269 | 		defer cancel()
270 | 		_, ret, err := client.GetUser(ctx, nil)
271 | 		So(err, ShouldBeNil)
272 | 		So(ret, ShouldEqual, "go-doudou")
273 | 	})
274 | }
275 | 
276 | func Test_NacosConfigType(t *testing.T) {
277 | 	Convey("Should be equal to go-doudou with nacos config", t, func() {
278 | 		ctrl := gomock.NewController(t)
279 | 		defer ctrl.Finish()
280 | 		dataId := ".env"
281 | 		configClient := mock.NewMockIConfigClient(ctrl)
282 | 		configClient.
283 | 			EXPECT().
284 | 			GetConfig(vo.ConfigParam{
285 | 				DataId: dataId,
286 | 				Group:  config.DefaultGddNacosConfigGroup,
287 | 			}).
288 | 			AnyTimes().
289 | 			Return("GDD_SERVICE_NAME=configmgr\n\nGDD_READ_TIMEOUT=60s\nGDD_WRITE_TIMEOUT=60s\nGDD_IDLE_TIMEOUT=120s", nil)
290 | 
291 | 		configClient.
292 | 			EXPECT().
293 | 			ListenConfig(gomock.Any()).
294 | 			AnyTimes().
295 | 			Return(nil)
296 | 
297 | 		configmgr.NewConfigClient = func(param vo.NacosClientParam) (iClient config_client.IConfigClient, err error) {
298 | 			return configClient, nil
299 | 		}
300 | 
301 | 		configmgr.NacosClient = configmgr.NewNacosConfigMgr([]string{dataId},
302 | 			config.DefaultGddNacosConfigGroup, configmgr.DotenvConfigFormat, config.DefaultGddNacosNamespaceId, configClient, cache.NewConcurrentMap())
303 | 
304 | 		_ = config.GddConfigRemoteType.Write(config.NacosConfigType)
305 | 		config.GddNacosConfigDataid.Write(dataId)
306 | 		config.GddPort.Write("6059")
307 | 		rest.InitialiseRemoteConfigListener()
308 | 		go func() {
309 | 			srv := rest.NewRestServer()
310 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
311 | 			srv.Run()
312 | 		}()
313 | 		time.Sleep(10 * time.Millisecond)
314 | 		os.Setenv("RESTFUL", "http://localhost:6059")
315 | 		client := NewMockClient()
316 | 		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
317 | 		defer cancel()
318 | 		_, ret, err := client.GetUser(ctx, nil)
319 | 		So(err, ShouldBeNil)
320 | 		So(ret, ShouldEqual, "go-doudou")
321 | 	})
322 | }
323 | 
324 | func Test_UnknownRemoteConfigType(t *testing.T) {
325 | 	Convey("Should be equal to go-doudou with unknown remote config type", t, func() {
326 | 		_ = config.GddConfigRemoteType.Write("Unknown")
327 | 		config.GddPort.Write("6061")
328 | 		rest.InitialiseRemoteConfigListener()
329 | 		go func() {
330 | 			srv := rest.NewRestServer()
331 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
332 | 			srv.Run()
333 | 		}()
334 | 		time.Sleep(10 * time.Millisecond)
335 | 		os.Setenv("RESTFUL", "http://localhost:6061")
336 | 		client := NewMockClient()
337 | 		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
338 | 		defer cancel()
339 | 		_, ret, err := client.GetUser(ctx, nil)
340 | 		So(err, ShouldBeNil)
341 | 		So(ret, ShouldEqual, "go-doudou")
342 | 	})
343 | }
344 | 
345 | func Test_ApolloConfigType(t *testing.T) {
346 | 	Convey("Should be equal to go-doudou with apollo config", t, func() {
347 | 		ctrl := gomock.NewController(t)
348 | 		defer ctrl.Finish()
349 | 		configClient := mock.NewMockClient(ctrl)
350 | 		factory := &memory.DefaultCacheFactory{}
351 | 		cache := factory.Create()
352 | 		cache.Set("gdd.retry.count", "3", 0)
353 | 		cache.Set("gdd.weight", "5", 0)
354 | 		configClient.
355 | 			EXPECT().
356 | 			GetConfigCache(config.DefaultGddApolloNamespace).
357 | 			AnyTimes().
358 | 			Return(cache)
359 | 
360 | 		configClient.
361 | 			EXPECT().
362 | 			AddChangeListener(gomock.Any()).
363 | 			AnyTimes().
364 | 			Return()
365 | 
366 | 		configmgr.StartWithConfig = func(loadAppConfig func() (*apolloConfig.AppConfig, error)) (agollo.Client, error) {
367 | 			_, _ = loadAppConfig()
368 | 			return configClient, nil
369 | 		}
370 | 
371 | 		configmgr.ApolloClient = configClient
372 | 
373 | 		_ = config.GddConfigRemoteType.Write(config.ApolloConfigType)
374 | 		config.GddPort.Write("6062")
375 | 		rest.InitialiseRemoteConfigListener()
376 | 		go func() {
377 | 			srv := rest.NewRestServer()
378 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
379 | 			srv.Run()
380 | 		}()
381 | 		time.Sleep(10 * time.Millisecond)
382 | 		os.Setenv("RESTFUL", "http://localhost:6062")
383 | 		client := NewMockClient()
384 | 		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
385 | 		defer cancel()
386 | 		_, ret, err := client.GetUser(ctx, nil)
387 | 		So(err, ShouldBeNil)
388 | 		So(ret, ShouldEqual, "go-doudou")
389 | 	})
390 | }
391 | 
392 | func TestCallbackOnChange(t *testing.T) {
393 | 	Convey("Environment variable GDD_MANAGE_USER should be changed", t, func() {
394 | 		listener := rest.NewHttpConfigListener()
395 | 		rest.CallbackOnChange(listener)(&configmgr.NacosChangeEvent{
396 | 			Namespace: "",
397 | 			Group:     "",
398 | 			DataId:    "",
399 | 			Changes: map[string]maputils.Change{
400 | 				"gdd.manage.user": {
401 | 					OldValue:   "admin",
402 | 					NewValue:   "go-doudou",
403 | 					ChangeType: maputils.MODIFIED,
404 | 				},
405 | 			},
406 | 		})
407 | 		So(config.GddManageUser.Load(), ShouldEqual, "")
408 | 		rest.CallbackOnChange(listener)(&configmgr.NacosChangeEvent{
409 | 			Namespace: "",
410 | 			Group:     "",
411 | 			DataId:    "",
412 | 			Changes: map[string]maputils.Change{
413 | 				"gdd.manage.user": {
414 | 					OldValue:   "admin",
415 | 					NewValue:   "go-doudou",
416 | 					ChangeType: maputils.MODIFIED,
417 | 				},
418 | 			},
419 | 		})
420 | 		So(config.GddManageUser.Load(), ShouldEqual, "go-doudou")
421 | 	})
422 | }
423 | 
424 | func Test_log_get_text(t *testing.T) {
425 | 	Convey("Should be equal to go-doudou", t, func() {
426 | 		config.GddLogReqEnable.Write("true")
427 | 		config.GddPort.Write("6063")
428 | 		go func() {
429 | 			srv := rest.NewRestServer()
430 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
431 | 			srv.Run()
432 | 		}()
433 | 		time.Sleep(10 * time.Millisecond)
434 | 		os.Setenv("RESTFUL", "http://localhost:6063")
435 | 		client := NewMockClient()
436 | 		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
437 | 		defer cancel()
438 | 		_, ret, err := client.GetUser(ctx, nil)
439 | 		So(err, ShouldBeNil)
440 | 		So(ret, ShouldEqual, "go-doudou")
441 | 	})
442 | }
443 | 
444 | func Test_log_post_json(t *testing.T) {
445 | 	Convey("Should be equal to OK", t, func() {
446 | 		config.GddLogReqEnable.Write("true")
447 | 		config.GddPort.Write("6064")
448 | 		go func() {
449 | 			srv := rest.NewRestServer()
450 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
451 | 			srv.Run()
452 | 		}()
453 | 		time.Sleep(10 * time.Millisecond)
454 | 		os.Setenv("RESTFUL", "http://localhost:6064")
455 | 		client := NewMockClient()
456 | 		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
457 | 		defer cancel()
458 | 		_, ret, err := client.SaveUser(ctx, nil, UserVo{
459 | 			Username: "go-doudou",
460 | 			Password: "go-doudou",
461 | 		})
462 | 		So(err, ShouldBeNil)
463 | 		So(ret, ShouldEqual, "OK")
464 | 	})
465 | }
466 | 
467 | func Test_log_post_formdata(t *testing.T) {
468 | 	Convey("Should be equal to OK", t, func() {
469 | 		config.GddLogReqEnable.Write("true")
470 | 		config.GddPort.Write("6065")
471 | 		go func() {
472 | 			srv := rest.NewRestServer()
473 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
474 | 			srv.Run()
475 | 		}()
476 | 		time.Sleep(10 * time.Millisecond)
477 | 		os.Setenv("RESTFUL", "http://localhost:6065")
478 | 		client := NewMockClient()
479 | 		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
480 | 		defer cancel()
481 | 		_, ret, err := client.SignUp(ctx, nil, "go-doudou", "go-doudou")
482 | 		So(err, ShouldBeNil)
483 | 		So(ret, ShouldEqual, "OK")
484 | 	})
485 | }
486 | 
487 | func Test_basicauth_401(t *testing.T) {
488 | 	Convey("Should return 401", t, func() {
489 | 		config.GddPort.Write("6066")
490 | 		config.GddManagePass.Write("admin")
491 | 		go func() {
492 | 			srv := rest.NewRestServer()
493 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
494 | 			srv.Run()
495 | 		}()
496 | 		time.Sleep(10 * time.Millisecond)
497 | 		resp, err := http.Get("http://localhost:6066/go-doudou/config")
498 | 		So(err, ShouldBeNil)
499 | 		So(resp.StatusCode, ShouldEqual, 401)
500 | 	})
501 | }
502 | 
503 | func Test_basicauth_200(t *testing.T) {
504 | 	Convey("Should return 200", t, func() {
505 | 		config.GddPort.Write("6066")
506 | 		config.GddManageUser.Write("admin")
507 | 		config.GddManagePass.Write("admin")
508 | 		go func() {
509 | 			srv := rest.NewRestServer()
510 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
511 | 			srv.Run()
512 | 		}()
513 | 		time.Sleep(10 * time.Millisecond)
514 | 		resp, err := http.Get("http://admin:admin@localhost:6066/go-doudou/config")
515 | 		So(err, ShouldBeNil)
516 | 		So(resp.StatusCode, ShouldEqual, 200)
517 | 	})
518 | }
519 | 
520 | func Test_recovery(t *testing.T) {
521 | 	Convey("Should recovery from panic", t, func() {
522 | 		config.GddPort.Write("6067")
523 | 		go func() {
524 | 			srv := rest.NewRestServer()
525 | 			srv.AddRoute(Routes(NewMocksvcHandler())...)
[TRUNCATED]
```

framework/rest/model.go
```
1 | package rest
2 | 
3 | import (
4 | 	"bytes"
5 | 	"io"
6 | 	"io/ioutil"
7 | 	"net/http"
8 | 	"net/http/httptest"
9 | 	"net/url"
10 | 	"strings"
11 | 
12 | 	"github.com/pkg/errors"
13 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
14 | )
15 | 
16 | // Route wraps config for route
17 | type Route struct {
18 | 	Name        string
19 | 	Method      string
20 | 	Pattern     string
21 | 	HandlerFunc http.HandlerFunc
22 | }
23 | 
24 | // borrowed from httputil unexported function drainBody
25 | func CopyReqBody(b io.ReadCloser) (r1, r2 io.ReadCloser, err error) {
26 | 	if b == nil || b == http.NoBody {
27 | 		// No copying needed. Preserve the magic sentinel meaning of NoBody.
28 | 		return http.NoBody, http.NoBody, nil
29 | 	}
30 | 	var buf bytes.Buffer
31 | 	if _, err = buf.ReadFrom(b); err != nil {
32 | 		return nil, b, err
33 | 	}
34 | 	if err = b.Close(); err != nil {
35 | 		return nil, b, err
36 | 	}
37 | 	return ioutil.NopCloser(&buf), ioutil.NopCloser(bytes.NewReader(buf.Bytes())), nil
38 | }
39 | 
40 | func CopyRespBody(b *bytes.Buffer) (b1, b2 *bytes.Buffer, err error) {
41 | 	if b == nil {
42 | 		return
43 | 	}
44 | 	var buf bytes.Buffer
45 | 	if _, err = buf.ReadFrom(b); err != nil {
46 | 		return nil, b, err
47 | 	}
48 | 	return &buf, bytes.NewBuffer(buf.Bytes()), nil
49 | }
50 | 
51 | func JsonMarshalIndent(data interface{}, prefix, indent string, disableHTMLEscape bool) (string, error) {
52 | 	b := &bytes.Buffer{}
53 | 	encoder := json.NewEncoder(b)
54 | 	encoder.SetEscapeHTML(!disableHTMLEscape)
55 | 	encoder.SetIndent(prefix, indent)
56 | 	if err := encoder.Encode(data); err != nil {
57 | 		return "", errors.Errorf("failed to marshal data to JSON, %s", err)
58 | 	}
59 | 	return b.String(), nil
60 | }
61 | 
62 | func GetReqBody(cp io.ReadCloser, r *http.Request) string {
63 | 	var contentType string
64 | 	if len(r.Header["Content-Type"]) > 0 {
65 | 		contentType = r.Header["Content-Type"][0]
66 | 	}
67 | 	var reqBody string
68 | 	if cp != nil {
69 | 		if strings.Contains(contentType, "multipart/form-data") {
70 | 			r.Body = cp
71 | 			if err := r.ParseMultipartForm(32 << 20); err == nil {
72 | 				reqBody = r.Form.Encode()
73 | 				if unescape, err := url.QueryUnescape(reqBody); err == nil {
74 | 					reqBody = unescape
75 | 				}
76 | 			} else {
77 | 				logger.Error().Err(err).Msg("call r.ParseMultipartForm(32 << 20) error")
78 | 			}
79 | 		} else if strings.Contains(contentType, "application/json") {
80 | 			data := make(map[string]interface{})
81 | 			if err := json.NewDecoder(cp).Decode(&data); err == nil {
82 | 				b, _ := json.MarshalIndent(data, "", "    ")
83 | 				reqBody = string(b)
84 | 			} else {
85 | 				logger.Error().Err(err).Msg("call json.NewDecoder(reqBodyCopy).Decode(&data) error")
86 | 			}
87 | 		} else {
88 | 			var buf bytes.Buffer
89 | 			if _, err := buf.ReadFrom(cp); err == nil {
90 | 				data := []rune(buf.String())
91 | 				end := len(data)
92 | 				if end > 1000 {
93 | 					end = 1000
94 | 				}
95 | 				reqBody = string(data[:end])
96 | 				if strings.Contains(contentType, "application/x-www-form-urlencoded") {
97 | 					if unescape, err := url.QueryUnescape(reqBody); err == nil {
98 | 						reqBody = unescape
99 | 					}
100 | 				}
101 | 			} else {
102 | 				logger.Error().Err(err).Msg("call buf.ReadFrom(reqBodyCopy) error")
103 | 			}
104 | 		}
105 | 	}
106 | 	return reqBody
107 | }
108 | 
109 | func GetRespBody(rec *httptest.ResponseRecorder) string {
110 | 	var (
111 | 		respBody string
112 | 		err      error
113 | 	)
114 | 	if strings.Contains(rec.Result().Header.Get("Content-Type"), "application/json") {
115 | 		var respBodyCopy *bytes.Buffer
116 | 		if respBodyCopy, rec.Body, err = CopyRespBody(rec.Body); err == nil {
117 | 			data := make(map[string]interface{})
118 | 			if err := json.NewDecoder(rec.Body).Decode(&data); err == nil {
119 | 				b, _ := json.MarshalIndent(data, "", "    ")
120 | 				respBody = string(b)
121 | 			} else {
122 | 				logger.Error().Err(err).Msg("call json.NewDecoder(rec.Body).Decode(&data) error")
123 | 			}
124 | 		} else {
125 | 			logger.Error().Err(err).Msg("call respBodyCopy.ReadFrom(rec.Body) error")
126 | 		}
127 | 		rec.Body = respBodyCopy
128 | 	} else {
129 | 		data := []rune(rec.Body.String())
130 | 		end := len(data)
131 | 		if end > 1000 {
132 | 			end = 1000
133 | 		}
134 | 		respBody = string(data[:end])
135 | 	}
136 | 	return respBody
137 | }
```

framework/rest/pprof.go
```
1 | // Copyright 2010 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | // Package rest serves via its HTTP server runtime profiling data
6 | // in the format expected by the pprof visualization tool.
7 | //
8 | // The package is typically only imported for the side effect of
9 | // registering its HTTP handlers.
10 | // The handled paths all begin with /debug/pprof/.
11 | //
12 | // To use pprof, link this package into your program:
13 | //
14 | //	import _ "net/http/pprof"
15 | //
16 | // If your application is not already running an http server, you
17 | // need to start one. Add "net/http" and "log" to your imports and
18 | // the following code to your main function:
19 | //
20 | //	go func() {
21 | //		log2.Println(http.ListenAndServe("localhost:6060", nil))
22 | //	}()
23 | //
24 | // By default, all the profiles listed in [runtime/pprof.Profile] are
25 | // available (via [Handler]), in addition to the [Cmdline], [Profile], [Symbol],
26 | // and [Trace] profiles defined in this package.
27 | // If you are not using DefaultServeMux, you will have to register handlers
28 | // with the mux you are using.
29 | //
30 | // # Parameters
31 | //
32 | // Parameters can be passed via GET query params:
33 | //
34 | //   - debug=N (all profiles): response format: N = 0: binary (default), N > 0: plaintext
35 | //   - gc=N (heap profile): N > 0: run a garbage collection cycle before profiling
36 | //   - seconds=N (allocs, block, goroutine, heap, mutex, threadcreate profiles): return a delta profile
37 | //   - seconds=N (cpu (profile), trace profiles): profile for the given duration
38 | //
39 | // # Usage examples
40 | //
41 | // Use the pprof tool to look at the heap profile:
42 | //
43 | //	go tool pprof http://localhost:6060/debug/pprof/heap
44 | //
45 | // Or to look at a 30-second CPU profile:
46 | //
47 | //	go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30
48 | //
49 | // Or to look at the goroutine blocking profile, after calling
50 | // [runtime.SetBlockProfileRate] in your program:
51 | //
52 | //	go tool pprof http://localhost:6060/debug/pprof/block
53 | //
54 | // Or to look at the holders of contended mutexes, after calling
55 | // [runtime.SetMutexProfileFraction] in your program:
56 | //
57 | //	go tool pprof http://localhost:6060/debug/pprof/mutex
58 | //
59 | // The package also exports a handler that serves execution trace data
60 | // for the "go tool trace" command. To collect a 5-second execution trace:
61 | //
62 | //	curl -o trace.out http://localhost:6060/debug/pprof/trace?seconds=5
63 | //	go tool trace trace.out
64 | //
65 | // To view all available profiles, open http://localhost:6060/debug/pprof/
66 | // in your browser.
67 | //
68 | // For a study of the facility in action, visit
69 | // https://blog.golang.org/2011/06/profiling-go-programs.html.
70 | package rest
71 | 
72 | import (
73 | 	"bufio"
74 | 	"bytes"
75 | 	"context"
76 | 	"fmt"
77 | 	"html"
78 | 	"io"
79 | 	log2 "log"
80 | 	"net/http"
81 | 	"net/url"
82 | 	"os"
83 | 	"runtime"
84 | 	"runtime/pprof"
85 | 	"runtime/trace"
86 | 	"sort"
87 | 	"strconv"
88 | 	"strings"
89 | 	"time"
90 | 
91 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
92 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest/profile"
93 | )
94 | 
95 | func init() {
96 | 	http.HandleFunc(config.GddConfig.RouteRootPath+"/debug/pprof/", Index)
97 | 	http.HandleFunc(config.GddConfig.RouteRootPath+"/debug/pprof/cmdline", Cmdline)
98 | 	http.HandleFunc(config.GddConfig.RouteRootPath+"/debug/pprof/profile", Profile)
99 | 	http.HandleFunc(config.GddConfig.RouteRootPath+"/debug/pprof/symbol", Symbol)
100 | 	http.HandleFunc(config.GddConfig.RouteRootPath+"/debug/pprof/trace", Trace)
101 | }
102 | 
103 | // Cmdline responds with the running program's
104 | // command line, with arguments separated by NUL bytes.
105 | // The package initialization registers it as /debug/pprof/cmdline.
106 | func Cmdline(w http.ResponseWriter, r *http.Request) {
107 | 	w.Header().Set("X-Content-Type-Options", "nosniff")
108 | 	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
109 | 	fmt.Fprint(w, strings.Join(os.Args, "\x00"))
110 | }
111 | 
112 | func sleep(r *http.Request, d time.Duration) {
113 | 	select {
114 | 	case <-time.After(d):
115 | 	case <-r.Context().Done():
116 | 	}
117 | }
118 | 
119 | func durationExceedsWriteTimeout(r *http.Request, seconds float64) bool {
120 | 	srv, ok := r.Context().Value(http.ServerContextKey).(*http.Server)
121 | 	return ok && srv.WriteTimeout != 0 && seconds >= srv.WriteTimeout.Seconds()
122 | }
123 | 
124 | func serveError(w http.ResponseWriter, status int, txt string) {
125 | 	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
126 | 	w.Header().Set("X-Go-Pprof", "1")
127 | 	w.Header().Del("Content-Disposition")
128 | 	w.WriteHeader(status)
129 | 	fmt.Fprintln(w, txt)
130 | }
131 | 
132 | // Profile responds with the pprof-formatted cpu profile.
133 | // Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
134 | // The package initialization registers it as /debug/pprof/profile.
135 | func Profile(w http.ResponseWriter, r *http.Request) {
136 | 	w.Header().Set("X-Content-Type-Options", "nosniff")
137 | 	sec, err := strconv.ParseInt(r.FormValue("seconds"), 10, 64)
138 | 	if sec <= 0 || err != nil {
139 | 		sec = 30
140 | 	}
141 | 
142 | 	if durationExceedsWriteTimeout(r, float64(sec)) {
143 | 		serveError(w, http.StatusBadRequest, "profile duration exceeds server's WriteTimeout")
144 | 		return
145 | 	}
146 | 
147 | 	// Set Content Type assuming StartCPUProfile will work,
148 | 	// because if it does it starts writing.
149 | 	w.Header().Set("Content-Type", "application/octet-stream")
150 | 	w.Header().Set("Content-Disposition", `attachment; filename="profile"`)
151 | 	if err := pprof.StartCPUProfile(w); err != nil {
152 | 		// StartCPUProfile failed, so no writes yet.
153 | 		serveError(w, http.StatusInternalServerError,
154 | 			fmt.Sprintf("Could not enable CPU profiling: %s", err))
155 | 		return
156 | 	}
157 | 	sleep(r, time.Duration(sec)*time.Second)
158 | 	pprof.StopCPUProfile()
159 | }
160 | 
161 | // Trace responds with the execution trace in binary form.
162 | // Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
163 | // The package initialization registers it as /debug/pprof/trace.
164 | func Trace(w http.ResponseWriter, r *http.Request) {
165 | 	w.Header().Set("X-Content-Type-Options", "nosniff")
166 | 	sec, err := strconv.ParseFloat(r.FormValue("seconds"), 64)
167 | 	if sec <= 0 || err != nil {
168 | 		sec = 1
169 | 	}
170 | 
171 | 	if durationExceedsWriteTimeout(r, sec) {
172 | 		serveError(w, http.StatusBadRequest, "profile duration exceeds server's WriteTimeout")
173 | 		return
174 | 	}
175 | 
176 | 	// Set Content Type assuming trace.Start will work,
177 | 	// because if it does it starts writing.
178 | 	w.Header().Set("Content-Type", "application/octet-stream")
179 | 	w.Header().Set("Content-Disposition", `attachment; filename="trace"`)
180 | 	if err := trace.Start(w); err != nil {
181 | 		// trace.Start failed, so no writes yet.
182 | 		serveError(w, http.StatusInternalServerError,
183 | 			fmt.Sprintf("Could not enable tracing: %s", err))
184 | 		return
185 | 	}
186 | 	sleep(r, time.Duration(sec*float64(time.Second)))
187 | 	trace.Stop()
188 | }
189 | 
190 | // Symbol looks up the program counters listed in the request,
191 | // responding with a table mapping program counters to function names.
192 | // The package initialization registers it as /debug/pprof/symbol.
193 | func Symbol(w http.ResponseWriter, r *http.Request) {
194 | 	w.Header().Set("X-Content-Type-Options", "nosniff")
195 | 	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
196 | 
197 | 	// We have to read the whole POST body before
198 | 	// writing any output. Buffer the output here.
199 | 	var buf bytes.Buffer
200 | 
201 | 	// We don't know how many symbols we have, but we
202 | 	// do have symbol information. Pprof only cares whether
203 | 	// this number is 0 (no symbols available) or > 0.
204 | 	fmt.Fprintf(&buf, "num_symbols: 1\n")
205 | 
206 | 	var b *bufio.Reader
207 | 	if r.Method == "POST" {
208 | 		b = bufio.NewReader(r.Body)
209 | 	} else {
210 | 		b = bufio.NewReader(strings.NewReader(r.URL.RawQuery))
211 | 	}
212 | 
213 | 	for {
214 | 		word, err := b.ReadSlice('+')
215 | 		if err == nil {
216 | 			word = word[0 : len(word)-1] // trim +
217 | 		}
218 | 		pc, _ := strconv.ParseUint(string(word), 0, 64)
219 | 		if pc != 0 {
220 | 			f := runtime.FuncForPC(uintptr(pc))
221 | 			if f != nil {
222 | 				fmt.Fprintf(&buf, "%#x %s\n", pc, f.Name())
223 | 			}
224 | 		}
225 | 
226 | 		// Wait until here to check for err; the last
227 | 		// symbol will have an err because it doesn't end in +.
228 | 		if err != nil {
229 | 			if err != io.EOF {
230 | 				fmt.Fprintf(&buf, "reading request: %v\n", err)
231 | 			}
232 | 			break
233 | 		}
234 | 	}
235 | 
236 | 	w.Write(buf.Bytes())
237 | }
238 | 
239 | // Handler returns an HTTP handler that serves the named profile.
240 | // Available profiles can be found in [runtime/pprof.Profile].
241 | func Handler(name string) http.Handler {
242 | 	return handler(name)
243 | }
244 | 
245 | type handler string
246 | 
247 | func (name handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
248 | 	w.Header().Set("X-Content-Type-Options", "nosniff")
249 | 	p := pprof.Lookup(string(name))
250 | 	if p == nil {
251 | 		serveError(w, http.StatusNotFound, "Unknown profile")
252 | 		return
253 | 	}
254 | 	if sec := r.FormValue("seconds"); sec != "" {
255 | 		name.serveDeltaProfile(w, r, p, sec)
256 | 		return
257 | 	}
258 | 	gc, _ := strconv.Atoi(r.FormValue("gc"))
259 | 	if name == "heap" && gc > 0 {
260 | 		runtime.GC()
261 | 	}
262 | 	debug, _ := strconv.Atoi(r.FormValue("debug"))
263 | 	if debug != 0 {
264 | 		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
265 | 	} else {
266 | 		w.Header().Set("Content-Type", "application/octet-stream")
267 | 		w.Header().Set("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, name))
268 | 	}
269 | 	p.WriteTo(w, debug)
270 | }
271 | 
272 | func (name handler) serveDeltaProfile(w http.ResponseWriter, r *http.Request, p *pprof.Profile, secStr string) {
273 | 	sec, err := strconv.ParseInt(secStr, 10, 64)
274 | 	if err != nil || sec <= 0 {
275 | 		serveError(w, http.StatusBadRequest, `invalid value for "seconds" - must be a positive integer`)
276 | 		return
277 | 	}
278 | 	if !profileSupportsDelta[name] {
279 | 		serveError(w, http.StatusBadRequest, `"seconds" parameter is not supported for this profile type`)
280 | 		return
281 | 	}
282 | 	// 'name' should be a key in profileSupportsDelta.
283 | 	if durationExceedsWriteTimeout(r, float64(sec)) {
284 | 		serveError(w, http.StatusBadRequest, "profile duration exceeds server's WriteTimeout")
285 | 		return
286 | 	}
287 | 	debug, _ := strconv.Atoi(r.FormValue("debug"))
288 | 	if debug != 0 {
289 | 		serveError(w, http.StatusBadRequest, "seconds and debug params are incompatible")
290 | 		return
291 | 	}
292 | 	p0, err := collectProfile(p)
293 | 	if err != nil {
294 | 		serveError(w, http.StatusInternalServerError, "failed to collect profile")
295 | 		return
296 | 	}
297 | 
298 | 	t := time.NewTimer(time.Duration(sec) * time.Second)
299 | 	defer t.Stop()
300 | 
301 | 	select {
302 | 	case <-r.Context().Done():
303 | 		err := r.Context().Err()
304 | 		if err == context.DeadlineExceeded {
305 | 			serveError(w, http.StatusRequestTimeout, err.Error())
306 | 		} else { // TODO: what's a good status code for canceled requests? 400?
307 | 			serveError(w, http.StatusInternalServerError, err.Error())
308 | 		}
309 | 		return
310 | 	case <-t.C:
311 | 	}
312 | 
313 | 	p1, err := collectProfile(p)
314 | 	if err != nil {
315 | 		serveError(w, http.StatusInternalServerError, "failed to collect profile")
316 | 		return
317 | 	}
318 | 	ts := p1.TimeNanos
319 | 	dur := p1.TimeNanos - p0.TimeNanos
320 | 
321 | 	p0.Scale(-1)
322 | 
323 | 	p1, err = profile.Merge([]*profile.Profile{p0, p1})
324 | 	if err != nil {
325 | 		serveError(w, http.StatusInternalServerError, "failed to compute delta")
326 | 		return
327 | 	}
328 | 
329 | 	p1.TimeNanos = ts // set since we don't know what profile.Merge set for TimeNanos.
330 | 	p1.DurationNanos = dur
331 | 
332 | 	w.Header().Set("Content-Type", "application/octet-stream")
333 | 	w.Header().Set("Content-Disposition", fmt.Sprintf(`attachment; filename="%s-delta"`, name))
334 | 	p1.Write(w)
335 | }
336 | 
337 | func collectProfile(p *pprof.Profile) (*profile.Profile, error) {
338 | 	var buf bytes.Buffer
339 | 	if err := p.WriteTo(&buf, 0); err != nil {
340 | 		return nil, err
341 | 	}
342 | 	ts := time.Now().UnixNano()
343 | 	p0, err := profile.Parse(&buf)
344 | 	if err != nil {
345 | 		return nil, err
346 | 	}
347 | 	p0.TimeNanos = ts
348 | 	return p0, nil
349 | }
350 | 
351 | var profileSupportsDelta = map[handler]bool{
352 | 	"allocs":       true,
353 | 	"block":        true,
354 | 	"goroutine":    true,
355 | 	"heap":         true,
356 | 	"mutex":        true,
357 | 	"threadcreate": true,
358 | }
359 | 
360 | var profileDescriptions = map[string]string{
361 | 	"allocs":       "A sampling of all past memory allocations",
362 | 	"block":        "Stack traces that led to blocking on synchronization primitives",
363 | 	"cmdline":      "The command line invocation of the current program",
364 | 	"goroutine":    "Stack traces of all current goroutines. Use debug=2 as a query parameter to export in the same format as an unrecovered panic.",
365 | 	"heap":         "A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample.",
366 | 	"mutex":        "Stack traces of holders of contended mutexes",
367 | 	"profile":      "CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile.",
368 | 	"threadcreate": "Stack traces that led to the creation of new OS threads",
369 | 	"trace":        "A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace.",
370 | }
371 | 
372 | type profileEntry struct {
373 | 	Name  string
374 | 	Href  string
375 | 	Desc  string
376 | 	Count int
377 | }
378 | 
379 | // Index responds with the pprof-formatted profile named by the request.
380 | // For example, config.GddConfig.RouteRootPath + "/debug/pprof/heap" serves the "heap" profile.
381 | // Index responds to a request for config.GddConfig.RouteRootPath + "/debug/pprof/" with an HTML page
382 | // listing the available profiles.
383 | func Index(w http.ResponseWriter, r *http.Request) {
384 | 	if name, found := strings.CutPrefix(r.URL.Path, config.GddConfig.RouteRootPath+"/debug/pprof/"); found {
385 | 		if name != "" {
386 | 			handler(name).ServeHTTP(w, r)
387 | 			return
388 | 		}
389 | 	}
390 | 
391 | 	w.Header().Set("X-Content-Type-Options", "nosniff")
392 | 	w.Header().Set("Content-Type", "text/html; charset=utf-8")
393 | 
394 | 	var profiles []profileEntry
395 | 	for _, p := range pprof.Profiles() {
396 | 		profiles = append(profiles, profileEntry{
397 | 			Name:  p.Name(),
398 | 			Href:  p.Name(),
399 | 			Desc:  profileDescriptions[p.Name()],
400 | 			Count: p.Count(),
401 | 		})
402 | 	}
403 | 
404 | 	// Adding other profiles exposed from within this package
405 | 	for _, p := range []string{"cmdline", "profile", "trace"} {
406 | 		profiles = append(profiles, profileEntry{
407 | 			Name: p,
408 | 			Href: p,
409 | 			Desc: profileDescriptions[p],
410 | 		})
411 | 	}
412 | 
413 | 	sort.Slice(profiles, func(i, j int) bool {
414 | 		return profiles[i].Name < profiles[j].Name
415 | 	})
416 | 
417 | 	if err := indexTmplExecute(w, profiles); err != nil {
418 | 		log2.Print(err)
419 | 	}
420 | }
421 | 
422 | func indexTmplExecute(w io.Writer, profiles []profileEntry) error {
423 | 	var b bytes.Buffer
424 | 	b.WriteString(`<html>
425 | <head>
426 | <title>/debug/pprof/</title>
427 | <style>
428 | .profile-name{
429 | 	display:inline-block;
430 | 	width:6rem;
431 | }
432 | </style>
433 | </head>
434 | <body>
435 | /debug/pprof/
436 | <br>
[TRUNCATED]
```

framework/rest/promhandler.go
```
1 | package rest
2 | 
3 | import (
4 | 	"github.com/prometheus/client_golang/prometheus/promhttp"
5 | )
6 | 
7 | var PromRoutes = promRoutes
8 | 
9 | func promRoutes() []Route {
10 | 	return []Route{
11 | 		{
12 | 			Name:        "Prometheus",
13 | 			Method:      "GET",
14 | 			Pattern:     "/go-doudou/prometheus",
15 | 			HandlerFunc: promhttp.Handler().ServeHTTP,
16 | 		},
17 | 	}
18 | }
```

framework/rest/prommiddleware.go
```
1 | package rest
2 | 
3 | // borrow code from https://github.com/TannerGabriel/learning-go/tree/master/advanced-programs/PrometheusHTTPServer
4 | // Many thanks to TannerGabriel https://github.com/TannerGabriel
5 | // Post link https://gabrieltanner.org/blog/collecting-prometheus-metrics-in-golang written by TannerGabriel
6 | import (
7 | 	"net/http"
8 | 	"runtime"
9 | 	"strconv"
10 | 	"time"
11 | 
12 | 	"github.com/prometheus/client_golang/prometheus"
13 | 	"github.com/unionj-cloud/go-doudou/v2/framework/buildinfo"
14 | 	"github.com/unionj-cloud/toolkit/constants"
15 | 	"github.com/unionj-cloud/toolkit/stringutils"
16 | )
17 | 
18 | type responseWriter struct {
19 | 	http.ResponseWriter
20 | 	statusCode int
21 | }
22 | 
23 | // NewResponseWriter creates new responseWriter
24 | func NewResponseWriter(w http.ResponseWriter) *responseWriter {
25 | 	return &responseWriter{w, http.StatusOK}
26 | }
27 | 
28 | // WriteHeader set header to code
29 | func (rw *responseWriter) WriteHeader(code int) {
30 | 	rw.statusCode = code
31 | 	rw.ResponseWriter.WriteHeader(code)
32 | }
33 | 
34 | var countRequests = prometheus.NewCounterVec(
35 | 	prometheus.CounterOpts{
36 | 		Name: "go_doudou_http_request_count",
37 | 		Help: "Number of http requests.",
38 | 	},
39 | 	[]string{"path", "method", "status"},
40 | )
41 | 
42 | var httpDuration = prometheus.NewHistogramVec(prometheus.HistogramOpts{
43 | 	Name: "go_doudou_http_response_time_seconds",
44 | 	Help: "Duration of HTTP requests.",
45 | }, []string{"path", "method"})
46 | 
47 | // PrometheusMiddleware returns http HandlerFunc for prometheus matrix
48 | func PrometheusMiddleware(next http.Handler) http.Handler {
49 | 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
50 | 		path := r.URL.Path
51 | 		method := r.Method
52 | 		timer := prometheus.NewTimer(httpDuration.WithLabelValues(path, method))
53 | 
54 | 		rw := NewResponseWriter(w)
55 | 		next.ServeHTTP(rw, r)
56 | 
57 | 		statusCode := rw.statusCode
58 | 
59 | 		countRequests.WithLabelValues(path, method, strconv.Itoa(statusCode)).Inc()
60 | 
61 | 		timer.ObserveDuration()
62 | 	})
63 | }
64 | 
65 | func init() {
66 | 	prometheus.Register(countRequests)
67 | 	prometheus.Register(httpDuration)
68 | 	buildTime := buildinfo.BuildTime
69 | 	if stringutils.IsNotEmpty(buildinfo.BuildTime) {
70 | 		if t, err := time.Parse(constants.FORMAT15, buildinfo.BuildTime); err == nil {
71 | 			buildTime = t.Local().Format(constants.FORMAT8)
72 | 		}
73 | 	}
74 | 	appInfo := prometheus.NewGauge(prometheus.GaugeOpts{
75 | 		Name: "go_doudou_app_info",
76 | 		Help: "Information about the go-doudou app",
77 | 		ConstLabels: prometheus.Labels{
78 | 			"goVer":     runtime.Version(),
79 | 			"gddVer":    buildinfo.GddVer,
80 | 			"buildUser": buildinfo.BuildUser,
81 | 			"buildTime": buildTime,
82 | 		},
83 | 	})
84 | 	appInfo.Set(1)
85 | 	prometheus.Register(appInfo)
86 | 
87 | 	prometheus.Register(prometheus.NewGaugeFunc(prometheus.GaugeOpts{
88 | 		Name:        "go_doudou_gomaxprocs",
89 | 		Help:        "The value of gomaxprocs",
90 | 		ConstLabels: nil,
91 | 	}, func() float64 {
92 | 		return float64(runtime.GOMAXPROCS(0))
93 | 	}))
94 | 
95 | 	prometheus.Register(prometheus.NewGaugeFunc(prometheus.GaugeOpts{
96 | 		Name:        "go_doudou_numcpu",
97 | 		Help:        "The value of numcpu",
98 | 		ConstLabels: nil,
99 | 	}, func() float64 {
100 | 		return float64(runtime.NumCPU())
101 | 	}))
102 | }
```

framework/rest/server.go
```
1 | package rest
2 | 
3 | import (
4 | 	"context"
5 | 	"io/fs"
6 | 	"net"
7 | 	"net/http"
8 | 	"os"
9 | 	"os/signal"
10 | 	"path"
11 | 	"strings"
12 | 	"time"
13 | 
14 | 	"github.com/arl/statsviz"
15 | 	"github.com/ascarter/requestid"
16 | 	mapset "github.com/deckarep/golang-set/v2"
17 | 	"github.com/gorilla/handlers"
18 | 	"github.com/iancoleman/strcase"
19 | 	"github.com/klauspost/compress/gzhttp"
20 | 	"github.com/olekukonko/tablewriter"
21 | 	"github.com/samber/lo"
22 | 	"github.com/unionj-cloud/go-doudou/v2/framework"
23 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
24 | 	register "github.com/unionj-cloud/go-doudou/v2/framework/registry"
25 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/constants"
26 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest/httprouter"
27 | 	"github.com/unionj-cloud/toolkit/stringutils"
28 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
29 | )
30 | 
31 | type MiddlewareFunc func(http.Handler) http.Handler
32 | 
33 | // Middleware allows MiddlewareFunc to implement the middleware interface.
34 | func (mw MiddlewareFunc) Middleware(handler http.Handler) http.Handler {
35 | 	return mw(handler)
36 | }
37 | 
38 | var startAt time.Time
39 | 
40 | func init() {
41 | 	startAt = time.Now()
42 | }
43 | 
44 | const gddPathPrefix = "/go-doudou/"
45 | const debugPathPrefix = "/debug/"
46 | 
47 | var contentTypeShouldbeGzip []string
48 | 
49 | func init() {
50 | 	contentTypeShouldbeGzip = []string{
51 | 		"text/html",
52 | 		"text/css",
53 | 		"text/plain",
54 | 		"text/xml",
55 | 		"text/x-component",
56 | 		"text/javascript",
57 | 		"application/x-javascript",
58 | 		"application/javascript",
59 | 		"application/json",
60 | 		"application/manifest+json",
61 | 		"application/vnd.api+json",
62 | 		"application/xml",
63 | 		"application/xhtml+xml",
64 | 		"application/rss+xml",
65 | 		"application/atom+xml",
66 | 		"application/vnd.ms-fontobject",
67 | 		"application/x-font-ttf",
68 | 		"application/x-font-opentype",
69 | 		"application/x-font-truetype",
70 | 		"image/svg+xml",
71 | 		"image/x-icon",
72 | 		"image/vnd.microsoft.icon",
73 | 		"font/ttf",
74 | 		"font/eot",
75 | 		"font/otf",
76 | 		"font/opentype",
77 | 	}
78 | }
79 | 
80 | // MiddlewareFunc is alias for func(http.Handler) http.Handler
81 | func toMiddlewareFunc(m func(http.Handler) http.HandlerFunc) MiddlewareFunc {
82 | 	return func(handler http.Handler) http.Handler {
83 | 		return m(handler)
84 | 	}
85 | }
86 | 
87 | // RestServer wraps httpRouter router
88 | type RestServer struct {
89 | 	bizRouter    *httprouter.RouteGroup
90 | 	rootRouter   *httprouter.Router
91 | 	gddRoutes    []Route
92 | 	debugRoutes  []Route
93 | 	bizRoutes    []Route
94 | 	middlewares  []MiddlewareFunc
95 | 	data         map[string]interface{}
96 | 	panicHandler func(inner http.Handler) http.Handler
97 | 	*http.Server
98 | }
99 | 
100 | func path2key(method, path string) string {
101 | 	var sb strings.Builder
102 | 	sb.WriteString(method)
103 | 	sb.WriteString(":")
104 | 	sb.WriteString(path)
105 | 	return sb.String()
106 | }
107 | 
108 | func (srv *RestServer) printRoutes() {
109 | 	if !config.CheckDev() {
110 | 		return
111 | 	}
112 | 	logger.Info().Msg("================ Registered Routes ================")
113 | 	data := [][]string{}
114 | 	var all []Route
115 | 	all = append(all, srv.bizRoutes...)
116 | 	all = append(all, srv.gddRoutes...)
117 | 	all = append(all, srv.debugRoutes...)
118 | 	routes := make(map[string]struct{})
119 | 	for _, r := range all {
120 | 		key := path2key(r.Method, r.Pattern)
121 | 		_, ok := routes[key]
122 | 		if !ok {
123 | 			routes[key] = struct{}{}
124 | 			data = append(data, []string{r.Name, r.Method, path.Clean(r.Pattern)})
125 | 		}
126 | 	}
127 | 	tableString := &strings.Builder{}
128 | 	table := tablewriter.NewWriter(tableString)
129 | 	table.SetHeader([]string{"Name", "Method", "Pattern"})
130 | 	for _, v := range data {
131 | 		table.Append(v)
132 | 	}
133 | 	table.Render() // Send output
134 | 	rows := strings.Split(strings.TrimSpace(tableString.String()), "\n")
135 | 	for _, row := range rows {
136 | 		logger.Info().Msg(row)
137 | 	}
138 | 	logger.Info().Msg("===================================================")
139 | }
140 | 
141 | // NewRestServer create a RestServer instance
142 | func NewRestServer(data ...map[string]interface{}) *RestServer {
143 | 	var options []ServerOption
144 | 	if len(data) > 0 {
145 | 		options = append(options, WithUserData(data[0]))
146 | 	}
147 | 	return NewRestServerWithOptions(options...)
148 | }
149 | 
150 | type ServerOption func(server *RestServer)
151 | 
152 | func WithPanicHandler(panicHandler func(inner http.Handler) http.Handler) ServerOption {
153 | 	return func(server *RestServer) {
154 | 		server.panicHandler = panicHandler
155 | 	}
156 | }
157 | 
158 | func WithUserData(userData map[string]interface{}) ServerOption {
159 | 	return func(server *RestServer) {
160 | 		server.data = userData
161 | 	}
162 | }
163 | 
164 | // NewRestServerWithOptions create a RestServer instance with options
165 | func NewRestServerWithOptions(options ...ServerOption) *RestServer {
166 | 	rootRouter := httprouter.New()
167 | 	rootRouter.SaveMatchedRoutePath = true
168 | 	srv := &RestServer{
169 | 		bizRouter:    rootRouter.NewGroup(config.GddConfig.RouteRootPath),
170 | 		rootRouter:   rootRouter,
171 | 		panicHandler: recovery,
172 | 		Server: &http.Server{
173 | 			// Good practice to set timeouts to avoid Slowloris attacks.
174 | 			WriteTimeout: config.GddConfig.WriteTimeout,
175 | 			ReadTimeout:  config.GddConfig.ReadTimeout,
176 | 			IdleTimeout:  config.GddConfig.IdleTimeout,
177 | 			Handler:      rootRouter, // Pass our instance of httprouter.Router in.
178 | 		},
179 | 	}
180 | 	for _, fn := range options {
181 | 		fn(srv)
182 | 	}
183 | 	srv.middlewares = append(srv.middlewares,
184 | 		srv.panicHandler,
185 | 		tracing,
186 | 		metrics,
187 | 		gzipBody,
188 | 	)
189 | 	if config.GddConfig.EnableResponseGzip {
190 | 		gzipMiddleware, err := gzhttp.NewWrapper(gzhttp.ContentTypes(contentTypeShouldbeGzip))
191 | 		if err != nil {
192 | 			panic(err)
193 | 		}
194 | 		srv.middlewares = append(srv.middlewares, toMiddlewareFunc(gzipMiddleware))
195 | 	}
196 | 	if config.GddConfig.LogReqEnable {
197 | 		srv.middlewares = append(srv.middlewares, log)
198 | 	}
199 | 	srv.middlewares = append(srv.middlewares,
200 | 		requestid.RequestIDHandler,
201 | 		handlers.ProxyHeaders,
202 | 	)
203 | 	if config.GddConfig.ManageEnable {
204 | 		srv.middlewares = append([]MiddlewareFunc{PrometheusMiddleware}, srv.middlewares...)
205 | 		basicAuthMiddle := MiddlewareFunc(basicAuth())
206 | 		gddmiddlewares := []MiddlewareFunc{metrics, basicAuthMiddle}
207 | 		srv.gddRoutes = append(srv.gddRoutes, promRoutes()...)
208 | 		srv.gddRoutes = append(srv.gddRoutes, configRoutes()...)
209 | 		if _, ok := config.ServiceDiscoveryMap()[constants.SD_MEMBERLIST]; ok {
210 | 			srv.gddRoutes = append(srv.gddRoutes, MemberlistUIRoutes()...)
211 | 		}
212 | 		freq, err := time.ParseDuration(config.GddStatsFreq.Load())
213 | 		if err != nil {
214 | 			logger.Debug().Msgf("Parse %s %s as time.Duration failed: %s, use default %s instead.\n", string(config.GddStatsFreq),
215 | 				config.GddStatsFreq.Load(), err.Error(), config.DefaultGddStatsFreq)
216 | 			freq, _ = time.ParseDuration(config.DefaultGddStatsFreq)
217 | 		}
218 | 		statsvizServer, _ := statsviz.NewServer(statsviz.Root(srv.bizRouter.SubPath(gddPathPrefix+"statsviz/")), statsviz.SendFrequency(freq))
219 | 		ws := statsvizServer.Ws()
220 | 		index := statsvizServer.Index()
221 | 		srv.gddRoutes = append(srv.gddRoutes, []Route{
222 | 			{
223 | 				Name:    "GetStatsvizWs",
224 | 				Method:  http.MethodGet,
225 | 				Pattern: gddPathPrefix + "statsviz/ws",
226 | 			},
227 | 			{
228 | 				Name:    "GetStatsviz",
229 | 				Method:  http.MethodGet,
230 | 				Pattern: gddPathPrefix + "statsviz/*",
231 | 				HandlerFunc: func(writer http.ResponseWriter, request *http.Request) {
232 | 					if strings.HasSuffix(request.URL.Path, "/ws") {
233 | 						ws(writer, request)
234 | 						return
235 | 					}
236 | 					index(writer, request)
237 | 				},
238 | 			},
239 | 		}...)
240 | 		for k, item := range srv.gddRoutes {
241 | 			if item.HandlerFunc != nil {
242 | 				h := http.Handler(item.HandlerFunc)
243 | 				for i := len(gddmiddlewares) - 1; i >= 0; i-- {
244 | 					h = gddmiddlewares[i].Middleware(h)
245 | 				}
246 | 				srv.bizRouter.Handler(item.Method, item.Pattern, h, item.Name)
247 | 			}
248 | 			item.Pattern = srv.bizRouter.SubPath(item.Pattern)
249 | 			srv.gddRoutes[k] = item
250 | 		}
251 | 		srv.debugRoutes = append(srv.debugRoutes, []Route{
252 | 			{
253 | 				Name:    "GetDebugPprofCmdline",
254 | 				Method:  http.MethodGet,
255 | 				Pattern: debugPathPrefix + "pprof/cmdline",
256 | 			},
257 | 			{
258 | 				Name:    "GetDebugPprofProfile",
259 | 				Method:  http.MethodGet,
260 | 				Pattern: debugPathPrefix + "pprof/profile",
261 | 			},
262 | 			{
263 | 				Name:    "GetDebugPprofSymbol",
264 | 				Method:  http.MethodGet,
265 | 				Pattern: debugPathPrefix + "pprof/symbol",
266 | 			},
267 | 			{
268 | 				Name:    "GetDebugPprofTrace",
269 | 				Method:  http.MethodGet,
270 | 				Pattern: debugPathPrefix + "pprof/trace",
271 | 			},
272 | 			{
273 | 				Name:    "GetDebugPprofIndex",
274 | 				Method:  http.MethodGet,
275 | 				Pattern: debugPathPrefix + "pprof/*",
276 | 				HandlerFunc: func(writer http.ResponseWriter, request *http.Request) {
277 | 					lastSegment := request.URL.Path[strings.LastIndex(request.URL.Path, "/"):]
278 | 					switch lastSegment {
279 | 					case "/cmdline":
280 | 						Cmdline(writer, request)
281 | 						return
282 | 					case "/profile":
283 | 						Profile(writer, request)
284 | 						return
285 | 					case "/symbol":
286 | 						Symbol(writer, request)
287 | 						return
288 | 					case "/trace":
289 | 						Trace(writer, request)
290 | 						return
291 | 					}
292 | 					Index(writer, request)
293 | 				},
294 | 			},
295 | 		}...)
296 | 		for k, item := range srv.debugRoutes {
297 | 			if item.HandlerFunc != nil {
298 | 				h := http.Handler(item.HandlerFunc)
299 | 				for i := len(gddmiddlewares) - 1; i >= 0; i-- {
300 | 					h = gddmiddlewares[i].Middleware(h)
301 | 				}
302 | 				srv.bizRouter.Handler(item.Method, item.Pattern, h, item.Name)
303 | 			}
304 | 			item.Pattern = srv.bizRouter.SubPath(item.Pattern)
305 | 			srv.debugRoutes[k] = item
306 | 		}
307 | 	}
308 | 	srv.rootRouter.NotFound = http.HandlerFunc(http.NotFound)
309 | 	srv.rootRouter.MethodNotAllowed = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
310 | 		w.WriteHeader(http.StatusMethodNotAllowed)
311 | 		w.Write([]byte("405 method not allowed"))
312 | 	})
313 | 	for i := len(srv.middlewares) - 1; i >= 0; i-- {
314 | 		srv.rootRouter.NotFound = srv.middlewares[i].Middleware(srv.rootRouter.NotFound)
315 | 		srv.rootRouter.MethodNotAllowed = srv.middlewares[i].Middleware(srv.rootRouter.MethodNotAllowed)
316 | 	}
317 | 	return srv
318 | }
319 | 
320 | func (srv *RestServer) groupRoutes(routeGroup *httprouter.RouteGroup, routes []Route, mwf ...MiddlewareFunc) {
321 | 	for _, item := range routes {
322 | 		h := http.Handler(item.HandlerFunc)
323 | 		for i := len(mwf) - 1; i >= 0; i-- {
324 | 			h = mwf[i].Middleware(h)
325 | 		}
326 | 		routeGroup.Handler(item.Method, item.Pattern, h, item.Name)
327 | 		item.Pattern = routeGroup.SubPath(item.Pattern)
328 | 		srv.bizRoutes = append(srv.bizRoutes, item)
329 | 	}
330 | }
331 | 
332 | // AddRoute adds routes to router
333 | func (srv *RestServer) AddRoute(route ...Route) {
334 | 	srv.groupRoutes(srv.bizRouter, route, srv.middlewares...)
335 | }
336 | 
337 | // AddRoutes adds routes to router
338 | func (srv *RestServer) AddRoutes(routes []Route, mwf ...func(http.Handler) http.Handler) {
339 | 	m := make([]MiddlewareFunc, 0)
340 | 	m = append(m, srv.middlewares...)
341 | 	m = append(m, lo.Map(mwf, func(item func(http.Handler) http.Handler, index int) MiddlewareFunc {
342 | 		return item
343 | 	})...)
344 | 	srv.groupRoutes(srv.bizRouter, routes, m...)
345 | }
346 | 
347 | // GroupRoutes adds routes to router
348 | func (srv *RestServer) GroupRoutes(group string, routes []Route, mwf ...func(http.Handler) http.Handler) {
349 | 	m := make([]MiddlewareFunc, 0)
350 | 	m = append(m, srv.middlewares...)
351 | 	m = append(m, lo.Map(mwf, func(item func(http.Handler) http.Handler, index int) MiddlewareFunc {
352 | 		return item
353 | 	})...)
354 | 	srv.groupRoutes(srv.bizRouter.NewGroup(group), routes, m...)
355 | }
356 | 
357 | // AddMiddleware adds middlewares to the end of chain
358 | // Deprecated: use Use instead
359 | func (srv *RestServer) AddMiddleware(mwf ...func(http.Handler) http.Handler) {
360 | 	for _, item := range mwf {
361 | 		srv.middlewares = append(srv.middlewares, item)
362 | 	}
363 | }
364 | 
365 | // Use adds middlewares to the end of chain
366 | func (srv *RestServer) Use(mwf ...func(http.Handler) http.Handler) {
367 | 	for _, item := range mwf {
368 | 		srv.middlewares = append(srv.middlewares, item)
369 | 	}
370 | }
371 | 
372 | // Run runs http server
373 | func (srv *RestServer) Run() {
374 | 	ln, err := net.Listen("tcp", strings.Join([]string{config.GddConfig.Host, config.GddConfig.Port}, ":"))
375 | 	if err != nil {
376 | 		logger.Panic().Msg(err.Error())
377 | 	}
378 | 	srv.Serve(ln)
379 | 	defer func() {
380 | 		logger.Info().Msgf("Rest server is gracefully shutting down in %s", config.GddConfig.GraceTimeout)
381 | 		// Make sure to set a deadline on exiting the process
382 | 		// after upg.Exit() is closed. No new upgrades can be
383 | 		// performed if the parent doesn't exit.
384 | 		time.AfterFunc(config.GddConfig.GraceTimeout, func() {
385 | 			logger.Error().Msg("Graceful shutdown timed out")
386 | 			config.Shutdown()
387 | 			os.Exit(1)
388 | 		})
389 | 		register.ShutdownRest()
390 | 		srv.Shutdown(context.Background())
391 | 	}()
392 | 
393 | 	c := make(chan os.Signal, 1)
394 | 	// We'll accept graceful shutdowns when quit via SIGINT (Ctrl+C)
395 | 	// SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.
396 | 	signal.Notify(c, os.Interrupt)
397 | 
398 | 	// Block until we receive our signal.
399 | 	<-c
400 | }
401 | 
402 | func (srv *RestServer) Serve(ln net.Listener) {
403 | 	var all []Route
404 | 	all = append(all, srv.bizRoutes...)
405 | 	all = append(all, srv.gddRoutes...)
406 | 	all = append(all, srv.debugRoutes...)
407 | 	docs := mapset.NewSet[DocItem]()
408 | 	for _, r := range all {
409 | 		if strings.Contains(r.Pattern, gddPathPrefix+"doc") {
410 | 			module := strings.TrimSuffix(r.Pattern, gddPathPrefix+"doc")
411 | 			if stringutils.IsEmpty(module) {
412 | 				module = "/"
413 | 			}
414 | 			docs.Add(DocItem{
415 | 				Label: module,
416 | 				Value: r.Pattern,
417 | 			})
418 | 		}
419 | 	}
420 | 	Docs = docs.ToSlice()
421 | 	framework.PrintBanner()
422 | 	framework.PrintLock.Lock()
423 | 	register.NewRest(srv.data)
424 | 	srv.printRoutes()
425 | 	// Run our server in a goroutine so that it doesn't block.
426 | 	go func() {
427 | 		if err := srv.Server.Serve(ln); err != http.ErrServerClosed {
428 | 			logger.Error().Msgf("HTTP server: %s", err.Error())
429 | 		}
430 | 	}()
431 | 	logger.Info().Msgf("Http server is listening at %v", ln.Addr().String())
432 | 	logger.Info().Msgf("Http server started in %s", time.Since(startAt))
433 | 	framework.PrintLock.Unlock()
434 | }
435 | 
436 | func (srv *RestServer) AddStaticResource(storage fs.FS, routePattern string) {
437 | 	assetHandler := http.FileServer(http.FS(storage))
438 | 	name := strcase.ToCamel(strings.ReplaceAll(routePattern, "/", "_"))
439 | 	srv.AddRoute(Route{
440 | 		Name:        name + "Home",
441 | 		Method:      http.MethodGet,
442 | 		Pattern:     routePattern,
443 | 		HandlerFunc: http.StripPrefix(config.GddConfig.RouteRootPath+routePattern, assetHandler).ServeHTTP,
444 | 	})
445 | 	srv.AddRoute(Route{
446 | 		Name:        name + "Assets",
447 | 		Method:      http.MethodGet,
448 | 		Pattern:     routePattern + "/*",
449 | 		HandlerFunc: http.StripPrefix(config.GddConfig.RouteRootPath+routePattern, assetHandler).ServeHTTP,
450 | 	})
451 | }
```

framework/rest/validate.go
```
1 | package rest
2 | 
3 | import (
4 | 	"strings"
5 | 
6 | 	ut "github.com/go-playground/universal-translator"
7 | 	"github.com/go-playground/validator/v10"
8 | 	"github.com/pkg/errors"
9 | 	"github.com/unionj-cloud/toolkit/stringutils"
10 | )
11 | 
12 | var validate = validator.New()
13 | var translator ut.Translator
14 | 
15 | func GetValidate() *validator.Validate {
16 | 	return validate
17 | }
18 | 
19 | func GetTranslator() ut.Translator {
20 | 	return translator
21 | }
22 | 
23 | func SetTranslator(trans ut.Translator) {
24 | 	translator = trans
25 | }
26 | 
27 | func handleValidationErr(err error) error {
28 | 	if err == nil {
29 | 		return nil
30 | 	}
31 | 	errs, ok := err.(validator.ValidationErrors)
32 | 	if !ok {
33 | 		return err
34 | 	}
35 | 	translations := errs.Translate(translator)
36 | 	var errmsgs []string
37 | 	for _, v := range translations {
38 | 		errmsgs = append(errmsgs, v)
39 | 	}
40 | 	return errors.New(strings.Join(errmsgs, ", "))
41 | }
42 | 
43 | func ValidateStruct(value interface{}) error {
44 | 	return handleValidationErr(validate.Struct(value))
45 | }
46 | 
47 | func ValidateVar(value interface{}, tag, param string) error {
48 | 	if stringutils.IsNotEmpty(param) {
49 | 		return errors.Wrap(handleValidationErr(validate.Var(value, tag)), param)
50 | 	}
51 | 	return handleValidationErr(validate.Var(value, tag))
52 | }
```

framework/restclient/restclient.go
```
1 | package restclient
2 | 
3 | import (
4 | 	"net"
5 | 	"net/http"
6 | 	"os"
7 | 	"runtime"
8 | 	"time"
9 | 
10 | 	"github.com/go-resty/resty/v2"
11 | 	"github.com/klauspost/compress/gzhttp"
12 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
13 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
15 | 	"github.com/unionj-cloud/toolkit/cast"
16 | )
17 | 
18 | // RestClient defines service client interface
19 | type RestClient interface {
20 | 	SetProvider(provider registry.IServiceProvider)
21 | 	SetClient(client *resty.Client)
22 | 	SetRootPath(rootPath string)
23 | }
24 | 
25 | // RestClientOption defines configure function type
26 | type RestClientOption func(RestClient)
27 | 
28 | // WithProvider sets service provider
29 | func WithProvider(provider registry.IServiceProvider) RestClientOption {
30 | 	return func(c RestClient) {
31 | 		c.SetProvider(provider)
32 | 	}
33 | }
34 | 
35 | // WithClient sets http client
36 | func WithClient(client *resty.Client) RestClientOption {
37 | 	return func(c RestClient) {
38 | 		c.SetClient(client)
39 | 	}
40 | }
41 | 
42 | // WithRootPath sets root path for sending http requests
43 | func WithRootPath(rootPath string) RestClientOption {
44 | 	return func(c RestClient) {
45 | 		c.SetRootPath(rootPath)
46 | 	}
47 | }
48 | 
49 | // ServiceProvider defines an implementation for IServiceProvider
50 | type ServiceProvider struct {
51 | 	server string
52 | }
53 | 
54 | func (s *ServiceProvider) Close() {
55 | }
56 | 
57 | // SelectServer return service address from environment variable
58 | func (s *ServiceProvider) SelectServer() string {
59 | 	return s.server
60 | }
61 | 
62 | // NewServiceProvider creates new ServiceProvider instance
63 | func NewServiceProvider(env string) *ServiceProvider {
64 | 	return &ServiceProvider{
65 | 		server: os.Getenv(env),
66 | 	}
67 | }
68 | 
69 | // NewClient creates new resty Client instance
70 | func NewClient() *resty.Client {
71 | 	client := resty.New()
72 | 	client.SetTimeout(1 * time.Minute)
73 | 	dialer := &net.Dialer{
74 | 		Timeout:   30 * time.Second,
75 | 		KeepAlive: 30 * time.Second,
76 | 		DualStack: true,
77 | 	}
78 | 	client.SetTransport(gzhttp.Transport(&nethttp.Transport{
79 | 		RoundTripper: &http.Transport{
80 | 			Proxy:                 http.ProxyFromEnvironment,
81 | 			DialContext:           dialer.DialContext,
82 | 			ForceAttemptHTTP2:     true,
83 | 			MaxIdleConns:          100,
84 | 			IdleConnTimeout:       90 * time.Second,
85 | 			TLSHandshakeTimeout:   10 * time.Second,
86 | 			ExpectContinueTimeout: 1 * time.Second,
87 | 			MaxIdleConnsPerHost:   runtime.GOMAXPROCS(0) + 1,
88 | 			MaxConnsPerHost:       10000,
89 | 		},
90 | 	}))
91 | 	retryCnt := config.DefaultGddRetryCount
92 | 	if cnt, err := cast.ToIntE(config.GddRetryCount.Load()); err == nil {
93 | 		retryCnt = cnt
94 | 	}
95 | 	client.SetRetryCount(retryCnt)
96 | 	return client
97 | }
```

framework/restclient/restclient_test.go
```
1 | package restclient_test
2 | 
3 | import (
4 | 	"os"
5 | 	"testing"
6 | 
7 | 	"github.com/go-resty/resty/v2"
8 | 	. "github.com/smartystreets/goconvey/convey"
9 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
10 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
11 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
12 | 	"github.com/wubin1989/nacos-sdk-go/v2/common/constant"
13 | )
14 | 
15 | var clientConfigTest = *constant.NewClientConfig(
16 | 	constant.WithTimeoutMs(10*1000),
17 | 	constant.WithBeatInterval(5*1000),
18 | 	constant.WithNotLoadCacheAtStart(true),
19 | )
20 | 
21 | var serverConfigTest = *constant.NewServerConfig("console.nacos.io", 80, constant.WithContextPath("/nacos"))
22 | 
23 | type MockRestClient struct {
24 | 	provider registry.IServiceProvider
25 | 	client   *resty.Client
26 | 	rootPath string
27 | }
28 | 
29 | func (receiver *MockRestClient) SetRootPath(rootPath string) {
30 | 	receiver.rootPath = rootPath
31 | }
32 | 
33 | func (receiver *MockRestClient) SetProvider(provider registry.IServiceProvider) {
34 | 	receiver.provider = provider
35 | }
36 | 
37 | func (receiver *MockRestClient) SetClient(client *resty.Client) {
38 | 	receiver.client = client
39 | }
40 | 
41 | func NewMockRestClient(opts ...restclient.RestClientOption) *MockRestClient {
42 | 	defaultProvider := restclient.NewServiceProvider("MOCKRESTCLIENT")
43 | 	defaultClient := restclient.NewClient()
44 | 
45 | 	svcClient := &MockRestClient{
46 | 		provider: defaultProvider,
47 | 		client:   defaultClient,
48 | 	}
49 | 
50 | 	for _, opt := range opts {
51 | 		opt(svcClient)
52 | 	}
53 | 
54 | 	return svcClient
55 | }
56 | 
57 | func TestWithClient(t *testing.T) {
58 | 	Convey("Create a RestClient instance with custom client", t, func() {
59 | 		m := NewMockRestClient(restclient.WithClient(resty.New()))
60 | 		So(m.client, ShouldNotBeZeroValue)
61 | 	})
62 | }
63 | 
64 | func TestWithRootPath(t *testing.T) {
65 | 	Convey("Create a RestClient instance with custom rootPath", t, func() {
66 | 		m := NewMockRestClient(restclient.WithRootPath("/v1"))
67 | 		So(m.rootPath, ShouldEqual, "/v1")
68 | 	})
69 | }
70 | 
71 | func TestRetryCount(t *testing.T) {
72 | 	Convey("Create a RestClient instance with 10 retry count", t, func() {
73 | 		os.Setenv("GDD_RETRY_COUNT", "10")
74 | 		m := NewMockRestClient()
75 | 		So(m.client.RetryCount, ShouldEqual, 10)
76 | 	})
77 | }
78 | 
79 | func TestMain(m *testing.M) {
80 | 	setup()
81 | 	m.Run()
82 | }
83 | 
84 | func setup() {
85 | 	_ = config.GddServiceName.Write("awesome-service")
86 | 	_ = config.GddLogLevel.Write("debug")
87 | 	_ = config.GddPort.Write("8088")
88 | 	_ = config.GddRouteRootPath.Write("/v1")
89 | }
```

framework/testdata/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"mime/multipart"
6 | 	"os"
7 | 
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/testdata/vo"
9 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
10 | )
11 | 
12 | // 用户服务接口
13 | // v1版本
14 | type Usersvc interface {
15 | 	// You can define your service methods as your need. Below is an example.
16 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, msg error)
17 | 
18 | 	// comment1
19 | 	// comment2
20 | 	GetUser(ctx context.Context,
21 | 		// 用户ID
22 | 		userId string,
23 | 		// 图片地址
24 | 		photo string,
25 | 	) (code int, data string, msg error)
26 | 
27 | 	// comment3
28 | 	SignUp(ctx context.Context, username string, password int, actived bool, score float64) (code int, data string, msg error)
29 | 
30 | 	// comment4
31 | 	UploadAvatar(context.Context, []*multipart.FileHeader, []*multipart.FileHeader, *multipart.FileHeader, v3.FileModel, string) (int, string, error)
32 | 
33 | 	// comment5
34 | 	DownloadAvatar(ctx context.Context, userId string) (*os.File, error)
35 | }
```

framework/testdata/svcp.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"os"
6 | 
7 | 	"github.com/unionj-cloud/go-doudou/v2/framework/testdata/vo"
8 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
9 | )
10 | 
11 | // 用户服务接口
12 | // v1版本
13 | type UsersvcPanic interface {
14 | 	// You can define your service methods as your need. Below is an example.
15 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, msg error)
16 | 
17 | 	// comment1
18 | 	// comment2
19 | 	GetUser(ctx context.Context,
20 | 		// 用户ID
21 | 		userId string,
22 | 		// 图片地址
23 | 		photo string,
24 | 	) (code int, data string, msg error)
25 | 
26 | 	// comment3
27 | 	SignUp(ctx context.Context, username string, password int, actived bool, score float64) (code int, data string, msg error)
28 | 
29 | 	// comment4
30 | 	UploadAvatar(context.Context, []v3.FileModel, string) (int, string, error)
31 | 
32 | 	// comment5
33 | 	DownloadAvatar(ctx context.Context, userId string) (*os.File, error)
34 | 
35 | 	// Wrong1
36 | 	Wrong1(ctx context.Context, userId string, query vo.PageQuery, files []v3.FileModel) (*os.File, error)
37 | 
38 | 	// Wrong2
39 | 	Wrong2(ctx context.Context, ch chan string) (*os.File, error)
40 | 
41 | 	// Wrong3
42 | 	Wrong3(ctx context.Context, fun func()) (*os.File, error)
43 | }
```

framework/testdata/testfilesdoc1_openapi3.json
```
1 | {"openapi":"3.0.2","info":{"title":"Testdatadoc1","version":"v20210625"},"paths":{"/testdatadoc1/pageusers":{"post":{"summary":"You can define your service methods as your need. Below is an example.","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageQuery"}}},"required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageUsersResp"}}}}}}}},"components":{"schemas":{"Order":{"title":"Order","type":"object","properties":{"Col":{"type":"string"},"Sort":{"type":"string"}}},"Page":{"title":"Page","type":"object","properties":{"Orders":{"type":"array","items":{"$ref":"#/components/schemas/Order"},"description":"排序规则"},"PageNo":{"type":"integer","format":"int32","description":"页码"},"Size":{"type":"integer","format":"int32","description":"每页行数"}}},"PageFilter":{"title":"PageFilter","type":"object","properties":{"Dept":{"type":"integer","format":"int32","description":"所属部门ID"},"Name":{"type":"string","description":"真实姓名，前缀匹配"}}},"PageQuery":{"title":"PageQuery","type":"object","properties":{"Filter":{"$ref":"#/components/schemas/PageFilter"},"Page":{"$ref":"#/components/schemas/Page"}},"description":"分页筛选条件"},"PageRet":{"title":"PageRet","type":"object","properties":{"HasNext":{"type":"boolean"},"Items":{"type":"object"},"PageNo":{"type":"integer","format":"int32"},"PageSize":{"type":"integer","format":"int32"},"Total":{"type":"integer","format":"int32"}}},"PageUsersResp":{"title":"PageUsersResp","type":"object","properties":{"code":{"type":"integer","format":"int32"},"data":{"$ref":"#/components/schemas/PageRet"},"msg":{"type":"string"}}},"UserVo":{"title":"UserVo","type":"object","properties":{"Dept":{"type":"string"},"Id":{"type":"integer","format":"int32"},"Name":{"type":"string"},"Phone":{"type":"string"}}}}}}
```

framework/testdata/usersvc_deployment.yaml
```
1 | apiVersion: apps/v1
2 | kind: Deployment
3 | metadata:
4 |   name: usersvc-deployment
5 | spec:
6 |   replicas: 1
7 |   selector:
8 |     matchLabels:
9 |       app: usersvc
10 |   template:
11 |     metadata:
12 |       labels:
13 |         app: usersvc
14 |     spec:
15 |       containers:
16 |       - image: wubin1989/go-doudou-usersvc:v20220210015930
17 |         imagePullPolicy: Always
18 |         name: usersvc
19 |         ports:
20 |         - containerPort: 6060
21 |           name: http-port
22 |           protocol: TCP
23 |         resources:
24 |           requests:
25 |             cpu: 100m
26 |             memory: 128Mi
27 |       restartPolicy: Always
28 | ---
29 | apiVersion: v1
30 | kind: Service
31 | metadata:
32 |   name: usersvc-service
33 | spec:
34 |   type: LoadBalancer
35 |   externalTrafficPolicy: Cluster
36 |   selector:
37 |     app: usersvc
38 |   ports:
39 |     - protocol: TCP
40 |       port: 6060
41 |       targetPort: 6060
```

framework/testdata/usersvc_statefulset.yaml
```
1 | apiVersion: apps/v1
2 | kind: StatefulSet
3 | metadata:
4 |   name: usersvc-statefulset
5 | spec:
6 |   replicas: 1
7 |   selector:
8 |     matchLabels:
9 |       app: usersvc
10 |   serviceName: usersvc-svc-headless
11 |   template:
12 |     metadata:
13 |       labels:
14 |         app: usersvc
15 |     spec:
16 |       containers:
17 |       - image: wubin1989/go-doudou-usersvc:v20220210015930
18 |         imagePullPolicy: Always
19 |         name: usersvc
20 |         ports:
21 |         - containerPort: 6060
22 |           name: http-port
23 |           protocol: TCP
24 |         resources:
25 |           requests:
26 |             cpu: 100m
27 |             memory: 128Mi
28 |       restartPolicy: Always
29 |       terminationGracePeriodSeconds: 10
30 | ---
31 | apiVersion: v1
32 | kind: Service
33 | metadata:
34 |   name: usersvc-svc-headless
35 | spec:
36 |   selector:
37 |     app: usersvc
38 |   ports:
39 |     - protocol: TCP
40 |       port: 6060
41 |       targetPort: 6060
42 |   clusterIP: None
```

framework/tracing/tracer.go
```
1 | package tracing
2 | 
3 | import (
4 | 	"io"
5 | 
6 | 	"github.com/opentracing/opentracing-go"
7 | 	"github.com/pkg/errors"
8 | 	"github.com/rs/zerolog"
9 | 	"github.com/uber/jaeger-client-go/config"
10 | 	"github.com/uber/jaeger-client-go/rpcmetrics"
11 | 	"github.com/uber/jaeger-lib/metrics"
12 | 	jprom "github.com/uber/jaeger-lib/metrics/prometheus"
13 | 	ddconfig "github.com/unionj-cloud/go-doudou/v2/framework/config"
14 | 	"github.com/unionj-cloud/toolkit/stringutils"
15 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
16 | )
17 | 
18 | // Init returns an instance of Jaeger Tracer.
19 | func Init() (opentracing.Tracer, io.Closer) {
20 | 	cfg := &config.Configuration{
21 | 		Sampler:  &config.SamplerConfig{},
22 | 		Reporter: &config.ReporterConfig{},
23 | 	}
24 | 	service := ddconfig.DefaultGddServiceName
25 | 	if stringutils.IsNotEmpty(ddconfig.GddServiceName.Load()) {
26 | 		service = ddconfig.GddServiceName.Load()
27 | 	}
28 | 	cfg.ServiceName = service
29 | 	cfg.Sampler.Type = "const"
30 | 	cfg.Sampler.Param = 1
31 | 	cfg.Reporter.LogSpans = true
32 | 	_, err := cfg.FromEnv()
33 | 	if err != nil {
34 | 		logger.Panic().Err(errors.Wrap(err, "[go-doudou] cannot parse Jaeger env vars")).Msg("")
35 | 	}
36 | 	jaegerLogger := jaegerLoggerAdapter{logger: logger.Logger}
37 | 	metricsRoot := ddconfig.DefaultGddTracingMetricsRoot
38 | 	if stringutils.IsNotEmpty(ddconfig.GddTracingMetricsRoot.Load()) {
39 | 		metricsRoot = ddconfig.GddTracingMetricsRoot.Load()
40 | 	}
41 | 	metricsFactory := jprom.New().Namespace(metrics.NSOptions{Name: metricsRoot, Tags: nil})
42 | 	tracer, closer, err := cfg.NewTracer(
43 | 		config.Logger(jaegerLogger),
44 | 		config.Metrics(metricsFactory),
45 | 		config.Observer(rpcmetrics.NewObserver(metricsFactory, rpcmetrics.DefaultNameNormalizer)),
46 | 	)
47 | 	if err != nil {
48 | 		logger.Panic().Err(errors.Wrap(err, "[go-doudou] cannot initialize Jaeger Tracer")).Msg("")
49 | 	}
50 | 	return tracer, closer
51 | }
52 | 
53 | type jaegerLoggerAdapter struct {
54 | 	logger zerolog.Logger
55 | }
56 | 
57 | func (l jaegerLoggerAdapter) Error(msg string) {
58 | 	l.logger.Error().Msg(msg)
59 | }
60 | 
61 | func (l jaegerLoggerAdapter) Infof(msg string, args ...interface{}) {
62 | 	l.logger.Info().Msgf(msg, args...)
63 | }
64 | 
65 | func (l jaegerLoggerAdapter) Debugf(msg string, args ...interface{}) {
66 | 	l.logger.Debug().Msgf(msg, args...)
67 | }
```

cmd/mock/mock_executils_runner.go
```
1 | // Code generated by MockGen. DO NOT EDIT.
2 | // Source: ./executils.go
3 | 
4 | // Package mock is a generated GoMock package.
5 | package mock
6 | 
7 | import (
8 | 	exec "os/exec"
9 | 	reflect "reflect"
10 | 
11 | 	gomock "github.com/golang/mock/gomock"
12 | )
13 | 
14 | // MockRunner is a mock of Runner interface.
15 | type MockRunner struct {
16 | 	ctrl     *gomock.Controller
17 | 	recorder *MockRunnerMockRecorder
18 | }
19 | 
20 | // MockRunnerMockRecorder is the mock recorder for MockRunner.
21 | type MockRunnerMockRecorder struct {
22 | 	mock *MockRunner
23 | }
24 | 
25 | // NewMockRunner creates a new mock instance.
26 | func NewMockRunner(ctrl *gomock.Controller) *MockRunner {
27 | 	mock := &MockRunner{ctrl: ctrl}
28 | 	mock.recorder = &MockRunnerMockRecorder{mock}
29 | 	return mock
30 | }
31 | 
32 | // EXPECT returns an object that allows the caller to indicate expected use.
33 | func (m *MockRunner) EXPECT() *MockRunnerMockRecorder {
34 | 	return m.recorder
35 | }
36 | 
37 | // Output mocks base method.
38 | func (m *MockRunner) Output(arg0 string, arg1 ...string) ([]byte, error) {
39 | 	m.ctrl.T.Helper()
40 | 	varargs := []interface{}{arg0}
41 | 	for _, a := range arg1 {
42 | 		varargs = append(varargs, a)
43 | 	}
44 | 	ret := m.ctrl.Call(m, "Output", varargs...)
45 | 	ret0, _ := ret[0].([]byte)
46 | 	ret1, _ := ret[1].(error)
47 | 	return ret0, ret1
48 | }
49 | 
50 | // Output indicates an expected call of Output.
51 | func (mr *MockRunnerMockRecorder) Output(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
52 | 	mr.mock.ctrl.T.Helper()
53 | 	varargs := append([]interface{}{arg0}, arg1...)
54 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockRunner)(nil).Output), varargs...)
55 | }
56 | 
57 | // Run mocks base method.
58 | func (m *MockRunner) Run(arg0 string, arg1 ...string) error {
59 | 	m.ctrl.T.Helper()
60 | 	varargs := []interface{}{arg0}
61 | 	for _, a := range arg1 {
62 | 		varargs = append(varargs, a)
63 | 	}
64 | 	ret := m.ctrl.Call(m, "Run", varargs...)
65 | 	ret0, _ := ret[0].(error)
66 | 	return ret0
67 | }
68 | 
69 | // Run indicates an expected call of Run.
70 | func (mr *MockRunnerMockRecorder) Run(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
71 | 	mr.mock.ctrl.T.Helper()
72 | 	varargs := append([]interface{}{arg0}, arg1...)
73 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockRunner)(nil).Run), varargs...)
74 | }
75 | 
76 | // Start mocks base method.
77 | func (m *MockRunner) Start(arg0 string, arg1 ...string) (*exec.Cmd, error) {
78 | 	m.ctrl.T.Helper()
79 | 	varargs := []interface{}{arg0}
80 | 	for _, a := range arg1 {
81 | 		varargs = append(varargs, a)
82 | 	}
83 | 	ret := m.ctrl.Call(m, "Start", varargs...)
84 | 	ret0, _ := ret[0].(*exec.Cmd)
85 | 	ret1, _ := ret[1].(error)
86 | 	return ret0, ret1
87 | }
88 | 
89 | // Start indicates an expected call of Start.
90 | func (mr *MockRunnerMockRecorder) Start(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
91 | 	mr.mock.ctrl.T.Helper()
92 | 	varargs := append([]interface{}{arg0}, arg1...)
93 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockRunner)(nil).Start), varargs...)
94 | }
```

cmd/mock/mock_promptui_select_interface.go
```
1 | // Code generated by MockGen. DO NOT EDIT.
2 | // Source: ./promptui_select_interface.go
3 | 
4 | // Package mock is a generated GoMock package.
5 | package mock
6 | 
7 | import (
8 | 	reflect "reflect"
9 | 
10 | 	gomock "github.com/golang/mock/gomock"
11 | )
12 | 
13 | // MockISelect is a mock of ISelect interface.
14 | type MockISelect struct {
15 | 	ctrl     *gomock.Controller
16 | 	recorder *MockISelectMockRecorder
17 | }
18 | 
19 | // MockISelectMockRecorder is the mock recorder for MockISelect.
20 | type MockISelectMockRecorder struct {
21 | 	mock *MockISelect
22 | }
23 | 
24 | // NewMockISelect creates a new mock instance.
25 | func NewMockISelect(ctrl *gomock.Controller) *MockISelect {
26 | 	mock := &MockISelect{ctrl: ctrl}
27 | 	mock.recorder = &MockISelectMockRecorder{mock}
28 | 	return mock
29 | }
30 | 
31 | // EXPECT returns an object that allows the caller to indicate expected use.
32 | func (m *MockISelect) EXPECT() *MockISelectMockRecorder {
33 | 	return m.recorder
34 | }
35 | 
36 | // Run mocks base method.
37 | func (m *MockISelect) Run() (int, string, error) {
38 | 	m.ctrl.T.Helper()
39 | 	ret := m.ctrl.Call(m, "Run")
40 | 	ret0, _ := ret[0].(int)
41 | 	ret1, _ := ret[1].(string)
42 | 	ret2, _ := ret[2].(error)
43 | 	return ret0, ret1, ret2
44 | }
45 | 
46 | // Run indicates an expected call of Run.
47 | func (mr *MockISelectMockRecorder) Run() *gomock.Call {
48 | 	mr.mock.ctrl.T.Helper()
49 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockISelect)(nil).Run))
50 | }
51 | 
52 | // RunCursorAt mocks base method.
53 | func (m *MockISelect) RunCursorAt(cursorPos, scroll int) (int, string, error) {
54 | 	m.ctrl.T.Helper()
55 | 	ret := m.ctrl.Call(m, "RunCursorAt", cursorPos, scroll)
56 | 	ret0, _ := ret[0].(int)
57 | 	ret1, _ := ret[1].(string)
58 | 	ret2, _ := ret[2].(error)
59 | 	return ret0, ret1, ret2
60 | }
61 | 
62 | // RunCursorAt indicates an expected call of RunCursorAt.
63 | func (mr *MockISelectMockRecorder) RunCursorAt(cursorPos, scroll interface{}) *gomock.Call {
64 | 	mr.mock.ctrl.T.Helper()
65 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunCursorAt", reflect.TypeOf((*MockISelect)(nil).RunCursorAt), cursorPos, scroll)
66 | }
67 | 
68 | // ScrollPosition mocks base method.
69 | func (m *MockISelect) ScrollPosition() int {
70 | 	m.ctrl.T.Helper()
71 | 	ret := m.ctrl.Call(m, "ScrollPosition")
72 | 	ret0, _ := ret[0].(int)
73 | 	return ret0
74 | }
75 | 
76 | // ScrollPosition indicates an expected call of ScrollPosition.
77 | func (mr *MockISelectMockRecorder) ScrollPosition() *gomock.Call {
78 | 	mr.mock.ctrl.T.Helper()
79 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScrollPosition", reflect.TypeOf((*MockISelect)(nil).ScrollPosition))
80 | }
```

cmd/mock/mock_svc.go
```
1 | // Code generated by MockGen. DO NOT EDIT.
2 | // Source: ./svc.go
3 | 
4 | // Package mock is a generated GoMock package.
5 | package mock
6 | 
7 | import (
8 | 	reflect "reflect"
9 | 
10 | 	gomock "github.com/golang/mock/gomock"
11 | 	watcher "github.com/radovskyb/watcher"
12 | )
13 | 
14 | // MockISvc is a mock of ISvc interface.
15 | type MockISvc struct {
16 | 	ctrl     *gomock.Controller
17 | 	recorder *MockISvcMockRecorder
18 | }
19 | 
20 | // MockISvcMockRecorder is the mock recorder for MockISvc.
21 | type MockISvcMockRecorder struct {
22 | 	mock *MockISvc
23 | }
24 | 
25 | // NewMockISvc creates a new mock instance.
26 | func NewMockISvc(ctrl *gomock.Controller) *MockISvc {
27 | 	mock := &MockISvc{ctrl: ctrl}
28 | 	mock.recorder = &MockISvcMockRecorder{mock}
29 | 	return mock
30 | }
31 | 
32 | // EXPECT returns an object that allows the caller to indicate expected use.
33 | func (m *MockISvc) EXPECT() *MockISvcMockRecorder {
34 | 	return m.recorder
35 | }
36 | 
37 | // Deploy mocks base method.
38 | func (m *MockISvc) Deploy(k8sfile string) {
39 | 	m.ctrl.T.Helper()
40 | 	m.ctrl.Call(m, "Deploy", k8sfile)
41 | }
42 | 
43 | // Deploy indicates an expected call of Deploy.
44 | func (mr *MockISvcMockRecorder) Deploy(k8sfile interface{}) *gomock.Call {
45 | 	mr.mock.ctrl.T.Helper()
46 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deploy", reflect.TypeOf((*MockISvc)(nil).Deploy), k8sfile)
47 | }
48 | 
49 | // DoRestart mocks base method.
50 | func (m *MockISvc) DoRestart() {
51 | 	m.ctrl.T.Helper()
52 | 	m.ctrl.Call(m, "DoRestart")
53 | }
54 | 
55 | // DoRestart indicates an expected call of DoRestart.
56 | func (mr *MockISvcMockRecorder) DoRestart() *gomock.Call {
57 | 	mr.mock.ctrl.T.Helper()
58 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoRestart", reflect.TypeOf((*MockISvc)(nil).DoRestart))
59 | }
60 | 
61 | // DoRun mocks base method.
62 | func (m *MockISvc) DoRun() {
63 | 	m.ctrl.T.Helper()
64 | 	m.ctrl.Call(m, "DoRun")
65 | }
66 | 
67 | // DoRun indicates an expected call of DoRun.
68 | func (mr *MockISvcMockRecorder) DoRun() *gomock.Call {
69 | 	mr.mock.ctrl.T.Helper()
70 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoRun", reflect.TypeOf((*MockISvc)(nil).DoRun))
71 | }
72 | 
73 | // DoWatch mocks base method.
74 | func (m *MockISvc) DoWatch() {
75 | 	m.ctrl.T.Helper()
76 | 	m.ctrl.Call(m, "DoWatch")
77 | }
78 | 
79 | // DoWatch indicates an expected call of DoWatch.
80 | func (mr *MockISvcMockRecorder) DoWatch() *gomock.Call {
81 | 	mr.mock.ctrl.T.Helper()
82 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoWatch", reflect.TypeOf((*MockISvc)(nil).DoWatch))
83 | }
84 | 
85 | // GenClient mocks base method.
86 | func (m *MockISvc) GenClient() {
87 | 	m.ctrl.T.Helper()
88 | 	m.ctrl.Call(m, "GenClient")
89 | }
90 | 
91 | // GenClient indicates an expected call of GenClient.
92 | func (mr *MockISvcMockRecorder) GenClient() *gomock.Call {
93 | 	mr.mock.ctrl.T.Helper()
94 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenClient", reflect.TypeOf((*MockISvc)(nil).GenClient))
95 | }
96 | 
97 | // GetDir mocks base method.
98 | func (m *MockISvc) GetDir() string {
99 | 	m.ctrl.T.Helper()
100 | 	ret := m.ctrl.Call(m, "GetDir")
101 | 	ret0, _ := ret[0].(string)
102 | 	return ret0
103 | }
104 | 
105 | // GetDir indicates an expected call of GetDir.
106 | func (mr *MockISvcMockRecorder) GetDir() *gomock.Call {
107 | 	mr.mock.ctrl.T.Helper()
108 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDir", reflect.TypeOf((*MockISvc)(nil).GetDir))
109 | }
110 | 
111 | // GetWatcher mocks base method.
112 | func (m *MockISvc) GetWatcher() *watcher.Watcher {
113 | 	m.ctrl.T.Helper()
114 | 	ret := m.ctrl.Call(m, "GetWatcher")
115 | 	ret0, _ := ret[0].(*watcher.Watcher)
116 | 	return ret0
117 | }
118 | 
119 | // GetWatcher indicates an expected call of GetWatcher.
120 | func (mr *MockISvcMockRecorder) GetWatcher() *gomock.Call {
121 | 	mr.mock.ctrl.T.Helper()
122 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWatcher", reflect.TypeOf((*MockISvc)(nil).GetWatcher))
123 | }
124 | 
125 | // Http mocks base method.
126 | func (m *MockISvc) Http() {
127 | 	m.ctrl.T.Helper()
128 | 	m.ctrl.Call(m, "Http")
129 | }
130 | 
131 | // Http indicates an expected call of Http.
132 | func (mr *MockISvcMockRecorder) Http() *gomock.Call {
133 | 	mr.mock.ctrl.T.Helper()
134 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Http", reflect.TypeOf((*MockISvc)(nil).Http))
135 | }
136 | 
137 | // Init mocks base method.
138 | func (m *MockISvc) Init() {
139 | 	m.ctrl.T.Helper()
140 | 	m.ctrl.Call(m, "Init")
141 | }
142 | 
143 | // Init indicates an expected call of Init.
144 | func (mr *MockISvcMockRecorder) Init() *gomock.Call {
145 | 	mr.mock.ctrl.T.Helper()
146 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockISvc)(nil).Init))
147 | }
148 | 
149 | // Push mocks base method.
150 | func (m *MockISvc) Push(repo string) {
151 | 	m.ctrl.T.Helper()
152 | 	m.ctrl.Call(m, "Push", repo)
153 | }
154 | 
155 | // Push indicates an expected call of Push.
156 | func (mr *MockISvcMockRecorder) Push(repo interface{}) *gomock.Call {
157 | 	mr.mock.ctrl.T.Helper()
158 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockISvc)(nil).Push), repo)
159 | }
160 | 
161 | // Run mocks base method.
162 | func (m *MockISvc) Run(watch bool) {
163 | 	m.ctrl.T.Helper()
164 | 	m.ctrl.Call(m, "Run", watch)
165 | }
166 | 
167 | // Run indicates an expected call of Run.
168 | func (mr *MockISvcMockRecorder) Run(watch interface{}) *gomock.Call {
169 | 	mr.mock.ctrl.T.Helper()
170 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockISvc)(nil).Run), watch)
171 | }
172 | 
173 | // SetWatcher mocks base method.
174 | func (m *MockISvc) SetWatcher(w *watcher.Watcher) {
175 | 	m.ctrl.T.Helper()
176 | 	m.ctrl.Call(m, "SetWatcher", w)
177 | }
178 | 
179 | // SetWatcher indicates an expected call of SetWatcher.
180 | func (mr *MockISvcMockRecorder) SetWatcher(w interface{}) *gomock.Call {
181 | 	mr.mock.ctrl.T.Helper()
182 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetWatcher", reflect.TypeOf((*MockISvc)(nil).SetWatcher), w)
183 | }
184 | 
185 | // Shutdown mocks base method.
186 | func (m *MockISvc) Shutdown(k8sfile string) {
187 | 	m.ctrl.T.Helper()
188 | 	m.ctrl.Call(m, "Shutdown", k8sfile)
189 | }
190 | 
191 | // Shutdown indicates an expected call of Shutdown.
192 | func (mr *MockISvcMockRecorder) Shutdown(k8sfile interface{}) *gomock.Call {
193 | 	mr.mock.ctrl.T.Helper()
194 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockISvc)(nil).Shutdown), k8sfile)
195 | }
196 | 
197 | // Upgrade mocks base method.
198 | func (m *MockISvc) Upgrade(version string) {
199 | 	m.ctrl.T.Helper()
200 | 	m.ctrl.Call(m, "Upgrade", version)
201 | }
202 | 
203 | // Upgrade indicates an expected call of Upgrade.
204 | func (mr *MockISvcMockRecorder) Upgrade(version interface{}) *gomock.Call {
205 | 	mr.mock.ctrl.T.Helper()
206 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upgrade", reflect.TypeOf((*MockISvc)(nil).Upgrade), version)
207 | }
```

cmd/modular/init.go
```
1 | package modular
2 | 
3 | import (
4 | 	"github.com/sirupsen/logrus"
5 | 	"github.com/spf13/cobra"
6 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/modular"
7 | 	"github.com/unionj-cloud/toolkit/executils"
8 | 	"github.com/unionj-cloud/toolkit/pathutils"
9 | )
10 | 
11 | // initCmd initializes the service
12 | var initCmd = &cobra.Command{
13 | 	Use:   "init",
14 | 	Short: "init a workspace folder",
15 | 	Long:  ``,
16 | 	Run: func(cmd *cobra.Command, args []string) {
17 | 		var workDir string
18 | 		if len(args) > 0 {
19 | 			workDir = args[0]
20 | 		}
21 | 		var err error
22 | 		if workDir, err = pathutils.FixPath(workDir, ""); err != nil {
23 | 			logrus.Panicln(err)
24 | 		}
25 | 		conf := modular.WorkConfig{
26 | 			WorkDir: workDir,
27 | 		}
28 | 		work := modular.NewWork(conf, executils.CmdRunner{})
29 | 		work.Init()
30 | 	},
31 | }
32 | 
33 | func init() {
34 | 	workCmd.AddCommand(initCmd)
35 | }
```

cmd/modular/work.go
```
1 | package modular
2 | 
3 | import (
4 | 	"github.com/spf13/cobra"
5 | )
6 | 
7 | // workCmd is the base command for generation or update
8 | var workCmd = &cobra.Command{
9 | 	Use:   "work",
10 | 	Short: "Build modular application",
11 | 	Long:  ``,
12 | 	Run: func(cmd *cobra.Command, args []string) {
13 | 	},
14 | }
15 | 
16 | func GetWorkCmd() *cobra.Command {
17 | 	return workCmd
18 | }
```

.github/workflows/go.yml
```
1 | name: Go
2 | 
3 | on:
4 |   push:
5 |     branches: [ main ]
6 |   pull_request:
7 |     branches: [ main ]
8 |   workflow_dispatch:
9 | 
10 | jobs:
11 | 
12 |   build:
13 |     runs-on: ubuntu-latest
14 |     steps:
15 |     - uses: actions/checkout@v2
16 | 
17 |     - name: Set up Go
18 |       uses: actions/setup-go@v2
19 |       with:
20 |         go-version: 1.22 
21 | 
22 |     - name: Build
23 |       run: go build -v ./...
24 | 
25 |     - name: Test
26 |       run: go test $(go list ./... | grep -v 'ddl\|mock\|serversets\|gorm_gen\|cmd') -coverprofile=coverage.out -covermode=atomic
27 |     
28 |     - name: Upload coverage to Codecov
29 |       run: bash <(curl -s https://codecov.io/bash)
```

framework/configmgr/mock/apollo_client_interface.go
```
1 | package mock
2 | 
3 | import (
4 | 	"container/list"
5 | 
6 | 	"github.com/apolloconfig/agollo/v4/agcache"
7 | 	"github.com/apolloconfig/agollo/v4/storage"
8 | )
9 | 
10 | //go:generate mockgen -destination mock_apollo_client_interface.go -package mock -source=./apollo_client_interface.go
11 | 
12 | // Client apollo 客户端接口
13 | type Client interface {
14 | 	GetConfig(namespace string) *storage.Config
15 | 	GetConfigAndInit(namespace string) *storage.Config
16 | 	GetConfigCache(namespace string) agcache.CacheInterface
17 | 	GetDefaultConfigCache() agcache.CacheInterface
18 | 	GetApolloConfigCache() agcache.CacheInterface
19 | 	GetValue(key string) string
20 | 	GetStringValue(key string, defaultValue string) string
21 | 	GetIntValue(key string, defaultValue int) int
22 | 	GetFloatValue(key string, defaultValue float64) float64
23 | 	GetBoolValue(key string, defaultValue bool) bool
24 | 	GetStringSliceValue(key string, defaultValue []string) []string
25 | 	GetIntSliceValue(key string, defaultValue []int) []int
26 | 	AddChangeListener(listener storage.ChangeListener)
27 | 	RemoveChangeListener(listener storage.ChangeListener)
28 | 	GetChangeListeners() *list.List
29 | 	UseEventDispatch()
30 | }
```

framework/configmgr/mock/mock_apollo_client_interface.go
```
1 | // Code generated by MockGen. DO NOT EDIT.
2 | // Source: ./apollo_client_interface.go
3 | 
4 | // Package mock is a generated GoMock package.
5 | package mock
6 | 
7 | import (
8 | 	list "container/list"
9 | 	reflect "reflect"
10 | 
11 | 	agcache "github.com/apolloconfig/agollo/v4/agcache"
12 | 	storage "github.com/apolloconfig/agollo/v4/storage"
13 | 	gomock "github.com/golang/mock/gomock"
14 | )
15 | 
16 | // MockClient is a mock of Client interface.
17 | type MockClient struct {
18 | 	ctrl     *gomock.Controller
19 | 	recorder *MockClientMockRecorder
20 | }
21 | 
22 | // MockClientMockRecorder is the mock recorder for MockClient.
23 | type MockClientMockRecorder struct {
24 | 	mock *MockClient
25 | }
26 | 
27 | // NewMockClient creates a new mock instance.
28 | func NewMockClient(ctrl *gomock.Controller) *MockClient {
29 | 	mock := &MockClient{ctrl: ctrl}
30 | 	mock.recorder = &MockClientMockRecorder{mock}
31 | 	return mock
32 | }
33 | 
34 | // EXPECT returns an object that allows the caller to indicate expected use.
35 | func (m *MockClient) EXPECT() *MockClientMockRecorder {
36 | 	return m.recorder
37 | }
38 | 
39 | // AddChangeListener mocks base method.
40 | func (m *MockClient) AddChangeListener(listener storage.ChangeListener) {
41 | 	m.ctrl.T.Helper()
42 | 	m.ctrl.Call(m, "AddChangeListener", listener)
43 | }
44 | 
45 | // AddChangeListener indicates an expected call of AddChangeListener.
46 | func (mr *MockClientMockRecorder) AddChangeListener(listener interface{}) *gomock.Call {
47 | 	mr.mock.ctrl.T.Helper()
48 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddChangeListener", reflect.TypeOf((*MockClient)(nil).AddChangeListener), listener)
49 | }
50 | 
51 | // GetApolloConfigCache mocks base method.
52 | func (m *MockClient) GetApolloConfigCache() agcache.CacheInterface {
53 | 	m.ctrl.T.Helper()
54 | 	ret := m.ctrl.Call(m, "GetApolloConfigCache")
55 | 	ret0, _ := ret[0].(agcache.CacheInterface)
56 | 	return ret0
57 | }
58 | 
59 | // GetApolloConfigCache indicates an expected call of GetApolloConfigCache.
60 | func (mr *MockClientMockRecorder) GetApolloConfigCache() *gomock.Call {
61 | 	mr.mock.ctrl.T.Helper()
62 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApolloConfigCache", reflect.TypeOf((*MockClient)(nil).GetApolloConfigCache))
63 | }
64 | 
65 | // GetBoolValue mocks base method.
66 | func (m *MockClient) GetBoolValue(key string, defaultValue bool) bool {
67 | 	m.ctrl.T.Helper()
68 | 	ret := m.ctrl.Call(m, "GetBoolValue", key, defaultValue)
69 | 	ret0, _ := ret[0].(bool)
70 | 	return ret0
71 | }
72 | 
73 | // GetBoolValue indicates an expected call of GetBoolValue.
74 | func (mr *MockClientMockRecorder) GetBoolValue(key, defaultValue interface{}) *gomock.Call {
75 | 	mr.mock.ctrl.T.Helper()
76 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBoolValue", reflect.TypeOf((*MockClient)(nil).GetBoolValue), key, defaultValue)
77 | }
78 | 
79 | // GetChangeListeners mocks base method.
80 | func (m *MockClient) GetChangeListeners() *list.List {
81 | 	m.ctrl.T.Helper()
82 | 	ret := m.ctrl.Call(m, "GetChangeListeners")
83 | 	ret0, _ := ret[0].(*list.List)
84 | 	return ret0
85 | }
86 | 
87 | // GetChangeListeners indicates an expected call of GetChangeListeners.
88 | func (mr *MockClientMockRecorder) GetChangeListeners() *gomock.Call {
89 | 	mr.mock.ctrl.T.Helper()
90 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetChangeListeners", reflect.TypeOf((*MockClient)(nil).GetChangeListeners))
91 | }
92 | 
93 | // GetConfig mocks base method.
94 | func (m *MockClient) GetConfig(namespace string) *storage.Config {
95 | 	m.ctrl.T.Helper()
96 | 	ret := m.ctrl.Call(m, "GetConfig", namespace)
97 | 	ret0, _ := ret[0].(*storage.Config)
98 | 	return ret0
99 | }
100 | 
101 | // GetConfig indicates an expected call of GetConfig.
102 | func (mr *MockClientMockRecorder) GetConfig(namespace interface{}) *gomock.Call {
103 | 	mr.mock.ctrl.T.Helper()
104 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConfig", reflect.TypeOf((*MockClient)(nil).GetConfig), namespace)
105 | }
106 | 
107 | // GetConfigAndInit mocks base method.
108 | func (m *MockClient) GetConfigAndInit(namespace string) *storage.Config {
109 | 	m.ctrl.T.Helper()
110 | 	ret := m.ctrl.Call(m, "GetConfigAndInit", namespace)
111 | 	ret0, _ := ret[0].(*storage.Config)
112 | 	return ret0
113 | }
114 | 
115 | // GetConfigAndInit indicates an expected call of GetConfigAndInit.
116 | func (mr *MockClientMockRecorder) GetConfigAndInit(namespace interface{}) *gomock.Call {
117 | 	mr.mock.ctrl.T.Helper()
118 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConfigAndInit", reflect.TypeOf((*MockClient)(nil).GetConfigAndInit), namespace)
119 | }
120 | 
121 | // GetConfigCache mocks base method.
122 | func (m *MockClient) GetConfigCache(namespace string) agcache.CacheInterface {
123 | 	m.ctrl.T.Helper()
124 | 	ret := m.ctrl.Call(m, "GetConfigCache", namespace)
125 | 	ret0, _ := ret[0].(agcache.CacheInterface)
126 | 	return ret0
127 | }
128 | 
129 | // GetConfigCache indicates an expected call of GetConfigCache.
130 | func (mr *MockClientMockRecorder) GetConfigCache(namespace interface{}) *gomock.Call {
131 | 	mr.mock.ctrl.T.Helper()
132 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConfigCache", reflect.TypeOf((*MockClient)(nil).GetConfigCache), namespace)
133 | }
134 | 
135 | // GetDefaultConfigCache mocks base method.
136 | func (m *MockClient) GetDefaultConfigCache() agcache.CacheInterface {
137 | 	m.ctrl.T.Helper()
138 | 	ret := m.ctrl.Call(m, "GetDefaultConfigCache")
139 | 	ret0, _ := ret[0].(agcache.CacheInterface)
140 | 	return ret0
141 | }
142 | 
143 | // GetDefaultConfigCache indicates an expected call of GetDefaultConfigCache.
144 | func (mr *MockClientMockRecorder) GetDefaultConfigCache() *gomock.Call {
145 | 	mr.mock.ctrl.T.Helper()
146 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDefaultConfigCache", reflect.TypeOf((*MockClient)(nil).GetDefaultConfigCache))
147 | }
148 | 
149 | // GetFloatValue mocks base method.
150 | func (m *MockClient) GetFloatValue(key string, defaultValue float64) float64 {
151 | 	m.ctrl.T.Helper()
152 | 	ret := m.ctrl.Call(m, "GetFloatValue", key, defaultValue)
153 | 	ret0, _ := ret[0].(float64)
154 | 	return ret0
155 | }
156 | 
157 | // GetFloatValue indicates an expected call of GetFloatValue.
158 | func (mr *MockClientMockRecorder) GetFloatValue(key, defaultValue interface{}) *gomock.Call {
159 | 	mr.mock.ctrl.T.Helper()
160 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFloatValue", reflect.TypeOf((*MockClient)(nil).GetFloatValue), key, defaultValue)
161 | }
162 | 
163 | // GetIntSliceValue mocks base method.
164 | func (m *MockClient) GetIntSliceValue(key string, defaultValue []int) []int {
165 | 	m.ctrl.T.Helper()
166 | 	ret := m.ctrl.Call(m, "GetIntSliceValue", key, defaultValue)
167 | 	ret0, _ := ret[0].([]int)
168 | 	return ret0
169 | }
170 | 
171 | // GetIntSliceValue indicates an expected call of GetIntSliceValue.
172 | func (mr *MockClientMockRecorder) GetIntSliceValue(key, defaultValue interface{}) *gomock.Call {
173 | 	mr.mock.ctrl.T.Helper()
174 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIntSliceValue", reflect.TypeOf((*MockClient)(nil).GetIntSliceValue), key, defaultValue)
175 | }
176 | 
177 | // GetIntValue mocks base method.
178 | func (m *MockClient) GetIntValue(key string, defaultValue int) int {
179 | 	m.ctrl.T.Helper()
180 | 	ret := m.ctrl.Call(m, "GetIntValue", key, defaultValue)
181 | 	ret0, _ := ret[0].(int)
182 | 	return ret0
183 | }
184 | 
185 | // GetIntValue indicates an expected call of GetIntValue.
186 | func (mr *MockClientMockRecorder) GetIntValue(key, defaultValue interface{}) *gomock.Call {
187 | 	mr.mock.ctrl.T.Helper()
188 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIntValue", reflect.TypeOf((*MockClient)(nil).GetIntValue), key, defaultValue)
189 | }
190 | 
191 | // GetStringSliceValue mocks base method.
192 | func (m *MockClient) GetStringSliceValue(key string, defaultValue []string) []string {
193 | 	m.ctrl.T.Helper()
194 | 	ret := m.ctrl.Call(m, "GetStringSliceValue", key, defaultValue)
195 | 	ret0, _ := ret[0].([]string)
196 | 	return ret0
197 | }
198 | 
199 | // GetStringSliceValue indicates an expected call of GetStringSliceValue.
200 | func (mr *MockClientMockRecorder) GetStringSliceValue(key, defaultValue interface{}) *gomock.Call {
201 | 	mr.mock.ctrl.T.Helper()
202 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStringSliceValue", reflect.TypeOf((*MockClient)(nil).GetStringSliceValue), key, defaultValue)
203 | }
204 | 
205 | // GetStringValue mocks base method.
206 | func (m *MockClient) GetStringValue(key, defaultValue string) string {
207 | 	m.ctrl.T.Helper()
208 | 	ret := m.ctrl.Call(m, "GetStringValue", key, defaultValue)
209 | 	ret0, _ := ret[0].(string)
210 | 	return ret0
211 | }
212 | 
213 | // GetStringValue indicates an expected call of GetStringValue.
214 | func (mr *MockClientMockRecorder) GetStringValue(key, defaultValue interface{}) *gomock.Call {
215 | 	mr.mock.ctrl.T.Helper()
216 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStringValue", reflect.TypeOf((*MockClient)(nil).GetStringValue), key, defaultValue)
217 | }
218 | 
219 | // GetValue mocks base method.
220 | func (m *MockClient) GetValue(key string) string {
221 | 	m.ctrl.T.Helper()
222 | 	ret := m.ctrl.Call(m, "GetValue", key)
223 | 	ret0, _ := ret[0].(string)
224 | 	return ret0
225 | }
226 | 
227 | // GetValue indicates an expected call of GetValue.
228 | func (mr *MockClientMockRecorder) GetValue(key interface{}) *gomock.Call {
229 | 	mr.mock.ctrl.T.Helper()
230 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValue", reflect.TypeOf((*MockClient)(nil).GetValue), key)
231 | }
232 | 
233 | // RemoveChangeListener mocks base method.
234 | func (m *MockClient) RemoveChangeListener(listener storage.ChangeListener) {
235 | 	m.ctrl.T.Helper()
236 | 	m.ctrl.Call(m, "RemoveChangeListener", listener)
237 | }
238 | 
239 | // RemoveChangeListener indicates an expected call of RemoveChangeListener.
240 | func (mr *MockClientMockRecorder) RemoveChangeListener(listener interface{}) *gomock.Call {
241 | 	mr.mock.ctrl.T.Helper()
242 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveChangeListener", reflect.TypeOf((*MockClient)(nil).RemoveChangeListener), listener)
243 | }
244 | 
245 | // UseEventDispatch mocks base method.
246 | func (m *MockClient) UseEventDispatch() {
247 | 	m.ctrl.T.Helper()
248 | 	m.ctrl.Call(m, "UseEventDispatch")
249 | }
250 | 
251 | // UseEventDispatch indicates an expected call of UseEventDispatch.
252 | func (mr *MockClientMockRecorder) UseEventDispatch() *gomock.Call {
253 | 	mr.mock.ctrl.T.Helper()
254 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UseEventDispatch", reflect.TypeOf((*MockClient)(nil).UseEventDispatch))
255 | }
```

framework/configmgr/mock/mock_config_client_interface.go
```
1 | // Code generated by MockGen. DO NOT EDIT.
2 | // Source: ./config_client_interface.go
3 | 
4 | // Package mock is a generated GoMock package.
5 | package mock
6 | 
7 | import (
8 | 	reflect "reflect"
9 | 
10 | 	gomock "github.com/golang/mock/gomock"
11 | 	model "github.com/wubin1989/nacos-sdk-go/v2/model"
12 | 	vo "github.com/wubin1989/nacos-sdk-go/v2/vo"
13 | )
14 | 
15 | // MockIConfigClient is a mock of IConfigClient interface.
16 | type MockIConfigClient struct {
17 | 	ctrl     *gomock.Controller
18 | 	recorder *MockIConfigClientMockRecorder
19 | }
20 | 
21 | // MockIConfigClientMockRecorder is the mock recorder for MockIConfigClient.
22 | type MockIConfigClientMockRecorder struct {
23 | 	mock *MockIConfigClient
24 | }
25 | 
26 | // NewMockIConfigClient creates a new mock instance.
27 | func NewMockIConfigClient(ctrl *gomock.Controller) *MockIConfigClient {
28 | 	mock := &MockIConfigClient{ctrl: ctrl}
29 | 	mock.recorder = &MockIConfigClientMockRecorder{mock}
30 | 	return mock
31 | }
32 | 
33 | // EXPECT returns an object that allows the caller to indicate expected use.
34 | func (m *MockIConfigClient) EXPECT() *MockIConfigClientMockRecorder {
35 | 	return m.recorder
36 | }
37 | 
38 | // CancelListenConfig mocks base method.
39 | func (m *MockIConfigClient) CancelListenConfig(params vo.ConfigParam) error {
40 | 	m.ctrl.T.Helper()
41 | 	ret := m.ctrl.Call(m, "CancelListenConfig", params)
42 | 	ret0, _ := ret[0].(error)
43 | 	return ret0
44 | }
45 | 
46 | // CancelListenConfig indicates an expected call of CancelListenConfig.
47 | func (mr *MockIConfigClientMockRecorder) CancelListenConfig(params interface{}) *gomock.Call {
48 | 	mr.mock.ctrl.T.Helper()
49 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CancelListenConfig", reflect.TypeOf((*MockIConfigClient)(nil).CancelListenConfig), params)
50 | }
51 | 
52 | // DeleteConfig mocks base method.
53 | func (m *MockIConfigClient) DeleteConfig(param vo.ConfigParam) (bool, error) {
54 | 	m.ctrl.T.Helper()
55 | 	ret := m.ctrl.Call(m, "DeleteConfig", param)
56 | 	ret0, _ := ret[0].(bool)
57 | 	ret1, _ := ret[1].(error)
58 | 	return ret0, ret1
59 | }
60 | 
61 | // DeleteConfig indicates an expected call of DeleteConfig.
62 | func (mr *MockIConfigClientMockRecorder) DeleteConfig(param interface{}) *gomock.Call {
63 | 	mr.mock.ctrl.T.Helper()
64 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteConfig", reflect.TypeOf((*MockIConfigClient)(nil).DeleteConfig), param)
65 | }
66 | 
67 | // GetConfig mocks base method.
68 | func (m *MockIConfigClient) GetConfig(param vo.ConfigParam) (string, error) {
69 | 	m.ctrl.T.Helper()
70 | 	ret := m.ctrl.Call(m, "GetConfig", param)
71 | 	ret0, _ := ret[0].(string)
72 | 	ret1, _ := ret[1].(error)
73 | 	return ret0, ret1
74 | }
75 | 
76 | // GetConfig indicates an expected call of GetConfig.
77 | func (mr *MockIConfigClientMockRecorder) GetConfig(param interface{}) *gomock.Call {
78 | 	mr.mock.ctrl.T.Helper()
79 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConfig", reflect.TypeOf((*MockIConfigClient)(nil).GetConfig), param)
80 | }
81 | 
82 | // ListenConfig mocks base method.
83 | func (m *MockIConfigClient) ListenConfig(params vo.ConfigParam) error {
84 | 	m.ctrl.T.Helper()
85 | 	ret := m.ctrl.Call(m, "ListenConfig", params)
86 | 	ret0, _ := ret[0].(error)
87 | 	return ret0
88 | }
89 | 
90 | // ListenConfig indicates an expected call of ListenConfig.
91 | func (mr *MockIConfigClientMockRecorder) ListenConfig(params interface{}) *gomock.Call {
92 | 	mr.mock.ctrl.T.Helper()
93 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListenConfig", reflect.TypeOf((*MockIConfigClient)(nil).ListenConfig), params)
94 | }
95 | 
96 | // PublishAggr mocks base method.
97 | func (m *MockIConfigClient) PublishAggr(param vo.ConfigParam) (bool, error) {
98 | 	m.ctrl.T.Helper()
99 | 	ret := m.ctrl.Call(m, "PublishAggr", param)
100 | 	ret0, _ := ret[0].(bool)
101 | 	ret1, _ := ret[1].(error)
102 | 	return ret0, ret1
103 | }
104 | 
105 | // PublishAggr indicates an expected call of PublishAggr.
106 | func (mr *MockIConfigClientMockRecorder) PublishAggr(param interface{}) *gomock.Call {
107 | 	mr.mock.ctrl.T.Helper()
108 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishAggr", reflect.TypeOf((*MockIConfigClient)(nil).PublishAggr), param)
109 | }
110 | 
111 | // PublishConfig mocks base method.
112 | func (m *MockIConfigClient) PublishConfig(param vo.ConfigParam) (bool, error) {
113 | 	m.ctrl.T.Helper()
114 | 	ret := m.ctrl.Call(m, "PublishConfig", param)
115 | 	ret0, _ := ret[0].(bool)
116 | 	ret1, _ := ret[1].(error)
117 | 	return ret0, ret1
118 | }
119 | 
120 | // PublishConfig indicates an expected call of PublishConfig.
121 | func (mr *MockIConfigClientMockRecorder) PublishConfig(param interface{}) *gomock.Call {
122 | 	mr.mock.ctrl.T.Helper()
123 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishConfig", reflect.TypeOf((*MockIConfigClient)(nil).PublishConfig), param)
124 | }
125 | 
126 | // SearchConfig mocks base method.
127 | func (m *MockIConfigClient) SearchConfig(param vo.SearchConfigParam) (*model.ConfigPage, error) {
128 | 	m.ctrl.T.Helper()
129 | 	ret := m.ctrl.Call(m, "SearchConfig", param)
130 | 	ret0, _ := ret[0].(*model.ConfigPage)
131 | 	ret1, _ := ret[1].(error)
132 | 	return ret0, ret1
133 | }
134 | 
135 | // SearchConfig indicates an expected call of SearchConfig.
136 | func (mr *MockIConfigClientMockRecorder) SearchConfig(param interface{}) *gomock.Call {
137 | 	mr.mock.ctrl.T.Helper()
138 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchConfig", reflect.TypeOf((*MockIConfigClient)(nil).SearchConfig), param)
139 | }
```

framework/grpcx/grpc_resolver_nacos/api.go
```
1 | package grpc_resolver_nacos
2 | 
3 | import "github.com/wubin1989/nacos-sdk-go/v2/vo"
4 | 
5 | func GetService(serviceName string, clusters []string, groupName string, nacosClient NacosClient) (NacosService, error) {
6 | 	service, err := nacosClient.GetService(vo.GetServiceParam{
7 | 		ServiceName: serviceName,
8 | 		Clusters:    clusters,
9 | 		GroupName:   groupName, // 默认值DEFAULT_GROUP
10 | 	})
11 | 	return service, err
12 | }
13 | 
14 | func GetOneHealthyInstance(serviceName string, clusters []string, groupName string, nacosClient NacosClient) (*NacosInstance, error) {
15 | 	instance, err := nacosClient.SelectOneHealthyInstance(vo.SelectOneHealthInstanceParam{
16 | 		ServiceName: serviceName,
17 | 		Clusters:    clusters,
18 | 		GroupName:   groupName, // 默认值DEFAULT_GROUP
19 | 	})
20 | 	return instance, err
21 | }
22 | 
23 | func GetHealthyInstances(serviceName string, clusters []string, groupName string, nacosClient NacosClient) ([]NacosInstance, error) {
24 | 	instances, err := nacosClient.SelectInstances(vo.SelectInstancesParam{
25 | 		ServiceName: serviceName,
26 | 		Clusters:    clusters,
27 | 		GroupName:   groupName, // 默认值DEFAULT_GROUP
28 | 		HealthyOnly: true,
29 | 	})
30 | 	return instances, err
31 | }
32 | 
33 | func RegisterInstance(ip string, port uint64, serviceName string, weight float64, enable bool, healthy bool,
34 | 	metadata map[string]string, clusterName string, groupName string, ephemeral bool, nacosClient NacosClient) (bool, error) {
35 | 	param := vo.RegisterInstanceParam{
36 | 		Ip:          ip,
37 | 		Port:        port,
38 | 		ServiceName: serviceName,
39 | 		Weight:      weight,
40 | 		Enable:      enable,
41 | 		Healthy:     healthy,
42 | 		Metadata:    metadata,
43 | 		ClusterName: clusterName,
44 | 		GroupName:   groupName,
45 | 		Ephemeral:   ephemeral,
46 | 	}
47 | 	success, err := nacosClient.RegisterInstance(param)
48 | 	return success, err
49 | }
```

framework/grpcx/grpc_resolver_nacos/balancer.go
```
1 | package grpc_resolver_nacos
2 | 
3 | import (
4 | 	"math/rand"
5 | 	"sort"
6 | 	"sync"
7 | 
8 | 	"github.com/unionj-cloud/toolkit/zlogger"
9 | 
10 | 	"google.golang.org/grpc/balancer"
11 | 	"google.golang.org/grpc/balancer/base"
12 | )
13 | 
14 | const Name = "nacos_weight_balancer"
15 | 
16 | func newBuilder() balancer.Builder {
17 | 	return base.NewBalancerBuilder(Name, &wPickerBuilder{}, base.Config{HealthCheck: true})
18 | }
19 | 
20 | func init() {
21 | 	balancer.Register(newBuilder())
22 | }
23 | 
24 | type wPickerBuilder struct{}
25 | 
26 | func (*wPickerBuilder) Build(info base.PickerBuildInfo) balancer.Picker {
27 | 	zlogger.Debug().Msgf("[go-doudou] nacos_weight_balancer Picker: Build called with info: %v", info)
28 | 	if len(info.ReadySCs) == 0 {
29 | 		return base.NewErrPicker(balancer.ErrNoSubConnAvailable)
30 | 	}
31 | 	scs := make([]conn, 0, len(info.ReadySCs))
32 | 	for sc, v := range info.ReadySCs {
33 | 		weight := v.Address.BalancerAttributes.Value(WeightAttributeKey{}).(WeightAddrInfo).Weight
34 | 		scs = append(scs, conn{sc: sc, Weight: weight})
35 | 	}
36 | 	return &wPicker{
37 | 		subConns: scs,
38 | 	}
39 | }
40 | 
41 | type wPicker struct {
42 | 	subConns conns
43 | 	mu       sync.Mutex
44 | }
45 | 
46 | func (p *wPicker) Pick(balancer.PickInfo) (balancer.PickResult, error) {
47 | 	p.mu.Lock()
48 | 	sc := newChooser(p.subConns).pick().sc
49 | 	p.mu.Unlock()
50 | 	return balancer.PickResult{SubConn: sc}, nil
51 | }
52 | 
53 | type WeightAttributeKey struct{}
54 | 
55 | type WeightAddrInfo struct {
56 | 	Weight int
57 | }
58 | 
59 | type conn struct {
60 | 	sc     balancer.SubConn
61 | 	Weight int
62 | }
63 | type conns []conn
64 | 
65 | func (a conns) Len() int {
66 | 	return len(a)
67 | }
68 | 
69 | func (a conns) Swap(i, j int) {
70 | 	a[i], a[j] = a[j], a[i]
71 | }
72 | 
73 | func (a conns) Less(i, j int) bool {
74 | 	return a[i].Weight < a[j].Weight
75 | }
76 | 
77 | // Chooser from naming_client package in nacos-sdk-go
78 | type Chooser struct {
79 | 	data   []conn
80 | 	totals []int
81 | 	max    int
82 | }
83 | 
84 | // NewChooser initializes a new Chooser for picking from the provided Choices.
85 | func newChooser(cs conns) Chooser {
86 | 	sort.Sort(cs)
87 | 	totals := make([]int, len(cs))
88 | 	runningTotal := 0
89 | 	for i, c := range cs {
90 | 		runningTotal += int(c.Weight)
91 | 		totals[i] = runningTotal
92 | 	}
93 | 	return Chooser{data: cs, totals: totals, max: runningTotal}
94 | }
95 | 
96 | func (chs Chooser) pick() conn {
97 | 	r := rand.Intn(chs.max) + 1
98 | 	i := sort.SearchInts(chs.totals, r)
99 | 	return chs.data[i]
100 | }
```

framework/grpcx/grpc_resolver_nacos/config.go
```
1 | package grpc_resolver_nacos
2 | 
3 | import (
4 | 	"net/url"
5 | 
6 | 	"github.com/pkg/errors"
7 | 
8 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/naming_client"
9 | 	"github.com/wubin1989/nacos-sdk-go/v2/model"
10 | )
11 | 
12 | type NacosClient = naming_client.INamingClient
13 | 
14 | type NacosInstance = model.Instance
15 | type NacosService = model.Service
16 | 
17 | type NacosConfig struct {
18 | 	Label       string //用做寻找配置的标签
19 | 	ServiceName string //标记服务名称
20 | 	Clusters    []string
21 | 	GroupName   string
22 | 	NacosClient NacosClient
23 | }
24 | 
25 | var NacosConfigs = make(map[string]*NacosConfig)
26 | 
27 | // AddNacosConfig is not thread-safe
28 | func AddNacosConfig(config NacosConfig) {
29 | 	NacosConfigs[config.Label] = &config
30 | }
31 | 
32 | // DelNacosConfig is not thread-safe
33 | func DelNacosConfig(label string) {
34 | 	delete(NacosConfigs, label)
35 | }
36 | 
37 | func parseURL(u string) (*NacosConfig, error) {
38 | 	rawURL, err := url.Parse(u)
39 | 	if err != nil {
40 | 		return &NacosConfig{}, errors.Wrap(err, "Wrong nacos URL")
41 | 	}
42 | 	if rawURL.Scheme != schemeName || len(rawURL.Host) == 0 {
43 | 		return &NacosConfig{}, errors.Wrap(err, "Wrong nacos URL")
44 | 	}
45 | 	config, ok := NacosConfigs[rawURL.Host]
46 | 	if !ok {
47 | 		return &NacosConfig{}, errors.Wrap(err, "The nacos config is not exist")
48 | 	}
49 | 	return config, nil
50 | }
```

framework/grpcx/grpc_resolver_nacos/nacos.go
```
1 | package grpc_resolver_nacos
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"strings"
7 | 	"time"
8 | 
9 | 	"github.com/pkg/errors"
10 | 	"google.golang.org/grpc/attributes"
11 | 	"google.golang.org/grpc/grpclog"
12 | 	"google.golang.org/grpc/resolver"
13 | )
14 | 
15 | const schemeName = "nacos"
16 | 
17 | const interval = 5 * time.Second
18 | 
19 | func init() {
20 | 	resolver.Register(&NacosResolver{})
21 | }
22 | 
23 | type NacosResolver struct {
24 | 	cancelFunc context.CancelFunc
25 | }
26 | 
27 | func (r *NacosResolver) Build(url resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (resolver.Resolver, error) {
28 | 	dsn := strings.Join([]string{schemeName + ":/", url.URL.Host, url.URL.Path}, "/")
29 | 	config, err := parseURL(dsn)
30 | 	if err != nil {
31 | 		return nil, errors.Wrap(err, "Wrong URL")
32 | 	}
33 | 
34 | 	ctx, cancel := context.WithCancel(context.Background())
35 | 	pipe := make(chan []serviceInfo)
36 | 	go watchNacosService(ctx, config, pipe)
37 | 	go populateEndpoints(ctx, cc, pipe)
38 | 
39 | 	return &NacosResolver{cancelFunc: cancel}, nil
40 | }
41 | 
42 | func (r *NacosResolver) Scheme() string {
43 | 	return schemeName
44 | }
45 | 
46 | func (r *NacosResolver) ResolveNow(resolver.ResolveNowOptions) {}
47 | 
48 | func (r *NacosResolver) Close() {
49 | 	r.cancelFunc()
50 | }
51 | 
52 | type serviceInfo struct {
53 | 	Address string
54 | 	Weight  int
55 | }
56 | 
57 | func watchNacosService(ctx context.Context, config *NacosConfig, out chan<- []serviceInfo) {
58 | 	res := make(chan []serviceInfo)
59 | 	quit := make(chan struct{})
60 | 	go func() {
61 | 		start := true
62 | 		for {
63 | 			if !start {
64 | 				time.Sleep(interval)
65 | 			}
66 | 			start = false
67 | 			inss, err := GetHealthyInstances(config.ServiceName, config.Clusters, config.GroupName, config.NacosClient)
68 | 			if err != nil {
69 | 				select {
70 | 				case <-quit:
71 | 					return
72 | 				default:
73 | 					grpclog.Errorf("[Nacos resolver] Couldn't fetch endpoints. label={%s}; error={%v}", config.Label, err)
74 | 					continue
75 | 				}
76 | 			}
77 | 			grpclog.Infof("[Nacos resolver] %d endpoints fetched for label={%s}",
78 | 				len(inss),
79 | 				config.Label,
80 | 			)
81 | 			ee := make([]serviceInfo, 0, len(inss))
82 | 			for _, s := range inss {
83 | 				address := fmt.Sprintf("%s:%d", s.Ip, s.Port)
84 | 				ee = append(ee, serviceInfo{Address: address, Weight: (int)(s.Weight)})
85 | 			}
86 | 			select {
87 | 			case res <- ee:
88 | 				continue
89 | 			case <-quit:
90 | 				return
91 | 			}
92 | 		}
93 | 	}()
94 | 	for {
95 | 		// If in the below select both channels have values that can be read,
96 | 		// Go picks one pseudo-randomly.
97 | 		// But when the context is canceled we want to act upon it immediately.
98 | 		if ctx.Err() != nil {
99 | 			// Close quit so the goroutine returns and doesn't leak.
100 | 			// Do NOT close res because that can lead to panics in the goroutine.
101 | 			// res will be garbage collected at some point.
102 | 			close(quit)
103 | 			return
104 | 		}
105 | 		select {
106 | 		case out <- <-res:
107 | 			continue
108 | 		case <-ctx.Done():
109 | 			close(quit)
110 | 			return
111 | 		}
112 | 	}
113 | }
114 | 
115 | func populateEndpoints(ctx context.Context, clientConn resolver.ClientConn, input <-chan []serviceInfo) {
116 | 	for {
117 | 		select {
118 | 		case cc := <-input:
119 | 			connsSet := make(map[serviceInfo]struct{}, len(cc))
120 | 			for _, c := range cc {
121 | 				connsSet[c] = struct{}{}
122 | 			}
123 | 			conns := make([]resolver.Address, 0, len(connsSet))
124 | 			for c := range connsSet {
125 | 				add := resolver.Address{Addr: c.Address,
126 | 					BalancerAttributes: attributes.New(WeightAttributeKey{}, WeightAddrInfo{Weight: c.Weight})}
127 | 				//fmt.Printf("%v/n", add)
128 | 				conns = append(conns, add)
129 | 			}
130 | 			clientConn.UpdateState(resolver.State{Addresses: conns})
131 | 		case <-ctx.Done():
132 | 			grpclog.Info("[Nacos resolver] Watch has been finished")
133 | 			return
134 | 		}
135 | 	}
136 | }
```

framework/grpcx/grpc_resolver_zk/balancer.go
```
1 | package grpc_resolver_zk
2 | 
3 | import (
4 | 	"math/rand"
5 | 	"sort"
6 | 	"sync"
7 | 
8 | 	"github.com/unionj-cloud/toolkit/zlogger"
9 | 
10 | 	"google.golang.org/grpc/balancer"
11 | 	"google.golang.org/grpc/balancer/base"
12 | )
13 | 
14 | const Name = "zk_weight_balancer"
15 | 
16 | func newBuilder() balancer.Builder {
17 | 	return base.NewBalancerBuilder(Name, &wPickerBuilder{}, base.Config{HealthCheck: true})
18 | }
19 | 
20 | func init() {
21 | 	balancer.Register(newBuilder())
22 | }
23 | 
24 | type wPickerBuilder struct{}
25 | 
26 | func (*wPickerBuilder) Build(info base.PickerBuildInfo) balancer.Picker {
27 | 	zlogger.Debug().Msgf("[go-doudou] zk_weight_balancer Picker: Build called with info: %v", info)
28 | 	if len(info.ReadySCs) == 0 {
29 | 		return base.NewErrPicker(balancer.ErrNoSubConnAvailable)
30 | 	}
31 | 	scs := make([]conn, 0, len(info.ReadySCs))
32 | 	for sc, v := range info.ReadySCs {
33 | 		weight := v.Address.BalancerAttributes.Value(WeightAttributeKey{}).(WeightAddrInfo).Weight
34 | 		scs = append(scs, conn{sc: sc, Weight: weight})
35 | 	}
36 | 	return &wPicker{
37 | 		subConns: scs,
38 | 	}
39 | }
40 | 
41 | type wPicker struct {
42 | 	subConns conns
43 | 	mu       sync.Mutex
44 | }
45 | 
46 | func (p *wPicker) Pick(balancer.PickInfo) (balancer.PickResult, error) {
47 | 	p.mu.Lock()
48 | 	sc := newChooser(p.subConns).pick().sc
49 | 	p.mu.Unlock()
50 | 	return balancer.PickResult{SubConn: sc}, nil
51 | }
52 | 
53 | type WeightAttributeKey struct{}
54 | 
55 | type WeightAddrInfo struct {
56 | 	Weight int
57 | }
58 | 
59 | type conn struct {
60 | 	sc     balancer.SubConn
61 | 	Weight int
62 | }
63 | type conns []conn
64 | 
65 | func (a conns) Len() int {
66 | 	return len(a)
67 | }
68 | 
69 | func (a conns) Swap(i, j int) {
70 | 	a[i], a[j] = a[j], a[i]
71 | }
72 | 
73 | func (a conns) Less(i, j int) bool {
74 | 	return a[i].Weight < a[j].Weight
75 | }
76 | 
77 | type Chooser struct {
78 | 	data   []conn
79 | 	totals []int
80 | 	max    int
81 | }
82 | 
83 | // NewChooser initializes a new Chooser for picking from the provided Choices.
84 | func newChooser(cs conns) Chooser {
85 | 	sort.Sort(cs)
86 | 	totals := make([]int, len(cs))
87 | 	runningTotal := 0
88 | 	for i, c := range cs {
89 | 		runningTotal += int(c.Weight)
90 | 		totals[i] = runningTotal
91 | 	}
92 | 	return Chooser{data: cs, totals: totals, max: runningTotal}
93 | }
94 | 
95 | func (chs Chooser) pick() conn {
96 | 	r := rand.Intn(chs.max) + 1
97 | 	i := sort.SearchInts(chs.totals, r)
98 | 	return chs.data[i]
99 | }
```

framework/grpcx/grpc_resolver_zk/config.go
```
1 | package grpc_resolver_zk
2 | 
3 | import (
4 | 	"net/url"
5 | 
6 | 	"github.com/pkg/errors"
7 | )
8 | 
9 | // A Watcher represents how a serverset.Watch is used so it can be stubbed out for tests.
10 | type Watcher interface {
11 | 	Endpoints() []string
12 | 	Event() <-chan struct{}
13 | 	IsClosed() bool
14 | 	Close()
15 | }
16 | 
17 | type ZkConfig struct {
18 | 	Label       string //用做寻找配置的标签
19 | 	ServiceName string //标记服务名称
20 | 	Watcher     Watcher
21 | 	Group       string
22 | 	Version     string
23 | }
24 | 
25 | var ZkConfigs = make(map[string]*ZkConfig)
26 | 
27 | // AddZkConfig is not thread-safe
28 | func AddZkConfig(config ZkConfig) {
29 | 	//ZkConfigs.Store(config.Label, &config)
30 | 	ZkConfigs[config.Label] = &config
31 | }
32 | 
33 | func DelZkConfig(label string) {
34 | 	delete(ZkConfigs, label)
35 | }
36 | 
37 | func parseURL(u string) (*ZkConfig, error) {
38 | 	rawURL, err := url.Parse(u)
39 | 	if err != nil {
40 | 		return &ZkConfig{}, errors.Wrap(err, "Wrong zookeeper URL")
41 | 	}
42 | 	if rawURL.Scheme != schemeName || len(rawURL.Host) == 0 {
43 | 		return &ZkConfig{}, errors.Wrap(err, "Wrong zookeeper URL")
44 | 	}
45 | 	config, ok := ZkConfigs[rawURL.Host]
46 | 	if !ok {
47 | 		return &ZkConfig{}, errors.Wrap(err, "The zookeeper config is not exist")
48 | 	}
49 | 	return config, nil
50 | }
```

framework/grpcx/grpc_resolver_zk/zk.go
```
1 | package grpc_resolver_zk
2 | 
3 | import (
4 | 	"net/url"
5 | 	"strings"
6 | 
7 | 	"github.com/pkg/errors"
8 | 	"github.com/unionj-cloud/toolkit/cast"
9 | 	"google.golang.org/grpc/attributes"
10 | 	"google.golang.org/grpc/resolver"
11 | )
12 | 
13 | const schemeName = "zk"
14 | 
15 | func init() {
16 | 	resolver.Register(&ZkResolver{})
17 | }
18 | 
19 | type ZkResolver struct {
20 | 	*ZkConfig
21 | }
22 | 
23 | func (r *ZkResolver) Build(url resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (resolver.Resolver, error) {
24 | 	dsn := strings.Join([]string{schemeName + ":/", url.URL.Host, url.URL.Path}, "/")
25 | 	config, err := parseURL(dsn)
26 | 	if err != nil {
27 | 		return nil, errors.Wrap(err, "Wrong URL")
28 | 	}
29 | 	zkResolver := &ZkResolver{
30 | 		ZkConfig: config,
31 | 	}
32 | 	go zkResolver.watchZkService(cc)
33 | 	return zkResolver, nil
34 | }
35 | 
36 | func (r *ZkResolver) Scheme() string {
37 | 	return schemeName
38 | }
39 | 
40 | func (r *ZkResolver) ResolveNow(resolver.ResolveNowOptions) {}
41 | 
42 | func (r *ZkResolver) Close() {
43 | 	r.Watcher.Close()
44 | }
45 | 
46 | type serviceInfo struct {
47 | 	Address string
48 | 	Weight  int
49 | }
50 | 
51 | func (r *ZkResolver) updateState(clientConn resolver.ClientConn) {
52 | 	services := r.convertToAddress(r.Watcher.Endpoints())
53 | 	connsSet := make(map[serviceInfo]struct{}, len(services))
54 | 	for _, c := range services {
55 | 		connsSet[c] = struct{}{}
56 | 	}
57 | 	addrs := make([]resolver.Address, 0, len(connsSet))
58 | 	for c := range connsSet {
59 | 		addr := resolver.Address{Addr: c.Address,
60 | 			BalancerAttributes: attributes.New(WeightAttributeKey{}, WeightAddrInfo{Weight: c.Weight})}
61 | 		addrs = append(addrs, addr)
62 | 	}
63 | 	clientConn.UpdateState(resolver.State{Addresses: addrs})
64 | }
65 | 
66 | func (r *ZkResolver) watchZkService(clientConn resolver.ClientConn) {
67 | 	r.updateState(clientConn)
68 | 	for {
69 | 		select {
70 | 		case _, ok := <-r.Watcher.Event():
71 | 			if !ok {
72 | 				return
73 | 			}
74 | 			r.updateState(clientConn)
75 | 		}
76 | 
77 | 		if r.Watcher.IsClosed() {
78 | 			return
79 | 		}
80 | 	}
81 | }
82 | 
83 | func (r *ZkResolver) convertToAddress(ups []string) (addrs []serviceInfo) {
84 | 	for _, up := range ups {
85 | 		unescaped, _ := url.QueryUnescape(up)
86 | 		u, _ := url.Parse(unescaped)
87 | 		weight := cast.ToIntOrDefault(u.Query().Get("weight"), 1)
88 | 		group := u.Query().Get("group")
89 | 		version := u.Query().Get("version")
90 | 		if group != r.Group || version != r.Version {
91 | 			continue
92 | 		}
93 | 		addrs = append(addrs, serviceInfo{Address: u.Host, Weight: weight})
94 | 	}
95 | 	return
96 | }
```

framework/ratelimit/memrate/memorystore.go
```
1 | package memrate
2 | 
3 | import (
4 | 	"context"
5 | 	"sync"
6 | 
7 | 	lru "github.com/hashicorp/golang-lru"
8 | 	"github.com/hashicorp/golang-lru/simplelru"
9 | 	"github.com/unionj-cloud/go-doudou/v2/framework/ratelimit"
10 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
11 | )
12 | 
13 | const defaultMaxKeys = 256
14 | 
15 | type LimiterFn func(ctx context.Context, store *MemoryStore, key string) ratelimit.Limiter
16 | 
17 | type MemoryStore struct {
18 | 	keys      *lru.Cache
19 | 	maxKeys   int
20 | 	onEvicted simplelru.EvictCallback
21 | 	limiterFn LimiterFn
22 | 	mu        sync.RWMutex
23 | }
24 | 
25 | type MemoryStoreOption func(*MemoryStore)
26 | 
27 | // WithMaxKeys set maxKeys
28 | func WithMaxKeys(maxKeys int) MemoryStoreOption {
29 | 	return func(ls *MemoryStore) {
30 | 		ls.maxKeys = maxKeys
31 | 	}
32 | }
33 | 
34 | // WithOnEvicted set onEvicted
35 | func WithOnEvicted(onEvicted func(key interface{}, value interface{})) MemoryStoreOption {
36 | 	return func(ls *MemoryStore) {
37 | 		ls.onEvicted = onEvicted
38 | 	}
39 | }
40 | 
41 | func NewMemoryStore(fn LimiterFn, opts ...MemoryStoreOption) *MemoryStore {
42 | 	store := &MemoryStore{
43 | 		maxKeys:   defaultMaxKeys,
44 | 		limiterFn: fn,
45 | 	}
46 | 
47 | 	for _, opt := range opts {
48 | 		opt(store)
49 | 	}
50 | 
51 | 	if store.onEvicted != nil {
52 | 		store.keys, _ = lru.NewWithEvict(store.maxKeys, store.onEvicted)
53 | 	} else {
54 | 		store.keys, _ = lru.New(store.maxKeys)
55 | 	}
56 | 
57 | 	return store
58 | }
59 | 
60 | // GetLimiter returns the rate limiter for the provided key if it exists,
61 | // otherwise calls addKey to add key to the map
62 | func (store *MemoryStore) GetLimiter(key string) ratelimit.Limiter {
63 | 	return store.GetLimiterCtx(context.Background(), key)
64 | }
65 | 
66 | func (store *MemoryStore) addKeyCtx(ctx context.Context, key string) ratelimit.Limiter {
67 | 	store.mu.Lock()
68 | 	defer store.mu.Unlock()
69 | 
70 | 	limiter, exists := store.keys.Get(key)
71 | 	if exists {
72 | 		return limiter.(ratelimit.Limiter)
73 | 	}
74 | 
75 | 	limiter = store.limiterFn(ctx, store, key)
76 | 	store.keys.Add(key, limiter)
77 | 
78 | 	return limiter.(ratelimit.Limiter)
79 | }
80 | 
81 | // GetLimiterCtx returns the rate limiter for the provided key if it exists,
82 | // otherwise calls addKey to add key to the map
83 | func (store *MemoryStore) GetLimiterCtx(ctx context.Context, key string) ratelimit.Limiter {
84 | 	store.mu.RLock()
85 | 
86 | 	limiter, exists := store.keys.Get(key)
87 | 	if !exists {
88 | 		store.mu.RUnlock()
89 | 		return store.addKeyCtx(ctx, key)
90 | 	}
91 | 
92 | 	store.mu.RUnlock()
93 | 	return limiter.(ratelimit.Limiter)
94 | }
95 | 
96 | func (store *MemoryStore) DeleteKey(key string) {
97 | 	store.mu.Lock()
98 | 	defer store.mu.Unlock()
99 | 
100 | 	store.keys.Remove(key)
101 | 	logger.Debug().Msgf("[go-doudou] key %s is deleted from store", key)
102 | }
```

framework/ratelimit/memrate/memorystore_test.go
```
1 | package memrate
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"reflect"
7 | 	"testing"
8 | 
9 | 	lru "github.com/hashicorp/golang-lru"
10 | 	"github.com/stretchr/testify/assert"
11 | 	"github.com/unionj-cloud/go-doudou/v2/framework/ratelimit"
12 | )
13 | 
14 | func TestMemoryStore_addKey(t *testing.T) {
15 | 	type fields struct {
16 | 		keys      map[string]ratelimit.Limiter
17 | 		limiterFn LimiterFn
18 | 	}
19 | 	type args struct {
20 | 		key string
21 | 	}
22 | 	limiter := NewLimiter(1, 3)
23 | 	tests := []struct {
24 | 		name   string
25 | 		fields fields
26 | 		args   args
27 | 		want   ratelimit.Limiter
28 | 	}{
29 | 		{
30 | 			name: "",
31 | 			fields: fields{
32 | 				keys: make(map[string]ratelimit.Limiter),
33 | 				limiterFn: func(ctx context.Context, store *MemoryStore, key string) ratelimit.Limiter {
34 | 					return NewLimiter(1, 3)
35 | 				},
36 | 			},
37 | 			args: args{
38 | 				key: "192.168.1.6:8080",
39 | 			},
40 | 			want: limiter,
41 | 		},
42 | 	}
43 | 	for _, tt := range tests {
44 | 		t.Run(tt.name, func(t *testing.T) {
45 | 			keys, _ := lru.New(256)
46 | 			store := &MemoryStore{
47 | 				keys:      keys,
48 | 				limiterFn: tt.fields.limiterFn,
49 | 			}
50 | 			if got := store.addKeyCtx(context.Background(), tt.args.key); !reflect.DeepEqual(got, tt.want) {
51 | 				t.Errorf("addKey() = %v, want %v", got, tt.want)
52 | 			}
53 | 		})
54 | 	}
55 | }
56 | 
57 | func TestMemoryStore_GetLimiter(t *testing.T) {
58 | 	type fields struct {
59 | 		keys      map[string]ratelimit.Limiter
60 | 		limiterFn LimiterFn
61 | 	}
62 | 	type args struct {
63 | 		key string
64 | 	}
65 | 	limiter := NewLimiter(1, 3)
66 | 	key := "192.168.1.6:8080"
67 | 	keys, _ := lru.New(256)
68 | 	store := &MemoryStore{
69 | 		keys: keys,
70 | 		limiterFn: func(ctx context.Context, store *MemoryStore, key string) ratelimit.Limiter {
71 | 			return NewLimiter(1, 3)
72 | 		},
73 | 	}
74 | 	assert.Equal(t, limiter, store.GetLimiter(key))
75 | 	assert.Equal(t, limiter, store.GetLimiter(key))
76 | }
77 | 
78 | func TestMemoryStore_DeleteKey(t *testing.T) {
79 | 	key := "192.168.1.6:8080"
80 | 	keys, _ := lru.New(256)
81 | 	store := &MemoryStore{
82 | 		keys: keys,
83 | 		limiterFn: func(ctx context.Context, store *MemoryStore, key string) ratelimit.Limiter {
84 | 			return NewLimiter(1, 3)
85 | 		},
86 | 	}
87 | 	store.addKeyCtx(context.Background(), key)
88 | 	store.addKeyCtx(context.Background(), key)
89 | 	if exists := store.keys.Contains(key); !exists {
90 | 		t.Error("key should exists")
91 | 	}
92 | 	store.DeleteKey(key)
93 | 	if exists := store.keys.Contains(key); exists {
94 | 		t.Error("key should not exists")
95 | 	}
96 | }
97 | 
98 | func TestNewMemoryStore(t *testing.T) {
99 | 	type args struct {
100 | 		fn   LimiterFn
101 | 		opts []MemoryStoreOption
102 | 	}
103 | 	tests := []struct {
104 | 		name string
105 | 		args args
106 | 	}{
107 | 		{
108 | 			name: "",
109 | 			args: args{
110 | 				fn: func(ctx context.Context, store *MemoryStore, key string) ratelimit.Limiter {
111 | 					return NewLimiter(1, 3)
112 | 				},
113 | 				opts: nil,
114 | 			},
115 | 		},
116 | 		{
117 | 			name: "",
118 | 			args: args{
119 | 				fn: func(ctx context.Context, store *MemoryStore, key string) ratelimit.Limiter {
120 | 					return NewLimiter(1, 3)
121 | 				},
122 | 				opts: []MemoryStoreOption{
123 | 					WithMaxKeys(100),
124 | 					WithOnEvicted(func(key interface{}, value interface{}) {
125 | 						fmt.Println(key, value)
126 | 					}),
127 | 				},
128 | 			},
129 | 		},
130 | 	}
131 | 	for _, tt := range tests {
132 | 		t.Run(tt.name, func(t *testing.T) {
133 | 			if got := NewMemoryStore(tt.args.fn, tt.args.opts...); got == nil {
134 | 				t.Error("NewMemoryStore() = nil")
135 | 			}
136 | 		})
137 | 	}
138 | }
```

framework/ratelimit/memrate/rate.go
```
1 | // Copyright 2015 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | // Package memrate provides a rate limiter.
6 | package memrate
7 | 
8 | import (
9 | 	"context"
10 | 	"fmt"
11 | 	"math"
12 | 	"sync"
13 | 	"time"
14 | 
15 | 	"github.com/unionj-cloud/go-doudou/v2/framework/ratelimit"
16 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
17 | )
18 | 
19 | // Limit defines the maximum frequency of some events.
20 | // Limit is represented as number of events per second.
21 | // A zero Limit allows no events.
22 | type Limit float64
23 | 
24 | // Inf is the infinite rate limit; it allows all events (even if burst is zero).
25 | const Inf = Limit(math.MaxFloat64)
26 | 
27 | // Every converts a minimum time interval between events to a Limit.
28 | func Every(interval time.Duration) Limit {
29 | 	if interval <= 0 {
30 | 		return Inf
31 | 	}
32 | 	return 1 / Limit(interval.Seconds())
33 | }
34 | 
35 | // A Limiter controls how frequently events are allowed to happen.
36 | // It implements a "token bucket" of size b, initially full and refilled
37 | // at rate r tokens per second.
38 | // Informally, in any large enough time interval, the Limiter limits the
39 | // rate to r tokens per second, with a maximum burst size of b events.
40 | // As a special case, if r == Inf (the infinite rate), b is ignored.
41 | // See https://en.wikipedia.org/wiki/Token_bucket for more about token buckets.
42 | //
43 | // The zero value is a valid Limiter, but it will reject all events.
44 | // Use NewLimiter to create non-zero Limiters.
45 | //
46 | // Limiter has three main methods, Allow, Reserve, and Wait.
47 | // Most callers should use Wait.
48 | //
49 | // Each of the three methods consumes a single token.
50 | // They differ in their behavior when no token is available.
51 | // If no token is available, Allow returns false.
52 | // If no token is available, Reserve returns a reservation for a future token
53 | // and the amount of time the caller must wait before using it.
54 | // If no token is available, Wait blocks until one can be obtained
55 | // or its associated context.Context is canceled.
56 | //
57 | // The methods AllowN, ReserveN, and WaitN consume n tokens.
58 | type Limiter struct {
59 | 	mu     sync.Mutex
60 | 	limit  Limit
61 | 	burst  int
62 | 	tokens float64
63 | 	// last is the last time the limiter's tokens field was updated
64 | 	last time.Time
65 | 	// lastEvent is the latest time of a rate-limited event (past or future)
66 | 	lastEvent time.Time
67 | 	timer     *time.Timer
68 | 	timeout   time.Duration
69 | }
70 | 
71 | // Limit returns the maximum overall event rate.
72 | func (lim *Limiter) Limit() Limit {
73 | 	lim.mu.Lock()
74 | 	defer lim.mu.Unlock()
75 | 	return lim.limit
76 | }
77 | 
78 | // Burst returns the maximum burst size. Burst is the maximum number of tokens
79 | // that can be consumed in a single call to Allow, Reserve, or Wait, so higher
80 | // Burst values allow more events to happen at once.
81 | // A zero Burst allows no events, unless limit == Inf.
82 | func (lim *Limiter) Burst() int {
83 | 	lim.mu.Lock()
84 | 	defer lim.mu.Unlock()
85 | 	return lim.burst
86 | }
87 | 
88 | type LimiterOption func(*Limiter)
89 | 
90 | func WithTimer(timeout time.Duration, fn func()) LimiterOption {
91 | 	return func(lim *Limiter) {
92 | 		lim.timeout = timeout
93 | 		lim.timer = time.AfterFunc(timeout, fn)
94 | 	}
95 | }
96 | 
97 | // NewLimiter returns a new Limiter that allows events up to rate r and permits
98 | // bursts of at most b tokens.
99 | func NewLimiter(r Limit, b int, opts ...LimiterOption) *Limiter {
100 | 	lim := &Limiter{
101 | 		limit: r,
102 | 		burst: b,
103 | 	}
104 | 
105 | 	for _, opt := range opts {
106 | 		opt(lim)
107 | 	}
108 | 	return lim
109 | }
110 | 
111 | // NewLimiterLimit returns a new Limiter that allows events up to rate r and permits
112 | // bursts of at most b tokens.
113 | func NewLimiterLimit(l ratelimit.Limit, opts ...LimiterOption) *Limiter {
114 | 	lim := &Limiter{
115 | 		limit: Limit(l.Rate / l.Period.Seconds()),
116 | 		burst: l.Burst,
117 | 	}
118 | 
119 | 	for _, opt := range opts {
120 | 		opt(lim)
121 | 	}
122 | 	return lim
123 | }
124 | 
125 | // Allow is shorthand for AllowN(time.Now(), 1).
126 | func (lim *Limiter) Allow() bool {
127 | 	allow, _ := lim.AllowE()
128 | 	return allow
129 | }
130 | 
131 | // AllowN reports whether n events may happen at time now.
132 | // Use this method if you intend to drop / skip events that exceed the rate limit.
133 | // Otherwise, use Reserve or Wait.
134 | func (lim *Limiter) AllowN(now time.Time, n int) bool {
135 | 	return lim.reserveN(now, n, 0).ok
136 | }
137 | 
138 | // A Reservation holds information about events that are permitted by a Limiter to happen after a delay.
139 | // A Reservation may be canceled, which may enable the Limiter to permit additional events.
140 | type Reservation struct {
141 | 	ok        bool
142 | 	lim       *Limiter
143 | 	tokens    int
144 | 	timeToAct time.Time
145 | 	// This is the Limit at reservation time, it can change later.
146 | 	limit Limit
147 | }
148 | 
149 | // OK returns whether the limiter can provide the requested number of tokens
150 | // within the maximum wait time.  If OK is false, Delay returns InfDuration, and
151 | // Cancel does nothing.
152 | func (r *Reservation) OK() bool {
153 | 	return r.ok
154 | }
155 | 
156 | // Delay is shorthand for DelayFrom(time.Now()).
157 | func (r *Reservation) Delay() time.Duration {
158 | 	return r.DelayFrom(time.Now())
159 | }
160 | 
161 | // InfDuration is the duration returned by Delay when a Reservation is not OK.
162 | const InfDuration = time.Duration(1<<63 - 1)
163 | 
164 | // DelayFrom returns the duration for which the reservation holder must wait
165 | // before taking the reserved action.  Zero duration means act immediately.
166 | // InfDuration means the limiter cannot grant the tokens requested in this
167 | // Reservation within the maximum wait time.
168 | func (r *Reservation) DelayFrom(now time.Time) time.Duration {
169 | 	if !r.ok {
170 | 		return InfDuration
171 | 	}
172 | 	delay := r.timeToAct.Sub(now)
173 | 	if delay < 0 {
174 | 		return 0
175 | 	}
176 | 	return delay
177 | }
178 | 
179 | // Cancel is shorthand for CancelAt(time.Now()).
180 | func (r *Reservation) Cancel() {
181 | 	r.CancelAt(time.Now())
182 | }
183 | 
184 | // CancelAt indicates that the reservation holder will not perform the reserved action
185 | // and reverses the effects of this Reservation on the rate limit as much as possible,
186 | // considering that other reservations may have already been made.
187 | func (r *Reservation) CancelAt(now time.Time) {
188 | 	if !r.ok {
189 | 		return
190 | 	}
191 | 
192 | 	r.lim.mu.Lock()
193 | 	defer r.lim.mu.Unlock()
194 | 
195 | 	if r.lim.limit == Inf || r.tokens == 0 || r.timeToAct.Before(now) {
196 | 		return
197 | 	}
198 | 
199 | 	// calculate tokens to restore
200 | 	// The duration between lim.lastEvent and r.timeToAct tells us how many tokens were reserved
201 | 	// after r was obtained. These tokens should not be restored.
202 | 	restoreTokens := float64(r.tokens) - r.limit.tokensFromDuration(r.lim.lastEvent.Sub(r.timeToAct))
203 | 	if restoreTokens <= 0 {
204 | 		return
205 | 	}
206 | 	// advance time to now
207 | 	now, _, tokens := r.lim.advance(now)
208 | 	// calculate new number of tokens
209 | 	tokens += restoreTokens
210 | 	if burst := float64(r.lim.burst); tokens > burst {
211 | 		tokens = burst
212 | 	}
213 | 	// update state
214 | 	r.lim.last = now
215 | 	r.lim.tokens = tokens
216 | 	if r.timeToAct == r.lim.lastEvent {
217 | 		prevEvent := r.timeToAct.Add(r.limit.durationFromTokens(float64(-r.tokens)))
218 | 		if !prevEvent.Before(now) {
219 | 			r.lim.lastEvent = prevEvent
220 | 		}
221 | 	}
222 | }
223 | 
224 | // reserve is shorthand for ReserveN(time.Now(), 1).
225 | func (lim *Limiter) reserve() *Reservation {
226 | 	return lim.ReserveN(time.Now(), 1)
227 | }
228 | 
229 | // ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.
230 | // The Limiter takes this Reservation into account when allowing future events.
231 | // The returned Reservation’s OK() method returns false if n exceeds the Limiter's burst size.
232 | // Usage example:
233 | //
234 | //	r := lim.ReserveN(time.Now(), 1)
235 | //	if !r.OK() {
236 | //	  // Not allowed to act! Did you remember to set lim.burst to be > 0 ?
237 | //	  return
238 | //	}
239 | //	time.Sleep(r.Delay())
240 | //	Act()
241 | //
242 | // Use this method if you wish to wait and slow down in accordance with the rate limit without dropping events.
243 | // If you need to respect a deadline or cancel the delay, use Wait instead.
244 | // To drop or skip events exceeding rate limit, use Allow instead.
245 | func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation {
246 | 	r := lim.reserveN(now, n, InfDuration)
247 | 	return &r
248 | }
249 | 
250 | // Wait is shorthand for WaitN(ctx, 1).
251 | func (lim *Limiter) Wait(ctx context.Context) (err error) {
252 | 	return lim.WaitN(ctx, 1)
253 | }
254 | 
255 | // WaitN blocks until lim permits n events to happen.
256 | // It returns an error if n exceeds the Limiter's burst size, the Context is
257 | // canceled, or the expected wait time exceeds the Context's Deadline.
258 | // The burst limit is ignored if the rate limit is Inf.
259 | func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) {
260 | 	lim.mu.Lock()
261 | 	burst := lim.burst
262 | 	limit := lim.limit
263 | 	lim.mu.Unlock()
264 | 
265 | 	if n > burst && limit != Inf {
266 | 		return fmt.Errorf("rate: Wait(n=%d) exceeds limiter's burst %d", n, burst)
267 | 	}
268 | 	// Check if ctx is already cancelled
269 | 	select {
270 | 	case <-ctx.Done():
271 | 		return ctx.Err()
272 | 	default:
273 | 	}
274 | 	// Determine wait limit
275 | 	now := time.Now()
276 | 	waitLimit := InfDuration
277 | 	if deadline, ok := ctx.Deadline(); ok {
278 | 		waitLimit = deadline.Sub(now)
279 | 	}
280 | 	// Reserve
281 | 	r := lim.reserveN(now, n, waitLimit)
282 | 	if !r.ok {
283 | 		return fmt.Errorf("rate: Wait(n=%d) would exceed context deadline", n)
284 | 	}
285 | 	// Wait if necessary
286 | 	delay := r.DelayFrom(now)
287 | 	if delay == 0 {
288 | 		return nil
289 | 	}
290 | 	t := time.NewTimer(delay)
291 | 	defer t.Stop()
292 | 	select {
293 | 	case <-t.C:
294 | 		// We can proceed.
295 | 		return nil
296 | 	case <-ctx.Done():
297 | 		// Context was canceled before we could proceed.  Cancel the
298 | 		// reservation, which may permit other events to proceed sooner.
299 | 		r.Cancel()
300 | 		return ctx.Err()
301 | 	}
302 | }
303 | 
304 | // SetLimit is shorthand for SetLimitAt(time.Now(), newLimit).
305 | func (lim *Limiter) SetLimit(newLimit Limit) {
306 | 	lim.SetLimitAt(time.Now(), newLimit)
307 | }
308 | 
309 | // SetLimitAt sets a new Limit for the limiter. The new Limit, and Burst, may be violated
310 | // or underutilized by those which reserved (using Reserve or Wait) but did not yet act
311 | // before SetLimitAt was called.
312 | func (lim *Limiter) SetLimitAt(now time.Time, newLimit Limit) {
313 | 	lim.mu.Lock()
314 | 	defer lim.mu.Unlock()
315 | 
316 | 	now, _, tokens := lim.advance(now)
317 | 
318 | 	lim.last = now
319 | 	lim.tokens = tokens
320 | 	lim.limit = newLimit
321 | }
322 | 
323 | // SetBurst is shorthand for SetBurstAt(time.Now(), newBurst).
324 | func (lim *Limiter) SetBurst(newBurst int) {
325 | 	lim.SetBurstAt(time.Now(), newBurst)
326 | }
327 | 
328 | // SetBurstAt sets a new burst size for the limiter.
329 | func (lim *Limiter) SetBurstAt(now time.Time, newBurst int) {
330 | 	lim.mu.Lock()
331 | 	defer lim.mu.Unlock()
332 | 
333 | 	now, _, tokens := lim.advance(now)
334 | 
335 | 	lim.last = now
336 | 	lim.tokens = tokens
337 | 	lim.burst = newBurst
338 | }
339 | 
340 | func (lim *Limiter) resetTimer() {
341 | 	if lim.timer != nil && lim.timer.Stop() {
342 | 		lim.timer.Reset(lim.timeout)
343 | 	}
344 | }
345 | 
346 | // reserveN is a helper method for AllowN, ReserveN, and WaitN.
347 | // maxFutureReserve specifies the maximum reservation wait duration allowed.
348 | // reserveN returns Reservation, not *Reservation, to avoid allocation in AllowN and WaitN.
349 | func (lim *Limiter) reserveN(now time.Time, n int, maxFutureReserve time.Duration) Reservation {
350 | 	lim.mu.Lock()
351 | 	defer lim.mu.Unlock()
352 | 	defer lim.resetTimer()
353 | 
354 | 	if lim.limit == Inf {
355 | 		return Reservation{
356 | 			ok:        true,
357 | 			lim:       lim,
358 | 			tokens:    n,
359 | 			timeToAct: now,
360 | 		}
361 | 	} else if lim.limit == 0 {
362 | 		var ok bool
363 | 		if lim.burst >= n {
364 | 			ok = true
365 | 			lim.burst -= n
366 | 		}
367 | 		return Reservation{
368 | 			ok:        ok,
369 | 			lim:       lim,
370 | 			tokens:    lim.burst,
371 | 			timeToAct: now,
372 | 		}
373 | 	}
374 | 
375 | 	now, last, tokens := lim.advance(now)
376 | 
377 | 	// Calculate the remaining number of tokens resulting from the request.
378 | 	tokens -= float64(n)
379 | 
380 | 	// Calculate the wait duration
381 | 	var waitDuration time.Duration
382 | 	if tokens < 0 {
383 | 		waitDuration = lim.limit.durationFromTokens(-tokens)
384 | 	}
385 | 
386 | 	// Decide result
387 | 	ok := n <= lim.burst && waitDuration <= maxFutureReserve
388 | 
389 | 	// Prepare reservation
390 | 	r := Reservation{
391 | 		ok:    ok,
392 | 		lim:   lim,
393 | 		limit: lim.limit,
394 | 	}
395 | 	if ok {
396 | 		r.tokens = n
397 | 		r.timeToAct = now.Add(waitDuration)
398 | 	}
399 | 
400 | 	// Update state
401 | 	if ok {
402 | 		lim.last = now
403 | 		lim.tokens = tokens
404 | 		lim.lastEvent = r.timeToAct
405 | 	} else {
406 | 		lim.last = last
407 | 	}
408 | 
409 | 	return r
410 | }
411 | 
412 | // advance calculates and returns an updated state for lim resulting from the passage of time.
413 | // lim is not changed.
414 | // advance requires that lim.mu is held.
415 | func (lim *Limiter) advance(now time.Time) (newNow time.Time, newLast time.Time, newTokens float64) {
416 | 	last := lim.last
417 | 	if now.Before(last) {
418 | 		last = now
419 | 	}
420 | 
421 | 	// Calculate the new number of tokens, due to time that passed.
422 | 	elapsed := now.Sub(last)
423 | 	delta := lim.limit.tokensFromDuration(elapsed)
424 | 	tokens := lim.tokens + delta
425 | 	if burst := float64(lim.burst); tokens > burst {
426 | 		tokens = burst
427 | 	}
428 | 	return now, last, tokens
429 | }
430 | 
431 | // durationFromTokens is a unit conversion function from the number of tokens to the duration
432 | // of time it takes to accumulate them at a rate of limit tokens per second.
433 | func (limit Limit) durationFromTokens(tokens float64) time.Duration {
434 | 	if limit <= 0 {
435 | 		return InfDuration
436 | 	}
437 | 	seconds := tokens / float64(limit)
438 | 	return time.Duration(float64(time.Second) * seconds)
439 | }
440 | 
441 | // tokensFromDuration is a unit conversion function from a time duration to the number of tokens
442 | // which could be accumulated during that duration at a rate of limit tokens per second.
443 | func (limit Limit) tokensFromDuration(d time.Duration) float64 {
444 | 	if limit <= 0 {
445 | 		return 0
446 | 	}
447 | 	return d.Seconds() * float64(limit)
448 | }
449 | 
[TRUNCATED]
```

framework/ratelimit/memrate/rate_test.go
```
1 | // Copyright 2015 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | //go:build go1.7
6 | // +build go1.7
7 | 
8 | package memrate
9 | 
10 | import (
11 | 	"context"
12 | 	"log"
13 | 	"math"
14 | 	"runtime"
15 | 	"sync"
16 | 	"sync/atomic"
17 | 	"testing"
18 | 	"time"
19 | 
20 | 	. "github.com/smartystreets/goconvey/convey"
21 | 	"github.com/unionj-cloud/go-doudou/v2/framework/ratelimit"
22 | )
23 | 
24 | func TestLimit(t *testing.T) {
25 | 	if Limit(10) == Inf {
26 | 		t.Errorf("Limit(10) == Inf should be false")
27 | 	}
28 | }
29 | 
30 | func closeEnough(a, b Limit) bool {
31 | 	return (math.Abs(float64(a)/float64(b)) - 1.0) < 1e-9
32 | }
33 | 
34 | func TestEvery(t *testing.T) {
35 | 	cases := []struct {
36 | 		interval time.Duration
37 | 		lim      Limit
38 | 	}{
39 | 		{0, Inf},
40 | 		{-1, Inf},
41 | 		{1 * time.Nanosecond, Limit(1e9)},
42 | 		{1 * time.Microsecond, Limit(1e6)},
43 | 		{1 * time.Millisecond, Limit(1e3)},
44 | 		{10 * time.Millisecond, Limit(100)},
45 | 		{100 * time.Millisecond, Limit(10)},
46 | 		{1 * time.Second, Limit(1)},
47 | 		{2 * time.Second, Limit(0.5)},
48 | 		{time.Duration(2.5 * float64(time.Second)), Limit(0.4)},
49 | 		{4 * time.Second, Limit(0.25)},
50 | 		{10 * time.Second, Limit(0.1)},
51 | 		{time.Duration(math.MaxInt64), Limit(1e9 / float64(math.MaxInt64))},
52 | 	}
53 | 	for _, tc := range cases {
54 | 		lim := Every(tc.interval)
55 | 		if !closeEnough(lim, tc.lim) {
56 | 			t.Errorf("Every(%v) = %v want %v", tc.interval, lim, tc.lim)
57 | 		}
58 | 	}
59 | }
60 | 
61 | const (
62 | 	d = 100 * time.Millisecond
63 | )
64 | 
65 | var (
66 | 	t0 = time.Now()
67 | 	t1 = t0.Add(time.Duration(1) * d)
68 | 	t2 = t0.Add(time.Duration(2) * d)
69 | 	t3 = t0.Add(time.Duration(3) * d)
70 | 	t4 = t0.Add(time.Duration(4) * d)
71 | 	t5 = t0.Add(time.Duration(5) * d)
72 | 	t9 = t0.Add(time.Duration(9) * d)
73 | )
74 | 
75 | type allow struct {
76 | 	t  time.Time
77 | 	n  int
78 | 	ok bool
79 | }
80 | 
81 | func run(t *testing.T, lim *Limiter, allows []allow) {
82 | 	t.Helper()
83 | 	for i, allow := range allows {
84 | 		ok := lim.AllowN(allow.t, allow.n)
85 | 		if ok != allow.ok {
86 | 			t.Errorf("step %d: lim.AllowN(%v, %v) = %v want %v",
87 | 				i, allow.t, allow.n, ok, allow.ok)
88 | 		}
89 | 	}
90 | }
91 | 
92 | func TestLimiterBurst1(t *testing.T) {
93 | 	run(t, NewLimiter(10, 1), []allow{
94 | 		{t0, 1, true},
95 | 		{t0, 1, false},
96 | 		{t0, 1, false},
97 | 		{t1, 1, true},
98 | 		{t1, 1, false},
99 | 		{t1, 1, false},
100 | 		{t2, 2, false}, // burst size is 1, so n=2 always fails
101 | 		{t2, 1, true},
102 | 		{t2, 1, false},
103 | 	})
104 | }
105 | 
106 | func TestLimiterBurst3(t *testing.T) {
107 | 	run(t, NewLimiter(10, 3), []allow{
108 | 		{t0, 2, true},
109 | 		{t0, 2, false},
110 | 		{t0, 1, true},
111 | 		{t0, 1, false},
112 | 		{t1, 4, false},
113 | 		{t2, 1, true},
114 | 		{t3, 1, true},
115 | 		{t4, 1, true},
116 | 		{t4, 1, true},
117 | 		{t4, 1, false},
118 | 		{t4, 1, false},
119 | 		{t9, 3, true},
120 | 		{t9, 0, true},
121 | 	})
122 | }
123 | 
124 | func TestLimiterJumpBackwards(t *testing.T) {
125 | 	run(t, NewLimiter(10, 3), []allow{
126 | 		{t1, 1, true}, // start at t1
127 | 		{t0, 1, true}, // jump back to t0, two tokens remain
128 | 		{t0, 1, true},
129 | 		{t0, 1, false},
130 | 		{t0, 1, false},
131 | 		{t1, 1, true}, // got a token
132 | 		{t1, 1, false},
133 | 		{t1, 1, false},
134 | 		{t2, 1, true}, // got another token
135 | 		{t2, 1, false},
136 | 		{t2, 1, false},
137 | 	})
138 | }
139 | 
140 | // Ensure that tokensFromDuration doesn't produce
141 | // rounding errors by truncating nanoseconds.
142 | // See golang.org/issues/34861.
143 | func TestLimiter_noTruncationErrors(t *testing.T) {
144 | 	if !NewLimiter(0.7692307692307693, 1).Allow() {
145 | 		t.Fatal("expected true")
146 | 	}
147 | }
148 | 
149 | func TestSimultaneousRequests(t *testing.T) {
150 | 	const (
151 | 		limit       = 1
152 | 		burst       = 5
153 | 		numRequests = 15
154 | 	)
155 | 	var (
156 | 		wg    sync.WaitGroup
157 | 		numOK = uint32(0)
158 | 	)
159 | 
160 | 	// Very slow replenishing bucket.
161 | 	lim := NewLimiter(limit, burst)
162 | 
163 | 	// Tries to take a token, atomically updates the counter and decreases the wait
164 | 	// group counter.
165 | 	f := func() {
166 | 		defer wg.Done()
167 | 		if ok := lim.Allow(); ok {
168 | 			atomic.AddUint32(&numOK, 1)
169 | 		}
170 | 	}
171 | 
172 | 	wg.Add(numRequests)
173 | 	for i := 0; i < numRequests; i++ {
174 | 		go f()
175 | 	}
176 | 	wg.Wait()
177 | 	if numOK != burst {
178 | 		t.Errorf("numOK = %d, want %d", numOK, burst)
179 | 	}
180 | }
181 | 
182 | func TestLongRunningQPS(t *testing.T) {
183 | 	if testing.Short() {
184 | 		t.Skip("skipping in short mode")
185 | 	}
186 | 	if runtime.GOOS == "openbsd" {
187 | 		t.Skip("low resolution time.Sleep invalidates test (golang.org/issue/14183)")
188 | 		return
189 | 	}
190 | 
191 | 	// The test runs for a few seconds executing many requests and then checks
192 | 	// that overall number of requests is reasonable.
193 | 	const (
194 | 		limit = 100
195 | 		burst = 100
196 | 	)
197 | 	var numOK = int32(0)
198 | 
199 | 	lim := NewLimiter(limit, burst)
200 | 
201 | 	var wg sync.WaitGroup
202 | 	f := func() {
203 | 		if ok := lim.Allow(); ok {
204 | 			atomic.AddInt32(&numOK, 1)
205 | 		}
206 | 		wg.Done()
207 | 	}
208 | 
209 | 	start := time.Now()
210 | 	end := start.Add(5 * time.Second)
211 | 	for time.Now().Before(end) {
212 | 		wg.Add(1)
213 | 		go f()
214 | 
215 | 		// This will still offer ~500 requests per second, but won't consume
216 | 		// outrageous amount of CPU.
217 | 		time.Sleep(2 * time.Millisecond)
218 | 	}
219 | 	wg.Wait()
220 | 	elapsed := time.Since(start)
221 | 	ideal := burst + (limit * float64(elapsed) / float64(time.Second))
222 | 
223 | 	// We should never get more requests than allowed.
224 | 	if want := int32(ideal + 1); numOK > want {
225 | 		t.Errorf("numOK = %d, want %d (ideal %f)", numOK, want, ideal)
226 | 	}
227 | 	// We should get very close to the number of requests allowed.
228 | 	if want := int32(0.999 * ideal); numOK < want {
229 | 		t.Errorf("numOK = %d, want %d (ideal %f)", numOK, want, ideal)
230 | 	}
231 | }
232 | 
233 | type request struct {
234 | 	t   time.Time
235 | 	n   int
236 | 	act time.Time
237 | 	ok  bool
238 | }
239 | 
240 | // dFromDuration converts a duration to a multiple of the global constant d
241 | func dFromDuration(dur time.Duration) int {
242 | 	// Adding a millisecond to be swallowed by the integer division
243 | 	// because we don't care about small inaccuracies
244 | 	return int((dur + time.Millisecond) / d)
245 | }
246 | 
247 | // dSince returns multiples of d since t0
248 | func dSince(t time.Time) int {
249 | 	return dFromDuration(t.Sub(t0))
250 | }
251 | 
252 | func runReserve(t *testing.T, lim *Limiter, req request) *Reservation {
253 | 	t.Helper()
254 | 	return runReserveMax(t, lim, req, InfDuration)
255 | }
256 | 
257 | func runReserveMax(t *testing.T, lim *Limiter, req request, maxReserve time.Duration) *Reservation {
258 | 	t.Helper()
259 | 	r := lim.reserveN(req.t, req.n, maxReserve)
260 | 	if r.ok && (dSince(r.timeToAct) != dSince(req.act)) || r.ok != req.ok {
261 | 		t.Errorf("lim.reserveN(t%d, %v, %v) = (t%d, %v) want (t%d, %v)",
262 | 			dSince(req.t), req.n, maxReserve, dSince(r.timeToAct), r.ok, dSince(req.act), req.ok)
263 | 	}
264 | 	return &r
265 | }
266 | 
267 | func TestSimpleReserve(t *testing.T) {
268 | 	lim := NewLimiter(10, 2)
269 | 
270 | 	runReserve(t, lim, request{t0, 2, t0, true})
271 | 	runReserve(t, lim, request{t0, 2, t2, true})
272 | 	runReserve(t, lim, request{t3, 2, t4, true})
273 | }
274 | 
275 | func TestMix(t *testing.T) {
276 | 	lim := NewLimiter(10, 2)
277 | 
278 | 	runReserve(t, lim, request{t0, 3, t1, false}) // should return false because n > Burst
279 | 	runReserve(t, lim, request{t0, 2, t0, true})
280 | 	run(t, lim, []allow{{t1, 2, false}}) // not enough tokens - don't allow
281 | 	runReserve(t, lim, request{t1, 2, t2, true})
282 | 	run(t, lim, []allow{{t1, 1, false}}) // negative tokens - don't allow
283 | 	run(t, lim, []allow{{t3, 1, true}})
284 | }
285 | 
286 | func TestCancelInvalid(t *testing.T) {
287 | 	lim := NewLimiter(10, 2)
288 | 
289 | 	runReserve(t, lim, request{t0, 2, t0, true})
290 | 	r := runReserve(t, lim, request{t0, 3, t3, false})
291 | 	r.CancelAt(t0)                               // should have no effect
292 | 	runReserve(t, lim, request{t0, 2, t2, true}) // did not get extra tokens
293 | }
294 | 
295 | func TestCancelLast(t *testing.T) {
296 | 	lim := NewLimiter(10, 2)
297 | 
298 | 	runReserve(t, lim, request{t0, 2, t0, true})
299 | 	r := runReserve(t, lim, request{t0, 2, t2, true})
300 | 	r.CancelAt(t1) // got 2 tokens back
301 | 	runReserve(t, lim, request{t1, 2, t2, true})
302 | }
303 | 
304 | func TestCancelTooLate(t *testing.T) {
305 | 	lim := NewLimiter(10, 2)
306 | 
307 | 	runReserve(t, lim, request{t0, 2, t0, true})
308 | 	r := runReserve(t, lim, request{t0, 2, t2, true})
309 | 	r.CancelAt(t3) // too late to cancel - should have no effect
310 | 	runReserve(t, lim, request{t3, 2, t4, true})
311 | }
312 | 
313 | func TestCancel0Tokens(t *testing.T) {
314 | 	lim := NewLimiter(10, 2)
315 | 
316 | 	runReserve(t, lim, request{t0, 2, t0, true})
317 | 	r := runReserve(t, lim, request{t0, 1, t1, true})
318 | 	runReserve(t, lim, request{t0, 1, t2, true})
319 | 	r.CancelAt(t0) // got 0 tokens back
320 | 	runReserve(t, lim, request{t0, 1, t3, true})
321 | }
322 | 
323 | func TestCancel1Token(t *testing.T) {
324 | 	lim := NewLimiter(10, 2)
325 | 
326 | 	runReserve(t, lim, request{t0, 2, t0, true})
327 | 	r := runReserve(t, lim, request{t0, 2, t2, true})
328 | 	runReserve(t, lim, request{t0, 1, t3, true})
329 | 	r.CancelAt(t2) // got 1 token back
330 | 	runReserve(t, lim, request{t2, 2, t4, true})
331 | }
332 | 
333 | func TestCancelMulti(t *testing.T) {
334 | 	lim := NewLimiter(10, 4)
335 | 
336 | 	runReserve(t, lim, request{t0, 4, t0, true})
337 | 	rA := runReserve(t, lim, request{t0, 3, t3, true})
338 | 	runReserve(t, lim, request{t0, 1, t4, true})
339 | 	rC := runReserve(t, lim, request{t0, 1, t5, true})
340 | 	rC.CancelAt(t1) // get 1 token back
341 | 	rA.CancelAt(t1) // get 2 tokens back, as if C was never reserved
342 | 	runReserve(t, lim, request{t1, 3, t5, true})
343 | }
344 | 
345 | func TestReserveJumpBack(t *testing.T) {
346 | 	lim := NewLimiter(10, 2)
347 | 
348 | 	runReserve(t, lim, request{t1, 2, t1, true}) // start at t1
349 | 	runReserve(t, lim, request{t0, 1, t1, true}) // should violate Limit,Burst
350 | 	runReserve(t, lim, request{t2, 2, t3, true})
351 | }
352 | 
353 | func TestReserveJumpBackCancel(t *testing.T) {
354 | 	lim := NewLimiter(10, 2)
355 | 
356 | 	runReserve(t, lim, request{t1, 2, t1, true}) // start at t1
357 | 	r := runReserve(t, lim, request{t1, 2, t3, true})
358 | 	runReserve(t, lim, request{t1, 1, t4, true})
359 | 	r.CancelAt(t0)                               // cancel at t0, get 1 token back
360 | 	runReserve(t, lim, request{t1, 2, t4, true}) // should violate Limit,Burst
361 | }
362 | 
363 | func TestReserveSetLimit(t *testing.T) {
364 | 	lim := NewLimiter(5, 2)
365 | 
366 | 	runReserve(t, lim, request{t0, 2, t0, true})
367 | 	runReserve(t, lim, request{t0, 2, t4, true})
368 | 	lim.SetLimitAt(t2, 10)
369 | 	runReserve(t, lim, request{t2, 1, t4, true}) // violates Limit and Burst
370 | }
371 | 
372 | func TestReserveSetBurst(t *testing.T) {
373 | 	lim := NewLimiter(5, 2)
374 | 
375 | 	runReserve(t, lim, request{t0, 2, t0, true})
376 | 	runReserve(t, lim, request{t0, 2, t4, true})
377 | 	lim.SetBurstAt(t3, 4)
378 | 	runReserve(t, lim, request{t0, 4, t9, true}) // violates Limit and Burst
379 | }
380 | 
381 | func TestReserveSetLimitCancel(t *testing.T) {
382 | 	lim := NewLimiter(5, 2)
383 | 
384 | 	runReserve(t, lim, request{t0, 2, t0, true})
385 | 	r := runReserve(t, lim, request{t0, 2, t4, true})
386 | 	lim.SetLimitAt(t2, 10)
387 | 	r.CancelAt(t2) // 2 tokens back
388 | 	runReserve(t, lim, request{t2, 2, t3, true})
389 | }
390 | 
391 | func TestReserveMax(t *testing.T) {
392 | 	lim := NewLimiter(10, 2)
393 | 	maxT := d
394 | 
395 | 	runReserveMax(t, lim, request{t0, 2, t0, true}, maxT)
396 | 	runReserveMax(t, lim, request{t0, 1, t1, true}, maxT)  // reserve for close future
397 | 	runReserveMax(t, lim, request{t0, 1, t2, false}, maxT) // time to act too far in the future
398 | }
399 | 
400 | type wait struct {
401 | 	name   string
402 | 	ctx    context.Context
403 | 	n      int
404 | 	delay  int // in multiples of d
405 | 	nilErr bool
406 | }
407 | 
408 | func runWait(t *testing.T, lim *Limiter, w wait) {
409 | 	t.Helper()
410 | 	start := time.Now()
411 | 	err := lim.WaitN(w.ctx, w.n)
412 | 	delay := time.Since(start)
413 | 	if (w.nilErr && err != nil) || (!w.nilErr && err == nil) || w.delay != dFromDuration(delay) {
414 | 		errString := "<nil>"
415 | 		if !w.nilErr {
416 | 			errString = "<non-nil error>"
417 | 		}
418 | 		t.Errorf("lim.WaitN(%v, lim, %v) = %v with delay %v ; want %v with delay %v",
419 | 			w.name, w.n, err, delay, errString, d*time.Duration(w.delay))
420 | 	}
421 | }
422 | 
423 | func TestWaitSimple(t *testing.T) {
424 | 	lim := NewLimiter(10, 3)
425 | 
426 | 	ctx, cancel := context.WithCancel(context.Background())
427 | 	cancel()
428 | 	runWait(t, lim, wait{"already-cancelled", ctx, 1, 0, false})
429 | 
430 | 	runWait(t, lim, wait{"exceed-burst-error", context.Background(), 4, 0, false})
431 | 
432 | 	runWait(t, lim, wait{"act-now", context.Background(), 2, 0, true})
433 | 	runWait(t, lim, wait{"act-later", context.Background(), 3, 2, true})
434 | }
435 | 
436 | func TestWaitCancel(t *testing.T) {
437 | 	lim := NewLimiter(10, 3)
438 | 
439 | 	ctx, cancel := context.WithCancel(context.Background())
440 | 	runWait(t, lim, wait{"act-now", ctx, 2, 0, true}) // after this lim.tokens = 1
441 | 	go func() {
442 | 		time.Sleep(d)
443 | 		cancel()
444 | 	}()
445 | 	runWait(t, lim, wait{"will-cancel", ctx, 3, 1, false})
446 | 	// should get 3 tokens back, and have lim.tokens = 2
447 | 	t.Logf("tokens:%v last:%v lastEvent:%v", lim.tokens, lim.last, lim.lastEvent)
448 | 	runWait(t, lim, wait{"act-now-after-cancel", context.Background(), 2, 0, true})
449 | }
450 | 
451 | func TestWaitTimeout(t *testing.T) {
452 | 	lim := NewLimiter(10, 3)
453 | 
454 | 	ctx, cancel := context.WithTimeout(context.Background(), d)
455 | 	defer cancel()
456 | 	runWait(t, lim, wait{"act-now", ctx, 2, 0, true})
457 | 	runWait(t, lim, wait{"w-timeout-err", ctx, 3, 0, false})
458 | }
459 | 
460 | func TestWaitInf(t *testing.T) {
[TRUNCATED]
```

framework/ratelimit/redisrate/gcralimiter.go
```
1 | package redisrate
2 | 
3 | import (
4 | 	"context"
5 | 	"strconv"
6 | 	"time"
7 | 
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/ratelimit"
9 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
10 | 
11 | 	"github.com/go-redis/redis/v8"
12 | )
13 | 
14 | const redisPrefix = "go-doudou:rate:"
15 | 
16 | type Rediser interface {
17 | 	Eval(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd
18 | 	EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd
19 | 	ScriptExists(ctx context.Context, hashes ...string) *redis.BoolSliceCmd
20 | 	ScriptLoad(ctx context.Context, script string) *redis.StringCmd
21 | 	Del(ctx context.Context, keys ...string) *redis.IntCmd
22 | }
23 | 
24 | type LimitFn func(ctx context.Context) ratelimit.Limit
25 | 
26 | type GcraLimiter struct {
27 | 	rdb     Rediser
28 | 	key     string
29 | 	limit   ratelimit.Limit
30 | 	limitFn LimitFn
31 | }
32 | 
33 | func (gl *GcraLimiter) AllowCtx(ctx context.Context) bool {
34 | 	allow, err := gl.AllowECtx(ctx)
35 | 	if err != nil {
36 | 		logger.Error().Err(err).Msg("")
37 | 		return false
38 | 	}
39 | 	return allow
40 | }
41 | 
42 | func (gl *GcraLimiter) Allow() bool {
43 | 	allow, err := gl.AllowE()
44 | 	if err != nil {
45 | 		logger.Error().Err(err).Msg("")
46 | 		return false
47 | 	}
48 | 	return allow
49 | }
50 | 
51 | // Wait you'd better pass a timeout or cancelable context
52 | func (gl *GcraLimiter) Wait(ctx context.Context) error {
53 | 	for {
54 | 		retryAfter, allow, err := gl.ReserveECtx(ctx)
55 | 		if err != nil {
56 | 			return err
57 | 		}
58 | 		if allow {
59 | 			return nil
60 | 		}
61 | 		time.Sleep(retryAfter)
62 | 	}
63 | }
64 | 
65 | func (gl *GcraLimiter) AllowE() (bool, error) {
66 | 	allow, err := gl.AllowN(context.Background(), 1)
67 | 	return allow.Allowed > 0, err
68 | }
69 | 
70 | func (gl *GcraLimiter) ReserveE() (time.Duration, bool, error) {
71 | 	allow, err := gl.AllowN(context.Background(), 1)
72 | 	if err != nil {
73 | 		return 0, false, err
74 | 	}
75 | 	return allow.RetryAfter, allow.Allowed > 0, nil
76 | }
77 | 
78 | func (gl *GcraLimiter) AllowECtx(ctx context.Context) (bool, error) {
79 | 	allow, err := gl.AllowN(ctx, 1)
80 | 	return allow.Allowed > 0, err
81 | }
82 | 
83 | func (gl *GcraLimiter) ReserveECtx(ctx context.Context) (time.Duration, bool, error) {
84 | 	allow, err := gl.AllowN(ctx, 1)
85 | 	if err != nil {
86 | 		return 0, false, err
87 | 	}
88 | 	return allow.RetryAfter, allow.Allowed > 0, nil
89 | }
90 | 
91 | // NewGcraLimiter returns a new Limiter.
92 | func NewGcraLimiter(rdb Rediser, key string, r float64, period time.Duration, b int) ratelimit.Limiter {
93 | 	return &GcraLimiter{
94 | 		rdb: rdb,
95 | 		key: key,
96 | 		limit: ratelimit.Limit{
97 | 			Rate:   r,
98 | 			Burst:  b,
99 | 			Period: period,
100 | 		},
101 | 	}
102 | }
103 | 
104 | // NewGcraLimiterLimit returns a new Limiter.
105 | func NewGcraLimiterLimit(rdb Rediser, key string, l ratelimit.Limit) ratelimit.Limiter {
106 | 	return &GcraLimiter{
107 | 		rdb:   rdb,
108 | 		key:   key,
109 | 		limit: l,
110 | 	}
111 | }
112 | 
113 | // NewGcraLimiterLimitFn returns a new Limiter.
114 | func NewGcraLimiterLimitFn(rdb Rediser, key string, fn LimitFn) ratelimit.Limiter {
115 | 	return &GcraLimiter{
116 | 		rdb:     rdb,
117 | 		key:     key,
118 | 		limitFn: fn,
119 | 	}
120 | }
121 | 
122 | // AllowN reports whether n events may happen at time now.
123 | func (gl *GcraLimiter) AllowN(ctx context.Context, n int) (res *Result, err error) {
124 | 	limit := gl.limit
125 | 	if gl.limitFn != nil {
126 | 		limit = gl.limitFn(ctx)
127 | 	}
128 | 	values := []interface{}{limit.Burst, limit.Rate, limit.Period.Seconds(), n}
129 | 	v, err := allowN.Run(ctx, gl.rdb, []string{redisPrefix + gl.key}, values...).Result()
130 | 	if err != nil {
131 | 		return nil, err
132 | 	}
133 | 
134 | 	values = v.([]interface{})
135 | 
136 | 	retryAfter, err := strconv.ParseFloat(values[2].(string), 64)
137 | 	if err != nil {
138 | 		return nil, err
139 | 	}
140 | 
141 | 	resetAfter, err := strconv.ParseFloat(values[3].(string), 64)
142 | 	if err != nil {
143 | 		return nil, err
144 | 	}
145 | 
146 | 	res = &Result{
147 | 		Limit:      limit,
148 | 		Allowed:    int(values[0].(int64)),
149 | 		Remaining:  int(values[1].(int64)),
150 | 		RetryAfter: dur(retryAfter),
151 | 		ResetAfter: dur(resetAfter),
152 | 	}
153 | 	return res, nil
154 | }
155 | 
156 | // Reset gets a key and reset all limitations and previous usages
157 | func (gl *GcraLimiter) Reset(ctx context.Context) error {
158 | 	return gl.rdb.Del(ctx, redisPrefix+gl.key).Err()
159 | }
160 | 
161 | func dur(f float64) time.Duration {
162 | 	if f == -1 {
163 | 		return -1
164 | 	}
165 | 	return time.Duration(f * float64(time.Second))
166 | }
167 | 
168 | type Result struct {
169 | 	// Limit is the limit that was used to obtain this result.
170 | 	Limit ratelimit.Limit
171 | 
172 | 	// Allowed is the number of events that may happen at time now.
173 | 	Allowed int
174 | 
175 | 	// Remaining is the maximum number of requests that could be
176 | 	// permitted instantaneously for this key given the current
177 | 	// state. For example, if a rate limiter allows 10 requests per
178 | 	// second and has already received 6 requests for this key this
179 | 	// second, Remaining would be 4.
180 | 	Remaining int
181 | 
182 | 	// RetryAfter is the time until the next request will be permitted.
183 | 	// It should be -1 unless the rate limit has been exceeded.
184 | 	RetryAfter time.Duration
185 | 
186 | 	// ResetAfter is the time until the RateLimiter returns to its
187 | 	// initial state for a given key. For example, if a rate limiter
188 | 	// manages requests per second and received one request 200ms ago,
189 | 	// Reset would return 800ms. You can also think of this as the time
190 | 	// until Limit and Remaining will be equal.
191 | 	ResetAfter time.Duration
192 | }
```

framework/ratelimit/redisrate/lua.go
```
1 | package redisrate
2 | 
3 | import "github.com/go-redis/redis/v8"
4 | 
5 | // Copyright (c) 2017 Pavel Pravosud
6 | // https://github.com/rwz/redis-gcra/blob/master/vendor/perform_gcra_ratelimit.lua
7 | var allowN = redis.NewScript(`
8 | -- this script has side-effects, so it requires replicate commands mode
9 | redis.replicate_commands()
10 | local rate_limit_key = KEYS[1]
11 | local burst = ARGV[1]
12 | local rate = ARGV[2]
13 | local period = ARGV[3]
14 | local cost = tonumber(ARGV[4])
15 | local emission_interval = period / rate
16 | local increment = emission_interval * cost
17 | local burst_offset = emission_interval * burst
18 | -- redis returns time as an array containing two integers: seconds of the epoch
19 | -- time (10 digits) and microseconds (6 digits). for convenience we need to
20 | -- convert them to a floating point number. the resulting number is 16 digits,
21 | -- bordering on the limits of a 64-bit double-precision floating point number.
22 | -- adjust the epoch to be relative to Jan 1, 2017 00:00:00 GMT to avoid floating
23 | -- point problems. this approach is good until "now" is 2,483,228,799 (Wed, 09
24 | -- Sep 2048 01:46:39 GMT), when the adjusted value is 16 digits.
25 | local jan_1_2017 = 1483228800
26 | local now = redis.call("TIME")
27 | now = (now[1] - jan_1_2017) + (now[2] / 1000000)
28 | local tat = redis.call("GET", rate_limit_key)
29 | if not tat then
30 |   tat = now
31 | else
32 |   tat = tonumber(tat)
33 | end
34 | tat = math.max(tat, now)
35 | local new_tat = tat + increment
36 | local allow_at = new_tat - burst_offset
37 | local diff = now - allow_at
38 | local remaining = diff / emission_interval
39 | if remaining < 0 then
40 |   local reset_after = tat - now
41 |   local retry_after = diff * -1
42 |   return {
43 |     0, -- allowed
44 |     0, -- remaining
45 |     tostring(retry_after),
46 |     tostring(reset_after),
47 |   }
48 | end
49 | local reset_after = new_tat - now
50 | if reset_after > 0 then
51 |   redis.call("SET", rate_limit_key, new_tat, "EX", math.ceil(reset_after))
52 | end
53 | local retry_after = -1
54 | return {cost, remaining, tostring(retry_after), tostring(reset_after)}
55 | `)
```

framework/registry/constants/constants.go
```
1 | package constants
2 | 
3 | const (
4 | 	SD_NACOS      = "nacos"
5 | 	SD_ETCD       = "etcd"
6 | 	SD_MEMBERLIST = "memberlist"
7 | 	SD_ZK         = "zk"
8 | )
9 | 
10 | type ServiceType string
11 | 
12 | const (
13 | 	GRPC_TYPE ServiceType = "grpc"
14 | 	REST_TYPE ServiceType = "rest"
15 | )
```

framework/registry/etcd/balancer.go
```
1 | package etcd
2 | 
3 | import (
4 | 	"sync"
5 | 
6 | 	"github.com/unionj-cloud/toolkit/zlogger"
7 | 
8 | 	"google.golang.org/grpc/balancer"
9 | 	"google.golang.org/grpc/balancer/base"
10 | )
11 | 
12 | const Name = "etcd_weight_balancer"
13 | 
14 | func newBuilder() balancer.Builder {
15 | 	return base.NewBalancerBuilder(Name, &wPickerBuilder{}, base.Config{HealthCheck: true})
16 | }
17 | 
18 | func init() {
19 | 	balancer.Register(newBuilder())
20 | }
21 | 
22 | type wPickerBuilder struct{}
23 | 
24 | func (*wPickerBuilder) Build(info base.PickerBuildInfo) balancer.Picker {
25 | 	zlogger.Debug().Msgf("[go-doudou] etcd_weight_balancer Picker: Build called with info: %v", info)
26 | 	if len(info.ReadySCs) == 0 {
27 | 		return base.NewErrPicker(balancer.ErrNoSubConnAvailable)
28 | 	}
29 | 	scs := make([]*conn, 0, len(info.ReadySCs))
30 | 	for sc, v := range info.ReadySCs {
31 | 		weight := 1
32 | 		if metadata, ok := v.Address.Metadata.(map[string]interface{}); !ok {
33 | 			zlogger.Error().Msg("[go-doudou] etcd endpoint metadata is not map[string]string type")
34 | 		} else {
35 | 			weight = int(metadata["weight"].(float64))
36 | 		}
37 | 		scs = append(scs, &conn{sc: sc, weight: weight})
38 | 	}
39 | 	return &wPicker{
40 | 		subConns: scs,
41 | 	}
42 | }
43 | 
44 | type wPicker struct {
45 | 	subConns []*conn
46 | 	mu       sync.Mutex
47 | }
48 | 
49 | func (p *wPicker) Pick(balancer.PickInfo) (balancer.PickResult, error) {
50 | 	p.mu.Lock()
51 | 	sc := newChooser(p.subConns).pick().sc
52 | 	p.mu.Unlock()
53 | 	return balancer.PickResult{SubConn: sc}, nil
54 | }
55 | 
56 | type conn struct {
57 | 	sc            balancer.SubConn
58 | 	weight        int
59 | 	currentWeight int
60 | }
61 | 
62 | // Chooser from naming_client package in nacos-sdk-go
63 | type Chooser struct {
64 | 	data []*conn
65 | }
66 | 
67 | // NewChooser initializes a new Chooser for picking from the provided Choices.
68 | func newChooser(cs []*conn) Chooser {
69 | 	return Chooser{data: cs}
70 | }
71 | 
72 | func (chs Chooser) pick() conn {
73 | 	var selected *conn
74 | 	total := 0
75 | 	for i := 0; i < len(chs.data); i++ {
76 | 		s := chs.data[i]
77 | 		s.currentWeight += s.weight
78 | 		total += s.weight
79 | 		if selected == nil || s.currentWeight > selected.currentWeight {
80 | 			selected = s
81 | 		}
82 | 	}
83 | 	selected.currentWeight -= total
84 | 	return *selected
85 | }
```

framework/registry/etcd/node.go
```
1 | package etcd
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"runtime"
7 | 	"sort"
8 | 	"strconv"
9 | 	"strings"
10 | 	"sync"
11 | 	"sync/atomic"
12 | 	"time"
13 | 
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/buildinfo"
15 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
16 | 	cons "github.com/unionj-cloud/go-doudou/v2/framework/registry/constants"
17 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/interfaces"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/utils"
19 | 	"github.com/unionj-cloud/toolkit/cast"
20 | 	"github.com/unionj-cloud/toolkit/constants"
21 | 	"github.com/unionj-cloud/toolkit/stringutils"
22 | 	"github.com/unionj-cloud/toolkit/zlogger"
23 | 	clientv3 "go.etcd.io/etcd/client/v3"
24 | 	"go.etcd.io/etcd/client/v3/naming/endpoints"
25 | 	"go.etcd.io/etcd/client/v3/naming/resolver"
26 | 	"google.golang.org/grpc"
27 | )
28 | 
29 | var onceEtcd sync.Once
30 | var EtcdCli *clientv3.Client
31 | var restLease clientv3.LeaseID
32 | var grpcLease clientv3.LeaseID
33 | var providers = map[string]interfaces.IServiceProvider{}
34 | 
35 | func InitEtcdCli() {
36 | 	etcdEndpoints := config.GddEtcdEndpoints.LoadOrDefault(config.DefaultGddEtcdEndpoints)
37 | 	if stringutils.IsEmpty(etcdEndpoints) {
38 | 		zlogger.Panic().Msg("[go-doudou] env GDD_ETCD_ENDPOINTS is not set")
39 | 	}
40 | 	endpoints := strings.Split(etcdEndpoints, ",")
41 | 	var err error
42 | 	if EtcdCli, err = clientv3.New(clientv3.Config{
43 | 		Endpoints:   endpoints,
44 | 		DialTimeout: 5 * time.Second,
45 | 	}); err != nil {
46 | 		zlogger.Panic().Err(err).Msg("[go-doudou] register to etcd failed")
47 | 	}
48 | }
49 | 
50 | func getLeaseID() clientv3.LeaseID {
51 | 	// grant lease time
52 | 	tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
53 | 	defer cancel()
54 | 	lease := config.DefaultGddEtcdLease
55 | 	leaseStr := config.GddEtcdLease.Load()
56 | 	if stringutils.IsNotEmpty(leaseStr) {
57 | 		if value, err := cast.ToInt64E(leaseStr); err != nil {
58 | 			zlogger.Error().Err(err).Msgf("[go-doudou] cast %s to int failed", leaseStr)
59 | 		} else {
60 | 			lease = value
61 | 		}
62 | 	}
63 | 	leaseResp, err := EtcdCli.Grant(tctx, lease)
64 | 	if err != nil {
65 | 		zlogger.Panic().Err(err).Msgf("[go-doudou] get etcd lease ID failed")
66 | 	}
67 | 	return leaseResp.ID
68 | }
69 | 
70 | func registerService(service string, port uint64, lease clientv3.LeaseID, userData ...map[string]interface{}) {
71 | 	em, err := endpoints.NewManager(EtcdCli, service)
72 | 	if err != nil {
73 | 		zlogger.Panic().Err(err).Msgf("[go-doudou] register %s to etcd failed", service)
74 | 	}
75 | 	host := utils.GetRegisterHost()
76 | 	addr := host + ":" + strconv.Itoa(int(port))
77 | 	metadata := make(map[string]interface{})
78 | 	populateMeta(metadata, strings.HasSuffix(service, "_grpc"), userData...)
79 | 	tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
80 | 	defer cancel()
81 | 	if err = em.AddEndpoint(tctx, service+"/"+addr, endpoints.Endpoint{Addr: addr, Metadata: metadata}, clientv3.WithLease(lease)); err != nil {
82 | 		zlogger.Panic().Err(err).Msgf("[go-doudou] register %s to etcd failed", service)
83 | 	}
84 | 	// set keep-alive logic
85 | 	leaseRespChan, err := EtcdCli.KeepAlive(context.Background(), lease)
86 | 	if err != nil {
87 | 		zlogger.Panic().Err(err).Msgf("[go-doudou] register %s to etcd failed", service)
88 | 	}
89 | 	go func() {
90 | 		for leaseKeepResp := range leaseRespChan {
91 | 			zlogger.Debug().Msgf("[go-doudou] %#v", *leaseKeepResp)
92 | 		}
93 | 	}()
94 | }
95 | 
96 | func populateMeta(meta map[string]interface{}, isGrpc bool, userData ...map[string]interface{}) {
97 | 	buildTime := buildinfo.BuildTime
98 | 	if stringutils.IsNotEmpty(buildinfo.BuildTime) {
99 | 		if t, err := time.Parse(constants.FORMAT15, buildinfo.BuildTime); err == nil {
100 | 			buildTime = t.Local().Format(constants.FORMAT8)
101 | 		}
102 | 	}
103 | 	weight := config.DefaultGddWeight
104 | 	if stringutils.IsNotEmpty(config.GddWeight.Load()) {
105 | 		if w, err := cast.ToIntE(config.GddWeight.Load()); err == nil {
106 | 			weight = w
107 | 		}
108 | 	}
109 | 	rr := config.DefaultGddRouteRootPath
110 | 	if stringutils.IsNotEmpty(config.GddRouteRootPath.Load()) {
111 | 		rr = config.GddRouteRootPath.Load()
112 | 	}
113 | 	meta["registerAt"] = time.Now().Local().Format(constants.FORMAT8)
114 | 	meta["goVer"] = runtime.Version()
115 | 	meta["weight"] = weight
116 | 	if stringutils.IsNotEmpty(buildinfo.GddVer) {
117 | 		meta["gddVer"] = buildinfo.GddVer
118 | 	}
119 | 	if stringutils.IsNotEmpty(buildinfo.BuildUser) {
120 | 		meta["buildUser"] = buildinfo.BuildUser
121 | 	}
122 | 	if stringutils.IsNotEmpty(buildTime) {
123 | 		meta["buildTime"] = buildTime
124 | 	}
125 | 	if stringutils.IsNotEmpty(rr) && !isGrpc {
126 | 		meta["rootPath"] = rr
127 | 	}
128 | 	for _, item := range userData {
129 | 		for k, v := range item {
130 | 			meta[k] = fmt.Sprint(v)
131 | 		}
132 | 	}
133 | }
134 | 
135 | func NewRest(data ...map[string]interface{}) {
136 | 	onceEtcd.Do(func() {
137 | 		InitEtcdCli()
138 | 	})
139 | 	service := config.GetServiceName() + "_" + string(cons.REST_TYPE)
140 | 	httpPort := config.GetPort()
141 | 	restLease = getLeaseID()
142 | 	registerService(service, httpPort, restLease, data...)
143 | 	zlogger.Info().Msgf("[go-doudou] %s registered to etcd successfully", service)
144 | }
145 | 
146 | func NewGrpc(data ...map[string]interface{}) {
147 | 	onceEtcd.Do(func() {
148 | 		InitEtcdCli()
149 | 	})
150 | 	service := config.GetServiceName() + "_" + string(cons.GRPC_TYPE)
151 | 	grpcPort := config.GetGrpcPort()
152 | 	grpcLease = getLeaseID()
153 | 	registerService(service, grpcPort, grpcLease, data...)
154 | 	zlogger.Info().Msgf("[go-doudou] %s registered to etcd successfully", service)
155 | }
156 | 
157 | func ShutdownRest() {
158 | 	if EtcdCli != nil {
159 | 		service := config.GetServiceName() + "_" + string(cons.REST_TYPE)
160 | 		em, err := endpoints.NewManager(EtcdCli, service)
161 | 		if err != nil {
162 | 			zlogger.Error().Err(err).Msgf("[go-doudou] failed to deregister %s from etcd", service)
163 | 			return
164 | 		}
165 | 		addr := utils.GetRegisterHost() + ":" + strconv.Itoa(int(config.GetPort()))
166 | 		tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
167 | 		defer cancel()
168 | 		if err = em.DeleteEndpoint(tctx, service+"/"+addr); err != nil {
169 | 			zlogger.Error().Err(err).Msgf("[go-doudou] failed to deregister %s from etcd", service)
170 | 			return
171 | 		}
172 | 		zlogger.Info().Msgf("[go-doudou] deregistered %s from etcd successfully", service)
173 | 	}
174 | }
175 | 
176 | func ShutdownGrpc() {
177 | 	if EtcdCli != nil {
178 | 		service := config.GetServiceName() + "_" + string(cons.GRPC_TYPE)
179 | 		em, err := endpoints.NewManager(EtcdCli, service)
180 | 		if err != nil {
181 | 			zlogger.Error().Err(err).Msgf("[go-doudou] failed to deregister %s from etcd", service)
182 | 			return
183 | 		}
184 | 		addr := utils.GetRegisterHost() + ":" + strconv.Itoa(int(config.GetGrpcPort()))
185 | 		tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
186 | 		defer cancel()
187 | 		if err = em.DeleteEndpoint(tctx, service+"/"+addr); err != nil {
188 | 			zlogger.Error().Err(err).Msgf("[go-doudou] failed to deregister %s from etcd", service)
189 | 			return
190 | 		}
191 | 		zlogger.Info().Msgf("[go-doudou] deregistered %s from etcd successfully", service)
192 | 	}
193 | }
194 | 
195 | var shutdownOnce sync.Once
196 | 
197 | func CloseEtcdClient() {
198 | 	shutdownOnce.Do(func() {
199 | 		if EtcdCli != nil {
200 | 			for _, p := range providers {
201 | 				p.Close()
202 | 			}
203 | 			EtcdCli.Close()
204 | 			EtcdCli = nil
205 | 			zlogger.Info().Msg("[go-doudou] etcd client closed")
206 | 		}
207 | 	})
208 | }
209 | 
210 | // RRServiceProvider is a simple round-robin load balance implementation for IServiceProvider
211 | type RRServiceProvider struct {
212 | 	current  uint64
213 | 	lock     sync.Mutex
214 | 	c        *clientv3.Client
215 | 	target   string
216 | 	wch      endpoints.WatchChannel
217 | 	ctx      context.Context
218 | 	cancel   context.CancelFunc
219 | 	curState atomic.Value
220 | }
221 | 
222 | type address struct {
223 | 	addr          string
224 | 	rootPath      string
225 | 	weight        int
226 | 	currentWeight int
227 | }
228 | 
229 | type state struct {
230 | 	addresses []*address
231 | }
232 | 
233 | func (r *RRServiceProvider) watch() {
234 | 	allUps := make(map[string]*endpoints.Update)
235 | 	for {
236 | 		select {
237 | 		case ups, ok := <-r.wch:
238 | 			if !ok {
239 | 				return
240 | 			}
241 | 
242 | 			for _, up := range ups {
243 | 				switch up.Op {
244 | 				case endpoints.Add:
245 | 					allUps[up.Key] = up
246 | 				case endpoints.Delete:
247 | 					delete(allUps, up.Key)
248 | 				}
249 | 			}
250 | 
251 | 			addrs := convertToAddress(allUps)
252 | 			r.curState.Store(state{addresses: addrs})
253 | 		}
254 | 	}
255 | }
256 | 
257 | func (r *RRServiceProvider) Close() {
258 | 	if r != nil {
259 | 		r.cancel()
260 | 	}
261 | }
262 | 
263 | func convertToAddress(ups map[string]*endpoints.Update) (addrs []*address) {
264 | 	for _, up := range ups {
265 | 		weight := 1
266 | 		var rootPath string
267 | 		if metadata, ok := up.Endpoint.Metadata.(map[string]interface{}); !ok {
268 | 			zlogger.Error().Msg("[go-doudou] etcd endpoint metadata is not map[string]string type")
269 | 		} else {
270 | 			weight = int(metadata["weight"].(float64))
271 | 			rootPath = metadata["rootPath"].(string)
272 | 		}
273 | 		addr := &address{
274 | 			addr:     up.Endpoint.Addr,
275 | 			rootPath: rootPath,
276 | 			weight:   weight,
277 | 		}
278 | 		addrs = append(addrs, addr)
279 | 	}
280 | 	return
281 | }
282 | 
283 | // SelectServer return service address from environment variable
284 | func (n *RRServiceProvider) SelectServer() string {
285 | 	n.lock.Lock()
286 | 	defer n.lock.Unlock()
287 | 	if n.curState.Load() == nil {
288 | 		return ""
289 | 	}
290 | 	instances := n.curState.Load().(state).addresses
291 | 	if len(instances) == 0 {
292 | 		zlogger.Error().Msgf("[go-doudou] %s server not found", n.target)
293 | 		return ""
294 | 	}
295 | 	sort.SliceStable(instances, func(i, j int) bool {
296 | 		return instances[i].addr < instances[j].addr
297 | 	})
298 | 	next := int(atomic.AddUint64(&n.current, uint64(1)) % uint64(len(instances)))
299 | 	n.current = uint64(next)
300 | 	selected := instances[next]
301 | 	return fmt.Sprintf("http://%s%s", selected.addr, selected.rootPath)
302 | }
303 | 
304 | // NewRRServiceProvider creates new RRServiceProvider instance
305 | func NewRRServiceProvider(serviceName string) *RRServiceProvider {
306 | 	onceEtcd.Do(func() {
307 | 		InitEtcdCli()
308 | 	})
309 | 	r := &RRServiceProvider{
310 | 		c:      EtcdCli,
311 | 		target: serviceName,
312 | 	}
313 | 	r.ctx, r.cancel = context.WithCancel(context.Background())
314 | 	defer func() {
315 | 		providers[serviceName] = r
316 | 	}()
317 | 	em, err := endpoints.NewManager(r.c, r.target)
318 | 	if err != nil {
319 | 		zlogger.Panic().Err(err).Msg("[go-doudou] failed to create endpoint manager")
320 | 	}
321 | 	r.wch, err = em.NewWatchChannel(r.ctx)
322 | 	if err != nil {
323 | 		zlogger.Panic().Err(err).Msg("[go-doudou] failed to create watch channel")
324 | 	}
325 | 	go r.watch()
326 | 	return r
327 | }
328 | 
329 | // SWRRServiceProvider is a smooth weighted round-robin service provider
330 | type SWRRServiceProvider struct {
331 | 	*RRServiceProvider
332 | }
333 | 
334 | // SelectServer selects a node which is supplying service specified by name property from cluster
335 | func (n *SWRRServiceProvider) SelectServer() string {
336 | 	n.lock.Lock()
337 | 	defer n.lock.Unlock()
338 | 	if n.curState.Load() == nil {
339 | 		return ""
340 | 	}
341 | 	instances := n.curState.Load().(state).addresses
342 | 	if len(instances) == 0 {
343 | 		zlogger.Error().Msgf("[go-doudou] %s server not found", n.target)
344 | 		return ""
345 | 	}
346 | 	var selected *address
347 | 	total := 0
348 | 	for i := 0; i < len(instances); i++ {
349 | 		s := instances[i]
350 | 		s.currentWeight += s.weight
351 | 		total += s.weight
352 | 		if selected == nil || s.currentWeight > selected.currentWeight {
353 | 			selected = s
354 | 		}
355 | 	}
356 | 	selected.currentWeight -= total
357 | 	return fmt.Sprintf("http://%s%s", selected.addr, selected.rootPath)
358 | }
359 | 
360 | // NewSWRRServiceProvider creates new SWRRServiceProvider instance
361 | func NewSWRRServiceProvider(serviceName string) *SWRRServiceProvider {
362 | 	return &SWRRServiceProvider{
363 | 		RRServiceProvider: NewRRServiceProvider(serviceName),
364 | 	}
365 | }
366 | 
367 | func NewSWRRGrpcClientConn(service string, dialOptions ...grpc.DialOption) *grpc.ClientConn {
368 | 	return NewGrpcClientConn(service, "etcd_weight_balancer", dialOptions...)
369 | }
370 | 
371 | func NewRRGrpcClientConn(service string, dialOptions ...grpc.DialOption) *grpc.ClientConn {
372 | 	return NewGrpcClientConn(service, "round_robin", dialOptions...)
373 | }
374 | 
375 | func NewGrpcClientConn(service string, lb string, dialOptions ...grpc.DialOption) *grpc.ClientConn {
376 | 	onceEtcd.Do(func() {
377 | 		InitEtcdCli()
378 | 	})
379 | 	etcdResolver, err := resolver.NewBuilder(EtcdCli)
380 | 	if err != nil {
381 | 		zlogger.Panic().Err(err).Msg("[go-doudou] failed to create etcd resolver")
382 | 	}
383 | 	dialOptions = append(dialOptions,
384 | 		grpc.WithBlock(),
385 | 		grpc.WithResolvers(etcdResolver),
386 | 		grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy": "`+lb+`"}`),
387 | 	)
388 | 	serverAddr := fmt.Sprintf("etcd:///%s", service)
389 | 	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
390 | 	defer cancel()
391 | 	grpcConn, err := grpc.DialContext(ctx, serverAddr, dialOptions...)
392 | 	if err != nil {
393 | 		zlogger.Panic().Err(err).Msgf("[go-doudou] failed to connect to server %s", serverAddr)
394 | 	}
395 | 	return grpcConn
396 | }
```

framework/registry/interfaces/interfaces.go
```
1 | package interfaces
2 | 
3 | type IServiceProvider interface {
4 | 	SelectServer() string
5 | 	Close()
6 | }
```

framework/registry/memberlist/balancer.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"sync"
5 | 
6 | 	"github.com/unionj-cloud/toolkit/zlogger"
7 | 
8 | 	"google.golang.org/grpc/balancer"
9 | 	balancerbase "google.golang.org/grpc/balancer/base"
10 | )
11 | 
12 | const Name = "memberlist_weight_balancer"
13 | 
14 | func newBuilder() balancer.Builder {
15 | 	return balancerbase.NewBalancerBuilder(Name, &wPickerBuilder{}, balancerbase.Config{HealthCheck: true})
16 | }
17 | 
18 | func init() {
19 | 	balancer.Register(newBuilder())
20 | }
21 | 
22 | type wPickerBuilder struct{}
23 | 
24 | func (*wPickerBuilder) Build(info balancerbase.PickerBuildInfo) balancer.Picker {
25 | 	zlogger.Debug().Msgf("[go-doudou] memberlist_weight_balancer Picker: Build called with info: %v", info)
26 | 	if len(info.ReadySCs) == 0 {
27 | 		return balancerbase.NewErrPicker(balancer.ErrNoSubConnAvailable)
28 | 	}
29 | 	scs := make([]*conn, 0, len(info.ReadySCs))
30 | 	for sc, v := range info.ReadySCs {
31 | 		weight := v.Address.BalancerAttributes.Value(WeightAttributeKey{}).(WeightAddrInfo).Weight
32 | 		scs = append(scs, &conn{sc: sc, weight: weight})
33 | 	}
34 | 	return &wPicker{
35 | 		subConns: scs,
36 | 	}
37 | }
38 | 
39 | type wPicker struct {
40 | 	subConns []*conn
41 | 	mu       sync.Mutex
42 | }
43 | 
44 | func (p *wPicker) Pick(balancer.PickInfo) (balancer.PickResult, error) {
45 | 	p.mu.Lock()
46 | 	sc := newChooser(p.subConns).pick().sc
47 | 	p.mu.Unlock()
48 | 	return balancer.PickResult{SubConn: sc}, nil
49 | }
50 | 
51 | type WeightAttributeKey struct{}
52 | 
53 | type WeightAddrInfo struct {
54 | 	Weight int
55 | }
56 | 
57 | type conn struct {
58 | 	sc            balancer.SubConn
59 | 	weight        int
60 | 	currentWeight int
61 | }
62 | 
63 | // Chooser from naming_client package in nacos-sdk-go
64 | type Chooser struct {
65 | 	data []*conn
66 | }
67 | 
68 | // NewChooser initializes a new Chooser for picking from the provided Choices.
69 | func newChooser(cs []*conn) Chooser {
70 | 	return Chooser{data: cs}
71 | }
72 | 
73 | func (chs Chooser) pick() conn {
74 | 	var selected *conn
75 | 	total := 0
76 | 	for i := 0; i < len(chs.data); i++ {
77 | 		s := chs.data[i]
78 | 		s.currentWeight += s.weight
79 | 		total += s.weight
80 | 		if selected == nil || s.currentWeight > selected.currentWeight {
81 | 			selected = s
82 | 		}
83 | 	}
84 | 	selected.currentWeight -= total
85 | 	return *selected
86 | }
```

framework/registry/memberlist/config.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"strconv"
5 | 	"time"
6 | 
7 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
8 | 	"github.com/unionj-cloud/toolkit/cast"
9 | 	"github.com/unionj-cloud/toolkit/memberlist"
10 | 	"github.com/unionj-cloud/toolkit/stringutils"
11 | )
12 | 
13 | func setGddMemDeadTimeout(conf *memberlist.Config) {
14 | 	var isSet bool
15 | 	deadTimeoutStr := config.GddMemDeadTimeout.Load()
16 | 	if stringutils.IsNotEmpty(deadTimeoutStr) {
17 | 		if deadTimeout, err := strconv.Atoi(deadTimeoutStr); err == nil {
18 | 			conf.GossipToTheDeadTime = time.Duration(deadTimeout) * time.Second
19 | 			isSet = true
20 | 		} else {
21 | 			if duration, err := time.ParseDuration(deadTimeoutStr); err == nil {
22 | 				conf.GossipToTheDeadTime = duration
23 | 				isSet = true
24 | 			}
25 | 		}
26 | 	}
27 | 	if !isSet {
28 | 		conf.GossipToTheDeadTime, _ = time.ParseDuration(config.DefaultGddMemDeadTimeout)
29 | 	}
30 | }
31 | 
32 | func setGddMemSyncInterval(conf *memberlist.Config) {
33 | 	var isSet bool
34 | 	syncIntervalStr := config.GddMemSyncInterval.Load()
35 | 	if stringutils.IsNotEmpty(syncIntervalStr) {
36 | 		if syncInterval, err := strconv.Atoi(syncIntervalStr); err == nil {
37 | 			conf.PushPullInterval = time.Duration(syncInterval) * time.Second
38 | 			isSet = true
39 | 		} else {
40 | 			if duration, err := time.ParseDuration(syncIntervalStr); err == nil {
41 | 				conf.PushPullInterval = duration
42 | 				isSet = true
43 | 			}
44 | 		}
45 | 	}
46 | 	if !isSet {
47 | 		conf.PushPullInterval, _ = time.ParseDuration(config.DefaultGddMemSyncInterval)
48 | 	}
49 | }
50 | 
51 | func setGddMemReclaimTimeout(conf *memberlist.Config) {
52 | 	var isSet bool
53 | 	reclaimTimeoutStr := config.GddMemReclaimTimeout.Load()
54 | 	if stringutils.IsNotEmpty(reclaimTimeoutStr) {
55 | 		if reclaimTimeout, err := strconv.Atoi(reclaimTimeoutStr); err == nil {
56 | 			conf.DeadNodeReclaimTime = time.Duration(reclaimTimeout) * time.Second
57 | 			isSet = true
58 | 		} else {
59 | 			if duration, err := time.ParseDuration(reclaimTimeoutStr); err == nil {
60 | 				conf.DeadNodeReclaimTime = duration
61 | 				isSet = true
62 | 			}
63 | 		}
64 | 	}
65 | 	if !isSet {
66 | 		conf.DeadNodeReclaimTime, _ = time.ParseDuration(config.DefaultGddMemReclaimTimeout)
67 | 	}
68 | }
69 | 
70 | func setGddMemGossipInterval(conf *memberlist.Config) {
71 | 	var isSet bool
72 | 	gossipIntervalStr := config.GddMemGossipInterval.Load()
73 | 	if stringutils.IsNotEmpty(gossipIntervalStr) {
74 | 		if gossipInterval, err := strconv.Atoi(gossipIntervalStr); err == nil {
75 | 			conf.GossipInterval = time.Duration(gossipInterval) * time.Millisecond
76 | 			isSet = true
77 | 		} else {
78 | 			if duration, err := time.ParseDuration(gossipIntervalStr); err == nil {
79 | 				conf.GossipInterval = duration
80 | 				isSet = true
81 | 			}
82 | 		}
83 | 	}
84 | 	if !isSet {
85 | 		conf.GossipInterval, _ = time.ParseDuration(config.DefaultGddMemGossipInterval)
86 | 	}
87 | }
88 | 
89 | func setGddMemProbeInterval(conf *memberlist.Config) {
90 | 	var isSet bool
91 | 	probeIntervalStr := config.GddMemProbeInterval.Load()
92 | 	if stringutils.IsNotEmpty(probeIntervalStr) {
93 | 		if probeInterval, err := strconv.Atoi(probeIntervalStr); err == nil {
94 | 			conf.ProbeInterval = time.Duration(probeInterval) * time.Second
95 | 			isSet = true
96 | 		} else {
97 | 			if duration, err := time.ParseDuration(probeIntervalStr); err == nil {
98 | 				conf.ProbeInterval = duration
99 | 				isSet = true
100 | 			}
101 | 		}
102 | 	}
103 | 	if !isSet {
104 | 		conf.ProbeInterval, _ = time.ParseDuration(config.DefaultGddMemProbeInterval)
105 | 	}
106 | }
107 | 
108 | func setGddMemProbeTimeout(conf *memberlist.Config) {
109 | 	var set bool
110 | 	probeTimeoutStr := config.GddMemProbeTimeout.Load()
111 | 	if stringutils.IsNotEmpty(probeTimeoutStr) {
112 | 		if probeTimeout, err := strconv.Atoi(probeTimeoutStr); err == nil {
113 | 			conf.ProbeTimeout = time.Duration(probeTimeout) * time.Second
114 | 			set = true
115 | 		} else {
116 | 			if duration, err := time.ParseDuration(probeTimeoutStr); err == nil {
117 | 				conf.ProbeTimeout = duration
118 | 				set = true
119 | 			}
120 | 		}
121 | 	}
122 | 	if !set {
123 | 		conf.ProbeTimeout, _ = time.ParseDuration(config.DefaultGddMemProbeTimeout)
124 | 	}
125 | }
126 | 
127 | func setGddMemSuspicionMult(conf *memberlist.Config) {
128 | 	var set bool
129 | 	if eg, err := cast.ToIntE(config.GddMemSuspicionMult.Load()); err == nil {
130 | 		conf.SuspicionMult = eg
131 | 		set = true
132 | 	}
133 | 	if !set {
134 | 		conf.SuspicionMult = config.DefaultGddMemSuspicionMult
135 | 	}
136 | }
137 | 
138 | func setGddMemRetransmitMult(conf *memberlist.Config) {
139 | 	var set bool
140 | 	if eg, err := cast.ToIntE(config.GddMemRetransmitMult.Load()); err == nil {
141 | 		conf.RetransmitMult = eg
142 | 		set = true
143 | 	}
144 | 	if !set {
145 | 		conf.RetransmitMult = config.DefaultGddMemRetransmitMult
146 | 	}
147 | }
148 | 
149 | func setGddMemGossipNodes(conf *memberlist.Config) {
150 | 	var set bool
151 | 	if eg, err := cast.ToIntE(config.GddMemGossipNodes.Load()); err == nil {
152 | 		conf.GossipNodes = eg
153 | 		set = true
154 | 	}
155 | 	if !set {
156 | 		conf.GossipNodes = config.DefaultGddMemGossipNodes
157 | 	}
158 | }
159 | 
160 | func setGddMemIndirectChecks(conf *memberlist.Config) {
161 | 	var set bool
162 | 	if eg, err := cast.ToIntE(config.GddMemIndirectChecks.Load()); err == nil {
163 | 		conf.IndirectChecks = eg
164 | 		set = true
165 | 	}
166 | 	if !set {
167 | 		conf.IndirectChecks = config.DefaultGddMemIndirectChecks
168 | 	}
169 | }
```

framework/registry/memberlist/config_test.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"os"
5 | 	"testing"
6 | 
7 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
8 | 	"github.com/unionj-cloud/toolkit/memberlist"
9 | )
10 | 
11 | func TestMain(m *testing.M) {
12 | 	config.GddMemDeadTimeout.Write("60")
13 | 	config.GddMemSyncInterval.Write("5")
14 | 	config.GddMemReclaimTimeout.Write("60")
15 | 	config.GddMemGossipInterval.Write("200")
16 | 	config.GddMemProbeInterval.Write("1")
17 | 	config.GddMemProbeTimeout.Write("3")
18 | 	config.GddMemRetransmitMult.Write("8")
19 | 	defer os.Clearenv()
20 | 	m.Run()
21 | }
22 | 
23 | func Test_setGddMemDeadTimeout(t *testing.T) {
24 | 	type args struct {
25 | 		conf *memberlist.Config
26 | 	}
27 | 	tests := []struct {
28 | 		name string
29 | 		args args
30 | 	}{
31 | 		{
32 | 			name: "",
33 | 			args: args{
34 | 				conf: newConf(),
35 | 			},
36 | 		},
37 | 	}
38 | 	for _, tt := range tests {
39 | 		t.Run(tt.name, func(t *testing.T) {
40 | 			setGddMemDeadTimeout(tt.args.conf)
41 | 		})
42 | 	}
43 | }
44 | 
45 | func Test_setGddMemGossipInterval(t *testing.T) {
46 | 	type args struct {
47 | 		conf *memberlist.Config
48 | 	}
49 | 	tests := []struct {
50 | 		name string
51 | 		args args
52 | 	}{
53 | 		{
54 | 			name: "",
55 | 			args: args{
56 | 				conf: newConf(),
57 | 			},
58 | 		},
59 | 	}
60 | 	for _, tt := range tests {
61 | 		t.Run(tt.name, func(t *testing.T) {
62 | 			setGddMemGossipInterval(tt.args.conf)
63 | 		})
64 | 	}
65 | }
66 | 
67 | func Test_setGddMemGossipNodes(t *testing.T) {
68 | 	type args struct {
69 | 		conf *memberlist.Config
70 | 	}
71 | 	tests := []struct {
72 | 		name string
73 | 		args args
74 | 	}{
75 | 		{
76 | 			name: "",
77 | 			args: args{
78 | 				conf: newConf(),
79 | 			},
80 | 		},
81 | 	}
82 | 	for _, tt := range tests {
83 | 		t.Run(tt.name, func(t *testing.T) {
84 | 			setGddMemGossipNodes(tt.args.conf)
85 | 		})
86 | 	}
87 | }
88 | 
89 | func Test_setGddMemIndirectChecks(t *testing.T) {
90 | 	type args struct {
91 | 		conf *memberlist.Config
92 | 	}
93 | 	tests := []struct {
94 | 		name string
95 | 		args args
96 | 	}{
97 | 		{
98 | 			name: "",
99 | 			args: args{
100 | 				conf: newConf(),
101 | 			},
102 | 		},
103 | 	}
104 | 	for _, tt := range tests {
105 | 		t.Run(tt.name, func(t *testing.T) {
106 | 			setGddMemIndirectChecks(tt.args.conf)
107 | 		})
108 | 	}
109 | }
110 | 
111 | func Test_setGddMemProbeInterval(t *testing.T) {
112 | 	type args struct {
113 | 		conf *memberlist.Config
114 | 	}
115 | 	tests := []struct {
116 | 		name string
117 | 		args args
118 | 	}{
119 | 		{
120 | 			name: "",
121 | 			args: args{
122 | 				conf: newConf(),
123 | 			},
124 | 		},
125 | 	}
126 | 	for _, tt := range tests {
127 | 		t.Run(tt.name, func(t *testing.T) {
128 | 			setGddMemProbeInterval(tt.args.conf)
129 | 		})
130 | 	}
131 | }
132 | 
133 | func Test_setGddMemProbeTimeout(t *testing.T) {
134 | 	type args struct {
135 | 		conf *memberlist.Config
136 | 	}
137 | 	tests := []struct {
138 | 		name string
139 | 		args args
140 | 	}{
141 | 		{
142 | 			name: "",
143 | 			args: args{
144 | 				conf: newConf(),
145 | 			},
146 | 		},
147 | 	}
148 | 	for _, tt := range tests {
149 | 		t.Run(tt.name, func(t *testing.T) {
150 | 			setGddMemProbeTimeout(tt.args.conf)
151 | 		})
152 | 	}
153 | }
154 | 
155 | func Test_setGddMemReclaimTimeout(t *testing.T) {
156 | 	type args struct {
157 | 		conf *memberlist.Config
158 | 	}
159 | 	tests := []struct {
160 | 		name string
161 | 		args args
162 | 	}{
163 | 		{
164 | 			name: "",
165 | 			args: args{
166 | 				conf: newConf(),
167 | 			},
168 | 		},
169 | 	}
170 | 	for _, tt := range tests {
171 | 		t.Run(tt.name, func(t *testing.T) {
172 | 			setGddMemReclaimTimeout(tt.args.conf)
173 | 		})
174 | 	}
175 | }
176 | 
177 | func Test_setGddMemRetransmitMult(t *testing.T) {
178 | 	type args struct {
179 | 		conf *memberlist.Config
180 | 	}
181 | 	tests := []struct {
182 | 		name string
183 | 		args args
184 | 	}{
185 | 		{
186 | 			name: "",
187 | 			args: args{
188 | 				conf: newConf(),
189 | 			},
190 | 		},
191 | 	}
192 | 	for _, tt := range tests {
193 | 		t.Run(tt.name, func(t *testing.T) {
194 | 			setGddMemRetransmitMult(tt.args.conf)
195 | 		})
196 | 	}
197 | }
198 | 
199 | func Test_setGddMemSuspicionMult(t *testing.T) {
200 | 	type args struct {
201 | 		conf *memberlist.Config
202 | 	}
203 | 	tests := []struct {
204 | 		name string
205 | 		args args
206 | 	}{
207 | 		{
208 | 			name: "",
209 | 			args: args{
210 | 				conf: newConf(),
211 | 			},
212 | 		},
213 | 	}
214 | 	for _, tt := range tests {
215 | 		t.Run(tt.name, func(t *testing.T) {
216 | 			setGddMemSuspicionMult(tt.args.conf)
217 | 		})
218 | 	}
219 | }
220 | 
221 | func Test_setGddMemSyncInterval(t *testing.T) {
222 | 	type args struct {
223 | 		conf *memberlist.Config
224 | 	}
225 | 	tests := []struct {
226 | 		name string
227 | 		args args
228 | 	}{
229 | 		{
230 | 			name: "",
231 | 			args: args{
232 | 				conf: newConf(),
233 | 			},
234 | 		},
235 | 	}
236 | 	for _, tt := range tests {
237 | 		t.Run(tt.name, func(t *testing.T) {
238 | 			setGddMemSyncInterval(tt.args.conf)
239 | 		})
240 | 	}
241 | }
242 | 
243 | func Test_setGddMemSyncInterval_unset(t *testing.T) {
244 | 	config.GddMemSyncInterval.Write("")
245 | 	type args struct {
246 | 		conf *memberlist.Config
247 | 	}
248 | 	tests := []struct {
249 | 		name string
250 | 		args args
251 | 	}{
252 | 		{
253 | 			name: "",
254 | 			args: args{
255 | 				conf: newConf(),
256 | 			},
257 | 		},
258 | 	}
259 | 	for _, tt := range tests {
260 | 		t.Run(tt.name, func(t *testing.T) {
261 | 			setGddMemSyncInterval(tt.args.conf)
262 | 		})
263 | 	}
264 | }
265 | 
266 | func Test_setGddMemReclaimTimeout_unset(t *testing.T) {
267 | 	config.GddMemReclaimTimeout.Write("")
268 | 	type args struct {
269 | 		conf *memberlist.Config
270 | 	}
271 | 	tests := []struct {
272 | 		name string
273 | 		args args
274 | 	}{
275 | 		{
276 | 			name: "",
277 | 			args: args{
278 | 				conf: newConf(),
279 | 			},
280 | 		},
281 | 	}
282 | 	for _, tt := range tests {
283 | 		t.Run(tt.name, func(t *testing.T) {
284 | 			setGddMemReclaimTimeout(tt.args.conf)
285 | 		})
286 | 	}
287 | }
288 | 
289 | func Test_setGddMemGossipInterval_unset(t *testing.T) {
290 | 	config.GddMemGossipInterval.Write("")
291 | 	type args struct {
292 | 		conf *memberlist.Config
293 | 	}
294 | 	tests := []struct {
295 | 		name string
296 | 		args args
297 | 	}{
298 | 		{
299 | 			name: "",
300 | 			args: args{
301 | 				conf: newConf(),
302 | 			},
303 | 		},
304 | 	}
305 | 	for _, tt := range tests {
306 | 		t.Run(tt.name, func(t *testing.T) {
307 | 			setGddMemGossipInterval(tt.args.conf)
308 | 		})
309 | 	}
310 | }
311 | 
312 | func Test_setGddMemProbeInterval_unset(t *testing.T) {
313 | 	config.GddMemProbeInterval.Write("")
314 | 	type args struct {
315 | 		conf *memberlist.Config
316 | 	}
317 | 	tests := []struct {
318 | 		name string
319 | 		args args
320 | 	}{
321 | 		{
322 | 			name: "",
323 | 			args: args{
324 | 				conf: newConf(),
325 | 			},
326 | 		},
327 | 	}
328 | 	for _, tt := range tests {
329 | 		t.Run(tt.name, func(t *testing.T) {
330 | 			setGddMemProbeInterval(tt.args.conf)
331 | 		})
332 | 	}
333 | }
334 | 
335 | func Test_setGddMemProbeTimeout_unset(t *testing.T) {
336 | 	config.GddMemProbeTimeout.Write("")
337 | 	type args struct {
338 | 		conf *memberlist.Config
339 | 	}
340 | 	tests := []struct {
341 | 		name string
342 | 		args args
343 | 	}{
344 | 		{
345 | 			name: "",
346 | 			args: args{
347 | 				conf: newConf(),
348 | 			},
349 | 		},
350 | 	}
351 | 	for _, tt := range tests {
352 | 		t.Run(tt.name, func(t *testing.T) {
353 | 			setGddMemProbeTimeout(tt.args.conf)
354 | 		})
355 | 	}
356 | }
357 | 
358 | func Test_setGddMemRetransmitMult_unset(t *testing.T) {
359 | 	config.GddMemRetransmitMult.Write("")
360 | 	type args struct {
361 | 		conf *memberlist.Config
362 | 	}
363 | 	tests := []struct {
364 | 		name string
365 | 		args args
366 | 	}{
367 | 		{
368 | 			name: "",
369 | 			args: args{
370 | 				conf: newConf(),
371 | 			},
372 | 		},
373 | 	}
374 | 	for _, tt := range tests {
375 | 		t.Run(tt.name, func(t *testing.T) {
376 | 			setGddMemRetransmitMult(tt.args.conf)
377 | 		})
378 | 	}
379 | }
```

framework/registry/memberlist/delegate.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"bytes"
5 | 	"fmt"
6 | 	"sync"
7 | 	"time"
8 | 
9 | 	"github.com/hashicorp/go-msgpack/codec"
10 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/constants"
11 | 	"github.com/unionj-cloud/toolkit/memberlist"
12 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
13 | )
14 | 
15 | type Service struct {
16 | 	Name          string                 `json:"name"`
17 | 	Host          string                 `json:"host"`
18 | 	Port          int                    `json:"port"`
19 | 	RouteRootPath string                 `json:"routeRootPath"`
20 | 	Type          constants.ServiceType  `json:"type"`
21 | 	Data          map[string]interface{} `json:"data,omitempty"`
22 | }
23 | 
24 | func (receiver *Service) BaseUrl() string {
25 | 	if receiver == nil {
26 | 		return ""
27 | 	}
28 | 	switch receiver.Type {
29 | 	case constants.REST_TYPE:
30 | 		return fmt.Sprintf("http://%s:%d%s", receiver.Host, receiver.Port, receiver.RouteRootPath)
31 | 	case constants.GRPC_TYPE:
32 | 		return fmt.Sprintf("%s:%d", receiver.Host, receiver.Port)
33 | 	}
34 | 	return ""
35 | }
36 | 
37 | type NodeMeta struct {
38 | 	Services   []Service  `json:"serviceInfo"`
39 | 	RegisterAt *time.Time `json:"registerAt"`
40 | 	GoVer      string     `json:"goVer"`
41 | 	GddVer     string     `json:"gddVer"`
42 | 	BuildUser  string     `json:"buildUser"`
43 | 	BuildTime  string     `json:"buildTime"`
44 | 	Weight     int        `json:"weight"`
45 | }
46 | 
47 | type delegate struct {
48 | 	meta  NodeMeta
49 | 	lock  sync.Mutex
50 | 	queue *memberlist.TransmitLimitedQueue
51 | }
52 | 
53 | func (d *delegate) AddService(service Service) {
54 | 	d.lock.Lock()
55 | 	defer d.lock.Unlock()
56 | 
57 | 	d.meta.Services = append(d.meta.Services, service)
58 | }
59 | 
60 | // NodeMeta return user custom node meta data
61 | func (d *delegate) NodeMeta(limit int) []byte {
62 | 	d.lock.Lock()
63 | 	defer d.lock.Unlock()
64 | 
65 | 	var buf bytes.Buffer
66 | 	enc := codec.NewEncoder(&buf, &codec.MsgpackHandle{})
67 | 	if err := enc.Encode(d.meta); err != nil {
68 | 		logger.Panic().Err(err).Msg("[go-doudou] Failed to encode node meta data")
69 | 	}
70 | 	raw := buf.Bytes()
71 | 
72 | 	if len(raw) > limit {
73 | 		logger.Panic().Msgf("[go-doudou] Node meta data '%v' exceeds length limit of %d bytes", d.meta, limit)
74 | 	}
75 | 	return raw
76 | }
77 | 
78 | // NotifyMsg callback function when received user data message from remote node
79 | func (d *delegate) NotifyMsg(msg []byte) {
80 | 	d.lock.Lock()
81 | 	defer d.lock.Unlock()
82 | 	// TODO
83 | }
84 | 
85 | // GetBroadcasts get a number of user data broadcasts
86 | func (d *delegate) GetBroadcasts(overhead, limit int) [][]byte {
87 | 	d.lock.Lock()
88 | 	defer d.lock.Unlock()
89 | 
90 | 	msgs := d.queue.GetBroadcasts(overhead, limit)
91 | 	return msgs
92 | }
93 | 
94 | // LocalState also sends user data, but by tcp connection when pushPull-ing state with other node
95 | func (d *delegate) LocalState(join bool) []byte {
96 | 	return nil
97 | }
98 | 
99 | // MergeRemoteState gets user data from remote node by tcp connection when pushPull-ing state with other node
100 | func (d *delegate) MergeRemoteState(s []byte, join bool) {
101 | }
```

framework/registry/memberlist/delegate_test.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"sync"
5 | 	"testing"
6 | 
7 | 	"github.com/stretchr/testify/assert"
8 | 	"github.com/stretchr/testify/require"
9 | 	"github.com/unionj-cloud/toolkit/memberlist"
10 | )
11 | 
12 | func Test_delegate_NodeMeta(t *testing.T) {
13 | 	type fields struct {
14 | 	}
15 | 	type args struct {
16 | 		limit int
17 | 	}
18 | 	tests := []struct {
19 | 		name   string
20 | 		fields fields
21 | 		args   args
22 | 		want   []byte
23 | 	}{
24 | 		{
25 | 			name:   "",
26 | 			fields: fields{},
27 | 			args: args{
28 | 				limit: 1024,
29 | 			},
30 | 			want: nil,
31 | 		},
32 | 	}
33 | 	for _, tt := range tests {
34 | 		t.Run(tt.name, func(t *testing.T) {
35 | 			d := &delegate{}
36 | 			assert.NotPanics(t, func() {
37 | 				d.NodeMeta(tt.args.limit)
38 | 			})
39 | 		})
40 | 	}
41 | }
42 | func Test_delegate_NodeMeta_panic(t *testing.T) {
43 | 	type fields struct {
44 | 	}
45 | 	type args struct {
46 | 		limit int
47 | 	}
48 | 	tests := []struct {
49 | 		name   string
50 | 		fields fields
51 | 		args   args
52 | 		want   []byte
53 | 	}{
54 | 		{
55 | 			name:   "",
56 | 			fields: fields{},
57 | 			args: args{
58 | 				limit: 1,
59 | 			},
60 | 			want: nil,
61 | 		},
62 | 	}
63 | 	for _, tt := range tests {
64 | 		t.Run(tt.name, func(t *testing.T) {
65 | 			d := &delegate{
66 | 				meta: NodeMeta{
67 | 					Services: []Service{
68 | 						{
69 | 							Name:          "test",
70 | 							RouteRootPath: "/api",
71 | 							Port:          6060,
72 | 						},
73 | 					},
74 | 					Weight: 8,
75 | 				},
76 | 				lock:  sync.Mutex{},
77 | 				queue: nil,
78 | 			}
79 | 			assert.Panics(t, func() {
80 | 				d.NodeMeta(tt.args.limit)
81 | 			})
82 | 		})
83 | 	}
84 | }
85 | 
86 | func Test_delegate_NotifyMsg(t *testing.T) {
87 | 	type fields struct {
88 | 	}
89 | 	type args struct {
90 | 		msg []byte
91 | 	}
92 | 	tests := []struct {
93 | 		name   string
94 | 		fields fields
95 | 		args   args
96 | 	}{
97 | 		{
98 | 			name:   "",
99 | 			fields: fields{},
100 | 			args: args{
101 | 				msg: []byte("this is a test msg"),
102 | 			},
103 | 		},
104 | 	}
105 | 	for _, tt := range tests {
106 | 		t.Run(tt.name, func(t *testing.T) {
107 | 			d := &delegate{}
108 | 			d.NotifyMsg(tt.args.msg)
109 | 		})
110 | 	}
111 | }
112 | 
113 | type testBroadcast struct {
114 | 	node   string
115 | 	msg    []byte
116 | 	notify chan struct{}
117 | }
118 | 
119 | func (b *testBroadcast) Invalidates(other memberlist.Broadcast) bool {
120 | 	// Check if that broadcast is a memberlist type
121 | 	mb, ok := other.(*testBroadcast)
122 | 	if !ok {
123 | 		return false
124 | 	}
125 | 
126 | 	// Invalidates any message about the same node
127 | 	return b.node == mb.node
128 | }
129 | 
130 | // memberlist.NamedBroadcast optional interface
131 | func (b *testBroadcast) Name() string {
132 | 	return b.node
133 | }
134 | 
135 | func (b *testBroadcast) Message() []byte {
136 | 	return b.msg
137 | }
138 | 
139 | func (b *testBroadcast) Finished() {
140 | 	select {
141 | 	case b.notify <- struct{}{}:
142 | 	default:
143 | 	}
144 | }
145 | 
146 | func prettyPrintMessages(msgs [][]byte) []string {
147 | 	var out []string
148 | 	for _, msg := range msgs {
149 | 		out = append(out, "'"+string(msg)+"'")
150 | 	}
151 | 	return out
152 | }
153 | 
154 | func Test_delegate_GetBroadcasts(t *testing.T) {
155 | 	q := &memberlist.TransmitLimitedQueue{RetransmitMult: 3, NumNodes: func() int { return 10 }}
156 | 
157 | 	// 18 bytes per message
158 | 	q.QueueBroadcast(&testBroadcast{"test", []byte("1. this is a test."), nil})
159 | 	q.QueueBroadcast(&testBroadcast{"foo", []byte("2. this is a test."), nil})
160 | 	q.QueueBroadcast(&testBroadcast{"bar", []byte("3. this is a test."), nil})
161 | 	q.QueueBroadcast(&testBroadcast{"baz", []byte("4. this is a test."), nil})
162 | 
163 | 	//
164 | 	//// 3 byte overhead, should only get 3 messages back
165 | 	//partial := q.GetBroadcasts(3, 80)
166 | 	//require.Equal(t, 3, len(partial), "missing messages: %v", prettyPrintMessages(partial))
167 | 
168 | 	type fields struct {
169 | 	}
170 | 	type args struct {
171 | 		overhead int
172 | 		limit    int
173 | 	}
174 | 	tests := []struct {
175 | 		name   string
176 | 		fields fields
177 | 		args   args
178 | 		want   [][]byte
179 | 	}{
180 | 		{
181 | 			name:   "",
182 | 			fields: fields{},
183 | 			args: args{
184 | 				overhead: 2,
185 | 				limit:    80,
186 | 			},
187 | 		},
188 | 	}
189 | 	for _, tt := range tests {
190 | 		t.Run(tt.name, func(t *testing.T) {
191 | 			d := &delegate{
192 | 				queue: q,
193 | 			}
194 | 			got := d.GetBroadcasts(tt.args.overhead, tt.args.limit)
195 | 			require.Equal(t, 4, len(got), "missing messages: %v", prettyPrintMessages(got))
196 | 		})
197 | 	}
198 | }
199 | 
200 | func Test_delegate_LocalState(t *testing.T) {
201 | 	d := delegate{}
202 | 	d.LocalState(false)
203 | }
204 | 
205 | func Test_delegate_MergeRemoteState(t *testing.T) {
206 | 	d := delegate{}
207 | 	d.MergeRemoteState(nil, false)
208 | }
```

framework/registry/memberlist/eventdelegate.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"github.com/unionj-cloud/toolkit/memberlist"
5 | )
6 | 
7 | type eventDelegate struct {
8 | 	ServiceProviders []IMemberlistServiceProvider
9 | }
10 | 
11 | func (e *eventDelegate) NotifySuspectSateChange(node *memberlist.Node) {
12 | 	for _, sp := range e.ServiceProviders {
13 | 		if node.State == memberlist.StateSuspect {
14 | 			sp.RemoveNode(node)
15 | 		} else if node.State == memberlist.StateAlive {
16 | 			sp.AddNode(node)
17 | 		}
18 | 	}
19 | }
20 | 
21 | func (e *eventDelegate) NotifyWeight(node *memberlist.Node) {
22 | 	for _, sp := range e.ServiceProviders {
23 | 		sp.UpdateWeight(node)
24 | 	}
25 | }
26 | 
27 | // NotifyJoin callback function when node joined
28 | func (e *eventDelegate) NotifyJoin(node *memberlist.Node) {
29 | 	for _, sp := range e.ServiceProviders {
30 | 		sp.AddNode(node)
31 | 	}
32 | }
33 | 
34 | // NotifyLeave callback function when node leave
35 | func (e *eventDelegate) NotifyLeave(node *memberlist.Node) {
36 | 	for _, sp := range e.ServiceProviders {
37 | 		sp.RemoveNode(node)
38 | 	}
39 | }
40 | 
41 | // NotifyUpdate callback function when node updated
42 | func (e *eventDelegate) NotifyUpdate(node *memberlist.Node) {
43 | 	for _, sp := range e.ServiceProviders {
44 | 		sp.AddNode(node)
45 | 	}
46 | }
```

framework/registry/memberlist/eventdelegate_test.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"testing"
5 | 
6 | 	"github.com/bytedance/sonic"
7 | 	"github.com/unionj-cloud/toolkit/memberlist"
8 | )
9 | 
10 | var json = sonic.ConfigDefault
11 | 
12 | func Test_eventDelegate_NotifyJoin(t *testing.T) {
13 | 	mm := NodeMeta{
14 | 		Services: []Service{
15 | 			{
16 | 				Name:          "test",
17 | 				RouteRootPath: "/api",
18 | 				Port:          6060,
19 | 			},
20 | 		},
21 | 		Weight: 8,
22 | 	}
23 | 	meta, _ := json.Marshal(mm)
24 | 	type fields struct {
25 | 	}
26 | 	type args struct {
27 | 		node *memberlist.Node
28 | 	}
29 | 	tests := []struct {
30 | 		name   string
31 | 		fields fields
32 | 		args   args
33 | 	}{
34 | 		{
35 | 			name:   "",
36 | 			fields: fields{},
37 | 			args: args{
38 | 				node: &memberlist.Node{
39 | 					Meta: meta,
40 | 				},
41 | 			},
42 | 		},
43 | 		{
44 | 			name:   "",
45 | 			fields: fields{},
46 | 			args: args{
47 | 				node: &memberlist.Node{
48 | 					Meta: []byte("{name:"),
49 | 				},
50 | 			},
51 | 		},
52 | 	}
53 | 	for _, tt := range tests {
54 | 		t.Run(tt.name, func(t *testing.T) {
55 | 			e := eventDelegate{}
56 | 			e.NotifyJoin(tt.args.node)
57 | 		})
58 | 	}
59 | }
60 | 
61 | func Test_eventDelegate_NotifyLeave(t *testing.T) {
62 | 	mm := NodeMeta{
63 | 		Services: []Service{
64 | 			{
65 | 				Name:          "test",
66 | 				RouteRootPath: "/api",
67 | 				Port:          6060,
68 | 			},
69 | 		},
70 | 		Weight: 8,
71 | 	}
72 | 	meta, _ := json.Marshal(mm)
73 | 	type fields struct {
74 | 	}
75 | 	type args struct {
76 | 		node *memberlist.Node
77 | 	}
78 | 	tests := []struct {
79 | 		name   string
80 | 		fields fields
81 | 		args   args
82 | 	}{
83 | 		{
84 | 			name:   "",
85 | 			fields: fields{},
86 | 			args: args{
87 | 				node: &memberlist.Node{
88 | 					Meta: meta,
89 | 				},
90 | 			},
91 | 		},
92 | 		{
93 | 			name:   "",
94 | 			fields: fields{},
95 | 			args: args{
96 | 				node: &memberlist.Node{
97 | 					Meta: []byte("{name:"),
98 | 				},
99 | 			},
100 | 		},
101 | 	}
102 | 	for _, tt := range tests {
103 | 		t.Run(tt.name, func(t *testing.T) {
104 | 			e := eventDelegate{}
105 | 			e.NotifyLeave(tt.args.node)
106 | 		})
107 | 	}
108 | }
109 | 
110 | func Test_eventDelegate_NotifyUpdate(t *testing.T) {
111 | 	mm := NodeMeta{
112 | 		Services: []Service{
113 | 			{
114 | 				Name:          "test",
115 | 				RouteRootPath: "/api",
116 | 				Port:          6060,
117 | 			},
118 | 		},
119 | 		Weight: 8,
120 | 	}
121 | 	meta, _ := json.Marshal(mm)
122 | 	type fields struct {
123 | 	}
124 | 	type args struct {
125 | 		node *memberlist.Node
126 | 	}
127 | 	tests := []struct {
128 | 		name   string
129 | 		fields fields
130 | 		args   args
131 | 	}{
132 | 		{
133 | 			name:   "",
134 | 			fields: fields{},
135 | 			args: args{
136 | 				node: &memberlist.Node{
137 | 					Meta: meta,
138 | 				},
139 | 			},
140 | 		},
141 | 		{
142 | 			name:   "",
143 | 			fields: fields{},
144 | 			args: args{
145 | 				node: &memberlist.Node{
146 | 					Meta: []byte("{name:"),
147 | 				},
148 | 			},
149 | 		},
150 | 	}
151 | 	for _, tt := range tests {
152 | 		t.Run(tt.name, func(t *testing.T) {
153 | 			e := eventDelegate{}
154 | 			e.NotifyUpdate(tt.args.node)
155 | 		})
156 | 	}
157 | }
158 | 
159 | func Test_eventDelegate_NotifySuspectSateChange(t *testing.T) {
160 | 	type fields struct {
161 | 		ServiceProviders []IMemberlistServiceProvider
162 | 	}
163 | 	type args struct {
164 | 		node *memberlist.Node
165 | 	}
166 | 	sp := newMockServiceProvider("TEST")
167 | 	providers := []IMemberlistServiceProvider{
168 | 		sp,
169 | 	}
170 | 	tests := []struct {
171 | 		name   string
172 | 		fields fields
173 | 		args   args
174 | 		want   int
175 | 	}{
176 | 		{
177 | 			name: "",
178 | 			fields: fields{
179 | 				ServiceProviders: providers,
180 | 			},
181 | 			args: args{
182 | 				node: &memberlist.Node{
183 | 					Name:  "test01",
184 | 					Addr:  "192.168.1.103",
185 | 					Port:  56199,
186 | 					State: memberlist.StateAlive,
187 | 				},
188 | 			},
189 | 			want: 1,
190 | 		},
191 | 		{
192 | 			name: "",
193 | 			fields: fields{
194 | 				ServiceProviders: providers,
195 | 			},
196 | 			args: args{
197 | 				node: &memberlist.Node{
198 | 					Name:  "test01",
199 | 					Addr:  "192.168.1.103",
200 | 					Port:  56199,
201 | 					State: memberlist.StateSuspect,
202 | 				},
203 | 			},
204 | 			want: 0,
205 | 		},
206 | 	}
207 | 	for _, tt := range tests {
208 | 		t.Run(tt.name, func(t *testing.T) {
209 | 			e := &eventDelegate{
210 | 				ServiceProviders: tt.fields.ServiceProviders,
211 | 			}
212 | 			e.NotifySuspectSateChange(tt.args.node)
213 | 			if got := len(sp.servers); got != tt.want {
214 | 				t.Errorf("expected: %d, actual: %d", got, tt.want)
215 | 			}
216 | 		})
217 | 	}
218 | }
219 | 
220 | func Test_eventDelegate_NotifyWeight(t *testing.T) {
221 | 	type fields struct {
222 | 		ServiceProviders []IMemberlistServiceProvider
223 | 	}
224 | 	type args struct {
225 | 		node *memberlist.Node
226 | 	}
227 | 	sp := newMockServiceProvider("TEST")
228 | 	providers := []IMemberlistServiceProvider{
229 | 		sp,
230 | 	}
231 | 	tests := []struct {
232 | 		name   string
233 | 		fields fields
234 | 		args   args
235 | 		want   int
236 | 	}{
237 | 		{
238 | 			name: "",
239 | 			fields: fields{
240 | 				ServiceProviders: providers,
241 | 			},
242 | 			args: args{
243 | 				node: &memberlist.Node{
244 | 					Name:   "test01",
245 | 					Addr:   "192.168.1.103",
246 | 					Port:   56199,
247 | 					State:  memberlist.StateSuspect,
248 | 					Weight: 8,
249 | 				},
250 | 			},
251 | 			want: 8,
252 | 		},
253 | 	}
254 | 	for _, tt := range tests {
255 | 		t.Run(tt.name, func(t *testing.T) {
256 | 			e := &eventDelegate{
257 | 				ServiceProviders: tt.fields.ServiceProviders,
258 | 			}
259 | 			e.NotifyJoin(tt.args.node)
260 | 			e.NotifyWeight(tt.args.node)
261 | 			if got := sp.serverMap["test01"].Weight; got != tt.want {
262 | 				t.Errorf("expected: %d, actual: %d", got, tt.want)
263 | 			}
264 | 		})
265 | 	}
266 | }
267 | 
268 | func Test_eventDelegate_NotifyLeave1(t *testing.T) {
269 | 	type fields struct {
270 | 		ServiceProviders []IMemberlistServiceProvider
271 | 	}
272 | 	type args struct {
273 | 		node *memberlist.Node
274 | 	}
275 | 	sp := newMockServiceProvider("TEST")
276 | 	providers := []IMemberlistServiceProvider{
277 | 		sp,
278 | 	}
279 | 	tests := []struct {
280 | 		name   string
281 | 		fields fields
282 | 		args   args
283 | 		want   int
284 | 	}{
285 | 		{
286 | 			name: "",
287 | 			fields: fields{
288 | 				ServiceProviders: providers,
289 | 			},
290 | 			args: args{
291 | 				node: &memberlist.Node{
292 | 					Name:   "test01",
293 | 					Addr:   "192.168.1.103",
294 | 					Port:   56199,
295 | 					State:  memberlist.StateSuspect,
296 | 					Weight: 8,
297 | 				},
298 | 			},
299 | 			want: 0,
300 | 		},
301 | 	}
302 | 	for _, tt := range tests {
303 | 		t.Run(tt.name, func(t *testing.T) {
304 | 			e := &eventDelegate{
305 | 				ServiceProviders: tt.fields.ServiceProviders,
306 | 			}
307 | 			e.NotifyJoin(tt.args.node)
308 | 			e.NotifyLeave(tt.args.node)
309 | 			if got := len(sp.servers); got != tt.want {
310 | 				t.Errorf("expected: %d, actual: %d", got, tt.want)
311 | 			}
312 | 		})
313 | 	}
314 | }
315 | 
316 | func Test_eventDelegate_NotifyUpdate1(t *testing.T) {
317 | 	type fields struct {
318 | 		ServiceProviders []IMemberlistServiceProvider
319 | 	}
320 | 	type args struct {
321 | 		node *memberlist.Node
322 | 	}
323 | 	sp := newMockServiceProvider("TEST")
324 | 	providers := []IMemberlistServiceProvider{
325 | 		sp,
326 | 	}
327 | 	tests := []struct {
328 | 		name   string
329 | 		fields fields
330 | 		args   args
331 | 		want   int
332 | 	}{
333 | 		{
334 | 			name: "",
335 | 			fields: fields{
336 | 				ServiceProviders: providers,
337 | 			},
338 | 			args: args{
339 | 				node: &memberlist.Node{
340 | 					Name:   "test01",
341 | 					Addr:   "192.168.1.103",
342 | 					Port:   56199,
343 | 					State:  memberlist.StateSuspect,
344 | 					Weight: 8,
345 | 				},
346 | 			},
347 | 			want: 1,
348 | 		},
349 | 	}
350 | 	for _, tt := range tests {
351 | 		t.Run(tt.name, func(t *testing.T) {
352 | 			e := &eventDelegate{
353 | 				ServiceProviders: tt.fields.ServiceProviders,
354 | 			}
355 | 			e.NotifyUpdate(tt.args.node)
356 | 			if got := len(sp.servers); got != tt.want {
357 | 				t.Errorf("expected: %d, actual: %d", got, tt.want)
358 | 			}
359 | 		})
360 | 	}
361 | }
```

framework/registry/memberlist/node.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"bytes"
5 | 	"fmt"
6 | 	"io/ioutil"
7 | 	"os"
8 | 	"runtime"
9 | 	"strconv"
10 | 	"strings"
11 | 	"sync"
12 | 	"time"
13 | 
14 | 	"github.com/apolloconfig/agollo/v4/storage"
15 | 	"github.com/hashicorp/go-msgpack/codec"
16 | 	"github.com/hashicorp/logutils"
17 | 	"github.com/pkg/errors"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/buildinfo"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
20 | 	"github.com/unionj-cloud/go-doudou/v2/framework/configmgr"
21 | 	cons "github.com/unionj-cloud/go-doudou/v2/framework/registry/constants"
22 | 	"github.com/unionj-cloud/toolkit/cast"
23 | 	"github.com/unionj-cloud/toolkit/constants"
24 | 	"github.com/unionj-cloud/toolkit/memberlist"
25 | 	"github.com/unionj-cloud/toolkit/stringutils"
26 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
27 | )
28 | 
29 | var mlist memberlist.IMemberlist
30 | var mconf *memberlist.Config
31 | var BroadcastQueue *memberlist.TransmitLimitedQueue
32 | var events = &eventDelegate{}
33 | var shutdownOnce sync.Once
34 | var delegator *delegate
35 | 
36 | func assertMlistNotNil() {
37 | 	if mlist == nil {
38 | 		panic("create memberlist first")
39 | 	}
40 | }
41 | 
42 | func init() {
43 | 	if _, ok := config.ServiceDiscoveryMap()[cons.SD_MEMBERLIST]; !ok {
44 | 		return
45 | 	}
46 | 	mconf = newConf()
47 | 	queue := &memberlist.TransmitLimitedQueue{
48 | 		NumNodes:             numNodes,
49 | 		RetransmitMultGetter: retransmitMultGetter,
50 | 	}
51 | 	now := time.Now()
52 | 	buildTime := buildinfo.BuildTime
53 | 	if stringutils.IsNotEmpty(buildinfo.BuildTime) {
54 | 		if t, err := time.Parse(constants.FORMAT15, buildinfo.BuildTime); err == nil {
55 | 			buildTime = t.Local().Format(constants.FORMAT8)
56 | 		}
57 | 	}
58 | 	weight := config.DefaultGddWeight
59 | 	if stringutils.IsNotEmpty(config.GddWeight.Load()) {
60 | 		if w, err := cast.ToIntE(config.GddWeight.Load()); err == nil {
61 | 			weight = w
62 | 		}
63 | 	} else if stringutils.IsNotEmpty(config.GddMemWeight.Load()) {
64 | 		if w, err := cast.ToIntE(config.GddMemWeight.Load()); err == nil {
65 | 			weight = w
66 | 		}
67 | 	}
68 | 	BroadcastQueue = queue
69 | 	delegator = &delegate{
70 | 		meta: NodeMeta{
71 | 			RegisterAt: &now,
72 | 			GoVer:      runtime.Version(),
73 | 			GddVer:     buildinfo.GddVer,
74 | 			BuildUser:  buildinfo.BuildUser,
75 | 			BuildTime:  buildTime,
76 | 			Weight:     weight,
77 | 		},
78 | 		queue: queue,
79 | 	}
80 | 	mconf.Delegate = delegator
81 | 	mconf.Events = events
82 | 	var err error
83 | 	if mlist, err = createMemberlist(mconf); err != nil {
84 | 		panic(errors.Wrap(err, "[go-doudou] Failed to create memberlist"))
85 | 	}
86 | 	if err = join(); err != nil {
87 | 		mlist.Shutdown()
88 | 		panic(errors.Wrap(err, "[go-doudou] Node register failed"))
89 | 	}
90 | 	local := mlist.LocalNode()
91 | 	logger.Info().Msgf("memberlist created. local node is Node %s, memberlist port %s", local.Name, fmt.Sprint(local.Port))
92 | 	registerConfigListener(mconf)
93 | }
94 | 
95 | func seeds(seedstr string) []string {
96 | 	if stringutils.IsEmpty(seedstr) {
97 | 		return nil
98 | 	}
99 | 	s := strings.Split(seedstr, ",")
100 | 	for i, seed := range s {
101 | 		li := strings.LastIndex(seed, ":")
102 | 		if li < 0 {
103 | 			s[i] = fmt.Sprintf("%s:%d", seed, config.DefaultGddMemPort)
104 | 			continue
105 | 		}
106 | 		if len(seed) > li+1 {
107 | 			if port, err := cast.ToIntE(seed[li+1:]); err != nil {
108 | 				s[i] = fmt.Sprintf("%s:%d", seed[:li], config.DefaultGddMemPort)
109 | 			} else {
110 | 				s[i] = fmt.Sprintf("%s:%d", seed[:li], port)
111 | 			}
112 | 		}
113 | 	}
114 | 	return s
115 | }
116 | 
117 | func join() error {
118 | 	assertMlistNotNil()
119 | 	seed := config.DefaultGddMemSeed
120 | 	if stringutils.IsNotEmpty(config.GddMemSeed.Load()) {
121 | 		seed = config.GddMemSeed.Load()
122 | 	}
123 | 	s := seeds(seed)
124 | 	if len(s) == 0 {
125 | 		logger.Warn().Msg("No seed found")
126 | 		return nil
127 | 	}
128 | 	_, err := mlist.Join(s)
129 | 	if err != nil {
130 | 		return errors.Wrap(err, "[go-doudou] Failed to join cluster")
131 | 	}
132 | 	logger.Info().Msgf("Node %s joined cluster successfully", mlist.LocalNode().FullAddress())
133 | 	return nil
134 | }
135 | 
136 | // AllNodes return all memberlist nodes except dead and left nodes
137 | func AllNodes() ([]*memberlist.Node, error) {
138 | 	assertMlistNotNil()
139 | 	var nodes []*memberlist.Node
140 | 	for _, node := range mlist.Members() {
141 | 		nodes = append(nodes, node)
142 | 	}
143 | 	return nodes, nil
144 | }
145 | 
146 | func ParseMeta(node *memberlist.Node) (NodeMeta, error) {
147 | 	var mm NodeMeta
148 | 	if len(node.Meta) > 0 {
149 | 		r := bytes.NewReader(node.Meta)
150 | 		dec := codec.NewDecoder(r, &codec.MsgpackHandle{})
151 | 		if err := dec.Decode(&mm); err != nil {
152 | 			logger.Panic().Err(errors.Wrap(err, "[go-doudou] parse node meta data error")).Msg("")
153 | 		}
154 | 	}
155 | 	return mm, nil
156 | }
157 | 
158 | func newConf() *memberlist.Config {
159 | 	cfg := memberlist.DefaultWANConfig()
160 | 	cidrs := config.GddMemCIDRsAllowed.LoadOrDefault(config.DefaultGddMemCIDRsAllowed)
161 | 	if stringutils.IsNotEmpty(cidrs) {
162 | 		var err error
163 | 		if cfg.CIDRsAllowed, err = memberlist.ParseCIDRs(strings.Split(cidrs, ",")); err != nil {
164 | 			logger.Error().Msgf("call ParseCIDRs error: %s\n", err.Error())
165 | 		}
166 | 	}
167 | 	setGddMemIndirectChecks(cfg)
168 | 	minLevel := config.DefaultGddLogLevel
169 | 	if stringutils.IsNotEmpty(config.GddLogLevel.Load()) {
170 | 		minLevel = strings.ToUpper(config.GddLogLevel.Load())
171 | 		if minLevel == "ERROR" {
172 | 			minLevel = "ERR"
173 | 		} else if minLevel == "WARNING" {
174 | 			minLevel = "WARN"
175 | 		}
176 | 	}
177 | 	lf := &logutils.LevelFilter{
178 | 		Levels:   []logutils.LogLevel{"DEBUG", "WARN", "ERR", "INFO"},
179 | 		MinLevel: logutils.LogLevel(minLevel),
180 | 	}
181 | 	disable := cast.ToBoolOrDefault(config.GddMemLogDisable.Load(), config.DefaultGddMemLogDisable)
182 | 	if disable {
183 | 		lf.Writer = ioutil.Discard
184 | 	} else {
185 | 		lf.Writer = logger.Logger
186 | 	}
187 | 	cfg.LogOutput = lf
188 | 	setGddMemDeadTimeout(cfg)
189 | 	setGddMemSyncInterval(cfg)
190 | 	setGddMemReclaimTimeout(cfg)
191 | 	setGddMemProbeInterval(cfg)
192 | 	setGddMemProbeTimeout(cfg)
193 | 	setGddMemSuspicionMult(cfg)
194 | 	setGddMemRetransmitMult(cfg)
195 | 	setGddMemGossipNodes(cfg)
196 | 	setGddMemGossipInterval(cfg)
197 | 	// if env GDD_MEM_WEIGHT is set to > 0, then disable weight calculation, client will always use the same weight
198 | 	weight := config.DefaultGddWeight
199 | 	if stringutils.IsNotEmpty(config.GddWeight.Load()) {
200 | 		if w, err := cast.ToIntE(config.GddWeight.Load()); err == nil {
201 | 			weight = w
202 | 		}
203 | 	} else if stringutils.IsNotEmpty(config.GddMemWeight.Load()) {
204 | 		if w, err := cast.ToIntE(config.GddMemWeight.Load()); err == nil {
205 | 			weight = w
206 | 		}
207 | 	}
208 | 	if weight > 0 {
209 | 		cfg.WeightInterval = 0
210 | 	} else {
211 | 		cfg.WeightInterval = config.DefaultGddMemWeightInterval
212 | 		weightIntervalStr := config.GddMemWeightInterval.Load()
213 | 		if stringutils.IsNotEmpty(weightIntervalStr) {
214 | 			if weightInterval, err := strconv.Atoi(weightIntervalStr); err == nil {
215 | 				cfg.WeightInterval = time.Duration(weightInterval) * time.Millisecond
216 | 			} else {
217 | 				if duration, err := time.ParseDuration(weightIntervalStr); err == nil {
218 | 					cfg.WeightInterval = duration
219 | 				}
220 | 			}
221 | 		}
222 | 	}
223 | 	cfg.TCPTimeout, _ = time.ParseDuration(config.DefaultGddMemTCPTimeout)
224 | 	tcpTimeoutStr := config.GddMemTCPTimeout.Load()
225 | 	if stringutils.IsNotEmpty(tcpTimeoutStr) {
226 | 		if tcpTimeout, err := strconv.Atoi(tcpTimeoutStr); err == nil {
227 | 			cfg.TCPTimeout = time.Duration(tcpTimeout) * time.Second
228 | 		} else {
229 | 			if duration, err := time.ParseDuration(tcpTimeoutStr); err == nil {
230 | 				cfg.TCPTimeout = duration
231 | 			}
232 | 		}
233 | 	}
234 | 	if stringutils.IsNotEmpty(config.GddMemName.Load()) {
235 | 		cfg.Name = config.GddMemName.Load()
236 | 	}
237 | 	memport := config.DefaultGddMemPort
238 | 	if m, err := cast.ToIntE(config.GddMemPort.Load()); err == nil {
239 | 		memport = m
240 | 	}
241 | 	cfg.BindPort = memport
242 | 	cfg.AdvertisePort = memport
243 | 	memhost := config.GddMemHost.Load()
244 | 	if stringutils.IsNotEmpty(memhost) {
245 | 		if strings.HasPrefix(memhost, ".") {
246 | 			hostname, _ := os.Hostname()
247 | 			cfg.AdvertiseAddr = hostname + memhost
248 | 		} else {
249 | 			cfg.AdvertiseAddr = memhost
250 | 		}
251 | 	}
252 | 	return cfg
253 | }
254 | 
255 | var createMemberlist = memberlist.Create
256 | 
257 | func numNodes() int {
258 | 	assertMlistNotNil()
259 | 	return mlist.NumMembers()
260 | }
261 | 
262 | func retransmitMultGetter() int {
263 | 	return mconf.RetransmitMult
264 | }
265 | 
266 | func NewRest(data ...map[string]interface{}) {
267 | 	assertMlistNotNil()
268 | 	service := config.GetServiceName() + "_" + string(cons.REST_TYPE)
269 | 	httpPort := config.GetPort()
270 | 	rr := config.DefaultGddRouteRootPath
271 | 	if stringutils.IsNotEmpty(config.GddRouteRootPath.Load()) {
272 | 		rr = config.GddRouteRootPath.Load()
273 | 	}
274 | 	si := Service{
275 | 		Name:          service,
276 | 		Host:          mlist.AdvertiseAddr(),
277 | 		Port:          int(httpPort),
278 | 		RouteRootPath: rr,
279 | 		Type:          cons.REST_TYPE,
280 | 	}
281 | 	if len(data) > 0 {
282 | 		si.Data = data[0]
283 | 	}
284 | 	delegator.AddService(si)
285 | 	if err := mlist.UpdateNode(mlist.Config().TCPTimeout); err != nil {
286 | 		panic(errors.Wrapf(err, "[go-doudou] failed to register %s service to memberlist", service))
287 | 	}
288 | 	logger.Info().Msgf("[go-doudou] registered %s service to memberlist successfully", service)
289 | }
290 | 
291 | func NewGrpc(data ...map[string]interface{}) {
292 | 	assertMlistNotNil()
293 | 	service := config.GetServiceName() + "_" + string(cons.GRPC_TYPE)
294 | 	grpcPort := config.GetGrpcPort()
295 | 	si := Service{
296 | 		Name: service,
297 | 		Host: mlist.AdvertiseAddr(),
298 | 		Port: int(grpcPort),
299 | 		Type: cons.GRPC_TYPE,
300 | 	}
301 | 	if len(data) > 0 {
302 | 		si.Data = data[0]
303 | 	}
304 | 	delegator.AddService(si)
305 | 	if err := mlist.UpdateNode(mlist.Config().TCPTimeout); err != nil {
306 | 		panic(errors.Wrapf(err, "[go-doudou] failed to register %s service to memberlist", service))
307 | 	}
308 | 	logger.Info().Msgf("[go-doudou] registered %s service to memberlist successfully", service)
309 | }
310 | 
311 | type memConfigListener struct {
312 | 	configmgr.BaseApolloListener
313 | 	memConf *memberlist.Config
314 | }
315 | 
316 | func (c *memConfigListener) OnChange(event *storage.ChangeEvent) {
317 | 	c.Lock.Lock()
318 | 	defer c.Lock.Unlock()
319 | 	if !c.SkippedFirstEvent {
320 | 		c.SkippedFirstEvent = true
321 | 		return
322 | 	}
323 | 	for key, value := range event.Changes {
324 | 		upperKey := strings.ToUpper(strings.ReplaceAll(key, ".", "_"))
325 | 		if strings.HasPrefix(upperKey, "GDD_MEM_") {
326 | 			if value.ChangeType == storage.DELETED {
327 | 				_ = os.Unsetenv(upperKey)
328 | 				continue
329 | 			}
330 | 			_ = os.Setenv(upperKey, fmt.Sprint(value.NewValue))
331 | 		}
332 | 	}
333 | 	setGddMemDeadTimeout(c.memConf)
334 | 	setGddMemSyncInterval(c.memConf)
335 | 	setGddMemReclaimTimeout(c.memConf)
336 | 	setGddMemProbeInterval(c.memConf)
337 | 	setGddMemGossipInterval(c.memConf)
338 | 	setGddMemProbeTimeout(c.memConf)
339 | 	setGddMemSuspicionMult(c.memConf)
340 | 	setGddMemRetransmitMult(c.memConf)
341 | 	setGddMemGossipNodes(c.memConf)
342 | 	setGddMemIndirectChecks(c.memConf)
343 | }
344 | 
345 | func CallbackOnChange(listener *memConfigListener) func(event *configmgr.NacosChangeEvent) {
346 | 	return func(event *configmgr.NacosChangeEvent) {
347 | 		changes := make(map[string]*storage.ConfigChange)
348 | 		for k, v := range event.Changes {
349 | 			changes[k] = &storage.ConfigChange{
350 | 				OldValue:   v.OldValue,
351 | 				NewValue:   v.NewValue,
352 | 				ChangeType: storage.ConfigChangeType(v.ChangeType),
353 | 			}
354 | 		}
355 | 		changeEvent := &storage.ChangeEvent{
356 | 			Changes: changes,
357 | 		}
358 | 		listener.OnChange(changeEvent)
359 | 	}
360 | }
361 | 
362 | func registerConfigListener(memConf *memberlist.Config) {
363 | 	listener := &memConfigListener{
364 | 		memConf: memConf,
365 | 	}
366 | 	configType := config.GddConfigRemoteType.LoadOrDefault(config.DefaultGddConfigRemoteType)
367 | 	switch configType {
368 | 	case "":
369 | 		return
370 | 	case config.NacosConfigType:
371 | 		dataIdStr := config.GddNacosConfigDataid.LoadOrDefault(config.DefaultGddNacosConfigDataid)
372 | 		dataIds := strings.Split(dataIdStr, ",")
373 | 		listener.SkippedFirstEvent = true
374 | 		for _, dataId := range dataIds {
375 | 			configmgr.NacosClient.AddChangeListener(configmgr.NacosConfigListenerParam{
376 | 				DataId:   "__" + dataId + "__" + "registry",
377 | 				OnChange: CallbackOnChange(listener),
378 | 			})
379 | 		}
380 | 	case config.ApolloConfigType:
381 | 		configmgr.ApolloClient.AddChangeListener(listener)
382 | 	default:
383 | 		panic(fmt.Errorf("[go-doudou] from registry pkg: unknown config type: %s\n", configType))
384 | 	}
385 | }
386 | 
387 | func Shutdown() {
388 | 	shutdownOnce.Do(func() {
389 | 		if mlist != nil {
390 | 			_ = mlist.Shutdown()
391 | 			mlist = nil
392 | 			logger.Info().Msg("memberlist shutdown")
393 | 		}
394 | 	})
395 | }
396 | 
397 | // Leave leaves the cluster on purpose
398 | func Leave(timeout time.Duration) {
399 | 	if mlist != nil {
400 | 		_ = mlist.Leave(timeout)
401 | 		logger.Info().Msg("local node left the cluster")
402 | 	}
403 | }
404 | 
405 | func RegisterServiceProvider(sp IMemberlistServiceProvider) {
406 | 	if mlist != nil {
407 | 		for _, node := range mlist.Members() {
408 | 			sp.AddNode(node)
409 | 		}
410 | 	}
411 | 	events.ServiceProviders = append(events.ServiceProviders, sp)
412 | }
413 | 
414 | func LocalNode() *memberlist.Node {
415 | 	assertMlistNotNil()
416 | 	return mlist.LocalNode()
417 | }
```

framework/registry/memberlist/resolver.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"net/url"
5 | 	"strings"
6 | 	"sync"
7 | 
8 | 	"github.com/pkg/errors"
9 | 	"github.com/unionj-cloud/toolkit/memberlist"
10 | 	"google.golang.org/grpc/attributes"
11 | 	gresolver "google.golang.org/grpc/resolver"
12 | )
13 | 
14 | const schemeName = "memberlist"
15 | 
16 | var _ gresolver.Builder = (*builder)(nil)
17 | var _ gresolver.Resolver = (*resolver)(nil)
18 | var _ IMemberlistServiceProvider = (*resolver)(nil)
19 | 
20 | func init() {
21 | 	gresolver.Register(&builder{})
22 | }
23 | 
24 | type builder struct {
25 | }
26 | 
27 | func parseURL(u string) (string, error) {
28 | 	rawURL, err := url.Parse(u)
29 | 	if err != nil {
30 | 		return "", errors.Wrap(err, "Wrong memberlist URL")
31 | 	}
32 | 	if rawURL.Scheme != schemeName || len(rawURL.Host) == 0 {
33 | 		return "", errors.Wrap(err, "Wrong memberlist URL")
34 | 	}
35 | 	return rawURL.Host, nil
36 | }
37 | 
38 | func (r *builder) Scheme() string {
39 | 	return schemeName
40 | }
41 | 
42 | func (b *builder) Build(target gresolver.Target, cc gresolver.ClientConn, opts gresolver.BuildOptions) (gresolver.Resolver, error) {
43 | 	dsn := strings.Join([]string{schemeName + ":/", target.URL.Host, target.URL.Path}, "/")
44 | 	name, err := parseURL(dsn)
45 | 	if err != nil {
46 | 		return nil, errors.Wrap(err, "Wrong URL")
47 | 	}
48 | 	r := &resolver{
49 | 		base: base{
50 | 			name:    name,
51 | 			nodeMap: make(map[string]*server),
52 | 		},
53 | 		cc: cc,
54 | 	}
55 | 	RegisterServiceProvider(r)
56 | 	return r, nil
57 | }
58 | 
59 | type resolver struct {
60 | 	base base
61 | 	cc   gresolver.ClientConn
62 | 	lock sync.RWMutex
63 | }
64 | 
65 | func (m *resolver) AddNode(node *memberlist.Node) {
66 | 	m.lock.Lock()
67 | 	defer m.lock.Unlock()
68 | 
69 | 	m.base.AddNode(node)
70 | 	m.UpdateCC()
71 | }
72 | 
73 | func (m *resolver) UpdateWeight(node *memberlist.Node) {
74 | 	m.lock.Lock()
75 | 	defer m.lock.Unlock()
76 | 
77 | 	m.base.UpdateWeight(node)
78 | 	m.UpdateCC()
79 | }
80 | 
81 | func (m *resolver) RemoveNode(node *memberlist.Node) {
82 | 	m.lock.Lock()
83 | 	defer m.lock.Unlock()
84 | 
85 | 	m.base.RemoveNode(node)
86 | 	m.UpdateCC()
87 | }
88 | 
89 | func (m *resolver) UpdateCC() {
90 | 	conns := make([]gresolver.Address, 0, len(m.base.nodes))
91 | 	for _, item := range m.base.nodes {
92 | 		add := gresolver.Address{Addr: item.baseUrl,
93 | 			BalancerAttributes: attributes.New(WeightAttributeKey{}, WeightAddrInfo{Weight: item.weight})}
94 | 		conns = append(conns, add)
95 | 	}
96 | 	m.cc.UpdateState(gresolver.State{Addresses: conns})
97 | }
98 | 
99 | func (m *resolver) ResolveNow(gresolver.ResolveNowOptions) {}
100 | 
101 | func (m *resolver) Close() {
102 | }
```

framework/registry/memberlist/serviceprovider.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"sync"
7 | 	"sync/atomic"
8 | 	"time"
9 | 
10 | 	"github.com/unionj-cloud/toolkit/memberlist"
11 | 	"github.com/unionj-cloud/toolkit/stringutils"
12 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
13 | 	"google.golang.org/grpc"
14 | )
15 | 
16 | // IMemberlistServiceProvider defines service provider interface for server discovery
17 | type IMemberlistServiceProvider interface {
18 | 	AddNode(node *memberlist.Node)
19 | 	UpdateWeight(node *memberlist.Node)
20 | 	RemoveNode(node *memberlist.Node)
21 | }
22 | 
23 | type server struct {
24 | 	service       string
25 | 	node          string
26 | 	baseUrl       string
27 | 	weight        int
28 | 	currentWeight int
29 | }
30 | 
31 | func (s *server) Weight() int {
32 | 	return s.weight
33 | }
34 | 
35 | type base struct {
36 | 	name    string
37 | 	nodes   []*server
38 | 	nodeMap map[string]*server
39 | }
40 | 
41 | func (m *base) GetService(meta NodeMeta) Service {
42 | 	for _, service := range meta.Services {
43 | 		if service.Name == m.name {
44 | 			return service
45 | 		}
46 | 	}
47 | 	return Service{}
48 | }
49 | 
50 | // AddNode add or update node providing the service
51 | func (m *base) AddNode(node *memberlist.Node) {
52 | 	meta, _ := ParseMeta(node)
53 | 	service := m.GetService(meta)
54 | 	if stringutils.IsEmpty(service.Name) {
55 | 		return
56 | 	}
57 | 	baseUrl := service.BaseUrl()
58 | 	weight := meta.Weight
59 | 	if s, exists := m.nodeMap[node.Name]; !exists {
60 | 		s = &server{
61 | 			service:       m.name,
62 | 			node:          node.Name,
63 | 			baseUrl:       baseUrl,
64 | 			weight:        weight,
65 | 			currentWeight: 0,
66 | 		}
67 | 		m.nodes = append(m.nodes, s)
68 | 		m.nodeMap[node.Name] = s
69 | 		logger.Info().Msgf("[go-doudou] add node %s to load balancer, supplying %s service", node.Name, service.Name)
70 | 	} else {
71 | 		old := *s
72 | 		s.baseUrl = baseUrl
73 | 		s.weight = weight
74 | 		logger.Info().Msgf("[go-doudou] node %s update, supplying %s service, old: %+v, new: %+v", node.Name, service.Name, old, *s)
75 | 	}
76 | }
77 | 
78 | func (m *base) UpdateWeight(node *memberlist.Node) {
79 | 	meta, _ := ParseMeta(node)
80 | 	if meta.Weight > 0 {
81 | 		return
82 | 	}
83 | 	service := m.GetService(meta)
84 | 	if stringutils.IsEmpty(service.Name) {
85 | 		return
86 | 	}
87 | 	if s, exists := m.nodeMap[node.Name]; exists {
88 | 		old := *s
89 | 		s.weight = node.Weight
90 | 		logger.Info().Msgf("[go-doudou] weight of node %s update, old: %d, new: %d", node.Name, old.weight, s.weight)
91 | 	}
92 | }
93 | 
94 | func (m *base) GetServer(nodeName string) *server {
95 | 	return m.nodeMap[nodeName]
96 | }
97 | 
98 | func (m *base) RemoveNode(node *memberlist.Node) {
99 | 	meta, _ := ParseMeta(node)
100 | 	service := m.GetService(meta)
101 | 	if stringutils.IsEmpty(service.Name) {
102 | 		return
103 | 	}
104 | 	if _, exists := m.nodeMap[node.Name]; exists {
105 | 		var idx int
106 | 		for i, n := range m.nodes {
107 | 			if n.node == node.Name {
108 | 				idx = i
109 | 			}
110 | 		}
111 | 		m.nodes = append(m.nodes[:idx], m.nodes[idx+1:]...)
112 | 		delete(m.nodeMap, node.Name)
113 | 		logger.Info().Msgf("[go-doudou] remove node %s from load balancer, supplying %s service", node.Name, service.Name)
114 | 	}
115 | }
116 | 
117 | var _ IMemberlistServiceProvider = (*RRServiceProvider)(nil)
118 | 
119 | // RRServiceProvider defines an implementation for IMemberlistServiceProvider
120 | type RRServiceProvider struct {
121 | 	base    base
122 | 	current uint64
123 | 	lock    sync.RWMutex
124 | }
125 | 
126 | func (m *RRServiceProvider) AddNode(node *memberlist.Node) {
127 | 	m.lock.Lock()
128 | 	defer m.lock.Unlock()
129 | 
130 | 	m.base.AddNode(node)
131 | }
132 | 
133 | func (m *RRServiceProvider) UpdateWeight(node *memberlist.Node) {
134 | 	m.lock.Lock()
135 | 	defer m.lock.Unlock()
136 | 
137 | 	m.base.UpdateWeight(node)
138 | }
139 | 
140 | func (m *RRServiceProvider) RemoveNode(node *memberlist.Node) {
141 | 	m.lock.Lock()
142 | 	defer m.lock.Unlock()
143 | 
144 | 	m.base.RemoveNode(node)
145 | }
146 | 
147 | // SelectServer selects a node which is supplying service specified by name property from cluster
148 | func (m *RRServiceProvider) SelectServer() string {
149 | 	m.lock.RLock()
150 | 	defer m.lock.RUnlock()
151 | 	if len(m.base.nodes) == 0 {
152 | 		return ""
153 | 	}
154 | 	next := int(atomic.AddUint64(&m.current, uint64(1)) % uint64(len(m.base.nodes)))
155 | 	m.current = uint64(next)
156 | 	selected := m.base.nodes[next]
157 | 	return selected.baseUrl
158 | }
159 | 
160 | func (m *RRServiceProvider) Close() {
161 | }
162 | 
163 | // NewRRServiceProvider create an RRServiceProvider instance
164 | func NewRRServiceProvider(name string) *RRServiceProvider {
165 | 	sp := &RRServiceProvider{
166 | 		base: base{
167 | 			name:    name,
168 | 			nodeMap: make(map[string]*server),
169 | 		},
170 | 	}
171 | 	RegisterServiceProvider(sp)
172 | 	return sp
173 | }
174 | 
175 | var _ IMemberlistServiceProvider = (*SWRRServiceProvider)(nil)
176 | 
177 | // SWRRServiceProvider is a smooth weighted round-robin algo implementation for IMemberlistServiceProvider
178 | // https://github.com/nginx/nginx/commit/52327e0627f49dbda1e8db695e63a4b0af4448b1
179 | type SWRRServiceProvider struct {
180 | 	base base
181 | 	lock sync.RWMutex
182 | }
183 | 
184 | func (m *SWRRServiceProvider) AddNode(node *memberlist.Node) {
185 | 	m.lock.Lock()
186 | 	defer m.lock.Unlock()
187 | 
188 | 	m.base.AddNode(node)
189 | }
190 | 
191 | func (m *SWRRServiceProvider) UpdateWeight(node *memberlist.Node) {
192 | 	m.lock.Lock()
193 | 	defer m.lock.Unlock()
194 | 
195 | 	m.base.UpdateWeight(node)
196 | }
197 | 
198 | func (m *SWRRServiceProvider) RemoveNode(node *memberlist.Node) {
199 | 	m.lock.Lock()
200 | 	defer m.lock.Unlock()
201 | 
202 | 	m.base.RemoveNode(node)
203 | }
204 | 
205 | // SelectServer selects a node which is supplying service specified by name property from cluster
206 | func (m *SWRRServiceProvider) SelectServer() string {
207 | 	m.lock.RLock()
208 | 	defer m.lock.RUnlock()
209 | 	if len(m.base.nodes) == 0 {
210 | 		return ""
211 | 	}
212 | 	var selected *server
213 | 	total := 0
214 | 	for i := 0; i < len(m.base.nodes); i++ {
215 | 		s := m.base.nodes[i]
216 | 		s.currentWeight += s.weight
217 | 		total += s.weight
218 | 		if selected == nil || s.currentWeight > selected.currentWeight {
219 | 			selected = s
220 | 		}
221 | 	}
222 | 	selected.currentWeight -= total
223 | 	return selected.baseUrl
224 | }
225 | 
226 | func (m *SWRRServiceProvider) Close() {
227 | }
228 | 
229 | // NewSWRRServiceProvider create an SWRRServiceProvider instance
230 | func NewSWRRServiceProvider(name string) *SWRRServiceProvider {
231 | 	sp := &SWRRServiceProvider{
232 | 		base: base{
233 | 			name:    name,
234 | 			nodeMap: make(map[string]*server),
235 | 		},
236 | 	}
237 | 	RegisterServiceProvider(sp)
238 | 	return sp
239 | }
240 | 
241 | func NewSWRRGrpcClientConn(service string, dialOptions ...grpc.DialOption) *grpc.ClientConn {
242 | 	return NewGrpcClientConn(service, "memberlist_weight_balancer", dialOptions...)
243 | }
244 | 
245 | func NewRRGrpcClientConn(service string, dialOptions ...grpc.DialOption) *grpc.ClientConn {
246 | 	return NewGrpcClientConn(service, "round_robin", dialOptions...)
247 | }
248 | 
249 | func NewGrpcClientConn(service string, lb string, dialOptions ...grpc.DialOption) *grpc.ClientConn {
250 | 	serverAddr := fmt.Sprintf(schemeName+"://%s/", service)
251 | 	dialOptions = append(dialOptions, grpc.WithBlock(), grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy": "`+lb+`"}`))
252 | 	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
253 | 	defer cancel()
254 | 	grpcConn, err := grpc.DialContext(ctx, serverAddr, dialOptions...)
255 | 	if err != nil {
256 | 		logger.Panic().Err(err).Msgf("[go-doudou] failed to connect to server %s", serverAddr)
257 | 	}
258 | 	return grpcConn
259 | }
```

framework/registry/memberlist/serviceprovider_test.go
```
1 | package memberlist
2 | 
3 | import (
4 | 	"sync"
5 | 
6 | 	"github.com/unionj-cloud/toolkit/memberlist"
7 | )
8 | 
9 | type mockServiceProvider struct {
10 | 	name      string
11 | 	servers   []*memberlist.Node
12 | 	serverMap map[string]*memberlist.Node
13 | 	lock      sync.RWMutex
14 | }
15 | 
16 | func (m *mockServiceProvider) SelectServer() string {
17 | 	return "mock server"
18 | }
19 | 
20 | func (m *mockServiceProvider) AddNode(node *memberlist.Node) {
21 | 	m.lock.Lock()
22 | 	defer m.lock.Unlock()
23 | 	m.servers = append(m.servers, node)
24 | 	m.serverMap[node.Name] = node
25 | }
26 | 
27 | func (m *mockServiceProvider) UpdateWeight(node *memberlist.Node) {
28 | 	m.lock.Lock()
29 | 	defer m.lock.Unlock()
30 | 	if s, exists := m.serverMap[node.Name]; exists {
31 | 		s.Weight = node.Weight
32 | 	}
33 | }
34 | 
35 | func (m *mockServiceProvider) RemoveNode(node *memberlist.Node) {
36 | 	m.lock.Lock()
37 | 	defer m.lock.Unlock()
38 | 	if _, exists := m.serverMap[node.Name]; exists {
39 | 		var idx int
40 | 		for i, n := range m.servers {
41 | 			if n.Name == node.Name {
42 | 				idx = i
43 | 			}
44 | 		}
45 | 		m.servers = append(m.servers[:idx], m.servers[idx+1:]...)
46 | 		delete(m.serverMap, node.Name)
47 | 	}
48 | }
49 | 
50 | func newMockServiceProvider(name string) *mockServiceProvider {
51 | 	return &mockServiceProvider{
52 | 		servers:   make([]*memberlist.Node, 0),
53 | 		serverMap: make(map[string]*memberlist.Node),
54 | 		name:      name,
55 | 	}
56 | }
```

framework/registry/nacos/naming_client_interface.go
```
1 | /*
2 |  * Copyright 1999-2020 Alibaba Group Holding Ltd.
3 |  *
4 |  * Licensed under the Apache License, Version 2.0 (the "License");
5 |  * you may not use this file except in compliance with the License.
6 |  * You may obtain a copy of the License at
7 |  *
8 |  *      http://www.apache.org/licenses/LICENSE-2.0
9 |  *
10 |  * Unless required by applicable law or agreed to in writing, software
11 |  * distributed under the License is distributed on an "AS IS" BASIS,
12 |  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13 |  * See the License for the specific language governing permissions and
14 |  * limitations under the License.
15 |  */
16 | package nacos
17 | 
18 | import (
19 | 	"github.com/wubin1989/nacos-sdk-go/v2/model"
20 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
21 | )
22 | 
23 | //go:generate mockgen -destination ./mock/mock_naming_client_interface.go -package mock -source=./naming_client_interface.go
24 | 
25 | // INamingClient interface for naming client
26 | type INamingClient interface {
27 | 
28 | 	// RegisterInstance use to register instance
29 | 	// Ip  require
30 | 	// Port  require
31 | 	// Weight  require,it must be lager than 0
32 | 	// Enable  require,the instance can be access or not
33 | 	// Healthy  require,the instance is health or not
34 | 	// Metadata  optional
35 | 	// ClusterName  optional,default:DEFAULT
36 | 	// ServiceName require
37 | 	// GroupName optional,default:DEFAULT_GROUP
38 | 	// Ephemeral optional
39 | 	RegisterInstance(param vo.RegisterInstanceParam) (bool, error)
40 | 
41 | 	// DeregisterInstance use to deregister instance
42 | 	// Ip required
43 | 	// Port required
44 | 	// Tenant optional
45 | 	// Cluster optional,default:DEFAULT
46 | 	// ServiceName  require
47 | 	// GroupName  optional,default:DEFAULT_GROUP
48 | 	// Ephemeral optional
49 | 	DeregisterInstance(param vo.DeregisterInstanceParam) (bool, error)
50 | 
51 | 	// UpdateInstance use to update instance
52 | 	// Ip  require
53 | 	// Port  require
54 | 	// Weight  require,it must be lager than 0
55 | 	// Enable  require,the instance can be access or not
56 | 	// Healthy  require,the instance is health or not
57 | 	// Metadata  optional
58 | 	// ClusterName  optional,default:DEFAULT
59 | 	// ServiceName require
60 | 	// GroupName optional,default:DEFAULT_GROUP
61 | 	// Ephemeral optional
62 | 	UpdateInstance(param vo.UpdateInstanceParam) (bool, error)
63 | 
64 | 	// GetService use to get service
65 | 	// ServiceName require
66 | 	// Clusters optional,default:DEFAULT
67 | 	// GroupName optional,default:DEFAULT_GROUP
68 | 	GetService(param vo.GetServiceParam) (model.Service, error)
69 | 
70 | 	// SelectAllInstances return all instances,include healthy=false,enable=false,weight<=0
71 | 	// ServiceName require
72 | 	// Clusters optional,default:DEFAULT
73 | 	// GroupName optional,default:DEFAULT_GROUP
74 | 	SelectAllInstances(param vo.SelectAllInstancesParam) ([]model.Instance, error)
75 | 
76 | 	// SelectInstances only return the instances of healthy=${HealthyOnly},enable=true and weight>0
77 | 	// ServiceName require
78 | 	// Clusters optional,default:DEFAULT
79 | 	// GroupName optional,default:DEFAULT_GROUP
80 | 	// HealthyOnly optional
81 | 	SelectInstances(param vo.SelectInstancesParam) ([]model.Instance, error)
82 | 
83 | 	// SelectOneHealthyInstance return one instance by WRR strategy for load balance
84 | 	// And the instance should be health=true,enable=true and weight>0
85 | 	// ServiceName require
86 | 	// Clusters optional,default:DEFAULT
87 | 	// GroupName optional,default:DEFAULT_GROUP
88 | 	SelectOneHealthyInstance(param vo.SelectOneHealthInstanceParam) (*model.Instance, error)
89 | 
90 | 	// Subscribe use to subscribe service change event
91 | 	// ServiceName require
92 | 	// Clusters optional,default:DEFAULT
93 | 	// GroupName optional,default:DEFAULT_GROUP
94 | 	// SubscribeCallback require
95 | 	Subscribe(param *vo.SubscribeParam) error
96 | 
97 | 	// Unsubscribe use to unsubscribe service change event
98 | 	// ServiceName require
99 | 	// Clusters optional,default:DEFAULT
100 | 	// GroupName optional,default:DEFAULT_GROUP
101 | 	// SubscribeCallback require
102 | 	Unsubscribe(param *vo.SubscribeParam) error
103 | 
104 | 	// GetAllServicesInfo use to get all service info by page
105 | 	GetAllServicesInfo(param vo.GetAllServiceInfoParam) (model.ServiceList, error)
106 | 
107 | 	//CloseClient close the GRPC client
108 | 	CloseClient()
109 | }
```

framework/registry/nacos/node.go
```
1 | package nacos
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"runtime"
7 | 	"sort"
8 | 	"strconv"
9 | 	"sync"
10 | 	"sync/atomic"
11 | 	"time"
12 | 
13 | 	"github.com/pkg/errors"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/buildinfo"
15 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
16 | 	"github.com/unionj-cloud/go-doudou/v2/framework/grpcx/grpc_resolver_nacos"
17 | 	cons "github.com/unionj-cloud/go-doudou/v2/framework/registry/constants"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/utils"
19 | 	"github.com/unionj-cloud/toolkit/cast"
20 | 	"github.com/unionj-cloud/toolkit/constants"
21 | 	"github.com/unionj-cloud/toolkit/stringutils"
22 | 	logger "github.com/unionj-cloud/toolkit/zlogger"
23 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients"
24 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/naming_client"
25 | 	"github.com/wubin1989/nacos-sdk-go/v2/model"
26 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
27 | 	"google.golang.org/grpc"
28 | )
29 | 
30 | var NamingClient naming_client.INamingClient
31 | var onceNacos sync.Once
32 | var NewNamingClient = clients.NewNamingClient
33 | 
34 | func InitialiseNacosNamingClient() {
35 | 	var err error
36 | 	NamingClient, err = NewNamingClient(config.GetNacosClientParam())
37 | 	if err != nil {
38 | 		logger.Panic().Err(err).Msg("[go-doudou] failed to create nacos discovery client")
39 | 	}
40 | }
41 | 
42 | func NewRest(data ...map[string]interface{}) {
43 | 	onceNacos.Do(func() {
44 | 		InitialiseNacosNamingClient()
45 | 	})
46 | 	registerHost := utils.GetRegisterHost()
47 | 	httpPort := config.GetPort()
48 | 	service := config.GetServiceName() + "_" + string(cons.REST_TYPE)
49 | 	weight := config.DefaultGddWeight
50 | 	if stringutils.IsNotEmpty(config.GddWeight.Load()) {
51 | 		if w, err := cast.ToIntE(config.GddWeight.Load()); err == nil {
52 | 			weight = w
53 | 		}
54 | 	}
55 | 	buildTime := buildinfo.BuildTime
56 | 	if stringutils.IsNotEmpty(buildinfo.BuildTime) {
57 | 		if t, err := time.Parse(constants.FORMAT15, buildinfo.BuildTime); err == nil {
58 | 			buildTime = t.Local().Format(constants.FORMAT8)
59 | 		}
60 | 	}
61 | 	rr := config.DefaultGddRouteRootPath
62 | 	if stringutils.IsNotEmpty(config.GddRouteRootPath.Load()) {
63 | 		rr = config.GddRouteRootPath.Load()
64 | 	}
65 | 	metadata := make(map[string]string)
66 | 	metadata["registerAt"] = time.Now().Local().Format(constants.FORMAT8)
67 | 	metadata["goVer"] = runtime.Version()
68 | 	metadata["gddVer"] = buildinfo.GddVer
69 | 	metadata["buildUser"] = buildinfo.BuildUser
70 | 	metadata["buildTime"] = buildTime
71 | 	metadata["weight"] = strconv.Itoa(weight)
72 | 	metadata["rootPath"] = rr
73 | 	for _, item := range data {
74 | 		for k, v := range item {
75 | 			metadata[k] = fmt.Sprint(v)
76 | 		}
77 | 	}
78 | 	success, err := NamingClient.RegisterInstance(vo.RegisterInstanceParam{
79 | 		Ip:          registerHost,
80 | 		Port:        httpPort,
81 | 		Weight:      float64(weight),
82 | 		Enable:      true,
83 | 		Healthy:     true,
84 | 		Metadata:    metadata,
85 | 		ClusterName: config.GddNacosClusterName.LoadOrDefault(config.DefaultGddNacosClusterName),
86 | 		ServiceName: service,
87 | 		GroupName:   config.GddNacosGroupName.LoadOrDefault(config.DefaultGddNacosGroupName),
88 | 		Ephemeral:   true,
89 | 	})
90 | 	if err != nil {
91 | 		panic(errors.Errorf("[go-doudou] %s failed to register to nacos server: %s", service, err))
92 | 	}
93 | 	if success {
94 | 		logger.Info().Msgf("[go-doudou] %s registered to nacos server successfully", service)
95 | 	}
96 | }
97 | 
98 | func NewGrpc(data ...map[string]interface{}) {
99 | 	onceNacos.Do(func() {
100 | 		InitialiseNacosNamingClient()
101 | 	})
102 | 	registerHost := utils.GetRegisterHost()
103 | 	grpcPort := config.GetGrpcPort()
104 | 	service := config.GetServiceName() + "_" + string(cons.GRPC_TYPE)
105 | 	weight := config.DefaultGddWeight
106 | 	if stringutils.IsNotEmpty(config.GddWeight.Load()) {
107 | 		if w, err := cast.ToIntE(config.GddWeight.Load()); err == nil {
108 | 			weight = w
109 | 		}
110 | 	}
111 | 	buildTime := buildinfo.BuildTime
112 | 	if stringutils.IsNotEmpty(buildinfo.BuildTime) {
113 | 		if t, err := time.Parse(constants.FORMAT15, buildinfo.BuildTime); err == nil {
114 | 			buildTime = t.Local().Format(constants.FORMAT8)
115 | 		}
116 | 	}
117 | 	metadata := make(map[string]string)
118 | 	metadata["registerAt"] = time.Now().Local().Format(constants.FORMAT8)
119 | 	metadata["goVer"] = runtime.Version()
120 | 	metadata["gddVer"] = buildinfo.GddVer
121 | 	metadata["buildUser"] = buildinfo.BuildUser
122 | 	metadata["buildTime"] = buildTime
123 | 	metadata["weight"] = strconv.Itoa(weight)
124 | 	for _, item := range data {
125 | 		for k, v := range item {
126 | 			metadata[k] = fmt.Sprint(v)
127 | 		}
128 | 	}
129 | 	success, err := NamingClient.RegisterInstance(vo.RegisterInstanceParam{
130 | 		Ip:          registerHost,
131 | 		Port:        grpcPort,
132 | 		Weight:      float64(weight),
133 | 		Enable:      true,
134 | 		Healthy:     true,
135 | 		Metadata:    metadata,
136 | 		ClusterName: config.GddNacosClusterName.LoadOrDefault(config.DefaultGddNacosClusterName),
137 | 		ServiceName: service,
138 | 		GroupName:   config.GddNacosGroupName.LoadOrDefault(config.DefaultGddNacosGroupName),
139 | 		Ephemeral:   true,
140 | 	})
141 | 	if err != nil {
142 | 		panic(errors.Errorf("[go-doudou] %s failed to register to nacos server: %s", service, err))
143 | 	}
144 | 	if success {
145 | 		logger.Info().Msgf("[go-doudou] %s registered to nacos server successfully", service)
146 | 	}
147 | }
148 | 
149 | func ShutdownRest() {
150 | 	if NamingClient != nil {
151 | 		registerHost := utils.GetRegisterHost()
152 | 		httpPort := config.GetPort()
153 | 		service := config.GetServiceName() + "_" + string(cons.REST_TYPE)
154 | 		success, err := NamingClient.DeregisterInstance(vo.DeregisterInstanceParam{
155 | 			Ip:          registerHost,
156 | 			Port:        httpPort,
157 | 			ServiceName: service,
158 | 			Ephemeral:   true,
159 | 		})
160 | 		if err != nil {
161 | 			logger.Error().Err(err).Msgf("[go-doudou] failed to deregister %s from nacos server", service)
162 | 			return
163 | 		}
164 | 		if !success {
165 | 			logger.Error().Msgf("[go-doudou] failed to deregister %s from nacos server", service)
166 | 			return
167 | 		}
168 | 		logger.Info().Msgf("[go-doudou] deregistered %s from nacos server successfully", service)
169 | 	}
170 | }
171 | 
172 | func ShutdownGrpc() {
173 | 	if NamingClient != nil {
174 | 		registerHost := utils.GetRegisterHost()
175 | 		grpcPort := config.GetGrpcPort()
176 | 		service := config.GetServiceName() + "_" + string(cons.GRPC_TYPE)
177 | 		success, err := NamingClient.DeregisterInstance(vo.DeregisterInstanceParam{
178 | 			Ip:          registerHost,
179 | 			Port:        grpcPort,
180 | 			ServiceName: service,
181 | 			Ephemeral:   true,
182 | 		})
183 | 		if err != nil {
184 | 			logger.Error().Err(err).Msgf("[go-doudou] failed to deregister %s from nacos server", service)
185 | 			return
186 | 		}
187 | 		if !success {
188 | 			logger.Error().Msgf("[go-doudou] failed to deregister %s from nacos server", service)
189 | 			return
190 | 		}
191 | 		logger.Info().Msgf("[go-doudou] deregistered %s from nacos server successfully", service)
192 | 	}
193 | }
194 | 
195 | var shutdownOnce sync.Once
196 | 
197 | func CloseNamingClient() {
198 | 	shutdownOnce.Do(func() {
199 | 		if NamingClient != nil {
200 | 			NamingClient.CloseClient()
201 | 			NamingClient = nil
202 | 			logger.Info().Msg("[go-doudou] nacos naming client closed")
203 | 		}
204 | 	})
205 | }
206 | 
207 | type nacosBase struct {
208 | 	clusters     []string //optional,default:DEFAULT
209 | 	serviceName  string   //required
210 | 	groupName    string   //optional,default:DEFAULT_GROUP
211 | 	lock         sync.Mutex
212 | 	namingClient naming_client.INamingClient
213 | }
214 | 
215 | func (b *nacosBase) SetClusters(clusters []string) {
216 | 	b.clusters = clusters
217 | }
218 | 
219 | func (b *nacosBase) SetGroupName(groupName string) {
220 | 	b.groupName = groupName
221 | }
222 | 
223 | func (b *nacosBase) SetNamingClient(namingClient naming_client.INamingClient) {
224 | 	b.namingClient = namingClient
225 | }
226 | 
227 | type INacosServiceProvider interface {
228 | 	SetClusters(clusters []string)
229 | 	SetGroupName(groupName string)
230 | 	SetNamingClient(namingClient naming_client.INamingClient)
231 | }
232 | 
233 | type NacosProviderOption func(INacosServiceProvider)
234 | 
235 | func WithNacosClusters(clusters []string) NacosProviderOption {
236 | 	return func(provider INacosServiceProvider) {
237 | 		provider.SetClusters(clusters)
238 | 	}
239 | }
240 | 
241 | func WithNacosGroupName(groupName string) NacosProviderOption {
242 | 	return func(provider INacosServiceProvider) {
243 | 		provider.SetGroupName(groupName)
244 | 	}
245 | }
246 | 
247 | func WithNacosNamingClient(namingClient naming_client.INamingClient) NacosProviderOption {
248 | 	return func(provider INacosServiceProvider) {
249 | 		provider.SetNamingClient(namingClient)
250 | 	}
251 | }
252 | 
253 | type instance []model.Instance
254 | 
255 | func (a instance) Len() int {
256 | 	return len(a)
257 | }
258 | 
259 | func (a instance) Swap(i, j int) {
260 | 	a[i], a[j] = a[j], a[i]
261 | }
262 | 
263 | func (a instance) Less(i, j int) bool {
264 | 	return a[i].InstanceId < a[j].InstanceId
265 | }
266 | 
267 | // RRServiceProvider is a simple round-robin load balance implementation for IServiceProvider
268 | type RRServiceProvider struct {
269 | 	nacosBase
270 | 	current uint64
271 | }
272 | 
273 | // SelectServer return service address from environment variable
274 | func (n *RRServiceProvider) SelectServer() string {
275 | 	n.lock.Lock()
276 | 	defer n.lock.Unlock()
277 | 	if n.namingClient == nil {
278 | 		logger.Error().Msg("[go-doudou] nacos discovery client has not been initialized")
279 | 		return ""
280 | 	}
281 | 	instances, err := n.namingClient.SelectInstances(vo.SelectInstancesParam{
282 | 		Clusters:    n.clusters,
283 | 		ServiceName: n.serviceName,
284 | 		GroupName:   n.groupName,
285 | 		HealthyOnly: true,
286 | 	})
287 | 	if err != nil {
288 | 		logger.Error().Err(err).Msgf("[go-doudou] %s server not found", n.serviceName)
289 | 		return ""
290 | 	}
291 | 	if len(instances) == 0 {
292 | 		logger.Error().Msgf("[go-doudou] %s server not found", n.serviceName)
293 | 		return ""
294 | 	}
295 | 	sort.Sort(instance(instances))
296 | 	next := int(atomic.AddUint64(&n.current, uint64(1)) % uint64(len(instances)))
297 | 	n.current = uint64(next)
298 | 	selected := instances[next]
299 | 	return fmt.Sprintf("http://%s:%d%s", selected.Ip, selected.Port, selected.Metadata["rootPath"])
300 | }
301 | 
302 | func (n *RRServiceProvider) Close() {
303 | }
304 | 
305 | // NewRRServiceProvider creates new ServiceProvider instance
306 | func NewRRServiceProvider(serviceName string, opts ...NacosProviderOption) *RRServiceProvider {
307 | 	onceNacos.Do(func() {
308 | 		InitialiseNacosNamingClient()
309 | 	})
310 | 	provider := &RRServiceProvider{
311 | 		nacosBase: nacosBase{
312 | 			serviceName:  serviceName,
313 | 			namingClient: NamingClient,
314 | 		},
315 | 	}
316 | 	for _, opt := range opts {
317 | 		opt(provider)
318 | 	}
319 | 	return provider
320 | }
321 | 
322 | // WRRServiceProvider is a WRR load balance implementation for IServiceProvider
323 | type WRRServiceProvider struct {
324 | 	nacosBase
325 | }
326 | 
327 | // SelectServer return service address from environment variable
328 | func (n *WRRServiceProvider) SelectServer() string {
329 | 	n.lock.Lock()
330 | 	defer n.lock.Unlock()
331 | 	if n.namingClient == nil {
332 | 		logger.Error().Msg("[go-doudou] nacos discovery client has not been initialized")
333 | 		return ""
334 | 	}
335 | 	instance, err := n.namingClient.SelectOneHealthyInstance(vo.SelectOneHealthInstanceParam{
336 | 		Clusters:    n.clusters,
337 | 		ServiceName: n.serviceName,
338 | 		GroupName:   n.groupName,
339 | 	})
340 | 	if err != nil {
341 | 		logger.Error().Err(err).Msgf("[go-doudou] %s server not found", n.serviceName)
342 | 		return ""
343 | 	}
344 | 	return fmt.Sprintf("http://%s:%d%s", instance.Ip, instance.Port, instance.Metadata["rootPath"])
345 | }
346 | 
347 | func (n *WRRServiceProvider) Close() {
348 | }
349 | 
350 | // NewWRRServiceProvider creates new ServiceProvider instance
351 | func NewWRRServiceProvider(serviceName string, opts ...NacosProviderOption) *WRRServiceProvider {
352 | 	onceNacos.Do(func() {
353 | 		InitialiseNacosNamingClient()
354 | 	})
355 | 	provider := &WRRServiceProvider{
356 | 		nacosBase{
357 | 			serviceName:  serviceName,
358 | 			namingClient: NamingClient,
359 | 		},
360 | 	}
361 | 	for _, opt := range opts {
362 | 		opt(provider)
363 | 	}
364 | 	return provider
365 | }
366 | 
367 | type NacosConfig struct {
368 | 	ServiceName string
369 | 	Clusters    []string
370 | 	GroupName   string
371 | }
372 | 
373 | func NewWRRGrpcClientConn(config NacosConfig, dialOptions ...grpc.DialOption) *grpc.ClientConn {
374 | 	return NewGrpcClientConn(config, "nacos_weight_balancer", dialOptions...)
375 | }
376 | 
377 | func NewRRGrpcClientConn(config NacosConfig, dialOptions ...grpc.DialOption) *grpc.ClientConn {
378 | 	return NewGrpcClientConn(config, "round_robin", dialOptions...)
379 | }
380 | 
381 | func NewGrpcClientConn(config NacosConfig, lb string, dialOptions ...grpc.DialOption) *grpc.ClientConn {
382 | 	onceNacos.Do(func() {
383 | 		InitialiseNacosNamingClient()
384 | 	})
385 | 	grpc_resolver_nacos.AddNacosConfig(grpc_resolver_nacos.NacosConfig{
386 | 		Label:       config.ServiceName,
387 | 		ServiceName: config.ServiceName,
388 | 		Clusters:    config.Clusters,
389 | 		GroupName:   config.GroupName,
390 | 		NacosClient: NamingClient,
391 | 	})
392 | 	serverAddr := fmt.Sprintf("nacos://%s/", config.ServiceName)
393 | 	dialOptions = append(dialOptions, grpc.WithBlock(), grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy": "`+lb+`"}`))
394 | 	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
395 | 	defer cancel()
396 | 	grpcConn, err := grpc.DialContext(ctx, serverAddr, dialOptions...)
397 | 	if err != nil {
398 | 		logger.Panic().Err(err).Msgf("[go-doudou] failed to connect to server %s", serverAddr)
399 | 	}
400 | 	return grpcConn
401 | }
```

framework/registry/nacos/node_test.go
```
1 | package nacos_test
2 | 
3 | import (
4 | 	"fmt"
5 | 	"testing"
6 | 
7 | 	"github.com/golang/mock/gomock"
8 | 	"github.com/pkg/errors"
9 | 	. "github.com/smartystreets/goconvey/convey"
10 | 	"github.com/stretchr/testify/require"
11 | 	"github.com/unionj-cloud/go-doudou/v2/framework/buildinfo"
12 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
13 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/nacos"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/nacos/mock"
15 | 	"github.com/wubin1989/nacos-sdk-go/v2/clients/naming_client"
16 | 	"github.com/wubin1989/nacos-sdk-go/v2/model"
17 | 	"github.com/wubin1989/nacos-sdk-go/v2/vo"
18 | )
19 | 
20 | func setup() {
21 | 	_ = config.GddServiceName.Write("seed")
22 | 	_ = config.GddLogLevel.Write("debug")
23 | 	_ = config.GddPort.Write("8088")
24 | 	_ = config.GddRouteRootPath.Write("/v1")
25 | 	_ = config.GddNacosServerAddr.Write("http://localhost:8848")
26 | 	_ = config.GddWeight.Write("5")
27 | }
28 | 
29 | func TestNewRest(t *testing.T) {
30 | 	Convey("Should not have error", t, func() {
31 | 		setup()
32 | 		_ = config.GddNacosRegisterHost.Write("seed")
33 | 		ctrl := gomock.NewController(t)
34 | 		defer ctrl.Finish()
35 | 
36 | 		buildinfo.BuildTime = "Mon Jan 2 15:04:05 MST 2006"
37 | 		namingClient := mock.NewMockINamingClient(ctrl)
38 | 		namingClient.
39 | 			EXPECT().
40 | 			RegisterInstance(gomock.Any()).
41 | 			AnyTimes().
42 | 			Return(true, nil)
43 | 
44 | 		namingClient.
45 | 			EXPECT().
46 | 			DeregisterInstance(gomock.Any()).
47 | 			AnyTimes().
48 | 			Return(true, nil)
49 | 
50 | 		nacos.NewNamingClient = func(param vo.NacosClientParam) (iClient naming_client.INamingClient, err error) {
51 | 			return namingClient, nil
52 | 		}
53 | 
54 | 		if nacos.NamingClient == nil {
55 | 			nacos.NamingClient = namingClient
56 | 		}
57 | 
58 | 		So(func() {
59 | 			nacos.NewRest(map[string]interface{}{
60 | 				"foo": "bar",
61 | 			})
62 | 		}, ShouldNotPanic)
63 | 
64 | 		nacos.ShutdownRest()
65 | 	})
66 | }
67 | 
68 | func TestNewRest2(t *testing.T) {
69 | 	Convey("Should not have error", t, func() {
70 | 		setup()
71 | 		ctrl := gomock.NewController(t)
72 | 		defer ctrl.Finish()
73 | 
74 | 		buildinfo.BuildTime = "Mon Jan 2 15:04:05 MST 2006"
75 | 		namingClient := mock.NewMockINamingClient(ctrl)
76 | 		namingClient.
77 | 			EXPECT().
78 | 			RegisterInstance(gomock.Any()).
79 | 			AnyTimes().
80 | 			Return(true, nil)
81 | 
82 | 		namingClient.
83 | 			EXPECT().
84 | 			DeregisterInstance(gomock.Any()).
85 | 			AnyTimes().
86 | 			Return(true, nil)
87 | 
88 | 		nacos.NewNamingClient = func(param vo.NacosClientParam) (iClient naming_client.INamingClient, err error) {
89 | 			return namingClient, nil
90 | 		}
91 | 
92 | 		if nacos.NamingClient == nil {
93 | 			nacos.NamingClient = namingClient
94 | 		}
95 | 
96 | 		_ = config.GddNacosRegisterHost.Write("")
97 | 
98 | 		So(func() {
99 | 			nacos.NewRest(map[string]interface{}{
100 | 				"foo": "bar",
101 | 			})
102 | 		}, ShouldNotPanic)
103 | 
104 | 		nacos.ShutdownRest()
105 | 
106 | 	})
107 | }
108 | 
109 | func TestShutdownRestFail(t *testing.T) {
110 | 	Convey("Should fail", t, func() {
111 | 		setup()
112 | 		ctrl := gomock.NewController(t)
113 | 		defer ctrl.Finish()
114 | 
115 | 		buildinfo.BuildTime = "Mon Jan 2 15:04:05 MST 2006"
116 | 		namingClient := mock.NewMockINamingClient(ctrl)
117 | 		namingClient.
118 | 			EXPECT().
119 | 			RegisterInstance(gomock.Any()).
120 | 			AnyTimes().
121 | 			Return(true, nil)
122 | 
123 | 		namingClient.
124 | 			EXPECT().
125 | 			DeregisterInstance(gomock.Any()).
126 | 			AnyTimes().
127 | 			Return(false, errors.New("mock test error"))
128 | 
129 | 		nacos.NewNamingClient = func(param vo.NacosClientParam) (iClient naming_client.INamingClient, err error) {
130 | 			return namingClient, nil
131 | 		}
132 | 
133 | 		if nacos.NamingClient == nil {
134 | 			nacos.NamingClient = namingClient
135 | 		}
136 | 
137 | 		_ = config.GddNacosRegisterHost.Write("")
138 | 
139 | 		So(func() {
140 | 			nacos.NewRest(map[string]interface{}{
141 | 				"foo": "bar",
142 | 			})
143 | 		}, ShouldNotPanic)
144 | 
145 | 		nacos.ShutdownRest()
146 | 
147 | 	})
148 | }
149 | 
150 | func TestShutdownRestFail2(t *testing.T) {
151 | 	Convey("Should fail", t, func() {
152 | 		setup()
153 | 		ctrl := gomock.NewController(t)
154 | 		defer ctrl.Finish()
155 | 
156 | 		buildinfo.BuildTime = "Mon Jan 2 15:04:05 MST 2006"
157 | 		namingClient := mock.NewMockINamingClient(ctrl)
158 | 		namingClient.
159 | 			EXPECT().
160 | 			RegisterInstance(gomock.Any()).
161 | 			AnyTimes().
162 | 			Return(true, nil)
163 | 
164 | 		namingClient.
165 | 			EXPECT().
166 | 			DeregisterInstance(gomock.Any()).
167 | 			AnyTimes().
168 | 			Return(false, nil)
169 | 
170 | 		nacos.NewNamingClient = func(param vo.NacosClientParam) (iClient naming_client.INamingClient, err error) {
171 | 			return namingClient, nil
172 | 		}
173 | 
174 | 		if nacos.NamingClient == nil {
175 | 			nacos.NamingClient = namingClient
176 | 		}
177 | 
178 | 		_ = config.GddNacosRegisterHost.Write("")
179 | 
180 | 		So(func() {
181 | 			nacos.NewRest(map[string]interface{}{
182 | 				"foo": "bar",
183 | 			})
184 | 		}, ShouldNotPanic)
185 | 
186 | 		nacos.ShutdownRest()
187 | 	})
188 | }
189 | 
190 | var services = model.Service{
191 | 	Name:        "DEFAULT_GROUP@@DEMO",
192 | 	CacheMillis: 1000,
193 | 	Hosts: []model.Instance{
194 | 		{
195 | 			InstanceId: "10.10.10.10-80-a-DEMO",
196 | 			Port:       80,
197 | 			Ip:         "10.10.10.10",
198 | 			Weight:     10,
199 | 			Metadata: map[string]string{
200 | 				"rootPath": "/api",
201 | 			},
202 | 			ClusterName: "a",
203 | 			ServiceName: "DEMO",
204 | 			Enable:      true,
205 | 			Healthy:     true,
206 | 		},
207 | 		{
208 | 			InstanceId:  "10.10.10.11-80-a-DEMO",
209 | 			Port:        80,
210 | 			Ip:          "10.10.10.11",
211 | 			Weight:      9,
212 | 			Metadata:    map[string]string{},
213 | 			ClusterName: "a",
214 | 			ServiceName: "DEMO",
215 | 			Enable:      true,
216 | 			Healthy:     true,
217 | 		},
218 | 		{
219 | 			InstanceId:  "10.10.10.12-80-a-DEMO",
220 | 			Port:        80,
221 | 			Ip:          "10.10.10.12",
222 | 			Weight:      8,
223 | 			Metadata:    map[string]string{},
224 | 			ClusterName: "a",
225 | 			ServiceName: "DEMO",
226 | 			Enable:      true,
227 | 			Healthy:     false,
228 | 		},
229 | 		{
230 | 			InstanceId:  "10.10.10.13-80-a-DEMO",
231 | 			Port:        80,
232 | 			Ip:          "10.10.10.13",
233 | 			Weight:      7,
234 | 			Metadata:    map[string]string{},
235 | 			ClusterName: "a",
236 | 			ServiceName: "DEMO",
237 | 			Enable:      false,
238 | 			Healthy:     true,
239 | 		},
240 | 		{
241 | 			InstanceId:  "10.10.10.14-80-a-DEMO",
242 | 			Port:        80,
243 | 			Ip:          "10.10.10.14",
244 | 			Weight:      6,
245 | 			Metadata:    map[string]string{},
246 | 			ClusterName: "a",
247 | 			ServiceName: "DEMO",
248 | 			Enable:      true,
249 | 			Healthy:     true,
250 | 		},
251 | 	},
252 | 	Checksum:    "3bbcf6dd1175203a8afdade0e77a27cd1528787794594",
253 | 	LastRefTime: 1528787794594,
254 | 	Clusters:    "a",
255 | }
256 | 
257 | func TestNacosRRServiceProvider_SelectServer(t *testing.T) {
258 | 	ctrl := gomock.NewController(t)
259 | 	defer ctrl.Finish()
260 | 
261 | 	namingClient := mock.NewMockINamingClient(ctrl)
262 | 	namingClient.
263 | 		EXPECT().
264 | 		SelectInstances(vo.SelectInstancesParam{
265 | 			Clusters:    []string{"a"},
266 | 			ServiceName: "testsvc",
267 | 			HealthyOnly: true,
268 | 		}).
269 | 		AnyTimes().
270 | 		Return(services.Hosts, nil)
271 | 
272 | 	n := nacos.NewRRServiceProvider("testsvc",
273 | 		nacos.WithNacosNamingClient(namingClient),
274 | 		nacos.WithNacosClusters([]string{"a"}))
275 | 	for i := 0; i < len(services.Hosts)*2; i++ {
276 | 		got := n.SelectServer()
277 | 		fmt.Println(got)
278 | 	}
279 | }
280 | 
281 | func TestNacosWRRServiceProvider_SelectServer(t *testing.T) {
282 | 	ctrl := gomock.NewController(t)
283 | 	defer ctrl.Finish()
284 | 
285 | 	namingClient := mock.NewMockINamingClient(ctrl)
286 | 	namingClient.
287 | 		EXPECT().
288 | 		SelectOneHealthyInstance(vo.SelectOneHealthInstanceParam{
289 | 			Clusters:    []string{"a"},
290 | 			ServiceName: "testsvc",
291 | 		}).
292 | 		AnyTimes().
293 | 		Return(&services.Hosts[0], nil)
294 | 
295 | 	n := nacos.NewWRRServiceProvider("testsvc",
296 | 		nacos.WithNacosNamingClient(namingClient),
297 | 		nacos.WithNacosClusters([]string{"a"}))
298 | 	got := n.SelectServer()
299 | 	require.Equal(t, got, "http://10.10.10.10:80/api")
300 | }
```

framework/registry/pipe/node.go
```
1 | package pipe
2 | 
3 | import (
4 | 	"context"
5 | 	"net"
6 | 	"time"
7 | 
8 | 	"github.com/unionj-cloud/toolkit/pipeconn"
9 | 	"github.com/unionj-cloud/toolkit/zlogger"
10 | 	"google.golang.org/grpc"
11 | 	"google.golang.org/grpc/credentials/insecure"
12 | )
13 | 
14 | func NewGrpcClientConn(dialCtx pipeconn.DialContextFunc) *grpc.ClientConn {
15 | 	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
16 | 	defer cancel()
17 | 	grpcConn, err := grpc.DialContext(ctx, "pipe",
18 | 		grpc.WithTransportCredentials(insecure.NewCredentials()),
19 | 		grpc.WithContextDialer(func(c context.Context, _ string) (net.Conn, error) {
20 | 			return dialCtx(c)
21 | 		}),
22 | 	)
23 | 	if err != nil {
24 | 		zlogger.Panic().Err(err).Msgf("[go-doudou] failed to connect to pipe")
25 | 	}
26 | 	return grpcConn
27 | }
```

framework/registry/serversets/endpoint.go
```
1 | package serversets
2 | 
3 | import (
4 | 	"fmt"
5 | 	"net/url"
6 | 	"strconv"
7 | 	"sync"
8 | 	"time"
9 | 
10 | 	"github.com/bytedance/sonic"
11 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
12 | 	"github.com/unionj-cloud/toolkit/cast"
13 | 
14 | 	"github.com/go-zookeeper/zk"
15 | )
16 | 
17 | var json = sonic.ConfigDefault
18 | 
19 | // An Endpoint is a service (host and port) registered on Zookeeper
20 | // to be discovered by clients/watchers.
21 | type Endpoint struct {
22 | 	*ServerSet
23 | 	PingRate   time.Duration // default/initial is 1 second
24 | 	CloseEvent chan struct{}
25 | 
26 | 	done chan struct{}
27 | 	wg   sync.WaitGroup
28 | 
29 | 	host string
30 | 	port int
31 | 
32 | 	key   string
33 | 	ping  func() error
34 | 	alive bool
35 | }
36 | 
37 | // RegisterEndpoint registers a host and port as alive. It creates the appropriate
38 | // Zookeeper nodes and watchers will be notified this server/endpoint is available.
39 | func (ss *ServerSet) RegisterEndpoint(host string, port int, ping func() error) (*Endpoint, error) {
40 | 	endpoint := &Endpoint{
41 | 		ServerSet:  ss,
42 | 		PingRate:   time.Second,
43 | 		CloseEvent: make(chan struct{}, 1),
44 | 		done:       make(chan struct{}),
45 | 		host:       host,
46 | 		port:       port,
47 | 		ping:       ping,
48 | 		alive:      true,
49 | 	}
50 | 
51 | 	if ping != nil {
52 | 		endpoint.alive = endpoint.ping() == nil
53 | 	}
54 | 
55 | 	connection, sessionEvents, err := ss.connectToZookeeper()
56 | 	if err != nil {
57 | 		return nil, err
58 | 	}
59 | 
60 | 	err = endpoint.update(connection)
61 | 	if err != nil {
62 | 		return nil, err
63 | 	}
64 | 
65 | 	// spawn goroutine to deal with connection/session issues.
66 | 	endpoint.wg.Add(1)
67 | 	go func() {
68 | 		defer endpoint.wg.Done()
69 | 		for {
70 | 			select {
71 | 			case event := <-sessionEvents:
72 | 				if event.Type == zk.EventSession && event.State == zk.StateExpired {
73 | 					connection.Close()
74 | 					connection = nil
75 | 				}
76 | 			case <-endpoint.done:
77 | 				connection.Close()
78 | 				return
79 | 			}
80 | 
81 | 			if connection == nil {
82 | 				connection, sessionEvents, err = ss.connectToZookeeper()
83 | 				if err != nil {
84 | 					panic(fmt.Errorf("unable to reconnect to zookeeper after session expired: %v", err))
85 | 				}
86 | 
87 | 				err = endpoint.update(connection)
88 | 				if err != nil {
89 | 					panic(fmt.Errorf("unable to reregister endpoint after session expired: %v", err))
90 | 				}
91 | 			}
92 | 		}
93 | 	}()
94 | 
95 | 	if ping != nil {
96 | 		endpoint.wg.Add(1)
97 | 		go func() {
98 | 			defer endpoint.wg.Done()
99 | 			for {
100 | 				select {
101 | 				case <-time.After(endpoint.PingRate):
102 | 				case <-endpoint.done:
103 | 					return
104 | 				}
105 | 
106 | 				alive := endpoint.ping() == nil
107 | 				if alive != endpoint.alive {
108 | 					endpoint.alive = alive
109 | 					err := endpoint.update(connection)
110 | 
111 | 					if err != nil {
112 | 						panic(fmt.Errorf("unable to reregister after ping change: %v", err))
113 | 					}
114 | 				}
115 | 			}
116 | 		}()
117 | 	}
118 | 
119 | 	return endpoint, nil
120 | }
121 | 
122 | func (ss *ServerSet) RegisterEndpointWithMeta(host string, port int, ping func() error, meta map[string]interface{}) (*Endpoint, error) {
123 | 	endpoint := &Endpoint{
124 | 		ServerSet:  ss,
125 | 		PingRate:   time.Second,
126 | 		CloseEvent: make(chan struct{}, 1),
127 | 		done:       make(chan struct{}),
128 | 		host:       host,
129 | 		port:       port,
130 | 		ping:       ping,
131 | 		alive:      true,
132 | 	}
133 | 
134 | 	if ping != nil {
135 | 		endpoint.alive = endpoint.ping() == nil
136 | 	}
137 | 
138 | 	connection, sessionEvents, err := ss.connectToZookeeper()
139 | 	if err != nil {
140 | 		return nil, err
141 | 	}
142 | 
143 | 	err = endpoint.updateWithMeta(connection, meta)
144 | 	if err != nil {
145 | 		return nil, err
146 | 	}
147 | 
148 | 	// spawn goroutine to deal with connection/session issues.
149 | 	endpoint.wg.Add(1)
150 | 	go func() {
151 | 		defer endpoint.wg.Done()
152 | 		for {
153 | 			select {
154 | 			case event := <-sessionEvents:
155 | 				if event.Type == zk.EventSession && event.State == zk.StateExpired {
156 | 					connection.Close()
157 | 					connection = nil
158 | 				}
159 | 			case <-endpoint.done:
160 | 				connection.Close()
161 | 				return
162 | 			}
163 | 
164 | 			if connection == nil {
165 | 				connection, sessionEvents, err = ss.connectToZookeeper()
166 | 				if err != nil {
167 | 					panic(fmt.Errorf("unable to reconnect to zookeeper after session expired: %v", err))
168 | 				}
169 | 
170 | 				err = endpoint.updateWithMeta(connection, meta)
171 | 				if err != nil {
172 | 					panic(fmt.Errorf("unable to reregister endpoint after session expired: %v", err))
173 | 				}
174 | 			}
175 | 		}
176 | 	}()
177 | 
178 | 	if ping != nil {
179 | 		endpoint.wg.Add(1)
180 | 		go func() {
181 | 			defer endpoint.wg.Done()
182 | 			for {
183 | 				select {
184 | 				case <-time.After(endpoint.PingRate):
185 | 				case <-endpoint.done:
186 | 					return
187 | 				}
188 | 
189 | 				alive := endpoint.ping() == nil
190 | 				if alive != endpoint.alive {
191 | 					endpoint.alive = alive
192 | 					err := endpoint.updateWithMeta(connection, meta)
193 | 
194 | 					if err != nil {
195 | 						panic(fmt.Errorf("unable to reregister after ping change: %v", err))
196 | 					}
197 | 				}
198 | 			}
199 | 		}()
200 | 	}
201 | 
202 | 	return endpoint, nil
203 | }
204 | 
205 | // Close blocks until the client connection to Zookeeper is closed.
206 | // If already called, will simply return, even if in the process of closing.
207 | func (ep *Endpoint) Close() {
208 | 	select {
209 | 	case <-ep.done:
210 | 		return
211 | 	default:
212 | 	}
213 | 
214 | 	close(ep.done)
215 | 	ep.wg.Wait()
216 | 	ep.CloseEvent <- struct{}{}
217 | 
218 | 	return
219 | }
220 | 
221 | func (ep *Endpoint) update(connection *zk.Conn) error {
222 | 	// don't create/remove the node if we're dead
223 | 	if !ep.alive {
224 | 		if ep.key != "" {
225 | 			err := connection.Delete(ep.key, 0)
226 | 			ep.key = ""
227 | 			return err
228 | 		}
229 | 
230 | 		return nil
231 | 	}
232 | 
233 | 	entityData, _ := json.Marshal(newEntity(ep.host, ep.port))
234 | 	entityMap := make(map[string]interface{})
235 | 	json.Unmarshal(entityData, &entityMap)
236 | 
237 | 	var err error
238 | 	ep.key, err = ep.ServerSet.registerEndpoint(connection, entityMap)
239 | 
240 | 	return err
241 | }
242 | 
243 | func (ep *Endpoint) updateWithMeta(connection *zk.Conn, meta map[string]interface{}) error {
244 | 	// don't create/remove the node if we're dead
245 | 	if !ep.alive {
246 | 		if ep.key != "" {
247 | 			err := connection.Delete(ep.key, 0)
248 | 			ep.key = ""
249 | 			return err
250 | 		}
251 | 
252 | 		return nil
253 | 	}
254 | 
255 | 	entityData := newEntity(ep.host, ep.port)
256 | 	meta["serviceEndpoint"] = entityData.ServiceEndpoint
257 | 	meta["status"] = entityData.Status
258 | 
259 | 	var err error
260 | 	ep.key, err = ep.ServerSet.registerEndpoint(connection, meta)
261 | 
262 | 	return err
263 | }
264 | 
265 | func (ss *ServerSet) registerEndpoint(connection *zk.Conn, meta map[string]interface{}) (string, error) {
266 | 	err := ss.createFullPath(connection)
267 | 	if err != nil {
268 | 		return "", err
269 | 	}
270 | 	flags := zk.FlagEphemeral
271 | 	if cast.ToBoolOrDefault(config.GddZkSequence.Load(), config.DefaultGddZkSequence) {
272 | 		flags = zk.FlagEphemeral | zk.FlagSequence
273 | 	}
274 | 	querystring := url.Values{}
275 | 	if meta["group"] != nil {
276 | 		querystring.Set("group", meta["group"].(string))
277 | 	}
278 | 	if meta["version"] != nil {
279 | 		querystring.Set("version", meta["version"].(string))
280 | 	}
281 | 	if meta["weight"] != nil {
282 | 		querystring.Set("weight", strconv.Itoa(meta["weight"].(int)))
283 | 	}
284 | 	if meta["rootPath"] != nil {
285 | 		querystring.Set("rootPath", meta["rootPath"].(string))
286 | 	}
287 | 	if meta["serviceEndpoint"] != nil {
288 | 		serviceEndpoint := meta["serviceEndpoint"].(endpoint)
289 | 		if meta["host"] == nil {
290 | 			meta["host"] = serviceEndpoint.Host
291 | 		}
292 | 		if meta["port"] == nil {
293 | 			meta["port"] = serviceEndpoint.Port
294 | 		}
295 | 	}
296 | 	memberPath := url.QueryEscape(fmt.Sprintf("%s://%s:%s/%s?%s", meta["scheme"], meta["host"], meta["port"], meta["service"], querystring.Encode()))
297 | 	data, _ := json.Marshal(meta)
298 | 	return connection.Create(
299 | 		ss.directoryPath()+"/"+memberPath,
300 | 		data,
301 | 		int32(flags),
302 | 		zk.WorldACL(zk.PermAll))
303 | }
```

framework/registry/serversets/endpoint_test.go
```
1 | package serversets
2 | 
3 | import (
4 | 	"errors"
5 | 	"testing"
6 | 	"time"
7 | )
8 | 
9 | func TestEndpointSameName(t *testing.T) {
10 | 	set := New(Test, "gotest", []string{TestServer})
11 | 	watch, err := set.Watch()
12 | 	if err != nil {
13 | 		panic(err)
14 | 	}
15 | 	defer watch.Close()
16 | 
17 | 	// add first endpoint
18 | 	ep1, err := set.RegisterEndpoint("localhost", 1, nil)
19 | 	if err != nil {
20 | 		t.Fatalf("registration failure: %v", err)
21 | 	}
22 | 	defer ep1.Close()
23 | 
24 | 	<-watch.Event()
25 | 
26 | 	ep2, err := set.RegisterEndpoint("localhost", 2, nil)
27 | 	if err != nil {
28 | 		t.Fatalf("registration failure: %v", err)
29 | 	}
30 | 	defer ep2.Close()
31 | 
32 | 	<-watch.Event()
33 | 
34 | 	if l := len(watch.Endpoints()); l != 2 {
35 | 		t.Errorf("should have 2 servers, got %v", watch.Endpoints())
36 | 	}
37 | }
38 | 
39 | func TestEndpointPingInitiallyUp(t *testing.T) {
40 | 	set := New(Test, "gotest", []string{TestServer})
41 | 	watch, err := set.Watch()
42 | 	if err != nil {
43 | 		panic(err)
44 | 	}
45 | 	defer watch.Close()
46 | 
47 | 	alive := false // will switch to up on first check
48 | 	pingFunction := func() error {
49 | 		alive = !alive
50 | 
51 | 		if !alive {
52 | 			return errors.New("not alive")
53 | 		}
54 | 
55 | 		return nil
56 | 	}
57 | 
58 | 	// add endpoint
59 | 	ep, err := set.RegisterEndpoint("localhost", 1, pingFunction)
60 | 	if err != nil {
61 | 		t.Fatalf("registration failure: %v", err)
62 | 	}
63 | 	defer ep.Close()
64 | 
65 | 	<-watch.Event()
66 | 
67 | 	if l := len(watch.Endpoints()); l != 1 {
68 | 		t.Errorf("should have one endpoint, got %v", watch.Endpoints())
69 | 	}
70 | 
71 | 	// in a second should ping to false
72 | 	<-watch.Event()
73 | 	if l := len(watch.Endpoints()); l != 0 {
74 | 		t.Errorf("should have zero endpoints, got %v", watch.Endpoints())
75 | 	}
76 | 
77 | 	// third ping should be true
78 | 	<-watch.Event()
79 | 	if l := len(watch.Endpoints()); l != 1 {
80 | 		t.Errorf("should have one endpoint, got %v", watch.Endpoints())
81 | 	}
82 | }
83 | 
84 | func TestEndpointPingInitiallyDown(t *testing.T) {
85 | 	set := New(Test, "gotest", []string{TestServer})
86 | 	watch, err := set.Watch()
87 | 	if err != nil {
88 | 		panic(err)
89 | 	}
90 | 	defer watch.Close()
91 | 
92 | 	alive := true // will switch to down on first check
93 | 	pingFunction := func() error {
94 | 		alive = !alive
95 | 
96 | 		if !alive {
97 | 			return errors.New("not alive")
98 | 		}
99 | 
100 | 		return nil
101 | 	}
102 | 
103 | 	// add endpoint
104 | 	ep, err := set.RegisterEndpoint("localhost", 1, pingFunction)
105 | 	if err != nil {
106 | 		t.Fatalf("registration failure: %v", err)
107 | 	}
108 | 	defer ep.Close()
109 | 
110 | 	// down so doesn't register itself
111 | 	// <-watch.Event()
112 | 
113 | 	if l := len(watch.Endpoints()); l != 0 {
114 | 		t.Errorf("should have zero endpoints, got %v", watch.Endpoints())
115 | 	}
116 | 
117 | 	// in a second should ping to true
118 | 	<-watch.Event()
119 | 	if l := len(watch.Endpoints()); l != 1 {
120 | 		t.Errorf("should have one endpoint, got %v", watch.Endpoints())
121 | 	}
122 | 
123 | 	// third ping should be false
124 | 	<-watch.Event()
125 | 	if l := len(watch.Endpoints()); l != 0 {
126 | 		t.Errorf("should have zero endpoints, got %v", watch.Endpoints())
127 | 	}
128 | }
129 | 
130 | func TestEndpointClosePingRoutine(t *testing.T) {
131 | 	set := New(Test, "gotest", []string{TestServer})
132 | 
133 | 	ping := 0
134 | 	ep, err := set.RegisterEndpoint("localhost", 1, func() error {
135 | 		ping++
136 | 		return nil
137 | 	})
138 | 
139 | 	if err != nil {
140 | 		t.Fatalf("registration failure: %v", err)
141 | 	}
142 | 
143 | 	ep.Close()
144 | 
145 | 	time.Sleep(3 * time.Second)
146 | 	if ping > 1 {
147 | 		t.Errorf("ping should be closed, called %d times", ping)
148 | 	}
149 | }
150 | 
151 | func TestEndpointMultipleClose(t *testing.T) {
152 | 	set := New(Test, "gotest", []string{TestServer})
153 | 
154 | 	ep, err := set.RegisterEndpoint("localhost", 1, nil)
155 | 	if err != nil {
156 | 		t.Fatalf("registration failure: %v", err)
157 | 	}
158 | 
159 | 	ep.Close()
160 | 	ep.Close()
161 | 	ep.Close()
162 | 	ep.Close()
163 | }
```

framework/registry/serversets/serverset.go
```
1 | package serversets
2 | 
3 | import (
4 | 	"fmt"
5 | 	"path"
6 | 	"strings"
7 | 	"time"
8 | 
9 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
10 | 
11 | 	"github.com/go-zookeeper/zk"
12 | )
13 | 
14 | var (
15 | 
16 | 	// MemberPrefix is prefix for the Zookeeper sequential ephemeral nodes.
17 | 	// member_ is used by Finagle server sets.
18 | 	MemberPrefix = "member_"
19 | )
20 | 
21 | // BaseZnodePath allows for a custom Zookeeper directory structure.
22 | // This function should return the path where you want the service's members to live.
23 | // Default is `BaseDirectory + "/" + environment + "/" + service` where the default base directory is `/discovery`
24 | // TODO decide how to make use of Environment
25 | var BaseZnodePath = func(_ Environment, service string) string {
26 | 	return fmt.Sprintf(config.GddZkDirectoryPattern.LoadOrDefault(config.DefaultGddZkDirectoryPattern), service)
27 | }
28 | 
29 | // An Environment is the test/staging/production state of the service.
30 | type Environment string
31 | 
32 | // Typically used environments
33 | const (
34 | 	Local      Environment = "local"
35 | 	Dev        Environment = "dev"
36 | 	Production Environment = "prod"
37 | 	Test       Environment = "test"
38 | 	Uat        Environment = "uat"
39 | 	Staging    Environment = "staging"
40 | )
41 | 
42 | // DefaultZKTimeout is the zookeeper timeout used if it is not overwritten.
43 | var DefaultZKTimeout = 5 * time.Second
44 | 
45 | // A ServerSet represents a service with a set of servers that may change over time.
46 | // The master lists of servers is kept as ephemeral nodes in Zookeeper.
47 | type ServerSet struct {
48 | 	ZKTimeout   time.Duration
49 | 	environment Environment
50 | 	service     string
51 | 	zkServers   []string
52 | }
53 | 
54 | // New creates a new ServerSet object that can then be watched
55 | // or have an endpoint added to. The service name must not contain
56 | // any slashes. Will panic if it does.
57 | func New(environment Environment, service string, zookeepers []string) *ServerSet {
58 | 	if strings.Contains(service, "/") {
59 | 		panic(fmt.Errorf("service name (%s) must not contain slashes", service))
60 | 	}
61 | 
62 | 	ss := &ServerSet{
63 | 		ZKTimeout: DefaultZKTimeout,
64 | 
65 | 		environment: environment,
66 | 		service:     service,
67 | 		zkServers:   zookeepers,
68 | 	}
69 | 
70 | 	return ss
71 | }
72 | 
73 | // ZookeeperServers returns the Zookeeper servers this set is using.
74 | // Useful to check if everything is configured correctly.
75 | func (ss *ServerSet) ZookeeperServers() []string {
76 | 	return ss.zkServers
77 | }
78 | 
79 | func (ss *ServerSet) connectToZookeeper() (*zk.Conn, <-chan zk.Event, error) {
80 | 	return zk.Connect(ss.zkServers, ss.ZKTimeout)
81 | }
82 | 
83 | // directoryPath returns the base path of where all the ephemeral nodes will live.
84 | func (ss *ServerSet) directoryPath() string {
85 | 	return BaseZnodePath(ss.environment, ss.service)
86 | }
87 | 
88 | func splitPaths(fullPath string) []string {
89 | 	var parts []string
90 | 
91 | 	var last string
92 | 	for fullPath != "/" {
93 | 		fullPath, last = path.Split(path.Clean(fullPath))
94 | 		parts = append(parts, last)
95 | 	}
96 | 
97 | 	// parts are in reverse order, put back together
98 | 	// into set of subdirectory paths
99 | 	result := make([]string, 0, len(parts))
100 | 	base := ""
101 | 	for i := len(parts) - 1; i >= 0; i-- {
102 | 		base += "/" + parts[i]
103 | 		result = append(result, base)
104 | 	}
105 | 
106 | 	return result
107 | }
108 | 
109 | // createFullPath makes sure all the znodes are created for the parent directories
110 | func (ss *ServerSet) createFullPath(connection *zk.Conn) error {
111 | 	paths := splitPaths(ss.directoryPath())
112 | 
113 | 	// TODO: can't we just create all? ie. mkdir -p
114 | 	for _, key := range paths {
115 | 		_, err := connection.Create(key, nil, 0, zk.WorldACL(zk.PermAll))
116 | 		if err != nil && err != zk.ErrNodeExists {
117 | 			return err
118 | 		}
119 | 	}
120 | 
121 | 	return nil
122 | }
123 | 
124 | // structure of the data in each member znode
125 | // Mimics finagle serverset structure.
126 | type entity struct {
127 | 	ServiceEndpoint endpoint `json:"serviceEndpoint"`
128 | 	Status          string   `json:"status"`
129 | }
130 | 
131 | type endpoint struct {
132 | 	Host string `json:"host"`
133 | 	Port int    `json:"port"`
134 | }
135 | 
136 | func newEntity(host string, port int) *entity {
137 | 	return &entity{
138 | 		ServiceEndpoint: endpoint{host, port},
139 | 		Status:          statusAlive,
140 | 	}
141 | }
142 | 
143 | // possible endpoint statuses. Currently only concerned with ALIVE.
144 | const (
145 | 	statusDead     = "DEAD"
146 | 	statusStarting = "STARTING"
147 | 	statusAlive    = "ALIVE"
148 | 	statusStopping = "STOPPING"
149 | 	statusStopped  = "STOPPED"
150 | 	statusWarning  = "WARNING"
151 | 	statusUnknown  = "UNKNOWN"
152 | )
```

framework/registry/serversets/serverset_test.go
```
1 | package serversets
2 | 
3 | import (
4 | 	"reflect"
5 | 	"testing"
6 | )
7 | 
8 | const TestServer = "localhost"
9 | 
10 | // This is the big run through a typical use case of add and remove and make sure it works.
11 | func TestServerSetAddAndRemove(t *testing.T) {
12 | 	set := New(Test, "gotest", []string{TestServer})
13 | 	watch, err := set.Watch()
14 | 	if err != nil {
15 | 		panic(err)
16 | 	}
17 | 
18 | 	// add first endpoint
19 | 	ep1, err := set.RegisterEndpoint("localhost", 1, nil)
20 | 	if err != nil {
21 | 		t.Fatalf("registration failure: %v", err)
22 | 	}
23 | 
24 | 	<-watch.Event()
25 | 	if !reflect.DeepEqual(watch.Endpoints(), []string{"%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D1%29%2F%25%21s%28%3Cnil%3E%29%3F"}) {
26 | 		t.Errorf("server list incorrect, got %v", watch.Endpoints())
27 | 	}
28 | 
29 | 	// add second endpoint
30 | 	ep2, err := set.RegisterEndpoint("localhost", 2, nil)
31 | 	if err != nil {
32 | 		t.Fatalf("registration failure: %v", err)
33 | 	}
34 | 
35 | 	<-watch.Event()
36 | 	if !reflect.DeepEqual(watch.Endpoints(), []string{"%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D1%29%2F%25%21s%28%3Cnil%3E%29%3F", "%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D2%29%2F%25%21s%28%3Cnil%3E%29%3F"}) {
37 | 		t.Errorf("server list incorrect, got %v", watch.Endpoints())
38 | 	}
39 | 
40 | 	// add third endpoint
41 | 	ep3, err := set.RegisterEndpoint("localhost", 3, nil)
42 | 	if err != nil {
43 | 		t.Fatalf("registration failure: %v", err)
44 | 	}
45 | 
46 | 	<-watch.Event()
47 | 	if !reflect.DeepEqual(watch.Endpoints(), []string{"%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D1%29%2F%25%21s%28%3Cnil%3E%29%3F", "%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D2%29%2F%25%21s%28%3Cnil%3E%29%3F", "%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D3%29%2F%25%21s%28%3Cnil%3E%29%3F"}) {
48 | 		t.Errorf("server list incorrect, got %v", watch.Endpoints())
49 | 	}
50 | 
51 | 	// remove second endpoint
52 | 	ep2.Close()
53 | 
54 | 	<-watch.Event()
55 | 	if !reflect.DeepEqual(watch.Endpoints(), []string{"%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D1%29%2F%25%21s%28%3Cnil%3E%29%3F", "%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D3%29%2F%25%21s%28%3Cnil%3E%29%3F"}) {
56 | 		t.Errorf("server list incorrect, got %v", watch.Endpoints())
57 | 	}
58 | 
59 | 	// add fourth endpoint
60 | 	ep4, err := set.RegisterEndpoint("localhost", 4, nil)
61 | 	if err != nil {
62 | 		t.Fatalf("registration failure: %v", err)
63 | 	}
64 | 
65 | 	<-watch.Event()
66 | 	if !reflect.DeepEqual(watch.Endpoints(), []string{"%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D1%29%2F%25%21s%28%3Cnil%3E%29%3F", "%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D3%29%2F%25%21s%28%3Cnil%3E%29%3F", "%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D4%29%2F%25%21s%28%3Cnil%3E%29%3F"}) {
67 | 		t.Errorf("server list incorrect, got %v", watch.Endpoints())
68 | 	}
69 | 
70 | 	// close and reopen watch
71 | 	if watch.EventCount != 5 {
72 | 		t.Errorf("event count incorrect, got %d", watch.EventCount)
73 | 	}
74 | 
75 | 	watch.Close()
76 | 
77 | 	watch, err = set.Watch()
78 | 	if err != nil {
79 | 		panic(err)
80 | 	}
81 | 
82 | 	if !reflect.DeepEqual(watch.Endpoints(), []string{"%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D1%29%2F%25%21s%28%3Cnil%3E%29%3F", "%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D3%29%2F%25%21s%28%3Cnil%3E%29%3F", "%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D4%29%2F%25%21s%28%3Cnil%3E%29%3F"}) {
83 | 		t.Errorf("server list incorrect, got %v", watch.Endpoints())
84 | 	}
85 | 
86 | 	// remove third endpoint
87 | 	ep3.Close()
88 | 
89 | 	<-watch.Event()
90 | 	if !reflect.DeepEqual(watch.Endpoints(), []string{"%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D1%29%2F%25%21s%28%3Cnil%3E%29%3F", "%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D4%29%2F%25%21s%28%3Cnil%3E%29%3F"}) {
91 | 		t.Errorf("server list incorrect, got %v", watch.Endpoints())
92 | 	}
93 | 
94 | 	// remove first endpoint
95 | 	ep1.Close()
96 | 
97 | 	<-watch.Event()
98 | 	if !reflect.DeepEqual(watch.Endpoints(), []string{"%25%21s%28%3Cnil%3E%29%3A%2F%2Flocalhost%3A%25%21s%28float64%3D4%29%2F%25%21s%28%3Cnil%3E%29%3F"}) {
99 | 		t.Errorf("server list incorrect, got %v", watch.Endpoints())
100 | 	}
101 | 
102 | 	// remove fourth endpoint
103 | 	ep4.Close()
104 | 
105 | 	<-watch.Event()
106 | 	if !reflect.DeepEqual(watch.Endpoints(), []string{}) {
107 | 		t.Errorf("server list incorrect, got %v", watch.Endpoints())
108 | 	}
109 | 
110 | 	if watch.EventCount != 3 {
111 | 		t.Errorf("event count incorrect, got %d", watch.EventCount)
112 | 	}
113 | 	watch.Close()
114 | }
115 | 
116 | func TestBaseZnodePath(t *testing.T) {
117 | 	// to verify nothing happens to the default
118 | 	path := BaseZnodePath(Test, "gotest")
119 | 	if path != "/registry/gotest/providers" {
120 | 		t.Errorf("baseznodepath incorrect, got %v", path)
121 | 	}
122 | }
123 | 
124 | func TestServerSetDirectoryPath(t *testing.T) {
125 | 	set := New(Test, "gotest", []string{TestServer})
126 | 	path := set.directoryPath()
127 | 
128 | 	// should just be a pass through to BaseZnodePath
129 | 	if path != BaseZnodePath(Test, "gotest") {
130 | 		t.Errorf("directory path incorrect, got %v", path)
131 | 	}
132 | }
133 | 
134 | func TestSplitPaths(t *testing.T) {
135 | 	path := "/discovery/test/gotest"
136 | 	parts := splitPaths(path)
137 | 	if !reflect.DeepEqual(parts, []string{"/discovery", "/discovery/test", "/discovery/test/gotest"}) {
138 | 		t.Errorf("split not correct, got %v", parts)
139 | 	}
140 | 
141 | 	path = "/discovery/test/"
142 | 	parts = splitPaths(path)
143 | 	if !reflect.DeepEqual(parts, []string{"/discovery", "/discovery/test"}) {
144 | 		t.Errorf("split not correct, got %v", parts)
145 | 	}
146 | 
147 | 	path = "/"
148 | 	parts = splitPaths(path)
149 | 	if !reflect.DeepEqual(parts, []string{}) {
150 | 		t.Errorf("split not correct, got %v", parts)
151 | 	}
152 | }
```

framework/registry/serversets/watch.go
```
1 | package serversets
2 | 
3 | import (
4 | 	"fmt"
5 | 	"sort"
6 | 	"sync"
7 | 	"time"
8 | 
9 | 	"github.com/pkg/errors"
10 | 	"github.com/unionj-cloud/toolkit/caller"
11 | 	"github.com/unionj-cloud/toolkit/zlogger"
12 | 
13 | 	"github.com/go-zookeeper/zk"
14 | )
15 | 
16 | const (
17 | 	// SOH control character
18 | 	SOH = "\x01"
19 | )
20 | 
21 | // A Watch keeps tabs on a server set in Zookeeper and notifies
22 | // via the Event() channel when the list of servers changes.
23 | // The list of servers is updated automatically and will be up to date when the Event is sent.
24 | type Watch struct {
25 | 	serverSet *ServerSet
26 | 
27 | 	LastEvent  time.Time
28 | 	EventCount int
29 | 	event      chan struct{}
30 | 
31 | 	done chan struct{} // used for closing
32 | 	wg   sync.WaitGroup
33 | 
34 | 	// lock for read/writing the endpoints slice
35 | 	lock      sync.RWMutex
36 | 	endpoints []string
37 | }
38 | 
39 | // Watch creates a new watch on this server set. Changes to the set will
40 | // update watch.Endpoints() and an event will be sent to watch.Event right after that happens.
41 | func (ss *ServerSet) Watch() (*Watch, error) {
42 | 	watch := &Watch{
43 | 		serverSet: ss,
44 | 		done:      make(chan struct{}),
45 | 		event:     make(chan struct{}, 1),
46 | 	}
47 | 
48 | 	connection, sessionEvents, err := ss.connectToZookeeper()
49 | 	if err != nil {
50 | 		return nil, errors.Wrap(err, caller.NewCaller().String())
51 | 	}
52 | 
53 | 	keys, watchEvents, err := watch.watch(connection)
54 | 	if err != nil {
55 | 		return nil, errors.Wrap(err, caller.NewCaller().String())
56 | 	}
57 | 
58 | 	watch.endpoints, err = watch.updateEndpoints(connection, keys)
59 | 	if err != nil {
60 | 		return nil, errors.Wrap(err, caller.NewCaller().String())
61 | 	}
62 | 
63 | 	// spawn a goroutine to deal with session disconnects and watch events
64 | 	watch.wg.Add(1)
65 | 	go func() {
66 | 		defer watch.wg.Done()
67 | 		for {
68 | 			select {
69 | 			case event := <-sessionEvents:
70 | 				if event.Type == zk.EventSession && event.State == zk.StateExpired {
71 | 					connection.Close()
72 | 					connection = nil
73 | 				}
74 | 			case <-watchEvents:
75 | 				keys, watchEvents, err = watch.watch(connection)
76 | 				if err != nil {
77 | 					panic(fmt.Errorf("unable to rewatch endpoint after znode event: %v", err))
78 | 				}
79 | 
80 | 				endpoints, err := watch.updateEndpoints(connection, keys)
81 | 				if err != nil {
82 | 					panic(fmt.Errorf("unable to updated endpoint list after znode event: %v", err))
83 | 				}
84 | 
85 | 				watch.lock.Lock()
86 | 				watch.endpoints = endpoints
87 | 				watch.lock.Unlock()
88 | 
89 | 				watch.triggerEvent()
90 | 
91 | 			case <-watch.done:
92 | 				connection.Close()
93 | 				return
94 | 			}
95 | 
96 | 			if connection == nil {
97 | 				connection, sessionEvents, err = ss.connectToZookeeper()
98 | 				if err != nil {
99 | 					panic(fmt.Errorf("unable to reconnect to zookeeper after session expired: %v", err))
100 | 				}
101 | 
102 | 				keys, watchEvents, err = watch.watch(connection)
103 | 				if err != nil {
104 | 					panic(fmt.Errorf("unable to reregister endpoint after session expired: %v", err))
105 | 				}
106 | 
107 | 				watch.endpoints, err = watch.updateEndpoints(connection, keys)
108 | 				if err != nil {
109 | 					panic(fmt.Errorf("unable to update endpoint list after session expired: %v", err))
110 | 				}
111 | 
112 | 				watch.triggerEvent()
113 | 			}
114 | 		}
115 | 	}()
116 | 
117 | 	return watch, nil
118 | }
119 | 
120 | // Endpoints returns a slice of the current list of servers/endpoints associated with this watch.
121 | func (w *Watch) Endpoints() []string {
122 | 	w.lock.RLock()
123 | 	defer w.lock.RUnlock()
124 | 
125 | 	return w.endpoints
126 | }
127 | 
128 | // Event returns the event channel. This channel will get an object
129 | // whenever something changes with the list of endpoints.
130 | func (w *Watch) Event() <-chan struct{} {
131 | 	return w.event
132 | }
133 | 
134 | // Close blocks until the underlying Zookeeper connection is closed.
135 | func (w *Watch) Close() {
136 | 	select {
137 | 	case <-w.done:
138 | 		w.wg.Wait()
139 | 		return
140 | 	default:
141 | 	}
142 | 
143 | 	close(w.done)
144 | 	w.wg.Wait()
145 | 
146 | 	// the goroutine watching for events must be terminated
147 | 	// before we close this channel, since it might still be sending events.
148 | 	close(w.event)
149 | 	return
150 | }
151 | 
152 | // IsClosed returns if this watch has been closed. This is a way for libraries wrapping
153 | // this package to know if their underlying watch is closed and should stop looking for events.
154 | func (w *Watch) IsClosed() bool {
155 | 	select {
156 | 	case <-w.done:
157 | 		return true
158 | 	default:
159 | 	}
160 | 
161 | 	return false
162 | }
163 | 
164 | // watch creates the actual Zookeeper watch.
165 | func (w *Watch) watch(connection *zk.Conn) ([]string, <-chan zk.Event, error) {
166 | 	err := w.serverSet.createFullPath(connection)
167 | 	if err != nil {
168 | 		return nil, nil, err
169 | 	}
170 | 
171 | 	children, _, events, err := connection.ChildrenW(w.serverSet.directoryPath())
172 | 	return children, events, err
173 | }
174 | 
175 | func (w *Watch) updateEndpoints(connection *zk.Conn, keys []string) ([]string, error) {
176 | 	endpoints := make([]string, 0, len(keys))
177 | 
178 | 	for _, k := range keys {
179 | 		e, err := w.getEndpoint(connection, k)
180 | 		if err != nil {
181 | 			return nil, errors.Wrap(err, caller.NewCaller().String())
182 | 		}
183 | 		if e == nil {
184 | 			continue
185 | 		}
186 | 		endpoints = append(endpoints, k)
187 | 	}
188 | 
189 | 	sort.Strings(endpoints)
190 | 	return endpoints, nil
191 | 
192 | }
193 | 
194 | func (w *Watch) getEndpoint(connection *zk.Conn, key string) (map[string]interface{}, error) {
195 | 
196 | 	data, _, err := connection.Get(w.serverSet.directoryPath() + "/" + key)
197 | 	if err == zk.ErrNoNode {
198 | 		return nil, nil
199 | 	}
200 | 
201 | 	if err != nil {
202 | 		// most likely some sort of zk connection error
203 | 		return nil, errors.Wrap(err, caller.NewCaller().String())
204 | 	}
205 | 
206 | 	// Found this SOH check while browsing the docker/libkv source
207 | 	// https://github.com/docker/libkv/commit/035e8143a336ceb29760c07278ef930f49767377
208 | 
209 | 	// FIXME handle very rare cases where Get returns the
210 | 	// SOH control character instead of the actual value
211 | 	if string(data) == SOH {
212 | 		return w.getEndpoint(connection, key)
213 | 	}
214 | 
215 | 	e := make(map[string]interface{})
216 | 	if len(data) == 0 {
217 | 		return e, nil
218 | 	}
219 | 	err = json.Unmarshal(data, &e)
220 | 	if err != nil {
221 | 		zlogger.Warn().Err(errors.Wrap(err, caller.NewCaller().String())).Msgf("Parse znode json data error")
222 | 	}
223 | 	return e, nil
224 | }
225 | 
226 | // triggerEvent will queue up something in the Event channel if there isn't already something there.
227 | func (w *Watch) triggerEvent() {
228 | 	w.EventCount++
229 | 	w.LastEvent = time.Now()
230 | 
231 | 	select {
232 | 	case w.event <- struct{}{}:
233 | 	default:
234 | 	}
235 | }
```

framework/registry/serversets/watch_test.go
```
1 | package serversets
2 | 
3 | import (
4 | 	"sort"
5 | 	"testing"
6 | )
7 | 
8 | func TestWatchSortEndpoints(t *testing.T) {
9 | 	set := New(Test, "gotest", []string{TestServer})
10 | 
11 | 	watch, err := set.Watch()
12 | 	if err != nil {
13 | 		t.Fatal(err)
14 | 	}
15 | 	defer watch.Close()
16 | 
17 | 	ep1, err := set.RegisterEndpoint("localhost", 1002, nil)
18 | 	if err != nil {
19 | 		t.Fatal(err)
20 | 	}
21 | 	defer ep1.Close()
22 | 	<-watch.Event()
23 | 
24 | 	ep2, err := set.RegisterEndpoint("localhost", 1001, nil)
25 | 	if err != nil {
26 | 		t.Fatal(err)
27 | 	}
28 | 	defer ep2.Close()
29 | 	<-watch.Event()
30 | 
31 | 	ep3, err := set.RegisterEndpoint("localhost", 1003, nil)
32 | 	if err != nil {
33 | 		t.Fatal(err)
34 | 	}
35 | 	defer ep3.Close()
36 | 	<-watch.Event()
37 | 
38 | 	endpoints := watch.Endpoints()
39 | 	if len(endpoints) != 3 {
40 | 		t.Errorf("should have 3 endpoint, got %v", endpoints)
41 | 	}
42 | 
43 | 	if !sort.StringsAreSorted(endpoints) {
44 | 		t.Errorf("endpoint list should be sorted, got %v", endpoints)
45 | 	}
46 | }
47 | 
48 | func TestWatchUpdateEndpoints(t *testing.T) {
49 | 	set := New(Test, "gotest", []string{TestServer})
50 | 
51 | 	watch, err := set.Watch()
52 | 	if err != nil {
53 | 		t.Fatal(err)
54 | 	}
55 | 	defer watch.Close()
56 | 
57 | 	ep1, err := set.RegisterEndpoint("localhost", 1002, nil)
58 | 	if err != nil {
59 | 		t.Fatal(err)
60 | 	}
61 | 	defer ep1.Close()
62 | 	<-watch.Event()
63 | 
64 | 	conn, _, err := set.connectToZookeeper()
65 | 	if err != nil {
66 | 		t.Fatal(err)
67 | 	}
68 | 	defer conn.Close()
69 | 
70 | 	eps, err := watch.updateEndpoints(conn, []string{MemberPrefix + "random"})
71 | 	if err != nil {
72 | 		t.Fatalf("should not have error, got %v", err)
73 | 	}
74 | 
75 | 	if len(eps) != 0 {
76 | 		t.Errorf("should not have any endpoints, got %v", eps)
77 | 	}
78 | }
79 | 
80 | func TestWatchIsClosed(t *testing.T) {
81 | 	set := New(Test, "gotest", []string{TestServer})
82 | 	watch, err := set.Watch()
83 | 	if err != nil {
84 | 		t.Fatal(err)
85 | 	}
86 | 
87 | 	watch.Close()
88 | 
89 | 	if watch.IsClosed() == false {
90 | 		t.Error("should say it's closed right after we close it")
91 | 	}
92 | }
93 | 
94 | func TestWatchMultipleClose(t *testing.T) {
95 | 	set := New(Test, "gotest", []string{TestServer})
96 | 	watch, err := set.Watch()
97 | 	if err != nil {
98 | 		t.Fatal(err)
99 | 	}
100 | 
101 | 	watch.Close()
102 | 	watch.Close()
103 | 	watch.Close()
104 | }
105 | 
106 | func TestWatchTriggerEvent(t *testing.T) {
107 | 	set := New(Test, "gotest", []string{TestServer})
108 | 	watch, err := set.Watch()
109 | 	if err != nil {
110 | 		t.Fatal(err)
111 | 	}
112 | 	defer watch.Close()
113 | 
114 | 	watch.triggerEvent()
115 | 	watch.triggerEvent()
116 | 	watch.triggerEvent()
117 | 	watch.triggerEvent()
118 | }
```

framework/registry/utils/utils.go
```
1 | package utils
2 | 
3 | import (
4 | 	"github.com/hashicorp/go-sockaddr"
5 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
6 | 	"github.com/unionj-cloud/toolkit/stringutils"
7 | 	"github.com/unionj-cloud/toolkit/zlogger"
8 | )
9 | 
10 | var GetPrivateIP = sockaddr.GetPrivateIP
11 | 
12 | func GetRegisterHost() string {
13 | 	registerHost := config.DefaultGddRegisterHost
14 | 	if stringutils.IsNotEmpty(config.GddRegisterHost.Load()) {
15 | 		registerHost = config.GddRegisterHost.Load()
16 | 	}
17 | 	if stringutils.IsEmpty(registerHost) {
18 | 		var err error
19 | 		registerHost, err = GetPrivateIP()
20 | 		if err != nil {
21 | 			zlogger.Panic().Err(err).Msg("[go-doudou] failed to get interface addresses")
22 | 		}
23 | 		if stringutils.IsEmpty(registerHost) {
24 | 			zlogger.Panic().Msg("[go-doudou] no private IP address found, and explicit IP not provided")
25 | 		}
26 | 	}
27 | 	return registerHost
28 | }
```

framework/registry/zk/node.go
```
1 | package zk
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"net/url"
7 | 	"os"
8 | 	"runtime"
9 | 	"sort"
10 | 	"strconv"
11 | 	"strings"
12 | 	"sync"
13 | 	"sync/atomic"
14 | 	"time"
15 | 
16 | 	"github.com/unionj-cloud/go-doudou/v2/framework/buildinfo"
17 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/grpcx/grpc_resolver_zk"
19 | 	cons "github.com/unionj-cloud/go-doudou/v2/framework/registry/constants"
20 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/interfaces"
21 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/serversets"
22 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry/utils"
23 | 	"github.com/unionj-cloud/toolkit/cast"
24 | 	"github.com/unionj-cloud/toolkit/constants"
25 | 	"github.com/unionj-cloud/toolkit/errorx"
26 | 	"github.com/unionj-cloud/toolkit/stringutils"
27 | 	"github.com/unionj-cloud/toolkit/zlogger"
28 | 	"google.golang.org/grpc"
29 | )
30 | 
31 | var restEndpoint *serversets.Endpoint
32 | var grpcEndpoint *serversets.Endpoint
33 | var providers = map[string]interfaces.IServiceProvider{}
34 | 
35 | func newServerSet(service string) *serversets.ServerSet {
36 | 	zkServers := config.GddZkServers.LoadOrDefault(config.DefaultGddZkServers)
37 | 	if stringutils.IsEmpty(zkServers) {
38 | 		zlogger.Panic().Msg("[go-doudou] env GDD_ZK_SERVERS is not set")
39 | 	}
40 | 	zookeepers := strings.Split(zkServers, ",")
41 | 	environment := os.Getenv("GDD_ENV")
42 | 	if stringutils.IsEmpty(environment) {
43 | 		environment = "dev"
44 | 	}
45 | 	return serversets.New(serversets.Environment(environment), service, zookeepers)
46 | }
47 | 
48 | func registerService(service string, port uint64, scheme string, userData ...map[string]interface{}) *serversets.Endpoint {
49 | 	host := utils.GetRegisterHost()
50 | 	metadata := make(map[string]interface{})
51 | 	metadata["scheme"] = scheme
52 | 	metadata["host"] = host
53 | 	metadata["port"] = strconv.Itoa(int(port))
54 | 	metadata["service"] = service
55 | 	populateMeta(metadata, userData...)
56 | 	serverSet := newServerSet(service)
57 | 	endpoint, err := serverSet.RegisterEndpointWithMeta(
58 | 		host,
59 | 		int(port),
60 | 		nil,
61 | 		metadata)
62 | 	if err != nil {
63 | 		zlogger.Panic().Err(err).Msgf("[go-doudou] register %s to zookeeper failed", service)
64 | 	}
65 | 	return endpoint
66 | }
67 | 
68 | func populateMeta(meta map[string]interface{}, userData ...map[string]interface{}) {
69 | 	buildTime := buildinfo.BuildTime
70 | 	if stringutils.IsNotEmpty(buildinfo.BuildTime) {
71 | 		if t, err := time.Parse(constants.FORMAT15, buildinfo.BuildTime); err == nil {
72 | 			buildTime = t.Local().Format(constants.FORMAT8)
73 | 		}
74 | 	}
75 | 	weight := config.DefaultGddWeight
76 | 	if stringutils.IsNotEmpty(config.GddWeight.Load()) {
77 | 		if w, err := cast.ToIntE(config.GddWeight.Load()); err == nil {
78 | 			weight = w
79 | 		}
80 | 	}
81 | 	group := config.GddServiceGroup.LoadOrDefault(config.DefaultGddServiceGroup)
82 | 	version := config.GddServiceVersion.LoadOrDefault(config.DefaultGddServiceVersion)
83 | 	meta["group"] = group
84 | 	meta["version"] = version
85 | 	meta["registerAt"] = time.Now().Local().Format(constants.FORMAT8)
86 | 	meta["goVer"] = runtime.Version()
87 | 	meta["weight"] = weight
88 | 	if stringutils.IsNotEmpty(buildinfo.GddVer) {
89 | 		meta["gddVer"] = buildinfo.GddVer
90 | 	}
91 | 	if stringutils.IsNotEmpty(buildinfo.BuildUser) {
92 | 		meta["buildUser"] = buildinfo.BuildUser
93 | 	}
94 | 	if stringutils.IsNotEmpty(buildTime) {
95 | 		meta["buildTime"] = buildTime
96 | 	}
97 | 	meta["rootPath"] = config.GddRouteRootPath.LoadOrDefault(config.DefaultGddRouteRootPath)
98 | 	for _, item := range userData {
99 | 		for k, v := range item {
100 | 			meta[k] = fmt.Sprint(v)
101 | 		}
102 | 	}
103 | }
104 | 
105 | func NewRest(data ...map[string]interface{}) {
106 | 	service := config.GetServiceName() + "_" + string(cons.REST_TYPE)
107 | 	httpPort := config.GetPort()
108 | 	restEndpoint = registerService(service, httpPort, "http", data...)
109 | 	zlogger.Info().Msgf("[go-doudou] %s registered to zookeeper successfully", service)
110 | }
111 | 
112 | func NewGrpc(data ...map[string]interface{}) {
113 | 	service := config.GetServiceName() + "_" + string(cons.GRPC_TYPE)
114 | 	grpcPort := config.GetGrpcPort()
115 | 	grpcEndpoint = registerService(service, grpcPort, "grpc", data...)
116 | 	zlogger.Info().Msgf("[go-doudou] %s registered to zookeeper successfully", service)
117 | }
118 | 
119 | func ShutdownRest() {
120 | 	if restEndpoint != nil {
121 | 		service := config.GetServiceName() + "_" + string(cons.REST_TYPE)
122 | 		restEndpoint.Close()
123 | 		zlogger.Info().Msgf("[go-doudou] deregistered %s from zookeeper successfully", service)
124 | 	}
125 | }
126 | 
127 | func ShutdownGrpc() {
128 | 	if grpcEndpoint != nil {
129 | 		service := config.GetServiceName() + "_" + string(cons.GRPC_TYPE)
130 | 		grpcEndpoint.Close()
131 | 		zlogger.Info().Msgf("[go-doudou] deregistered %s from zookeeper successfully", service)
132 | 	}
133 | }
134 | 
135 | // A Watcher represents how a serverset.Watch is used so it can be stubbed out for tests.
136 | type Watcher interface {
137 | 	Endpoints() []string
138 | 	Event() <-chan struct{}
139 | 	IsClosed() bool
140 | 	Close()
141 | }
142 | 
143 | // RRServiceProvider is a simple round-robin load balance implementation for IServiceProvider
144 | type RRServiceProvider struct {
145 | 	current  uint64
146 | 	lock     sync.Mutex
147 | 	watcher  Watcher
148 | 	target   ServiceConfig
149 | 	curState atomic.Value
150 | }
151 | 
152 | type address struct {
153 | 	addr          string
154 | 	rootPath      string
155 | 	weight        int
156 | 	currentWeight int
157 | }
158 | 
159 | type state struct {
160 | 	addresses []*address
161 | }
162 | 
163 | func (r *RRServiceProvider) updateState() {
164 | 	addrs := r.convertToAddress(r.watcher.Endpoints())
165 | 	r.curState.Store(state{addresses: addrs})
166 | }
167 | 
168 | func (r *RRServiceProvider) watch() {
169 | 	r.updateState()
170 | 	for {
171 | 		select {
172 | 		case _, ok := <-r.watcher.Event():
173 | 			if !ok {
174 | 				return
175 | 			}
176 | 			r.updateState()
177 | 		}
178 | 
179 | 		if r.watcher.IsClosed() {
180 | 			return
181 | 		}
182 | 	}
183 | }
184 | 
185 | func (r *RRServiceProvider) convertToAddress(ups []string) (addrs []*address) {
186 | 	for _, up := range ups {
187 | 		unescaped, _ := url.QueryUnescape(up)
188 | 		u, _ := url.Parse(unescaped)
189 | 		weight := cast.ToIntOrDefault(u.Query().Get("weight"), 1)
190 | 		rootPath := u.Query().Get("rootPath")
191 | 		group := u.Query().Get("group")
192 | 		version := u.Query().Get("version")
193 | 		if group != r.target.Group || version != r.target.Version {
194 | 			continue
195 | 		}
196 | 		addr := &address{
197 | 			addr:     u.Host,
198 | 			rootPath: rootPath,
199 | 			weight:   weight,
200 | 		}
201 | 		addrs = append(addrs, addr)
202 | 	}
203 | 	return
204 | }
205 | 
206 | // SelectServer return service address from environment variable
207 | func (n *RRServiceProvider) SelectServer() string {
208 | 	n.lock.Lock()
209 | 	defer n.lock.Unlock()
210 | 	if n.curState.Load() == nil {
211 | 		return ""
212 | 	}
213 | 	instances := n.curState.Load().(state).addresses
214 | 	if len(instances) == 0 {
215 | 		zlogger.Error().Msgf("[go-doudou] %s server not found", n.target)
216 | 		return ""
217 | 	}
218 | 	sort.SliceStable(instances, func(i, j int) bool {
219 | 		return instances[i].addr < instances[j].addr
220 | 	})
221 | 	next := int(atomic.AddUint64(&n.current, uint64(1)) % uint64(len(instances)))
222 | 	n.current = uint64(next)
223 | 	selected := instances[next]
224 | 	return fmt.Sprintf("http://%s%s", selected.addr, selected.rootPath)
225 | }
226 | 
227 | func (r *RRServiceProvider) Close() {
228 | 	r.watcher.Close()
229 | }
230 | 
231 | type ServiceConfig struct {
232 | 	Name    string
233 | 	Group   string
234 | 	Version string
235 | }
236 | 
237 | // NewRRServiceProvider creates new RRServiceProvider instance.
238 | // If you don't need it, You should call Close to release resource.
239 | // You can also call CloseProviders to close all at one shot
240 | // NewRRServiceProvider is not thread-safe
241 | func NewRRServiceProvider(conf ServiceConfig) *RRServiceProvider {
242 | 	serverSet := newServerSet(conf.Name)
243 | 	watcher, err := serverSet.Watch()
244 | 	if err != nil {
245 | 		errorx.Panic(err.Error())
246 | 	}
247 | 	r := &RRServiceProvider{
248 | 		watcher: watcher,
249 | 		target:  conf,
250 | 	}
251 | 	defer func() {
252 | 		providers[conf.Name] = r
253 | 	}()
254 | 	go r.watch()
255 | 	return r
256 | }
257 | 
258 | // SWRRServiceProvider is a smooth weighted round-robin service provider
259 | type SWRRServiceProvider struct {
260 | 	*RRServiceProvider
261 | }
262 | 
263 | // SelectServer selects a node which is supplying service specified by name property from cluster
264 | func (n *SWRRServiceProvider) SelectServer() string {
265 | 	n.lock.Lock()
266 | 	defer n.lock.Unlock()
267 | 	if n.curState.Load() == nil {
268 | 		return ""
269 | 	}
270 | 	instances := n.curState.Load().(state).addresses
271 | 	if len(instances) == 0 {
272 | 		zlogger.Error().Msgf("[go-doudou] %s server not found", n.target)
273 | 		return ""
274 | 	}
275 | 	var selected *address
276 | 	total := 0
277 | 	for i := 0; i < len(instances); i++ {
278 | 		s := instances[i]
279 | 		s.currentWeight += s.weight
280 | 		total += s.weight
281 | 		if selected == nil || s.currentWeight > selected.currentWeight {
282 | 			selected = s
283 | 		}
284 | 	}
285 | 	selected.currentWeight -= total
286 | 	return fmt.Sprintf("http://%s%s", selected.addr, selected.rootPath)
287 | }
288 | 
289 | // NewSWRRServiceProvider creates new SWRRServiceProvider instance
290 | func NewSWRRServiceProvider(conf ServiceConfig) *SWRRServiceProvider {
291 | 	return &SWRRServiceProvider{
292 | 		RRServiceProvider: NewRRServiceProvider(conf),
293 | 	}
294 | }
295 | 
296 | // NewSWRRGrpcClientConn is not thread-safe
297 | func NewSWRRGrpcClientConn(conf ServiceConfig, dialOptions ...grpc.DialOption) *grpc.ClientConn {
298 | 	return NewGrpcClientConn(conf, "zk_weight_balancer", dialOptions...)
299 | }
300 | 
301 | // NewRRGrpcClientConn is not thread-safe
302 | func NewRRGrpcClientConn(conf ServiceConfig, dialOptions ...grpc.DialOption) *grpc.ClientConn {
303 | 	return NewGrpcClientConn(conf, "round_robin", dialOptions...)
304 | }
305 | 
306 | func NewGrpcClientConn(conf ServiceConfig, lb string, dialOptions ...grpc.DialOption) *grpc.ClientConn {
307 | 	serverSet := newServerSet(conf.Name)
308 | 	watcher, err := serverSet.Watch()
309 | 	if err != nil {
310 | 		errorx.Panic(err.Error())
311 | 	}
312 | 	grpc_resolver_zk.AddZkConfig(grpc_resolver_zk.ZkConfig{
313 | 		Label:       conf.Name,
314 | 		ServiceName: conf.Name,
315 | 		Watcher:     watcher,
316 | 		Group:       conf.Group,
317 | 		Version:     conf.Version,
318 | 	})
319 | 	serverAddr := fmt.Sprintf("zk://%s/", conf.Name)
320 | 	dialOptions = append(dialOptions, grpc.WithBlock(), grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy": "`+lb+`"}`))
321 | 	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
322 | 	defer cancel()
323 | 	grpcConn, err := grpc.DialContext(ctx, serverAddr, dialOptions...)
324 | 	if err != nil {
325 | 		zlogger.Panic().Err(err).Msgf("[go-doudou] failed to connect to server %s", serverAddr)
326 | 	}
327 | 	return grpcConn
328 | }
329 | 
330 | var shutdownOnce sync.Once
331 | 
332 | // CloseProviders you must call CloseProviders when program is shutting down, otherwise goroutine will leak
333 | func CloseProviders() {
334 | 	shutdownOnce.Do(func() {
335 | 		for _, p := range providers {
336 | 			p.Close()
337 | 		}
338 | 	})
339 | }
```

framework/rest/httprouter/.travis.yml
```
1 | sudo: false
2 | language: go
3 | go:
4 |   - 1.7.x
5 |   - 1.8.x
6 |   - 1.9.x
7 |   - 1.10.x
8 |   - 1.11.x
9 |   - 1.12.x
10 |   - 1.13.x
11 |   - master
12 | matrix:
13 |   allow_failures:
14 |     - go: master
15 |   fast_finish: true
16 | before_install:
17 |   - go get github.com/mattn/goveralls
18 | script:
19 |   - go test -v -covermode=count -coverprofile=coverage.out
20 |   - go vet ./...
21 |   - test -z "$(gofmt -d -s . | tee /dev/stderr)"
22 |   - $HOME/gopath/bin/goveralls  -coverprofile=coverage.out -service=travis-ci
```

framework/rest/httprouter/routegroup.go
```
1 | package httprouter
2 | 
3 | import (
4 | 	"net/http"
5 | 
6 | 	"github.com/unionj-cloud/toolkit/stringutils"
7 | )
8 | 
9 | type RouteGroup struct {
10 | 	r *Router
11 | 	p string
12 | }
13 | 
14 | func validatePath(path string) {
15 | 	if stringutils.IsEmpty(path) {
16 | 		panic("path should not be empty")
17 | 	}
18 | 	if path[0] != '/' {
19 | 		panic("path must start with a '/'")
20 | 	}
21 | }
22 | 
23 | func newRouteGroup(r *Router, path string) *RouteGroup {
24 | 	validatePath(path)
25 | 
26 | 	//Strip traling / (if present) as all added sub paths must start with a /
27 | 	if path[len(path)-1] == '/' {
28 | 		path = path[:len(path)-1]
29 | 	}
30 | 	return &RouteGroup{r: r, p: path}
31 | }
32 | 
33 | func (r *RouteGroup) NewGroup(path string) *RouteGroup {
34 | 	return newRouteGroup(r.r, r.SubPath(path))
35 | }
36 | 
37 | func (r *RouteGroup) Handle(method, path string, handle Handle, name ...string) {
38 | 	r.r.Handle(method, r.SubPath(path), handle, name...)
39 | }
40 | 
41 | func (r *RouteGroup) Handler(method, path string, handler http.Handler, name ...string) {
42 | 	r.r.Handler(method, r.SubPath(path), handler, name...)
43 | }
44 | 
45 | func (r *RouteGroup) HandlerFunc(method, path string, handler http.HandlerFunc, name ...string) {
46 | 	r.r.HandlerFunc(method, r.SubPath(path), handler, name...)
47 | }
48 | 
49 | func (r *RouteGroup) GET(path string, handle Handle) {
50 | 	r.Handle("GET", path, handle)
51 | }
52 | func (r *RouteGroup) HEAD(path string, handle Handle) {
53 | 	r.Handle("HEAD", path, handle)
54 | }
55 | func (r *RouteGroup) OPTIONS(path string, handle Handle) {
56 | 	r.Handle("OPTIONS", path, handle)
57 | }
58 | func (r *RouteGroup) POST(path string, handle Handle) {
59 | 	r.Handle("POST", path, handle)
60 | }
61 | func (r *RouteGroup) PUT(path string, handle Handle) {
62 | 	r.Handle("PUT", path, handle)
63 | }
64 | func (r *RouteGroup) PATCH(path string, handle Handle) {
65 | 	r.Handle("PATCH", path, handle)
66 | }
67 | func (r *RouteGroup) DELETE(path string, handle Handle) {
68 | 	r.Handle("DELETE", path, handle)
69 | }
70 | 
71 | func (r *RouteGroup) SubPath(path string) string {
72 | 	result := r.p + path
73 | 	if stringutils.IsEmpty(result) {
74 | 		return "/"
75 | 	}
76 | 	return r.p + path
77 | }
```

framework/rest/httprouter/routegroup_test.go
```
1 | package httprouter
2 | 
3 | import (
4 | 	"net/http"
5 | 	"testing"
6 | )
7 | 
8 | func TestRouteGroupOfARouteGroup(t *testing.T) {
9 | 	var get bool
10 | 	router := New()
11 | 	router.SaveMatchedRoutePath = false
12 | 	foo := router.NewGroup("/foo") // creates /foo group
13 | 	bar := foo.NewGroup("/bar")
14 | 
15 | 	bar.GET("/GET", func(w http.ResponseWriter, r *http.Request, _ Params) {
16 | 		get = true
17 | 	})
18 | 
19 | 	w := new(mockResponseWriter)
20 | 
21 | 	r, _ := http.NewRequest("GET", "/foo/bar/GET", nil)
22 | 	router.ServeHTTP(w, r)
23 | 	if !get {
24 | 		t.Error("routing GET /foo/bar/GET failed")
25 | 	}
26 | 
27 | }
28 | 
29 | func TestRouteGroupAPI(t *testing.T) {
30 | 	var get, head, options, post, put, patch, delete, handler, handlerFunc bool
31 | 
32 | 	httpHandler := handlerStruct{&handler}
33 | 
34 | 	router := New()
35 | 	router.SaveMatchedRoutePath = false
36 | 	group := router.NewGroup("/foo") // creates /foo group
37 | 
38 | 	group.GET("/GET", func(w http.ResponseWriter, r *http.Request, _ Params) {
39 | 		get = true
40 | 	})
41 | 	group.HEAD("/GET", func(w http.ResponseWriter, r *http.Request, _ Params) {
42 | 		head = true
43 | 	})
44 | 	group.OPTIONS("/GET", func(w http.ResponseWriter, r *http.Request, _ Params) {
45 | 		options = true
46 | 	})
47 | 	group.POST("/POST", func(w http.ResponseWriter, r *http.Request, _ Params) {
48 | 		post = true
49 | 	})
50 | 	group.PUT("/PUT", func(w http.ResponseWriter, r *http.Request, _ Params) {
51 | 		put = true
52 | 	})
53 | 	group.PATCH("/PATCH", func(w http.ResponseWriter, r *http.Request, _ Params) {
54 | 		patch = true
55 | 	})
56 | 	group.DELETE("/DELETE", func(w http.ResponseWriter, r *http.Request, _ Params) {
57 | 		delete = true
58 | 	})
59 | 	group.Handler("GET", "/Handler", httpHandler)
60 | 	group.HandlerFunc("GET", "/HandlerFunc", func(w http.ResponseWriter, r *http.Request) {
61 | 		handlerFunc = true
62 | 	})
63 | 
64 | 	w := new(mockResponseWriter)
65 | 
66 | 	r, _ := http.NewRequest("GET", "/foo/GET", nil)
67 | 	router.ServeHTTP(w, r)
68 | 	if !get {
69 | 		t.Error("routing /foo/GET failed")
70 | 	}
71 | 
72 | 	r, _ = http.NewRequest("HEAD", "/foo/GET", nil)
73 | 	router.ServeHTTP(w, r)
74 | 	if !head {
75 | 		t.Error("routing HEAD failed")
76 | 	}
77 | 
78 | 	r, _ = http.NewRequest("OPTIONS", "/foo/GET", nil)
79 | 	router.ServeHTTP(w, r)
80 | 	if !options {
81 | 		t.Error("routing OPTIONS failed")
82 | 	}
83 | 
84 | 	r, _ = http.NewRequest("POST", "/foo/POST", nil)
85 | 	router.ServeHTTP(w, r)
86 | 	if !post {
87 | 		t.Error("routing POST failed")
88 | 	}
89 | 
90 | 	r, _ = http.NewRequest("PUT", "/foo/PUT", nil)
91 | 	router.ServeHTTP(w, r)
92 | 	if !put {
93 | 		t.Error("routing PUT failed")
94 | 	}
95 | 
96 | 	r, _ = http.NewRequest("PATCH", "/foo/PATCH", nil)
97 | 	router.ServeHTTP(w, r)
98 | 	if !patch {
99 | 		t.Error("routing PATCH failed")
100 | 	}
101 | 
102 | 	r, _ = http.NewRequest("DELETE", "/foo/DELETE", nil)
103 | 	router.ServeHTTP(w, r)
104 | 	if !delete {
105 | 		t.Error("routing DELETE failed")
106 | 	}
107 | 
108 | 	r, _ = http.NewRequest("GET", "/foo/Handler", nil)
109 | 	router.ServeHTTP(w, r)
110 | 	if !handler {
111 | 		t.Error("routing Handler failed")
112 | 	}
113 | 
114 | 	r, _ = http.NewRequest("GET", "/foo/HandlerFunc", nil)
115 | 	router.ServeHTTP(w, r)
116 | 	if !handlerFunc {
117 | 		t.Error("routing HandlerFunc failed")
118 | 	}
119 | }
```

framework/rest/httprouter/router.go
```
1 | // Copyright 2013 Julien Schmidt. All rights reserved.
2 | // Use of this source code is governed by a BSD-style license that can be found
3 | // in the LICENSE file.
4 | 
5 | // Package httprouter is a trie based high performance HTTP request router.
6 | //
7 | // A trivial example is:
8 | //
9 | //	package main
10 | //
11 | //	import (
12 | //	    "fmt"
13 | //	    "github.com/julienschmidt/httprouter"
14 | //	    "net/http"
15 | //	    "log"
16 | //	)
17 | //
18 | //	func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
19 | //	    fmt.Fprint(w, "Welcome!\n")
20 | //	}
21 | //
22 | //	func Hello(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
23 | //	    fmt.Fprintf(w, "hello, %s!\n", ps.ByName("name"))
24 | //	}
25 | //
26 | //	func main() {
27 | //	    router := httprouter.New()
28 | //	    router.GET("/", Index)
29 | //	    router.GET("/hello/:name", Hello)
30 | //
31 | //	    log.Fatal(http.ListenAndServe(":8080", router))
32 | //	}
33 | //
34 | // The router matches incoming requests by the request method and the path.
35 | // If a handle is registered for this path and method, the router delegates the
36 | // request to that function.
37 | // For the methods GET, POST, PUT, PATCH, DELETE and OPTIONS shortcut functions exist to
38 | // register handles, for all other methods router.Handle can be used.
39 | //
40 | // The registered path, against which the router matches incoming requests, can
41 | // contain two types of parameters:
42 | //
43 | //	Syntax    Type
44 | //	:name     named parameter
45 | //	*name     catch-all parameter
46 | //
47 | // Named parameters are dynamic path segments. They match anything until the
48 | // next '/' or the path end:
49 | //
50 | //	Path: /blog/:category/:post
51 | //
52 | //	Requests:
53 | //	 /blog/go/request-routers            match: category="go", post="request-routers"
54 | //	 /blog/go/request-routers/           no match, but the router would redirect
55 | //	 /blog/go/                           no match
56 | //	 /blog/go/request-routers/comments   no match
57 | //
58 | // Catch-all parameters match anything until the path end, including the
59 | // directory index (the '/' before the catch-all). Since they match anything
60 | // until the end, catch-all parameters must always be the final path element.
61 | //
62 | //	Path: /files/*filepath
63 | //
64 | //	Requests:
65 | //	 /files/                             match: filepath="/"
66 | //	 /files/LICENSE                      match: filepath="/LICENSE"
67 | //	 /files/templates/article.html       match: filepath="/templates/article.html"
68 | //	 /files                              no match, but the router would redirect
69 | //
70 | // The value of parameters is saved as a slice of the Param struct, consisting
71 | // each of a key and a value. The slice is passed to the Handle func as a third
72 | // parameter.
73 | // There are two ways to retrieve the value of a parameter:
74 | //
75 | //	// by the name of the parameter
76 | //	user := ps.ByName("user") // defined by :user or *user
77 | //
78 | //	// by the index of the parameter. This way you can also get the name (key)
79 | //	thirdKey   := ps[2].Key   // the name of the 3rd parameter
80 | //	thirdValue := ps[2].Value // the value of the 3rd parameter
81 | package httprouter
82 | 
83 | import (
84 | 	"context"
85 | 	"net/http"
86 | 	"strings"
87 | 	"sync"
88 | 
89 | 	"github.com/ucarion/urlpath"
90 | )
91 | 
92 | // Handle is a function that can be registered to a route to handle HTTP
93 | // requests. Like http.HandlerFunc, but has a third parameter for the values of
94 | // wildcards (path variables).
95 | type Handle func(http.ResponseWriter, *http.Request, Params)
96 | 
97 | // Param is a single URL parameter, consisting of a key and a value.
98 | type Param struct {
99 | 	Key   string
100 | 	Value string
101 | }
102 | 
103 | // Params is a Param-slice, as returned by the router.
104 | // The slice is ordered, the first URL parameter is also the first slice value.
105 | // It is therefore safe to read values by the index.
106 | type Params []Param
107 | 
108 | // ByName returns the value of the first Param which key matches the given name.
109 | // If no matching Param is found, an empty string is returned.
110 | func (ps Params) ByName(name string) string {
111 | 	for _, p := range ps {
112 | 		if p.Key == name {
113 | 			return p.Value
114 | 		}
115 | 	}
116 | 	return ""
117 | }
118 | 
119 | type paramsKey struct{}
120 | 
121 | // ParamsKey is the request context key under which URL params are stored.
122 | var ParamsKey = paramsKey{}
123 | 
124 | // ParamsFromContext pulls the URL parameters from a request context,
125 | // or returns nil if none are present.
126 | func ParamsFromContext(ctx context.Context) Params {
127 | 	p, _ := ctx.Value(ParamsKey).(Params)
128 | 	return p
129 | }
130 | 
131 | // MatchedRouteNameParam is the Param name under which the name of the matched
132 | // route is stored, if Router.SaveMatchedRoutePath is set.
133 | var MatchedRouteNameParam = "$matchedRouteName"
134 | 
135 | // MatchedRouteName retrieves the name of the matched route.
136 | // Router.SaveMatchedRoutePath must have been enabled when the respective
137 | // handler was added, otherwise this function always returns an empty string.
138 | func (ps Params) MatchedRouteName() string {
139 | 	return ps.ByName(MatchedRouteNameParam)
140 | }
141 | 
142 | // Router is a http.Handler which can be used to dispatch requests to different
143 | // handler functions via configurable routes
144 | type Router struct {
145 | 	paramsPool sync.Pool
146 | 
147 | 	// If enabled, adds the matched route path onto the http.Request context
148 | 	// before invoking the handler.
149 | 	// The matched route path is only added to handlers of routes that were
150 | 	// registered when this option was enabled.
151 | 	SaveMatchedRoutePath bool
152 | 
153 | 	// If enabled, the router checks if another method is allowed for the
154 | 	// current route, if the current request can not be routed.
155 | 	// If this is the case, the request is answered with 'Method Not Allowed'
156 | 	// and HTTP status code 405.
157 | 	// If no other Method is allowed, the request is delegated to the NotFound
158 | 	// handler.
159 | 	HandleMethodNotAllowed bool
160 | 
161 | 	// If enabled, the router automatically replies to OPTIONS requests.
162 | 	// Custom OPTIONS handlers take priority over automatic replies.
163 | 	HandleOPTIONS bool
164 | 
165 | 	// An optional http.Handler that is called on automatic OPTIONS requests.
166 | 	// The handler is only called if HandleOPTIONS is true and no OPTIONS
167 | 	// handler for the specific path was set.
168 | 	// The "Allowed" header is set before calling the handler.
169 | 	GlobalOPTIONS http.Handler
170 | 
171 | 	// Cached value of global (*) allowed methods
172 | 	globalAllowed string
173 | 
174 | 	// Configurable http.Handler which is called when no matching route is
175 | 	// found. If it is not set, http.NotFound is used.
176 | 	NotFound http.Handler
177 | 
178 | 	// Configurable http.Handler which is called when a request
179 | 	// cannot be routed and HandleMethodNotAllowed is true.
180 | 	// If it is not set, http.Error with http.StatusMethodNotAllowed is used.
181 | 	// The "Allow" header with allowed request methods is set before the handler
182 | 	// is called.
183 | 	MethodNotAllowed http.Handler
184 | 
185 | 	// Function to handle panics recovered from http handlers.
186 | 	// It should be used to generate a error page and return the http error code
187 | 	// 500 (Internal Server Error).
188 | 	// The handler can be used to keep your server from crashing because of
189 | 	// unrecovered panics.
190 | 	PanicHandler func(http.ResponseWriter, *http.Request, interface{})
191 | 
192 | 	// key is method
193 | 	registeredPaths map[string]struct{}
194 | 	handlers        map[string]Handle
195 | 	// here we use pointer type because urlpath.Path is not comparable
196 | 	dynamicHandlers []map[*urlpath.Path]Handle
197 | 	// key is path
198 | 	dynamicPaths map[string]*urlpath.Path
199 | }
200 | 
201 | // Make sure the Router conforms with the http.Handler interface
202 | var _ http.Handler = New()
203 | 
204 | var httpMethods = []string{http.MethodGet, http.MethodHead, http.MethodPost,
205 | 	http.MethodPut, http.MethodPatch, http.MethodDelete, http.MethodConnect,
206 | 	http.MethodOptions, http.MethodTrace}
207 | 
208 | // New returns a new initialized Router.
209 | // Path auto-correction, including trailing slashes, is enabled by default.
210 | func New() *Router {
211 | 	r := &Router{
212 | 		HandleMethodNotAllowed: true,
213 | 		HandleOPTIONS:          true,
214 | 		registeredPaths:        make(map[string]struct{}),
215 | 		handlers:               make(map[string]Handle),
216 | 		dynamicHandlers:        make([]map[*urlpath.Path]Handle, len(httpMethods)),
217 | 		dynamicPaths:           make(map[string]*urlpath.Path),
218 | 	}
219 | 	for i := range httpMethods {
220 | 		r.dynamicHandlers[i] = make(map[*urlpath.Path]Handle)
221 | 	}
222 | 	r.paramsPool.New = func() interface{} {
223 | 		ps := make(Params, 0, 1)
224 | 		return &ps
225 | 	}
226 | 	return r
227 | }
228 | 
229 | func (r *Router) NewGroup(path string) *RouteGroup {
230 | 	return newRouteGroup(r, path)
231 | }
232 | 
233 | func (r *Router) getParams() *Params {
234 | 	ps, _ := r.paramsPool.Get().(*Params)
235 | 	*ps = (*ps)[0:0] // reset slice
236 | 	return ps
237 | }
238 | 
239 | func (r *Router) putParams(ps *Params) {
240 | 	if ps != nil {
241 | 		r.paramsPool.Put(ps)
242 | 	}
243 | }
244 | 
245 | func (r *Router) saveMatchedRoutePath(name string, handle Handle) Handle {
246 | 	return func(w http.ResponseWriter, req *http.Request, ps Params) {
247 | 		if ps == nil {
248 | 			psp := r.getParams()
249 | 			ps = (*psp)[0:1]
250 | 			ps[0] = Param{Key: MatchedRouteNameParam, Value: name}
251 | 			handle(w, req, ps)
252 | 			r.putParams(psp)
253 | 		} else {
254 | 			ps = append(ps, Param{Key: MatchedRouteNameParam, Value: name})
255 | 			handle(w, req, ps)
256 | 		}
257 | 	}
258 | }
259 | 
260 | // GET is a shortcut for router.Handle(http.MethodGet, path, handle)
261 | func (r *Router) GET(path string, handle Handle) {
262 | 	r.Handle(http.MethodGet, path, handle)
263 | }
264 | 
265 | // HEAD is a shortcut for router.Handle(http.MethodHead, path, handle)
266 | func (r *Router) HEAD(path string, handle Handle) {
267 | 	r.Handle(http.MethodHead, path, handle)
268 | }
269 | 
270 | // OPTIONS is a shortcut for router.Handle(http.MethodOptions, path, handle)
271 | func (r *Router) OPTIONS(path string, handle Handle) {
272 | 	r.Handle(http.MethodOptions, path, handle)
273 | }
274 | 
275 | // POST is a shortcut for router.Handle(http.MethodPost, path, handle)
276 | func (r *Router) POST(path string, handle Handle) {
277 | 	r.Handle(http.MethodPost, path, handle)
278 | }
279 | 
280 | // PUT is a shortcut for router.Handle(http.MethodPut, path, handle)
281 | func (r *Router) PUT(path string, handle Handle) {
282 | 	r.Handle(http.MethodPut, path, handle)
283 | }
284 | 
285 | // PATCH is a shortcut for router.Handle(http.MethodPatch, path, handle)
286 | func (r *Router) PATCH(path string, handle Handle) {
287 | 	r.Handle(http.MethodPatch, path, handle)
288 | }
289 | 
290 | // DELETE is a shortcut for router.Handle(http.MethodDelete, path, handle)
291 | func (r *Router) DELETE(path string, handle Handle) {
292 | 	r.Handle(http.MethodDelete, path, handle)
293 | }
294 | 
295 | func (r *Router) methodIndexOf(method string) int {
296 | 	switch method {
297 | 	case http.MethodGet:
298 | 		return 0
299 | 	case http.MethodHead:
300 | 		return 1
301 | 	case http.MethodPost:
302 | 		return 2
303 | 	case http.MethodPut:
304 | 		return 3
305 | 	case http.MethodPatch:
306 | 		return 4
307 | 	case http.MethodDelete:
308 | 		return 5
309 | 	case http.MethodConnect:
310 | 		return 6
311 | 	case http.MethodOptions:
312 | 		return 7
313 | 	case http.MethodTrace:
314 | 		return 8
315 | 	}
316 | 	return -1
317 | }
318 | 
319 | func path2key(method, path string) string {
320 | 	var sb strings.Builder
321 | 	sb.WriteString(method)
322 | 	sb.WriteString(":")
323 | 	sb.WriteString(path)
324 | 	return sb.String()
325 | }
326 | 
327 | func countParams(path string) uint16 {
328 | 	var n uint
329 | 	for i := range []byte(path) {
330 | 		switch path[i] {
331 | 		case ':', '*':
332 | 			n++
333 | 		}
334 | 	}
335 | 	return uint16(n)
336 | }
337 | 
338 | // Handle registers a new request handle with the given path and method.
339 | //
340 | // For GET, POST, PUT, PATCH and DELETE requests the respective shortcut
341 | // functions can be used.
342 | //
343 | // This function is intended for bulk loading and to allow the usage of less
344 | // frequently used, non-standardized or custom methods (e.g. for internal
345 | // communication with a proxy).
346 | func (r *Router) Handle(method, path string, handle Handle, name ...string) {
347 | 	switch {
348 | 	case len(method) == 0:
349 | 		panic("method must not be empty")
350 | 	case len(path) < 1 || path[0] != '/':
351 | 		panic("path must begin with '/' in path '" + path + "'")
352 | 	case handle == nil:
353 | 		panic("handler must not be nil")
354 | 	}
355 | 	idx := r.methodIndexOf(method)
356 | 	if idx < 0 {
357 | 		panic("unknown http method")
358 | 	}
359 | 	_, f := r.registeredPaths[method]
360 | 	r.registeredPaths[method] = struct{}{}
361 | 	if !f {
362 | 		r.globalAllowed = r.allowed("*", "")
363 | 	}
364 | 	if r.SaveMatchedRoutePath {
365 | 		if len(name) == 0 {
366 | 			panic("route name must not be nil")
367 | 		}
368 | 		handle = r.saveMatchedRoutePath(name[0], handle)
369 | 	}
370 | 	key := path2key(method, path)
371 | 	// later registered rest handler will replace previous one
372 | 	if strings.Contains(path, "*") || strings.Contains(path, ":") {
373 | 		if p, ok := r.dynamicPaths[path]; ok {
374 | 			r.dynamicHandlers[idx][p] = handle
375 | 		} else {
376 | 			pt := urlpath.New(path)
377 | 			r.dynamicHandlers[idx][&pt] = handle
378 | 			r.dynamicPaths[path] = &pt
379 | 		}
380 | 	} else {
381 | 		r.handlers[key] = handle
382 | 	}
383 | }
384 | 
385 | // Handler is an adapter which allows the usage of an http.Handler as a
386 | // request handle.
387 | // The Params are available in the request context under ParamsKey.
388 | func (r *Router) Handler(method, path string, handler http.Handler, name ...string) {
389 | 	methods := []string{method, http.MethodOptions}
390 | 	for _, m := range methods {
391 | 		r.Handle(m, path,
392 | 			func(w http.ResponseWriter, req *http.Request, p Params) {
393 | 				if len(p) > 0 {
394 | 					req = req.WithContext(context.WithValue(req.Context(), ParamsKey, p))
395 | 				}
396 | 				handler.ServeHTTP(w, req)
397 | 			},
398 | 			name...,
399 | 		)
400 | 	}
401 | }
402 | 
403 | // HandlerFunc is an adapter which allows the usage of an http.HandlerFunc as a
404 | // request handle.
405 | func (r *Router) HandlerFunc(method, path string, handler http.HandlerFunc, name ...string) {
406 | 	r.Handler(method, path, handler, name...)
407 | }
408 | 
409 | func (r *Router) recv(w http.ResponseWriter, req *http.Request) {
410 | 	if rcv := recover(); rcv != nil {
411 | 		r.PanicHandler(w, req, rcv)
412 | 	}
413 | }
414 | 
415 | func (r *Router) search(method, path string, ps *Params) Handle {
416 | 	idx := r.methodIndexOf(method)
417 | 	if idx < 0 {
418 | 		return nil
419 | 	}
420 | 	for k := range r.dynamicHandlers[idx] {
421 | 		match, ok := k.Match(path)
422 | 		if !ok {
423 | 			continue
424 | 		}
425 | 		for k1, v1 := range match.Params {
426 | 			*ps = append(*ps, Param{Key: k1, Value: v1})
427 | 		}
428 | 		return r.dynamicHandlers[idx][k]
429 | 	}
430 | 	return nil
431 | }
432 | 
433 | func (r *Router) allowed(path, reqMethod string) (allow string) {
434 | 	allowed := make([]string, 0, 9)
435 | 
436 | 	if path == "*" || path == "/*" { // server-wide{ // server-wide
437 | 		// empty method is used for internal calls to refresh the cache
438 | 		if reqMethod == "" {
439 | 			for method := range r.registeredPaths {
440 | 				if method == http.MethodOptions {
441 | 					continue
442 | 				}
443 | 				// Add request method to list of allowed methods
444 | 				allowed = append(allowed, method)
445 | 			}
446 | 		} else {
447 | 			return r.globalAllowed
448 | 		}
449 | 	} else { // specific path
450 | 		for method := range r.registeredPaths {
451 | 			// Skip the requested method - we already tried this one
[TRUNCATED]
```

framework/rest/httprouter/router_test.go
```
1 | // Copyright 2013 Julien Schmidt. All rights reserved.
2 | // Use of this source code is governed by a BSD-style license that can be found
3 | // in the LICENSE file.
4 | 
5 | package httprouter
6 | 
7 | import (
8 | 	"net/http"
9 | 	"net/http/httptest"
10 | 	"testing"
11 | )
12 | 
13 | type mockResponseWriter struct{}
14 | 
15 | func (m *mockResponseWriter) Header() (h http.Header) {
16 | 	return http.Header{}
17 | }
18 | 
19 | func (m *mockResponseWriter) Write(p []byte) (n int, err error) {
20 | 	return len(p), nil
21 | }
22 | 
23 | func (m *mockResponseWriter) WriteString(s string) (n int, err error) {
24 | 	return len(s), nil
25 | }
26 | 
27 | func (m *mockResponseWriter) WriteHeader(int) {}
28 | 
29 | func TestParams(t *testing.T) {
30 | 	ps := Params{
31 | 		Param{"param1", "value1"},
32 | 		Param{"param2", "value2"},
33 | 		Param{"param3", "value3"},
34 | 	}
35 | 	for i := range ps {
36 | 		if val := ps.ByName(ps[i].Key); val != ps[i].Value {
37 | 			t.Errorf("Wrong value for %s: Got %s; Want %s", ps[i].Key, val, ps[i].Value)
38 | 		}
39 | 	}
40 | 	if val := ps.ByName("noKey"); val != "" {
41 | 		t.Errorf("Expected empty string for not found key; got: %s", val)
42 | 	}
43 | }
44 | 
45 | type handlerStruct struct {
46 | 	handled *bool
47 | }
48 | 
49 | func (h handlerStruct) ServeHTTP(w http.ResponseWriter, r *http.Request) {
50 | 	*h.handled = true
51 | }
52 | 
53 | func TestRouterAPI(t *testing.T) {
54 | 	var get, head, options, post, put, patch, delete, handler, handlerFunc bool
55 | 
56 | 	httpHandler := handlerStruct{&handler}
57 | 
58 | 	router := New()
59 | 	router.GET("/GET", func(w http.ResponseWriter, r *http.Request, _ Params) {
60 | 		get = true
61 | 	})
62 | 	router.HEAD("/GET", func(w http.ResponseWriter, r *http.Request, _ Params) {
63 | 		head = true
64 | 	})
65 | 	router.OPTIONS("/GET", func(w http.ResponseWriter, r *http.Request, _ Params) {
66 | 		options = true
67 | 	})
68 | 	router.POST("/POST", func(w http.ResponseWriter, r *http.Request, _ Params) {
69 | 		post = true
70 | 	})
71 | 	router.PUT("/PUT", func(w http.ResponseWriter, r *http.Request, _ Params) {
72 | 		put = true
73 | 	})
74 | 	router.PATCH("/PATCH", func(w http.ResponseWriter, r *http.Request, _ Params) {
75 | 		patch = true
76 | 	})
77 | 	router.DELETE("/DELETE", func(w http.ResponseWriter, r *http.Request, _ Params) {
78 | 		delete = true
79 | 	})
80 | 	router.Handler(http.MethodGet, "/Handler", httpHandler)
81 | 	router.HandlerFunc(http.MethodGet, "/HandlerFunc", func(w http.ResponseWriter, r *http.Request) {
82 | 		handlerFunc = true
83 | 	})
84 | 
85 | 	w := new(mockResponseWriter)
86 | 
87 | 	r, _ := http.NewRequest(http.MethodGet, "/GET", nil)
88 | 	router.ServeHTTP(w, r)
89 | 	if !get {
90 | 		t.Error("routing GET failed")
91 | 	}
92 | 
93 | 	r, _ = http.NewRequest(http.MethodHead, "/GET", nil)
94 | 	router.ServeHTTP(w, r)
95 | 	if !head {
96 | 		t.Error("routing HEAD failed")
97 | 	}
98 | 
99 | 	r, _ = http.NewRequest(http.MethodOptions, "/GET", nil)
100 | 	router.ServeHTTP(w, r)
101 | 	if !options {
102 | 		t.Error("routing OPTIONS failed")
103 | 	}
104 | 
105 | 	r, _ = http.NewRequest(http.MethodPost, "/POST", nil)
106 | 	router.ServeHTTP(w, r)
107 | 	if !post {
108 | 		t.Error("routing POST failed")
109 | 	}
110 | 
111 | 	r, _ = http.NewRequest(http.MethodPut, "/PUT", nil)
112 | 	router.ServeHTTP(w, r)
113 | 	if !put {
114 | 		t.Error("routing PUT failed")
115 | 	}
116 | 
117 | 	r, _ = http.NewRequest(http.MethodPatch, "/PATCH", nil)
118 | 	router.ServeHTTP(w, r)
119 | 	if !patch {
120 | 		t.Error("routing PATCH failed")
121 | 	}
122 | 
123 | 	r, _ = http.NewRequest(http.MethodDelete, "/DELETE", nil)
124 | 	router.ServeHTTP(w, r)
125 | 	if !delete {
126 | 		t.Error("routing DELETE failed")
127 | 	}
128 | 
129 | 	r, _ = http.NewRequest(http.MethodGet, "/Handler", nil)
130 | 	router.ServeHTTP(w, r)
131 | 	if !handler {
132 | 		t.Error("routing Handler failed")
133 | 	}
134 | 
135 | 	r, _ = http.NewRequest(http.MethodGet, "/HandlerFunc", nil)
136 | 	router.ServeHTTP(w, r)
137 | 	if !handlerFunc {
138 | 		t.Error("routing HandlerFunc failed")
139 | 	}
140 | }
141 | 
142 | func TestRouterChaining(t *testing.T) {
143 | 	router1 := New()
144 | 	router2 := New()
145 | 	router1.NotFound = router2
146 | 
147 | 	fooHit := false
148 | 	router1.POST("/foo", func(w http.ResponseWriter, req *http.Request, _ Params) {
149 | 		fooHit = true
150 | 		w.WriteHeader(http.StatusOK)
151 | 	})
152 | 
153 | 	barHit := false
154 | 	router2.POST("/bar", func(w http.ResponseWriter, req *http.Request, _ Params) {
155 | 		barHit = true
156 | 		w.WriteHeader(http.StatusOK)
157 | 	})
158 | 
159 | 	r, _ := http.NewRequest(http.MethodPost, "/foo", nil)
160 | 	w := httptest.NewRecorder()
161 | 	router1.ServeHTTP(w, r)
162 | 	if !(w.Code == http.StatusOK && fooHit) {
163 | 		t.Errorf("Regular routing failed with router chaining.")
164 | 		t.FailNow()
165 | 	}
166 | 
167 | 	r, _ = http.NewRequest(http.MethodPost, "/bar", nil)
168 | 	w = httptest.NewRecorder()
169 | 	router1.ServeHTTP(w, r)
170 | 	if !(w.Code == http.StatusOK && barHit) {
171 | 		t.Errorf("Chained routing failed with router chaining.")
172 | 		t.FailNow()
173 | 	}
174 | 
175 | 	r, _ = http.NewRequest(http.MethodPost, "/qax", nil)
176 | 	w = httptest.NewRecorder()
177 | 	router1.ServeHTTP(w, r)
178 | 	if !(w.Code == http.StatusNotFound) {
179 | 		t.Errorf("NotFound behavior failed with router chaining.")
180 | 		t.FailNow()
181 | 	}
182 | }
183 | 
184 | func BenchmarkAllowed(b *testing.B) {
185 | 	handlerFunc := func(_ http.ResponseWriter, _ *http.Request, _ Params) {}
186 | 
187 | 	router := New()
188 | 	router.POST("/path", handlerFunc)
189 | 	router.GET("/path", handlerFunc)
190 | 
191 | 	b.Run("Global", func(b *testing.B) {
192 | 		b.ReportAllocs()
193 | 		for i := 0; i < b.N; i++ {
194 | 			_ = router.allowed("*", http.MethodOptions)
195 | 		}
196 | 	})
197 | 	b.Run("Path", func(b *testing.B) {
198 | 		b.ReportAllocs()
199 | 		for i := 0; i < b.N; i++ {
200 | 			_ = router.allowed("/path", http.MethodOptions)
201 | 		}
202 | 	})
203 | }
204 | 
205 | func TestRouterOPTIONS(t *testing.T) {
206 | 	handlerFunc := func(_ http.ResponseWriter, _ *http.Request, _ Params) {}
207 | 
208 | 	router := New()
209 | 	router.POST("/path", handlerFunc)
210 | 
211 | 	// test not allowed
212 | 	// * (server)
213 | 	r, _ := http.NewRequest(http.MethodOptions, "*", nil)
214 | 	w := httptest.NewRecorder()
215 | 	router.ServeHTTP(w, r)
216 | 	if !(w.Code == http.StatusOK) {
217 | 		t.Errorf("OPTIONS handling failed: Code=%d, Header=%v", w.Code, w.Header())
218 | 	} else if allow := w.Header().Get("Allow"); allow != "OPTIONS, POST" {
219 | 		t.Error("unexpected Allow header value: " + allow)
220 | 	}
221 | 
222 | 	// path
223 | 	r, _ = http.NewRequest(http.MethodOptions, "/path", nil)
224 | 	w = httptest.NewRecorder()
225 | 	router.ServeHTTP(w, r)
226 | 	if !(w.Code == http.StatusOK) {
227 | 		t.Errorf("OPTIONS handling failed: Code=%d, Header=%v", w.Code, w.Header())
228 | 	} else if allow := w.Header().Get("Allow"); allow != "OPTIONS, POST" {
229 | 		t.Error("unexpected Allow header value: " + allow)
230 | 	}
231 | 
232 | 	r, _ = http.NewRequest(http.MethodOptions, "/doesnotexist", nil)
233 | 	w = httptest.NewRecorder()
234 | 	router.ServeHTTP(w, r)
235 | 	if !(w.Code == http.StatusNotFound) {
236 | 		t.Errorf("OPTIONS handling failed: Code=%d, Header=%v", w.Code, w.Header())
237 | 	}
238 | 
239 | 	// add another method
240 | 	router.GET("/path", handlerFunc)
241 | 
242 | 	// set a global OPTIONS handler
243 | 	router.GlobalOPTIONS = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
244 | 		// Adjust status code to 204
245 | 		w.WriteHeader(http.StatusNoContent)
246 | 	})
247 | 
248 | 	// test again
249 | 	// * (server)
250 | 	r, _ = http.NewRequest(http.MethodOptions, "*", nil)
251 | 	w = httptest.NewRecorder()
252 | 	router.ServeHTTP(w, r)
253 | 	if !(w.Code == http.StatusNoContent) {
254 | 		t.Errorf("OPTIONS handling failed: Code=%d, Header=%v", w.Code, w.Header())
255 | 	} else if allow := w.Header().Get("Allow"); allow != "GET, OPTIONS, POST" {
256 | 		t.Error("unexpected Allow header value: " + allow)
257 | 	}
258 | 
259 | 	// path
260 | 	r, _ = http.NewRequest(http.MethodOptions, "/path", nil)
261 | 	w = httptest.NewRecorder()
262 | 	router.ServeHTTP(w, r)
263 | 	if !(w.Code == http.StatusNoContent) {
264 | 		t.Errorf("OPTIONS handling failed: Code=%d, Header=%v", w.Code, w.Header())
265 | 	} else if allow := w.Header().Get("Allow"); allow != "GET, OPTIONS, POST" {
266 | 		t.Error("unexpected Allow header value: " + allow)
267 | 	}
268 | 
269 | 	// custom handler
270 | 	var custom bool
271 | 	router.OPTIONS("/path", func(w http.ResponseWriter, r *http.Request, _ Params) {
272 | 		custom = true
273 | 	})
274 | 
275 | 	// test again
276 | 	// * (server)
277 | 	r, _ = http.NewRequest(http.MethodOptions, "*", nil)
278 | 	w = httptest.NewRecorder()
279 | 	router.ServeHTTP(w, r)
280 | 	if !(w.Code == http.StatusNoContent) {
281 | 		t.Errorf("OPTIONS handling failed: Code=%d, Header=%v", w.Code, w.Header())
282 | 	} else if allow := w.Header().Get("Allow"); allow != "GET, OPTIONS, POST" {
283 | 		t.Error("unexpected Allow header value: " + allow)
284 | 	}
285 | 	if custom {
286 | 		t.Error("custom handler called on *")
287 | 	}
288 | 
289 | 	// path
290 | 	r, _ = http.NewRequest(http.MethodOptions, "/path", nil)
291 | 	w = httptest.NewRecorder()
292 | 	router.ServeHTTP(w, r)
293 | 	if !(w.Code == http.StatusOK) {
294 | 		t.Errorf("OPTIONS handling failed: Code=%d, Header=%v", w.Code, w.Header())
295 | 	}
296 | 	if !custom {
297 | 		t.Error("custom handler not called")
298 | 	}
299 | }
300 | 
301 | func TestRouterNotAllowed(t *testing.T) {
302 | 	handlerFunc := func(_ http.ResponseWriter, _ *http.Request, _ Params) {}
303 | 
304 | 	router := New()
305 | 	router.POST("/path", handlerFunc)
306 | 
307 | 	// test not allowed
308 | 	r, _ := http.NewRequest(http.MethodGet, "/path", nil)
309 | 	w := httptest.NewRecorder()
310 | 	router.ServeHTTP(w, r)
311 | 	if !(w.Code == http.StatusMethodNotAllowed) {
312 | 		t.Errorf("NotAllowed handling failed: Code=%d, Header=%v", w.Code, w.Header())
313 | 	} else if allow := w.Header().Get("Allow"); allow != "OPTIONS, POST" {
314 | 		t.Error("unexpected Allow header value: " + allow)
315 | 	}
316 | 
317 | 	// add another method
318 | 	router.DELETE("/path", handlerFunc)
319 | 	router.OPTIONS("/path", handlerFunc) // must be ignored
320 | 
321 | 	// test again
322 | 	r, _ = http.NewRequest(http.MethodGet, "/path", nil)
323 | 	w = httptest.NewRecorder()
324 | 	router.ServeHTTP(w, r)
325 | 	if !(w.Code == http.StatusMethodNotAllowed) {
326 | 		t.Errorf("NotAllowed handling failed: Code=%d, Header=%v", w.Code, w.Header())
327 | 	} else if allow := w.Header().Get("Allow"); allow != "DELETE, OPTIONS, POST" {
328 | 		t.Error("unexpected Allow header value: " + allow)
329 | 	}
330 | 
331 | 	// test custom handler
332 | 	w = httptest.NewRecorder()
333 | 	responseText := "custom method"
334 | 	router.MethodNotAllowed = http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
335 | 		w.WriteHeader(http.StatusTeapot)
336 | 		w.Write([]byte(responseText))
337 | 	})
338 | 	router.ServeHTTP(w, r)
339 | 	if got := w.Body.String(); !(got == responseText) {
340 | 		t.Errorf("unexpected response got %q want %q", got, responseText)
341 | 	}
342 | 	if w.Code != http.StatusTeapot {
343 | 		t.Errorf("unexpected response code %d want %d", w.Code, http.StatusTeapot)
344 | 	}
345 | 	if allow := w.Header().Get("Allow"); allow != "DELETE, OPTIONS, POST" {
346 | 		t.Error("unexpected Allow header value: " + allow)
347 | 	}
348 | }
```

framework/rest/lazyregexp/lazyre.go
```
1 | // Copyright 2018 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | // Package lazyregexp is a thin wrapper over regexp, allowing the use of global
6 | // regexp variables without forcing them to be compiled at init.
7 | package lazyregexp
8 | 
9 | import (
10 | 	"os"
11 | 	"regexp"
12 | 	"strings"
13 | 	"sync"
14 | )
15 | 
16 | // Regexp is a wrapper around regexp.Regexp, where the underlying regexp will be
17 | // compiled the first time it is needed.
18 | type Regexp struct {
19 | 	str  string
20 | 	once sync.Once
21 | 	rx   *regexp.Regexp
22 | }
23 | 
24 | func (r *Regexp) re() *regexp.Regexp {
25 | 	r.once.Do(r.build)
26 | 	return r.rx
27 | }
28 | 
29 | func (r *Regexp) build() {
30 | 	r.rx = regexp.MustCompile(r.str)
31 | 	r.str = ""
32 | }
33 | 
34 | func (r *Regexp) FindSubmatch(s []byte) [][]byte {
35 | 	return r.re().FindSubmatch(s)
36 | }
37 | 
38 | func (r *Regexp) FindStringSubmatch(s string) []string {
39 | 	return r.re().FindStringSubmatch(s)
40 | }
41 | 
42 | func (r *Regexp) FindStringSubmatchIndex(s string) []int {
43 | 	return r.re().FindStringSubmatchIndex(s)
44 | }
45 | 
46 | func (r *Regexp) ReplaceAllString(src, repl string) string {
47 | 	return r.re().ReplaceAllString(src, repl)
48 | }
49 | 
50 | func (r *Regexp) FindString(s string) string {
51 | 	return r.re().FindString(s)
52 | }
53 | 
54 | func (r *Regexp) FindAllString(s string, n int) []string {
55 | 	return r.re().FindAllString(s, n)
56 | }
57 | 
58 | func (r *Regexp) MatchString(s string) bool {
59 | 	return r.re().MatchString(s)
60 | }
61 | 
62 | func (r *Regexp) SubexpNames() []string {
63 | 	return r.re().SubexpNames()
64 | }
65 | 
66 | var inTest = len(os.Args) > 0 && strings.HasSuffix(strings.TrimSuffix(os.Args[0], ".exe"), ".test")
67 | 
68 | // New creates a new lazy regexp, delaying the compiling work until it is first
69 | // needed. If the code is being run as part of tests, the regexp compiling will
70 | // happen immediately.
71 | func New(str string) *Regexp {
72 | 	lr := &Regexp{str: str}
73 | 	if inTest {
74 | 		// In tests, always compile the regexps early.
75 | 		lr.re()
76 | 	}
77 | 	return lr
78 | }
```

framework/rest/mock/goresilience_runner_interface.go
```
1 | package mock
2 | 
3 | import (
4 | 	"context"
5 | 
6 | 	"github.com/slok/goresilience"
7 | )
8 | 
9 | //go:generate mockgen -destination ./mock_goresilience_runner_interface.go -package mock -source=./goresilience_runner_interface.go
10 | 
11 | type Runner interface {
12 | 	// Run will run the unit of execution passed on f.
13 | 	Run(ctx context.Context, f goresilience.Func) error
14 | }
```

framework/rest/mock/mock_goresilience_runner_interface.go
```
1 | // Code generated by MockGen. DO NOT EDIT.
2 | // Source: ./goresilience_runner_interface.go
3 | 
4 | // Package mock is a generated GoMock package.
5 | package mock
6 | 
7 | import (
8 | 	context "context"
9 | 	reflect "reflect"
10 | 
11 | 	gomock "github.com/golang/mock/gomock"
12 | 	goresilience "github.com/slok/goresilience"
13 | )
14 | 
15 | // MockRunner is a mock of Runner interface.
16 | type MockRunner struct {
17 | 	ctrl     *gomock.Controller
18 | 	recorder *MockRunnerMockRecorder
19 | }
20 | 
21 | // MockRunnerMockRecorder is the mock recorder for MockRunner.
22 | type MockRunnerMockRecorder struct {
23 | 	mock *MockRunner
24 | }
25 | 
26 | // NewMockRunner creates a new mock instance.
27 | func NewMockRunner(ctrl *gomock.Controller) *MockRunner {
28 | 	mock := &MockRunner{ctrl: ctrl}
29 | 	mock.recorder = &MockRunnerMockRecorder{mock}
30 | 	return mock
31 | }
32 | 
33 | // EXPECT returns an object that allows the caller to indicate expected use.
34 | func (m *MockRunner) EXPECT() *MockRunnerMockRecorder {
35 | 	return m.recorder
36 | }
37 | 
38 | // Run mocks base method.
39 | func (m *MockRunner) Run(ctx context.Context, f goresilience.Func) error {
40 | 	m.ctrl.T.Helper()
41 | 	ret := m.ctrl.Call(m, "Run", ctx, f)
42 | 	ret0, _ := ret[0].(error)
43 | 	return ret0
44 | }
45 | 
46 | // Run indicates an expected call of Run.
47 | func (mr *MockRunnerMockRecorder) Run(ctx, f interface{}) *gomock.Call {
48 | 	mr.mock.ctrl.T.Helper()
49 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockRunner)(nil).Run), ctx, f)
50 | }
```

framework/rest/profile/encode.go
```
1 | // Copyright 2014 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | package profile
6 | 
7 | import (
8 | 	"errors"
9 | 	"fmt"
10 | 	"sort"
11 | )
12 | 
13 | func (p *Profile) decoder() []decoder {
14 | 	return profileDecoder
15 | }
16 | 
17 | // preEncode populates the unexported fields to be used by encode
18 | // (with suffix X) from the corresponding exported fields. The
19 | // exported fields are cleared up to facilitate testing.
20 | func (p *Profile) preEncode() {
21 | 	strings := make(map[string]int)
22 | 	addString(strings, "")
23 | 
24 | 	for _, st := range p.SampleType {
25 | 		st.typeX = addString(strings, st.Type)
26 | 		st.unitX = addString(strings, st.Unit)
27 | 	}
28 | 
29 | 	for _, s := range p.Sample {
30 | 		s.labelX = nil
31 | 		var keys []string
32 | 		for k := range s.Label {
33 | 			keys = append(keys, k)
34 | 		}
35 | 		sort.Strings(keys)
36 | 		for _, k := range keys {
37 | 			vs := s.Label[k]
38 | 			for _, v := range vs {
39 | 				s.labelX = append(s.labelX,
40 | 					Label{
41 | 						keyX: addString(strings, k),
42 | 						strX: addString(strings, v),
43 | 					},
44 | 				)
45 | 			}
46 | 		}
47 | 		var numKeys []string
48 | 		for k := range s.NumLabel {
49 | 			numKeys = append(numKeys, k)
50 | 		}
51 | 		sort.Strings(numKeys)
52 | 		for _, k := range numKeys {
53 | 			vs := s.NumLabel[k]
54 | 			for _, v := range vs {
55 | 				s.labelX = append(s.labelX,
56 | 					Label{
57 | 						keyX: addString(strings, k),
58 | 						numX: v,
59 | 					},
60 | 				)
61 | 			}
62 | 		}
63 | 		s.locationIDX = nil
64 | 		for _, l := range s.Location {
65 | 			s.locationIDX = append(s.locationIDX, l.ID)
66 | 		}
67 | 	}
68 | 
69 | 	for _, m := range p.Mapping {
70 | 		m.fileX = addString(strings, m.File)
71 | 		m.buildIDX = addString(strings, m.BuildID)
72 | 	}
73 | 
74 | 	for _, l := range p.Location {
75 | 		for i, ln := range l.Line {
76 | 			if ln.Function != nil {
77 | 				l.Line[i].functionIDX = ln.Function.ID
78 | 			} else {
79 | 				l.Line[i].functionIDX = 0
80 | 			}
81 | 		}
82 | 		if l.Mapping != nil {
83 | 			l.mappingIDX = l.Mapping.ID
84 | 		} else {
85 | 			l.mappingIDX = 0
86 | 		}
87 | 	}
88 | 	for _, f := range p.Function {
89 | 		f.nameX = addString(strings, f.Name)
90 | 		f.systemNameX = addString(strings, f.SystemName)
91 | 		f.filenameX = addString(strings, f.Filename)
92 | 	}
93 | 
94 | 	p.dropFramesX = addString(strings, p.DropFrames)
95 | 	p.keepFramesX = addString(strings, p.KeepFrames)
96 | 
97 | 	if pt := p.PeriodType; pt != nil {
98 | 		pt.typeX = addString(strings, pt.Type)
99 | 		pt.unitX = addString(strings, pt.Unit)
100 | 	}
101 | 
102 | 	p.stringTable = make([]string, len(strings))
103 | 	for s, i := range strings {
104 | 		p.stringTable[i] = s
105 | 	}
106 | }
107 | 
108 | func (p *Profile) encode(b *buffer) {
109 | 	for _, x := range p.SampleType {
110 | 		encodeMessage(b, 1, x)
111 | 	}
112 | 	for _, x := range p.Sample {
113 | 		encodeMessage(b, 2, x)
114 | 	}
115 | 	for _, x := range p.Mapping {
116 | 		encodeMessage(b, 3, x)
117 | 	}
118 | 	for _, x := range p.Location {
119 | 		encodeMessage(b, 4, x)
120 | 	}
121 | 	for _, x := range p.Function {
122 | 		encodeMessage(b, 5, x)
123 | 	}
124 | 	encodeStrings(b, 6, p.stringTable)
125 | 	encodeInt64Opt(b, 7, p.dropFramesX)
126 | 	encodeInt64Opt(b, 8, p.keepFramesX)
127 | 	encodeInt64Opt(b, 9, p.TimeNanos)
128 | 	encodeInt64Opt(b, 10, p.DurationNanos)
129 | 	if pt := p.PeriodType; pt != nil && (pt.typeX != 0 || pt.unitX != 0) {
130 | 		encodeMessage(b, 11, p.PeriodType)
131 | 	}
132 | 	encodeInt64Opt(b, 12, p.Period)
133 | }
134 | 
135 | var profileDecoder = []decoder{
136 | 	nil, // 0
137 | 	// repeated ValueType sample_type = 1
138 | 	func(b *buffer, m message) error {
139 | 		x := new(ValueType)
140 | 		pp := m.(*Profile)
141 | 		pp.SampleType = append(pp.SampleType, x)
142 | 		return decodeMessage(b, x)
143 | 	},
144 | 	// repeated Sample sample = 2
145 | 	func(b *buffer, m message) error {
146 | 		x := new(Sample)
147 | 		pp := m.(*Profile)
148 | 		pp.Sample = append(pp.Sample, x)
149 | 		return decodeMessage(b, x)
150 | 	},
151 | 	// repeated Mapping mapping = 3
152 | 	func(b *buffer, m message) error {
153 | 		x := new(Mapping)
154 | 		pp := m.(*Profile)
155 | 		pp.Mapping = append(pp.Mapping, x)
156 | 		return decodeMessage(b, x)
157 | 	},
158 | 	// repeated Location location = 4
159 | 	func(b *buffer, m message) error {
160 | 		x := new(Location)
161 | 		pp := m.(*Profile)
162 | 		pp.Location = append(pp.Location, x)
163 | 		return decodeMessage(b, x)
164 | 	},
165 | 	// repeated Function function = 5
166 | 	func(b *buffer, m message) error {
167 | 		x := new(Function)
168 | 		pp := m.(*Profile)
169 | 		pp.Function = append(pp.Function, x)
170 | 		return decodeMessage(b, x)
171 | 	},
172 | 	// repeated string string_table = 6
173 | 	func(b *buffer, m message) error {
174 | 		err := decodeStrings(b, &m.(*Profile).stringTable)
175 | 		if err != nil {
176 | 			return err
177 | 		}
178 | 		if m.(*Profile).stringTable[0] != "" {
179 | 			return errors.New("string_table[0] must be ''")
180 | 		}
181 | 		return nil
182 | 	},
183 | 	// repeated int64 drop_frames = 7
184 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Profile).dropFramesX) },
185 | 	// repeated int64 keep_frames = 8
186 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Profile).keepFramesX) },
187 | 	// repeated int64 time_nanos = 9
188 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Profile).TimeNanos) },
189 | 	// repeated int64 duration_nanos = 10
190 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Profile).DurationNanos) },
191 | 	// optional string period_type = 11
192 | 	func(b *buffer, m message) error {
193 | 		x := new(ValueType)
194 | 		pp := m.(*Profile)
195 | 		pp.PeriodType = x
196 | 		return decodeMessage(b, x)
197 | 	},
198 | 	// repeated int64 period = 12
199 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Profile).Period) },
200 | 	// repeated int64 comment = 13
201 | 	func(b *buffer, m message) error { return decodeInt64s(b, &m.(*Profile).commentX) },
202 | 	// int64 defaultSampleType = 14
203 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Profile).defaultSampleTypeX) },
204 | }
205 | 
206 | // postDecode takes the unexported fields populated by decode (with
207 | // suffix X) and populates the corresponding exported fields.
208 | // The unexported fields are cleared up to facilitate testing.
209 | func (p *Profile) postDecode() error {
210 | 	var err error
211 | 
212 | 	mappings := make(map[uint64]*Mapping)
213 | 	for _, m := range p.Mapping {
214 | 		m.File, err = getString(p.stringTable, &m.fileX, err)
215 | 		m.BuildID, err = getString(p.stringTable, &m.buildIDX, err)
216 | 		mappings[m.ID] = m
217 | 	}
218 | 
219 | 	functions := make(map[uint64]*Function)
220 | 	for _, f := range p.Function {
221 | 		f.Name, err = getString(p.stringTable, &f.nameX, err)
222 | 		f.SystemName, err = getString(p.stringTable, &f.systemNameX, err)
223 | 		f.Filename, err = getString(p.stringTable, &f.filenameX, err)
224 | 		functions[f.ID] = f
225 | 	}
226 | 
227 | 	locations := make(map[uint64]*Location)
228 | 	for _, l := range p.Location {
229 | 		l.Mapping = mappings[l.mappingIDX]
230 | 		l.mappingIDX = 0
231 | 		for i, ln := range l.Line {
232 | 			if id := ln.functionIDX; id != 0 {
233 | 				l.Line[i].Function = functions[id]
234 | 				if l.Line[i].Function == nil {
235 | 					return fmt.Errorf("Function ID %d not found", id)
236 | 				}
237 | 				l.Line[i].functionIDX = 0
238 | 			}
239 | 		}
240 | 		locations[l.ID] = l
241 | 	}
242 | 
243 | 	for _, st := range p.SampleType {
244 | 		st.Type, err = getString(p.stringTable, &st.typeX, err)
245 | 		st.Unit, err = getString(p.stringTable, &st.unitX, err)
246 | 	}
247 | 
248 | 	for _, s := range p.Sample {
249 | 		labels := make(map[string][]string)
250 | 		numLabels := make(map[string][]int64)
251 | 		for _, l := range s.labelX {
252 | 			var key, value string
253 | 			key, err = getString(p.stringTable, &l.keyX, err)
254 | 			if l.strX != 0 {
255 | 				value, err = getString(p.stringTable, &l.strX, err)
256 | 				labels[key] = append(labels[key], value)
257 | 			} else {
258 | 				numLabels[key] = append(numLabels[key], l.numX)
259 | 			}
260 | 		}
261 | 		if len(labels) > 0 {
262 | 			s.Label = labels
263 | 		}
264 | 		if len(numLabels) > 0 {
265 | 			s.NumLabel = numLabels
266 | 		}
267 | 		s.Location = nil
268 | 		for _, lid := range s.locationIDX {
269 | 			s.Location = append(s.Location, locations[lid])
270 | 		}
271 | 		s.locationIDX = nil
272 | 	}
273 | 
274 | 	p.DropFrames, err = getString(p.stringTable, &p.dropFramesX, err)
275 | 	p.KeepFrames, err = getString(p.stringTable, &p.keepFramesX, err)
276 | 
277 | 	if pt := p.PeriodType; pt == nil {
278 | 		p.PeriodType = &ValueType{}
279 | 	}
280 | 
281 | 	if pt := p.PeriodType; pt != nil {
282 | 		pt.Type, err = getString(p.stringTable, &pt.typeX, err)
283 | 		pt.Unit, err = getString(p.stringTable, &pt.unitX, err)
284 | 	}
285 | 	for _, i := range p.commentX {
286 | 		var c string
287 | 		c, err = getString(p.stringTable, &i, err)
288 | 		p.Comments = append(p.Comments, c)
289 | 	}
290 | 
291 | 	p.commentX = nil
292 | 	p.DefaultSampleType, err = getString(p.stringTable, &p.defaultSampleTypeX, err)
293 | 	p.stringTable = nil
294 | 	return err
295 | }
296 | 
297 | func (p *ValueType) decoder() []decoder {
298 | 	return valueTypeDecoder
299 | }
300 | 
301 | func (p *ValueType) encode(b *buffer) {
302 | 	encodeInt64Opt(b, 1, p.typeX)
303 | 	encodeInt64Opt(b, 2, p.unitX)
304 | }
305 | 
306 | var valueTypeDecoder = []decoder{
307 | 	nil, // 0
308 | 	// optional int64 type = 1
309 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*ValueType).typeX) },
310 | 	// optional int64 unit = 2
311 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*ValueType).unitX) },
312 | }
313 | 
314 | func (p *Sample) decoder() []decoder {
315 | 	return sampleDecoder
316 | }
317 | 
318 | func (p *Sample) encode(b *buffer) {
319 | 	encodeUint64s(b, 1, p.locationIDX)
320 | 	for _, x := range p.Value {
321 | 		encodeInt64(b, 2, x)
322 | 	}
323 | 	for _, x := range p.labelX {
324 | 		encodeMessage(b, 3, x)
325 | 	}
326 | }
327 | 
328 | var sampleDecoder = []decoder{
329 | 	nil, // 0
330 | 	// repeated uint64 location = 1
331 | 	func(b *buffer, m message) error { return decodeUint64s(b, &m.(*Sample).locationIDX) },
332 | 	// repeated int64 value = 2
333 | 	func(b *buffer, m message) error { return decodeInt64s(b, &m.(*Sample).Value) },
334 | 	// repeated Label label = 3
335 | 	func(b *buffer, m message) error {
336 | 		s := m.(*Sample)
337 | 		n := len(s.labelX)
338 | 		s.labelX = append(s.labelX, Label{})
339 | 		return decodeMessage(b, &s.labelX[n])
340 | 	},
341 | }
342 | 
343 | func (p Label) decoder() []decoder {
344 | 	return labelDecoder
345 | }
346 | 
347 | func (p Label) encode(b *buffer) {
348 | 	encodeInt64Opt(b, 1, p.keyX)
349 | 	encodeInt64Opt(b, 2, p.strX)
350 | 	encodeInt64Opt(b, 3, p.numX)
351 | }
352 | 
353 | var labelDecoder = []decoder{
354 | 	nil, // 0
355 | 	// optional int64 key = 1
356 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Label).keyX) },
357 | 	// optional int64 str = 2
358 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Label).strX) },
359 | 	// optional int64 num = 3
360 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Label).numX) },
361 | }
362 | 
363 | func (p *Mapping) decoder() []decoder {
364 | 	return mappingDecoder
365 | }
366 | 
367 | func (p *Mapping) encode(b *buffer) {
368 | 	encodeUint64Opt(b, 1, p.ID)
369 | 	encodeUint64Opt(b, 2, p.Start)
370 | 	encodeUint64Opt(b, 3, p.Limit)
371 | 	encodeUint64Opt(b, 4, p.Offset)
372 | 	encodeInt64Opt(b, 5, p.fileX)
373 | 	encodeInt64Opt(b, 6, p.buildIDX)
374 | 	encodeBoolOpt(b, 7, p.HasFunctions)
375 | 	encodeBoolOpt(b, 8, p.HasFilenames)
376 | 	encodeBoolOpt(b, 9, p.HasLineNumbers)
377 | 	encodeBoolOpt(b, 10, p.HasInlineFrames)
378 | }
379 | 
380 | var mappingDecoder = []decoder{
381 | 	nil, // 0
382 | 	func(b *buffer, m message) error { return decodeUint64(b, &m.(*Mapping).ID) },            // optional uint64 id = 1
383 | 	func(b *buffer, m message) error { return decodeUint64(b, &m.(*Mapping).Start) },         // optional uint64 memory_offset = 2
384 | 	func(b *buffer, m message) error { return decodeUint64(b, &m.(*Mapping).Limit) },         // optional uint64 memory_limit = 3
385 | 	func(b *buffer, m message) error { return decodeUint64(b, &m.(*Mapping).Offset) },        // optional uint64 file_offset = 4
386 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Mapping).fileX) },          // optional int64 filename = 5
387 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Mapping).buildIDX) },       // optional int64 build_id = 6
388 | 	func(b *buffer, m message) error { return decodeBool(b, &m.(*Mapping).HasFunctions) },    // optional bool has_functions = 7
389 | 	func(b *buffer, m message) error { return decodeBool(b, &m.(*Mapping).HasFilenames) },    // optional bool has_filenames = 8
390 | 	func(b *buffer, m message) error { return decodeBool(b, &m.(*Mapping).HasLineNumbers) },  // optional bool has_line_numbers = 9
391 | 	func(b *buffer, m message) error { return decodeBool(b, &m.(*Mapping).HasInlineFrames) }, // optional bool has_inline_frames = 10
392 | }
393 | 
394 | func (p *Location) decoder() []decoder {
395 | 	return locationDecoder
396 | }
397 | 
398 | func (p *Location) encode(b *buffer) {
399 | 	encodeUint64Opt(b, 1, p.ID)
400 | 	encodeUint64Opt(b, 2, p.mappingIDX)
401 | 	encodeUint64Opt(b, 3, p.Address)
402 | 	for i := range p.Line {
403 | 		encodeMessage(b, 4, &p.Line[i])
404 | 	}
405 | }
406 | 
407 | var locationDecoder = []decoder{
408 | 	nil, // 0
409 | 	func(b *buffer, m message) error { return decodeUint64(b, &m.(*Location).ID) },         // optional uint64 id = 1;
410 | 	func(b *buffer, m message) error { return decodeUint64(b, &m.(*Location).mappingIDX) }, // optional uint64 mapping_id = 2;
411 | 	func(b *buffer, m message) error { return decodeUint64(b, &m.(*Location).Address) },    // optional uint64 address = 3;
412 | 	func(b *buffer, m message) error { // repeated Line line = 4
413 | 		pp := m.(*Location)
414 | 		n := len(pp.Line)
415 | 		pp.Line = append(pp.Line, Line{})
416 | 		return decodeMessage(b, &pp.Line[n])
417 | 	},
418 | }
419 | 
420 | func (p *Line) decoder() []decoder {
421 | 	return lineDecoder
422 | }
423 | 
424 | func (p *Line) encode(b *buffer) {
425 | 	encodeUint64Opt(b, 1, p.functionIDX)
426 | 	encodeInt64Opt(b, 2, p.Line)
427 | }
428 | 
429 | var lineDecoder = []decoder{
430 | 	nil, // 0
431 | 	// optional uint64 function_id = 1
432 | 	func(b *buffer, m message) error { return decodeUint64(b, &m.(*Line).functionIDX) },
433 | 	// optional int64 line = 2
434 | 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Line).Line) },
435 | }
436 | 
437 | func (p *Function) decoder() []decoder {
438 | 	return functionDecoder
439 | }
440 | 
441 | func (p *Function) encode(b *buffer) {
442 | 	encodeUint64Opt(b, 1, p.ID)
443 | 	encodeInt64Opt(b, 2, p.nameX)
444 | 	encodeInt64Opt(b, 3, p.systemNameX)
445 | 	encodeInt64Opt(b, 4, p.filenameX)
446 | 	encodeInt64Opt(b, 5, p.StartLine)
447 | }
448 | 
449 | var functionDecoder = []decoder{
450 | 	nil, // 0
451 | 	// optional uint64 id = 1
[TRUNCATED]
```

framework/rest/profile/filter.go
```
1 | // Copyright 2014 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | // Implements methods to filter samples from profiles.
6 | 
7 | package profile
8 | 
9 | import "regexp"
10 | 
11 | // FilterSamplesByName filters the samples in a profile and only keeps
12 | // samples where at least one frame matches focus but none match ignore.
13 | // Returns true is the corresponding regexp matched at least one sample.
14 | func (p *Profile) FilterSamplesByName(focus, ignore, hide *regexp.Regexp) (fm, im, hm bool) {
15 | 	focusOrIgnore := make(map[uint64]bool)
16 | 	hidden := make(map[uint64]bool)
17 | 	for _, l := range p.Location {
18 | 		if ignore != nil && l.matchesName(ignore) {
19 | 			im = true
20 | 			focusOrIgnore[l.ID] = false
21 | 		} else if focus == nil || l.matchesName(focus) {
22 | 			fm = true
23 | 			focusOrIgnore[l.ID] = true
24 | 		}
25 | 		if hide != nil && l.matchesName(hide) {
26 | 			hm = true
27 | 			l.Line = l.unmatchedLines(hide)
28 | 			if len(l.Line) == 0 {
29 | 				hidden[l.ID] = true
30 | 			}
31 | 		}
32 | 	}
33 | 
34 | 	s := make([]*Sample, 0, len(p.Sample))
35 | 	for _, sample := range p.Sample {
36 | 		if focusedAndNotIgnored(sample.Location, focusOrIgnore) {
37 | 			if len(hidden) > 0 {
38 | 				var locs []*Location
39 | 				for _, loc := range sample.Location {
40 | 					if !hidden[loc.ID] {
41 | 						locs = append(locs, loc)
42 | 					}
43 | 				}
44 | 				if len(locs) == 0 {
45 | 					// Remove sample with no locations (by not adding it to s).
46 | 					continue
47 | 				}
48 | 				sample.Location = locs
49 | 			}
50 | 			s = append(s, sample)
51 | 		}
52 | 	}
53 | 	p.Sample = s
54 | 
55 | 	return
56 | }
57 | 
58 | // matchesName reports whether the function name or file in the
59 | // location matches the regular expression.
60 | func (loc *Location) matchesName(re *regexp.Regexp) bool {
61 | 	for _, ln := range loc.Line {
62 | 		if fn := ln.Function; fn != nil {
63 | 			if re.MatchString(fn.Name) {
64 | 				return true
65 | 			}
66 | 			if re.MatchString(fn.Filename) {
67 | 				return true
68 | 			}
69 | 		}
70 | 	}
71 | 	return false
72 | }
73 | 
74 | // unmatchedLines returns the lines in the location that do not match
75 | // the regular expression.
76 | func (loc *Location) unmatchedLines(re *regexp.Regexp) []Line {
77 | 	var lines []Line
78 | 	for _, ln := range loc.Line {
79 | 		if fn := ln.Function; fn != nil {
80 | 			if re.MatchString(fn.Name) {
81 | 				continue
82 | 			}
83 | 			if re.MatchString(fn.Filename) {
84 | 				continue
85 | 			}
86 | 		}
87 | 		lines = append(lines, ln)
88 | 	}
89 | 	return lines
90 | }
91 | 
92 | // focusedAndNotIgnored looks up a slice of ids against a map of
93 | // focused/ignored locations. The map only contains locations that are
94 | // explicitly focused or ignored. Returns whether there is at least
95 | // one focused location but no ignored locations.
96 | func focusedAndNotIgnored(locs []*Location, m map[uint64]bool) bool {
97 | 	var f bool
98 | 	for _, loc := range locs {
99 | 		if focus, focusOrIgnore := m[loc.ID]; focusOrIgnore {
100 | 			if focus {
101 | 				// Found focused location. Must keep searching in case there
102 | 				// is an ignored one as well.
103 | 				f = true
104 | 			} else {
105 | 				// Found ignored location. Can return false right away.
106 | 				return false
107 | 			}
108 | 		}
109 | 	}
110 | 	return f
111 | }
112 | 
113 | // TagMatch selects tags for filtering
114 | type TagMatch func(key, val string, nval int64) bool
115 | 
116 | // FilterSamplesByTag removes all samples from the profile, except
117 | // those that match focus and do not match the ignore regular
118 | // expression.
119 | func (p *Profile) FilterSamplesByTag(focus, ignore TagMatch) (fm, im bool) {
120 | 	samples := make([]*Sample, 0, len(p.Sample))
121 | 	for _, s := range p.Sample {
122 | 		focused, ignored := focusedSample(s, focus, ignore)
123 | 		fm = fm || focused
124 | 		im = im || ignored
125 | 		if focused && !ignored {
126 | 			samples = append(samples, s)
127 | 		}
128 | 	}
129 | 	p.Sample = samples
130 | 	return
131 | }
132 | 
133 | // focusedSample checks a sample against focus and ignore regexps.
134 | // Returns whether the focus/ignore regexps match any tags.
135 | func focusedSample(s *Sample, focus, ignore TagMatch) (fm, im bool) {
136 | 	fm = focus == nil
137 | 	for key, vals := range s.Label {
138 | 		for _, val := range vals {
139 | 			if ignore != nil && ignore(key, val, 0) {
140 | 				im = true
141 | 			}
142 | 			if !fm && focus(key, val, 0) {
143 | 				fm = true
144 | 			}
145 | 		}
146 | 	}
147 | 	for key, vals := range s.NumLabel {
148 | 		for _, val := range vals {
149 | 			if ignore != nil && ignore(key, "", val) {
150 | 				im = true
151 | 			}
152 | 			if !fm && focus(key, "", val) {
153 | 				fm = true
154 | 			}
155 | 		}
156 | 	}
157 | 	return fm, im
158 | }
```

framework/rest/profile/legacy_profile.go
```
1 | // Copyright 2014 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | // This file implements parsers to convert legacy profiles into the
6 | // profile.proto format.
7 | 
8 | package profile
9 | 
10 | import (
11 | 	"bufio"
12 | 	"bytes"
13 | 	"fmt"
14 | 	"io"
15 | 	"math"
16 | 	"strconv"
17 | 	"strings"
18 | 
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest/lazyregexp"
20 | )
21 | 
22 | var (
23 | 	countStartRE = lazyregexp.New(`\A(\w+) profile: total \d+\n\z`)
24 | 	countRE      = lazyregexp.New(`\A(\d+) @(( 0x[0-9a-f]+)+)\n\z`)
25 | 
26 | 	heapHeaderRE = lazyregexp.New(`heap profile: *(\d+): *(\d+) *\[ *(\d+): *(\d+) *\] *@ *(heap[_a-z0-9]*)/?(\d*)`)
27 | 	heapSampleRE = lazyregexp.New(`(-?\d+): *(-?\d+) *\[ *(\d+): *(\d+) *] @([ x0-9a-f]*)`)
28 | 
29 | 	contentionSampleRE = lazyregexp.New(`(\d+) *(\d+) @([ x0-9a-f]*)`)
30 | 
31 | 	hexNumberRE = lazyregexp.New(`0x[0-9a-f]+`)
32 | 
33 | 	growthHeaderRE = lazyregexp.New(`heap profile: *(\d+): *(\d+) *\[ *(\d+): *(\d+) *\] @ growthz`)
34 | 
35 | 	fragmentationHeaderRE = lazyregexp.New(`heap profile: *(\d+): *(\d+) *\[ *(\d+): *(\d+) *\] @ fragmentationz`)
36 | 
37 | 	threadzStartRE = lazyregexp.New(`--- threadz \d+ ---`)
38 | 	threadStartRE  = lazyregexp.New(`--- Thread ([[:xdigit:]]+) \(name: (.*)/(\d+)\) stack: ---`)
39 | 
40 | 	procMapsRE = lazyregexp.New(`([[:xdigit:]]+)-([[:xdigit:]]+)\s+([-rwxp]+)\s+([[:xdigit:]]+)\s+([[:xdigit:]]+):([[:xdigit:]]+)\s+([[:digit:]]+)\s*(\S+)?`)
41 | 
42 | 	briefMapsRE = lazyregexp.New(`\s*([[:xdigit:]]+)-([[:xdigit:]]+):\s*(\S+)(\s.*@)?([[:xdigit:]]+)?`)
43 | 
44 | 	// LegacyHeapAllocated instructs the heapz parsers to use the
45 | 	// allocated memory stats instead of the default in-use memory. Note
46 | 	// that tcmalloc doesn't provide all allocated memory, only in-use
47 | 	// stats.
48 | 	LegacyHeapAllocated bool
49 | )
50 | 
51 | func isSpaceOrComment(line string) bool {
52 | 	trimmed := strings.TrimSpace(line)
53 | 	return len(trimmed) == 0 || trimmed[0] == '#'
54 | }
55 | 
56 | // parseGoCount parses a Go count profile (e.g., threadcreate or
57 | // goroutine) and returns a new Profile.
58 | func parseGoCount(b []byte) (*Profile, error) {
59 | 	r := bytes.NewBuffer(b)
60 | 
61 | 	var line string
62 | 	var err error
63 | 	for {
64 | 		// Skip past comments and empty lines seeking a real header.
65 | 		line, err = r.ReadString('\n')
66 | 		if err != nil {
67 | 			return nil, err
68 | 		}
69 | 		if !isSpaceOrComment(line) {
70 | 			break
71 | 		}
72 | 	}
73 | 
74 | 	m := countStartRE.FindStringSubmatch(line)
75 | 	if m == nil {
76 | 		return nil, errUnrecognized
77 | 	}
78 | 	profileType := m[1]
79 | 	p := &Profile{
80 | 		PeriodType: &ValueType{Type: profileType, Unit: "count"},
81 | 		Period:     1,
82 | 		SampleType: []*ValueType{{Type: profileType, Unit: "count"}},
83 | 	}
84 | 	locations := make(map[uint64]*Location)
85 | 	for {
86 | 		line, err = r.ReadString('\n')
87 | 		if err != nil {
88 | 			if err == io.EOF {
89 | 				break
90 | 			}
91 | 			return nil, err
92 | 		}
93 | 		if isSpaceOrComment(line) {
94 | 			continue
95 | 		}
96 | 		if strings.HasPrefix(line, "---") {
97 | 			break
98 | 		}
99 | 		m := countRE.FindStringSubmatch(line)
100 | 		if m == nil {
101 | 			return nil, errMalformed
102 | 		}
103 | 		n, err := strconv.ParseInt(m[1], 0, 64)
104 | 		if err != nil {
105 | 			return nil, errMalformed
106 | 		}
107 | 		fields := strings.Fields(m[2])
108 | 		locs := make([]*Location, 0, len(fields))
109 | 		for _, stk := range fields {
110 | 			addr, err := strconv.ParseUint(stk, 0, 64)
111 | 			if err != nil {
112 | 				return nil, errMalformed
113 | 			}
114 | 			// Adjust all frames by -1 to land on the call instruction.
115 | 			addr--
116 | 			loc := locations[addr]
117 | 			if loc == nil {
118 | 				loc = &Location{
119 | 					Address: addr,
120 | 				}
121 | 				locations[addr] = loc
122 | 				p.Location = append(p.Location, loc)
123 | 			}
124 | 			locs = append(locs, loc)
125 | 		}
126 | 		p.Sample = append(p.Sample, &Sample{
127 | 			Location: locs,
128 | 			Value:    []int64{n},
129 | 		})
130 | 	}
131 | 
132 | 	if err = parseAdditionalSections(strings.TrimSpace(line), r, p); err != nil {
133 | 		return nil, err
134 | 	}
135 | 	return p, nil
136 | }
137 | 
138 | // remapLocationIDs ensures there is a location for each address
139 | // referenced by a sample, and remaps the samples to point to the new
140 | // location ids.
141 | func (p *Profile) remapLocationIDs() {
142 | 	seen := make(map[*Location]bool, len(p.Location))
143 | 	var locs []*Location
144 | 
145 | 	for _, s := range p.Sample {
146 | 		for _, l := range s.Location {
147 | 			if seen[l] {
148 | 				continue
149 | 			}
150 | 			l.ID = uint64(len(locs) + 1)
151 | 			locs = append(locs, l)
152 | 			seen[l] = true
153 | 		}
154 | 	}
155 | 	p.Location = locs
156 | }
157 | 
158 | func (p *Profile) remapFunctionIDs() {
159 | 	seen := make(map[*Function]bool, len(p.Function))
160 | 	var fns []*Function
161 | 
162 | 	for _, l := range p.Location {
163 | 		for _, ln := range l.Line {
164 | 			fn := ln.Function
165 | 			if fn == nil || seen[fn] {
166 | 				continue
167 | 			}
168 | 			fn.ID = uint64(len(fns) + 1)
169 | 			fns = append(fns, fn)
170 | 			seen[fn] = true
171 | 		}
172 | 	}
173 | 	p.Function = fns
174 | }
175 | 
176 | // remapMappingIDs matches location addresses with existing mappings
177 | // and updates them appropriately. This is O(N*M), if this ever shows
178 | // up as a bottleneck, evaluate sorting the mappings and doing a
179 | // binary search, which would make it O(N*log(M)).
180 | func (p *Profile) remapMappingIDs() {
181 | 	if len(p.Mapping) == 0 {
182 | 		return
183 | 	}
184 | 
185 | 	// Some profile handlers will incorrectly set regions for the main
186 | 	// executable if its section is remapped. Fix them through heuristics.
187 | 
188 | 	// Remove the initial mapping if named '/anon_hugepage' and has a
189 | 	// consecutive adjacent mapping.
190 | 	if m := p.Mapping[0]; strings.HasPrefix(m.File, "/anon_hugepage") {
191 | 		if len(p.Mapping) > 1 && m.Limit == p.Mapping[1].Start {
192 | 			p.Mapping = p.Mapping[1:]
193 | 		}
194 | 	}
195 | 
196 | 	for _, l := range p.Location {
197 | 		if a := l.Address; a != 0 {
198 | 			for _, m := range p.Mapping {
199 | 				if m.Start <= a && a < m.Limit {
200 | 					l.Mapping = m
201 | 					break
202 | 				}
203 | 			}
204 | 		}
205 | 	}
206 | 
207 | 	// Reset all mapping IDs.
208 | 	for i, m := range p.Mapping {
209 | 		m.ID = uint64(i + 1)
210 | 	}
211 | }
212 | 
213 | var cpuInts = []func([]byte) (uint64, []byte){
214 | 	get32l,
215 | 	get32b,
216 | 	get64l,
217 | 	get64b,
218 | }
219 | 
220 | func get32l(b []byte) (uint64, []byte) {
221 | 	if len(b) < 4 {
222 | 		return 0, nil
223 | 	}
224 | 	return uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24, b[4:]
225 | }
226 | 
227 | func get32b(b []byte) (uint64, []byte) {
228 | 	if len(b) < 4 {
229 | 		return 0, nil
230 | 	}
231 | 	return uint64(b[3]) | uint64(b[2])<<8 | uint64(b[1])<<16 | uint64(b[0])<<24, b[4:]
232 | }
233 | 
234 | func get64l(b []byte) (uint64, []byte) {
235 | 	if len(b) < 8 {
236 | 		return 0, nil
237 | 	}
238 | 	return uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56, b[8:]
239 | }
240 | 
241 | func get64b(b []byte) (uint64, []byte) {
242 | 	if len(b) < 8 {
243 | 		return 0, nil
244 | 	}
245 | 	return uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 | uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56, b[8:]
246 | }
247 | 
248 | // ParseTracebacks parses a set of tracebacks and returns a newly
249 | // populated profile. It will accept any text file and generate a
250 | // Profile out of it with any hex addresses it can identify, including
251 | // a process map if it can recognize one. Each sample will include a
252 | // tag "source" with the addresses recognized in string format.
253 | func ParseTracebacks(b []byte) (*Profile, error) {
254 | 	r := bytes.NewBuffer(b)
255 | 
256 | 	p := &Profile{
257 | 		PeriodType: &ValueType{Type: "trace", Unit: "count"},
258 | 		Period:     1,
259 | 		SampleType: []*ValueType{
260 | 			{Type: "trace", Unit: "count"},
261 | 		},
262 | 	}
263 | 
264 | 	var sources []string
265 | 	var sloc []*Location
266 | 
267 | 	locs := make(map[uint64]*Location)
268 | 	for {
269 | 		l, err := r.ReadString('\n')
270 | 		if err != nil {
271 | 			if err != io.EOF {
272 | 				return nil, err
273 | 			}
274 | 			if l == "" {
275 | 				break
276 | 			}
277 | 		}
278 | 		if sectionTrigger(l) == memoryMapSection {
279 | 			break
280 | 		}
281 | 		if s, addrs := extractHexAddresses(l); len(s) > 0 {
282 | 			for _, addr := range addrs {
283 | 				// Addresses from stack traces point to the next instruction after
284 | 				// each call. Adjust by -1 to land somewhere on the actual call.
285 | 				addr--
286 | 				loc := locs[addr]
287 | 				if locs[addr] == nil {
288 | 					loc = &Location{
289 | 						Address: addr,
290 | 					}
291 | 					p.Location = append(p.Location, loc)
292 | 					locs[addr] = loc
293 | 				}
294 | 				sloc = append(sloc, loc)
295 | 			}
296 | 
297 | 			sources = append(sources, s...)
298 | 		} else {
299 | 			if len(sources) > 0 || len(sloc) > 0 {
300 | 				addTracebackSample(sloc, sources, p)
301 | 				sloc, sources = nil, nil
302 | 			}
303 | 		}
304 | 	}
305 | 
306 | 	// Add final sample to save any leftover data.
307 | 	if len(sources) > 0 || len(sloc) > 0 {
308 | 		addTracebackSample(sloc, sources, p)
309 | 	}
310 | 
311 | 	if err := p.ParseMemoryMap(r); err != nil {
312 | 		return nil, err
313 | 	}
314 | 	return p, nil
315 | }
316 | 
317 | func addTracebackSample(l []*Location, s []string, p *Profile) {
318 | 	p.Sample = append(p.Sample,
319 | 		&Sample{
320 | 			Value:    []int64{1},
321 | 			Location: l,
322 | 			Label:    map[string][]string{"source": s},
323 | 		})
324 | }
325 | 
326 | // parseCPU parses a profilez legacy profile and returns a newly
327 | // populated Profile.
328 | //
329 | // The general format for profilez samples is a sequence of words in
330 | // binary format. The first words are a header with the following data:
331 | //
332 | //	1st word -- 0
333 | //	2nd word -- 3
334 | //	3rd word -- 0 if a c++ application, 1 if a java application.
335 | //	4th word -- Sampling period (in microseconds).
336 | //	5th word -- Padding.
337 | func parseCPU(b []byte) (*Profile, error) {
338 | 	var parse func([]byte) (uint64, []byte)
339 | 	var n1, n2, n3, n4, n5 uint64
340 | 	for _, parse = range cpuInts {
341 | 		var tmp []byte
342 | 		n1, tmp = parse(b)
343 | 		n2, tmp = parse(tmp)
344 | 		n3, tmp = parse(tmp)
345 | 		n4, tmp = parse(tmp)
346 | 		n5, tmp = parse(tmp)
347 | 
348 | 		if tmp != nil && n1 == 0 && n2 == 3 && n3 == 0 && n4 > 0 && n5 == 0 {
349 | 			b = tmp
350 | 			return cpuProfile(b, int64(n4), parse)
351 | 		}
352 | 	}
353 | 	return nil, errUnrecognized
354 | }
355 | 
356 | // cpuProfile returns a new Profile from C++ profilez data.
357 | // b is the profile bytes after the header, period is the profiling
358 | // period, and parse is a function to parse 8-byte chunks from the
359 | // profile in its native endianness.
360 | func cpuProfile(b []byte, period int64, parse func(b []byte) (uint64, []byte)) (*Profile, error) {
361 | 	p := &Profile{
362 | 		Period:     period * 1000,
363 | 		PeriodType: &ValueType{Type: "cpu", Unit: "nanoseconds"},
364 | 		SampleType: []*ValueType{
365 | 			{Type: "samples", Unit: "count"},
366 | 			{Type: "cpu", Unit: "nanoseconds"},
367 | 		},
368 | 	}
369 | 	var err error
370 | 	if b, _, err = parseCPUSamples(b, parse, true, p); err != nil {
371 | 		return nil, err
372 | 	}
373 | 
374 | 	// If all samples have the same second-to-the-bottom frame, it
375 | 	// strongly suggests that it is an uninteresting artifact of
376 | 	// measurement -- a stack frame pushed by the signal handler. The
377 | 	// bottom frame is always correct as it is picked up from the signal
378 | 	// structure, not the stack. Check if this is the case and if so,
379 | 	// remove.
380 | 	if len(p.Sample) > 1 && len(p.Sample[0].Location) > 1 {
381 | 		allSame := true
382 | 		id1 := p.Sample[0].Location[1].Address
383 | 		for _, s := range p.Sample {
384 | 			if len(s.Location) < 2 || id1 != s.Location[1].Address {
385 | 				allSame = false
386 | 				break
387 | 			}
388 | 		}
389 | 		if allSame {
390 | 			for _, s := range p.Sample {
391 | 				s.Location = append(s.Location[:1], s.Location[2:]...)
392 | 			}
393 | 		}
394 | 	}
395 | 
396 | 	if err := p.ParseMemoryMap(bytes.NewBuffer(b)); err != nil {
397 | 		return nil, err
398 | 	}
399 | 	return p, nil
400 | }
401 | 
402 | // parseCPUSamples parses a collection of profilez samples from a
403 | // profile.
404 | //
405 | // profilez samples are a repeated sequence of stack frames of the
406 | // form:
407 | //
408 | //	1st word -- The number of times this stack was encountered.
409 | //	2nd word -- The size of the stack (StackSize).
410 | //	3rd word -- The first address on the stack.
411 | //	...
412 | //	StackSize + 2 -- The last address on the stack
413 | //
414 | // The last stack trace is of the form:
415 | //
416 | //	1st word -- 0
417 | //	2nd word -- 1
418 | //	3rd word -- 0
419 | //
420 | // Addresses from stack traces may point to the next instruction after
421 | // each call. Optionally adjust by -1 to land somewhere on the actual
422 | // call (except for the leaf, which is not a call).
423 | func parseCPUSamples(b []byte, parse func(b []byte) (uint64, []byte), adjust bool, p *Profile) ([]byte, map[uint64]*Location, error) {
424 | 	locs := make(map[uint64]*Location)
425 | 	for len(b) > 0 {
426 | 		var count, nstk uint64
427 | 		count, b = parse(b)
428 | 		nstk, b = parse(b)
429 | 		if b == nil || nstk > uint64(len(b)/4) {
430 | 			return nil, nil, errUnrecognized
431 | 		}
432 | 		var sloc []*Location
433 | 		addrs := make([]uint64, nstk)
434 | 		for i := 0; i < int(nstk); i++ {
435 | 			addrs[i], b = parse(b)
436 | 		}
437 | 
438 | 		if count == 0 && nstk == 1 && addrs[0] == 0 {
439 | 			// End of data marker
440 | 			break
441 | 		}
442 | 		for i, addr := range addrs {
443 | 			if adjust && i > 0 {
444 | 				addr--
445 | 			}
446 | 			loc := locs[addr]
447 | 			if loc == nil {
448 | 				loc = &Location{
449 | 					Address: addr,
450 | 				}
451 | 				locs[addr] = loc
452 | 				p.Location = append(p.Location, loc)
453 | 			}
454 | 			sloc = append(sloc, loc)
455 | 		}
456 | 		p.Sample = append(p.Sample,
457 | 			&Sample{
458 | 				Value:    []int64{int64(count), int64(count) * p.Period},
459 | 				Location: sloc,
460 | 			})
461 | 	}
462 | 	// Reached the end without finding the EOD marker.
463 | 	return b, locs, nil
464 | }
465 | 
466 | // parseHeap parses a heapz legacy or a growthz profile and
[TRUNCATED]
```

framework/rest/profile/merge.go
```
1 | // Copyright 2019 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | package profile
6 | 
7 | import (
8 | 	"fmt"
9 | 	"sort"
10 | 	"strconv"
11 | 	"strings"
12 | )
13 | 
14 | // Merge merges all the profiles in profs into a single Profile.
15 | // Returns a new profile independent of the input profiles. The merged
16 | // profile is compacted to eliminate unused samples, locations,
17 | // functions and mappings. Profiles must have identical profile sample
18 | // and period types or the merge will fail. profile.Period of the
19 | // resulting profile will be the maximum of all profiles, and
20 | // profile.TimeNanos will be the earliest nonzero one.
21 | func Merge(srcs []*Profile) (*Profile, error) {
22 | 	if len(srcs) == 0 {
23 | 		return nil, fmt.Errorf("no profiles to merge")
24 | 	}
25 | 	p, err := combineHeaders(srcs)
26 | 	if err != nil {
27 | 		return nil, err
28 | 	}
29 | 
30 | 	pm := &profileMerger{
31 | 		p:         p,
32 | 		samples:   make(map[sampleKey]*Sample, len(srcs[0].Sample)),
33 | 		locations: make(map[locationKey]*Location, len(srcs[0].Location)),
34 | 		functions: make(map[functionKey]*Function, len(srcs[0].Function)),
35 | 		mappings:  make(map[mappingKey]*Mapping, len(srcs[0].Mapping)),
36 | 	}
37 | 
38 | 	for _, src := range srcs {
39 | 		// Clear the profile-specific hash tables
40 | 		pm.locationsByID = make(map[uint64]*Location, len(src.Location))
41 | 		pm.functionsByID = make(map[uint64]*Function, len(src.Function))
42 | 		pm.mappingsByID = make(map[uint64]mapInfo, len(src.Mapping))
43 | 
44 | 		if len(pm.mappings) == 0 && len(src.Mapping) > 0 {
45 | 			// The Mapping list has the property that the first mapping
46 | 			// represents the main binary. Take the first Mapping we see,
47 | 			// otherwise the operations below will add mappings in an
48 | 			// arbitrary order.
49 | 			pm.mapMapping(src.Mapping[0])
50 | 		}
51 | 
52 | 		for _, s := range src.Sample {
53 | 			if !isZeroSample(s) {
54 | 				pm.mapSample(s)
55 | 			}
56 | 		}
57 | 	}
58 | 
59 | 	for _, s := range p.Sample {
60 | 		if isZeroSample(s) {
61 | 			// If there are any zero samples, re-merge the profile to GC
62 | 			// them.
63 | 			return Merge([]*Profile{p})
64 | 		}
65 | 	}
66 | 
67 | 	return p, nil
68 | }
69 | 
70 | // Normalize normalizes the source profile by multiplying each value in profile by the
71 | // ratio of the sum of the base profile's values of that sample type to the sum of the
72 | // source profile's value of that sample type.
73 | func (p *Profile) Normalize(pb *Profile) error {
74 | 
75 | 	if err := p.compatible(pb); err != nil {
76 | 		return err
77 | 	}
78 | 
79 | 	baseVals := make([]int64, len(p.SampleType))
80 | 	for _, s := range pb.Sample {
81 | 		for i, v := range s.Value {
82 | 			baseVals[i] += v
83 | 		}
84 | 	}
85 | 
86 | 	srcVals := make([]int64, len(p.SampleType))
87 | 	for _, s := range p.Sample {
88 | 		for i, v := range s.Value {
89 | 			srcVals[i] += v
90 | 		}
91 | 	}
92 | 
93 | 	normScale := make([]float64, len(baseVals))
94 | 	for i := range baseVals {
95 | 		if srcVals[i] == 0 {
96 | 			normScale[i] = 0.0
97 | 		} else {
98 | 			normScale[i] = float64(baseVals[i]) / float64(srcVals[i])
99 | 		}
100 | 	}
101 | 	p.ScaleN(normScale)
102 | 	return nil
103 | }
104 | 
105 | func isZeroSample(s *Sample) bool {
106 | 	for _, v := range s.Value {
107 | 		if v != 0 {
108 | 			return false
109 | 		}
110 | 	}
111 | 	return true
112 | }
113 | 
114 | type profileMerger struct {
115 | 	p *Profile
116 | 
117 | 	// Memoization tables within a profile.
118 | 	locationsByID map[uint64]*Location
119 | 	functionsByID map[uint64]*Function
120 | 	mappingsByID  map[uint64]mapInfo
121 | 
122 | 	// Memoization tables for profile entities.
123 | 	samples   map[sampleKey]*Sample
124 | 	locations map[locationKey]*Location
125 | 	functions map[functionKey]*Function
126 | 	mappings  map[mappingKey]*Mapping
127 | }
128 | 
129 | type mapInfo struct {
130 | 	m      *Mapping
131 | 	offset int64
132 | }
133 | 
134 | func (pm *profileMerger) mapSample(src *Sample) *Sample {
135 | 	s := &Sample{
136 | 		Location: make([]*Location, len(src.Location)),
137 | 		Value:    make([]int64, len(src.Value)),
138 | 		Label:    make(map[string][]string, len(src.Label)),
139 | 		NumLabel: make(map[string][]int64, len(src.NumLabel)),
140 | 		NumUnit:  make(map[string][]string, len(src.NumLabel)),
141 | 	}
142 | 	for i, l := range src.Location {
143 | 		s.Location[i] = pm.mapLocation(l)
144 | 	}
145 | 	for k, v := range src.Label {
146 | 		vv := make([]string, len(v))
147 | 		copy(vv, v)
148 | 		s.Label[k] = vv
149 | 	}
150 | 	for k, v := range src.NumLabel {
151 | 		u := src.NumUnit[k]
152 | 		vv := make([]int64, len(v))
153 | 		uu := make([]string, len(u))
154 | 		copy(vv, v)
155 | 		copy(uu, u)
156 | 		s.NumLabel[k] = vv
157 | 		s.NumUnit[k] = uu
158 | 	}
159 | 	// Check memoization table. Must be done on the remapped location to
160 | 	// account for the remapped mapping. Add current values to the
161 | 	// existing sample.
162 | 	k := s.key()
163 | 	if ss, ok := pm.samples[k]; ok {
164 | 		for i, v := range src.Value {
165 | 			ss.Value[i] += v
166 | 		}
167 | 		return ss
168 | 	}
169 | 	copy(s.Value, src.Value)
170 | 	pm.samples[k] = s
171 | 	pm.p.Sample = append(pm.p.Sample, s)
172 | 	return s
173 | }
174 | 
175 | // key generates sampleKey to be used as a key for maps.
176 | func (sample *Sample) key() sampleKey {
177 | 	ids := make([]string, len(sample.Location))
178 | 	for i, l := range sample.Location {
179 | 		ids[i] = strconv.FormatUint(l.ID, 16)
180 | 	}
181 | 
182 | 	labels := make([]string, 0, len(sample.Label))
183 | 	for k, v := range sample.Label {
184 | 		labels = append(labels, fmt.Sprintf("%q%q", k, v))
185 | 	}
186 | 	sort.Strings(labels)
187 | 
188 | 	numlabels := make([]string, 0, len(sample.NumLabel))
189 | 	for k, v := range sample.NumLabel {
190 | 		numlabels = append(numlabels, fmt.Sprintf("%q%x%x", k, v, sample.NumUnit[k]))
191 | 	}
192 | 	sort.Strings(numlabels)
193 | 
194 | 	return sampleKey{
195 | 		strings.Join(ids, "|"),
196 | 		strings.Join(labels, ""),
197 | 		strings.Join(numlabels, ""),
198 | 	}
199 | }
200 | 
201 | type sampleKey struct {
202 | 	locations string
203 | 	labels    string
204 | 	numlabels string
205 | }
206 | 
207 | func (pm *profileMerger) mapLocation(src *Location) *Location {
208 | 	if src == nil {
209 | 		return nil
210 | 	}
211 | 
212 | 	if l, ok := pm.locationsByID[src.ID]; ok {
213 | 		pm.locationsByID[src.ID] = l
214 | 		return l
215 | 	}
216 | 
217 | 	mi := pm.mapMapping(src.Mapping)
218 | 	l := &Location{
219 | 		ID:       uint64(len(pm.p.Location) + 1),
220 | 		Mapping:  mi.m,
221 | 		Address:  uint64(int64(src.Address) + mi.offset),
222 | 		Line:     make([]Line, len(src.Line)),
223 | 		IsFolded: src.IsFolded,
224 | 	}
225 | 	for i, ln := range src.Line {
226 | 		l.Line[i] = pm.mapLine(ln)
227 | 	}
228 | 	// Check memoization table. Must be done on the remapped location to
229 | 	// account for the remapped mapping ID.
230 | 	k := l.key()
231 | 	if ll, ok := pm.locations[k]; ok {
232 | 		pm.locationsByID[src.ID] = ll
233 | 		return ll
234 | 	}
235 | 	pm.locationsByID[src.ID] = l
236 | 	pm.locations[k] = l
237 | 	pm.p.Location = append(pm.p.Location, l)
238 | 	return l
239 | }
240 | 
241 | // key generates locationKey to be used as a key for maps.
242 | func (l *Location) key() locationKey {
243 | 	key := locationKey{
244 | 		addr:     l.Address,
245 | 		isFolded: l.IsFolded,
246 | 	}
247 | 	if l.Mapping != nil {
248 | 		// Normalizes address to handle address space randomization.
249 | 		key.addr -= l.Mapping.Start
250 | 		key.mappingID = l.Mapping.ID
251 | 	}
252 | 	lines := make([]string, len(l.Line)*2)
253 | 	for i, line := range l.Line {
254 | 		if line.Function != nil {
255 | 			lines[i*2] = strconv.FormatUint(line.Function.ID, 16)
256 | 		}
257 | 		lines[i*2+1] = strconv.FormatInt(line.Line, 16)
258 | 	}
259 | 	key.lines = strings.Join(lines, "|")
260 | 	return key
261 | }
262 | 
263 | type locationKey struct {
264 | 	addr, mappingID uint64
265 | 	lines           string
266 | 	isFolded        bool
267 | }
268 | 
269 | func (pm *profileMerger) mapMapping(src *Mapping) mapInfo {
270 | 	if src == nil {
271 | 		return mapInfo{}
272 | 	}
273 | 
274 | 	if mi, ok := pm.mappingsByID[src.ID]; ok {
275 | 		return mi
276 | 	}
277 | 
278 | 	// Check memoization tables.
279 | 	mk := src.key()
280 | 	if m, ok := pm.mappings[mk]; ok {
281 | 		mi := mapInfo{m, int64(m.Start) - int64(src.Start)}
282 | 		pm.mappingsByID[src.ID] = mi
283 | 		return mi
284 | 	}
285 | 	m := &Mapping{
286 | 		ID:              uint64(len(pm.p.Mapping) + 1),
287 | 		Start:           src.Start,
288 | 		Limit:           src.Limit,
289 | 		Offset:          src.Offset,
290 | 		File:            src.File,
291 | 		BuildID:         src.BuildID,
292 | 		HasFunctions:    src.HasFunctions,
293 | 		HasFilenames:    src.HasFilenames,
294 | 		HasLineNumbers:  src.HasLineNumbers,
295 | 		HasInlineFrames: src.HasInlineFrames,
296 | 	}
297 | 	pm.p.Mapping = append(pm.p.Mapping, m)
298 | 
299 | 	// Update memoization tables.
300 | 	pm.mappings[mk] = m
301 | 	mi := mapInfo{m, 0}
302 | 	pm.mappingsByID[src.ID] = mi
303 | 	return mi
304 | }
305 | 
306 | // key generates encoded strings of Mapping to be used as a key for
307 | // maps.
308 | func (m *Mapping) key() mappingKey {
309 | 	// Normalize addresses to handle address space randomization.
310 | 	// Round up to next 4K boundary to avoid minor discrepancies.
311 | 	const mapsizeRounding = 0x1000
312 | 
313 | 	size := m.Limit - m.Start
314 | 	size = size + mapsizeRounding - 1
315 | 	size = size - (size % mapsizeRounding)
316 | 	key := mappingKey{
317 | 		size:   size,
318 | 		offset: m.Offset,
319 | 	}
320 | 
321 | 	switch {
322 | 	case m.BuildID != "":
323 | 		key.buildIDOrFile = m.BuildID
324 | 	case m.File != "":
325 | 		key.buildIDOrFile = m.File
326 | 	default:
327 | 		// A mapping containing neither build ID nor file name is a fake mapping. A
328 | 		// key with empty buildIDOrFile is used for fake mappings so that they are
329 | 		// treated as the same mapping during merging.
330 | 	}
331 | 	return key
332 | }
333 | 
334 | type mappingKey struct {
335 | 	size, offset  uint64
336 | 	buildIDOrFile string
337 | }
338 | 
339 | func (pm *profileMerger) mapLine(src Line) Line {
340 | 	ln := Line{
341 | 		Function: pm.mapFunction(src.Function),
342 | 		Line:     src.Line,
343 | 	}
344 | 	return ln
345 | }
346 | 
347 | func (pm *profileMerger) mapFunction(src *Function) *Function {
348 | 	if src == nil {
349 | 		return nil
350 | 	}
351 | 	if f, ok := pm.functionsByID[src.ID]; ok {
352 | 		return f
353 | 	}
354 | 	k := src.key()
355 | 	if f, ok := pm.functions[k]; ok {
356 | 		pm.functionsByID[src.ID] = f
357 | 		return f
358 | 	}
359 | 	f := &Function{
360 | 		ID:         uint64(len(pm.p.Function) + 1),
361 | 		Name:       src.Name,
362 | 		SystemName: src.SystemName,
363 | 		Filename:   src.Filename,
364 | 		StartLine:  src.StartLine,
365 | 	}
366 | 	pm.functions[k] = f
367 | 	pm.functionsByID[src.ID] = f
368 | 	pm.p.Function = append(pm.p.Function, f)
369 | 	return f
370 | }
371 | 
372 | // key generates a struct to be used as a key for maps.
373 | func (f *Function) key() functionKey {
374 | 	return functionKey{
375 | 		f.StartLine,
376 | 		f.Name,
377 | 		f.SystemName,
378 | 		f.Filename,
379 | 	}
380 | }
381 | 
382 | type functionKey struct {
383 | 	startLine                  int64
384 | 	name, systemName, fileName string
385 | }
386 | 
387 | // combineHeaders checks that all profiles can be merged and returns
388 | // their combined profile.
389 | func combineHeaders(srcs []*Profile) (*Profile, error) {
390 | 	for _, s := range srcs[1:] {
391 | 		if err := srcs[0].compatible(s); err != nil {
392 | 			return nil, err
393 | 		}
394 | 	}
395 | 
396 | 	var timeNanos, durationNanos, period int64
397 | 	var comments []string
398 | 	seenComments := map[string]bool{}
399 | 	var defaultSampleType string
400 | 	for _, s := range srcs {
401 | 		if timeNanos == 0 || s.TimeNanos < timeNanos {
402 | 			timeNanos = s.TimeNanos
403 | 		}
404 | 		durationNanos += s.DurationNanos
405 | 		if period == 0 || period < s.Period {
406 | 			period = s.Period
407 | 		}
408 | 		for _, c := range s.Comments {
409 | 			if seen := seenComments[c]; !seen {
410 | 				comments = append(comments, c)
411 | 				seenComments[c] = true
412 | 			}
413 | 		}
414 | 		if defaultSampleType == "" {
415 | 			defaultSampleType = s.DefaultSampleType
416 | 		}
417 | 	}
418 | 
419 | 	p := &Profile{
420 | 		SampleType: make([]*ValueType, len(srcs[0].SampleType)),
421 | 
422 | 		DropFrames: srcs[0].DropFrames,
423 | 		KeepFrames: srcs[0].KeepFrames,
424 | 
425 | 		TimeNanos:     timeNanos,
426 | 		DurationNanos: durationNanos,
427 | 		PeriodType:    srcs[0].PeriodType,
428 | 		Period:        period,
429 | 
430 | 		Comments:          comments,
431 | 		DefaultSampleType: defaultSampleType,
432 | 	}
433 | 	copy(p.SampleType, srcs[0].SampleType)
434 | 	return p, nil
435 | }
436 | 
437 | // compatible determines if two profiles can be compared/merged.
438 | // returns nil if the profiles are compatible; otherwise an error with
439 | // details on the incompatibility.
440 | func (p *Profile) compatible(pb *Profile) error {
441 | 	if !equalValueType(p.PeriodType, pb.PeriodType) {
442 | 		return fmt.Errorf("incompatible period types %v and %v", p.PeriodType, pb.PeriodType)
443 | 	}
444 | 
445 | 	if len(p.SampleType) != len(pb.SampleType) {
446 | 		return fmt.Errorf("incompatible sample types %v and %v", p.SampleType, pb.SampleType)
447 | 	}
448 | 
449 | 	for i := range p.SampleType {
450 | 		if !equalValueType(p.SampleType[i], pb.SampleType[i]) {
451 | 			return fmt.Errorf("incompatible sample types %v and %v", p.SampleType, pb.SampleType)
452 | 		}
453 | 	}
454 | 	return nil
455 | }
456 | 
457 | // equalValueType returns true if the two value types are semantically
458 | // equal. It ignores the internal fields used during encode/decode.
459 | func equalValueType(st1, st2 *ValueType) bool {
460 | 	return st1.Type == st2.Type && st1.Unit == st2.Unit
461 | }
```

framework/rest/profile/profile.go
```
1 | // Copyright 2014 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | // Package profile provides a representation of
6 | // github.com/google/pprof/proto/profile.proto and
7 | // methods to encode/decode/merge profiles in this format.
8 | package profile
9 | 
10 | import (
11 | 	"bytes"
12 | 	"compress/gzip"
13 | 	"fmt"
14 | 	"io"
15 | 	"strings"
16 | 	"time"
17 | 
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest/lazyregexp"
19 | )
20 | 
21 | // Profile is an in-memory representation of profile.proto.
22 | type Profile struct {
23 | 	SampleType        []*ValueType
24 | 	DefaultSampleType string
25 | 	Sample            []*Sample
26 | 	Mapping           []*Mapping
27 | 	Location          []*Location
28 | 	Function          []*Function
29 | 	Comments          []string
30 | 
31 | 	DropFrames string
32 | 	KeepFrames string
33 | 
34 | 	TimeNanos     int64
35 | 	DurationNanos int64
36 | 	PeriodType    *ValueType
37 | 	Period        int64
38 | 
39 | 	commentX           []int64
40 | 	dropFramesX        int64
41 | 	keepFramesX        int64
42 | 	stringTable        []string
43 | 	defaultSampleTypeX int64
44 | }
45 | 
46 | // ValueType corresponds to Profile.ValueType
47 | type ValueType struct {
48 | 	Type string // cpu, wall, inuse_space, etc
49 | 	Unit string // seconds, nanoseconds, bytes, etc
50 | 
51 | 	typeX int64
52 | 	unitX int64
53 | }
54 | 
55 | // Sample corresponds to Profile.Sample
56 | type Sample struct {
57 | 	Location []*Location
58 | 	Value    []int64
59 | 	Label    map[string][]string
60 | 	NumLabel map[string][]int64
61 | 	NumUnit  map[string][]string
62 | 
63 | 	locationIDX []uint64
64 | 	labelX      []Label
65 | }
66 | 
67 | // Label corresponds to Profile.Label
68 | type Label struct {
69 | 	keyX int64
70 | 	// Exactly one of the two following values must be set
71 | 	strX int64
72 | 	numX int64 // Integer value for this label
73 | }
74 | 
75 | // Mapping corresponds to Profile.Mapping
76 | type Mapping struct {
77 | 	ID              uint64
78 | 	Start           uint64
79 | 	Limit           uint64
80 | 	Offset          uint64
81 | 	File            string
82 | 	BuildID         string
83 | 	HasFunctions    bool
84 | 	HasFilenames    bool
85 | 	HasLineNumbers  bool
86 | 	HasInlineFrames bool
87 | 
88 | 	fileX    int64
89 | 	buildIDX int64
90 | }
91 | 
92 | // Location corresponds to Profile.Location
93 | type Location struct {
94 | 	ID       uint64
95 | 	Mapping  *Mapping
96 | 	Address  uint64
97 | 	Line     []Line
98 | 	IsFolded bool
99 | 
100 | 	mappingIDX uint64
101 | }
102 | 
103 | // Line corresponds to Profile.Line
104 | type Line struct {
105 | 	Function *Function
106 | 	Line     int64
107 | 
108 | 	functionIDX uint64
109 | }
110 | 
111 | // Function corresponds to Profile.Function
112 | type Function struct {
113 | 	ID         uint64
114 | 	Name       string
115 | 	SystemName string
116 | 	Filename   string
117 | 	StartLine  int64
118 | 
119 | 	nameX       int64
120 | 	systemNameX int64
121 | 	filenameX   int64
122 | }
123 | 
124 | // Parse parses a profile and checks for its validity. The input
125 | // may be a gzip-compressed encoded protobuf or one of many legacy
126 | // profile formats which may be unsupported in the future.
127 | func Parse(r io.Reader) (*Profile, error) {
128 | 	orig, err := io.ReadAll(r)
129 | 	if err != nil {
130 | 		return nil, err
131 | 	}
132 | 
133 | 	var p *Profile
134 | 	if len(orig) >= 2 && orig[0] == 0x1f && orig[1] == 0x8b {
135 | 		gz, err := gzip.NewReader(bytes.NewBuffer(orig))
136 | 		if err != nil {
137 | 			return nil, fmt.Errorf("decompressing profile: %v", err)
138 | 		}
139 | 		data, err := io.ReadAll(gz)
140 | 		if err != nil {
141 | 			return nil, fmt.Errorf("decompressing profile: %v", err)
142 | 		}
143 | 		orig = data
144 | 	}
145 | 
146 | 	var lErr error
147 | 	p, pErr := parseUncompressed(orig)
148 | 	if pErr != nil {
149 | 		p, lErr = parseLegacy(orig)
150 | 	}
151 | 	if pErr != nil && lErr != nil {
152 | 		return nil, fmt.Errorf("parsing profile: not a valid proto profile (%w) or legacy profile (%w)", pErr, lErr)
153 | 	}
154 | 
155 | 	if err := p.CheckValid(); err != nil {
156 | 		return nil, fmt.Errorf("malformed profile: %v", err)
157 | 	}
158 | 	return p, nil
159 | }
160 | 
161 | var errUnrecognized = fmt.Errorf("unrecognized profile format")
162 | var errMalformed = fmt.Errorf("malformed profile format")
163 | var ErrNoData = fmt.Errorf("empty input file")
164 | 
165 | func parseLegacy(data []byte) (*Profile, error) {
166 | 	parsers := []func([]byte) (*Profile, error){
167 | 		parseCPU,
168 | 		parseHeap,
169 | 		parseGoCount, // goroutine, threadcreate
170 | 		parseThread,
171 | 		parseContention,
172 | 	}
173 | 
174 | 	for _, parser := range parsers {
175 | 		p, err := parser(data)
176 | 		if err == nil {
177 | 			p.setMain()
178 | 			p.addLegacyFrameInfo()
179 | 			return p, nil
180 | 		}
181 | 		if err != errUnrecognized {
182 | 			return nil, err
183 | 		}
184 | 	}
185 | 	return nil, errUnrecognized
186 | }
187 | 
188 | func parseUncompressed(data []byte) (*Profile, error) {
189 | 	if len(data) == 0 {
190 | 		return nil, ErrNoData
191 | 	}
192 | 
193 | 	p := &Profile{}
194 | 	if err := unmarshal(data, p); err != nil {
195 | 		return nil, err
196 | 	}
197 | 
198 | 	if err := p.postDecode(); err != nil {
199 | 		return nil, err
200 | 	}
201 | 
202 | 	return p, nil
203 | }
204 | 
205 | var libRx = lazyregexp.New(`([.]so$|[.]so[._][0-9]+)`)
206 | 
207 | // setMain scans Mapping entries and guesses which entry is main
208 | // because legacy profiles don't obey the convention of putting main
209 | // first.
210 | func (p *Profile) setMain() {
211 | 	for i := 0; i < len(p.Mapping); i++ {
212 | 		file := strings.TrimSpace(strings.ReplaceAll(p.Mapping[i].File, "(deleted)", ""))
213 | 		if len(file) == 0 {
214 | 			continue
215 | 		}
216 | 		if len(libRx.FindStringSubmatch(file)) > 0 {
217 | 			continue
218 | 		}
219 | 		if strings.HasPrefix(file, "[") {
220 | 			continue
221 | 		}
222 | 		// Swap what we guess is main to position 0.
223 | 		p.Mapping[i], p.Mapping[0] = p.Mapping[0], p.Mapping[i]
224 | 		break
225 | 	}
226 | }
227 | 
228 | // Write writes the profile as a gzip-compressed marshaled protobuf.
229 | func (p *Profile) Write(w io.Writer) error {
230 | 	p.preEncode()
231 | 	b := marshal(p)
232 | 	zw := gzip.NewWriter(w)
233 | 	defer zw.Close()
234 | 	_, err := zw.Write(b)
235 | 	return err
236 | }
237 | 
238 | // CheckValid tests whether the profile is valid. Checks include, but are
239 | // not limited to:
240 | //   - len(Profile.Sample[n].value) == len(Profile.value_unit)
241 | //   - Sample.id has a corresponding Profile.Location
242 | func (p *Profile) CheckValid() error {
243 | 	// Check that sample values are consistent
244 | 	sampleLen := len(p.SampleType)
245 | 	if sampleLen == 0 && len(p.Sample) != 0 {
246 | 		return fmt.Errorf("missing sample type information")
247 | 	}
248 | 	for _, s := range p.Sample {
249 | 		if len(s.Value) != sampleLen {
250 | 			return fmt.Errorf("mismatch: sample has: %d values vs. %d types", len(s.Value), len(p.SampleType))
251 | 		}
252 | 	}
253 | 
254 | 	// Check that all mappings/locations/functions are in the tables
255 | 	// Check that there are no duplicate ids
256 | 	mappings := make(map[uint64]*Mapping, len(p.Mapping))
257 | 	for _, m := range p.Mapping {
258 | 		if m.ID == 0 {
259 | 			return fmt.Errorf("found mapping with reserved ID=0")
260 | 		}
261 | 		if mappings[m.ID] != nil {
262 | 			return fmt.Errorf("multiple mappings with same id: %d", m.ID)
263 | 		}
264 | 		mappings[m.ID] = m
265 | 	}
266 | 	functions := make(map[uint64]*Function, len(p.Function))
267 | 	for _, f := range p.Function {
268 | 		if f.ID == 0 {
269 | 			return fmt.Errorf("found function with reserved ID=0")
270 | 		}
271 | 		if functions[f.ID] != nil {
272 | 			return fmt.Errorf("multiple functions with same id: %d", f.ID)
273 | 		}
274 | 		functions[f.ID] = f
275 | 	}
276 | 	locations := make(map[uint64]*Location, len(p.Location))
277 | 	for _, l := range p.Location {
278 | 		if l.ID == 0 {
279 | 			return fmt.Errorf("found location with reserved id=0")
280 | 		}
281 | 		if locations[l.ID] != nil {
282 | 			return fmt.Errorf("multiple locations with same id: %d", l.ID)
283 | 		}
284 | 		locations[l.ID] = l
285 | 		if m := l.Mapping; m != nil {
286 | 			if m.ID == 0 || mappings[m.ID] != m {
287 | 				return fmt.Errorf("inconsistent mapping %p: %d", m, m.ID)
288 | 			}
289 | 		}
290 | 		for _, ln := range l.Line {
291 | 			if f := ln.Function; f != nil {
292 | 				if f.ID == 0 || functions[f.ID] != f {
293 | 					return fmt.Errorf("inconsistent function %p: %d", f, f.ID)
294 | 				}
295 | 			}
296 | 		}
297 | 	}
298 | 	return nil
299 | }
300 | 
301 | // Aggregate merges the locations in the profile into equivalence
302 | // classes preserving the request attributes. It also updates the
303 | // samples to point to the merged locations.
304 | func (p *Profile) Aggregate(inlineFrame, function, filename, linenumber, address bool) error {
305 | 	for _, m := range p.Mapping {
306 | 		m.HasInlineFrames = m.HasInlineFrames && inlineFrame
307 | 		m.HasFunctions = m.HasFunctions && function
308 | 		m.HasFilenames = m.HasFilenames && filename
309 | 		m.HasLineNumbers = m.HasLineNumbers && linenumber
310 | 	}
311 | 
312 | 	// Aggregate functions
313 | 	if !function || !filename {
314 | 		for _, f := range p.Function {
315 | 			if !function {
316 | 				f.Name = ""
317 | 				f.SystemName = ""
318 | 			}
319 | 			if !filename {
320 | 				f.Filename = ""
321 | 			}
322 | 		}
323 | 	}
324 | 
325 | 	// Aggregate locations
326 | 	if !inlineFrame || !address || !linenumber {
327 | 		for _, l := range p.Location {
328 | 			if !inlineFrame && len(l.Line) > 1 {
329 | 				l.Line = l.Line[len(l.Line)-1:]
330 | 			}
331 | 			if !linenumber {
332 | 				for i := range l.Line {
333 | 					l.Line[i].Line = 0
334 | 				}
335 | 			}
336 | 			if !address {
337 | 				l.Address = 0
338 | 			}
339 | 		}
340 | 	}
341 | 
342 | 	return p.CheckValid()
343 | }
344 | 
345 | // Print dumps a text representation of a profile. Intended mainly
346 | // for debugging purposes.
347 | func (p *Profile) String() string {
348 | 
349 | 	ss := make([]string, 0, len(p.Sample)+len(p.Mapping)+len(p.Location))
350 | 	if pt := p.PeriodType; pt != nil {
351 | 		ss = append(ss, fmt.Sprintf("PeriodType: %s %s", pt.Type, pt.Unit))
352 | 	}
353 | 	ss = append(ss, fmt.Sprintf("Period: %d", p.Period))
354 | 	if p.TimeNanos != 0 {
355 | 		ss = append(ss, fmt.Sprintf("Time: %v", time.Unix(0, p.TimeNanos)))
356 | 	}
357 | 	if p.DurationNanos != 0 {
358 | 		ss = append(ss, fmt.Sprintf("Duration: %v", time.Duration(p.DurationNanos)))
359 | 	}
360 | 
361 | 	ss = append(ss, "Samples:")
362 | 	var sh1 string
363 | 	for _, s := range p.SampleType {
364 | 		sh1 = sh1 + fmt.Sprintf("%s/%s ", s.Type, s.Unit)
365 | 	}
366 | 	ss = append(ss, strings.TrimSpace(sh1))
367 | 	for _, s := range p.Sample {
368 | 		var sv string
369 | 		for _, v := range s.Value {
370 | 			sv = fmt.Sprintf("%s %10d", sv, v)
371 | 		}
372 | 		sv = sv + ": "
373 | 		for _, l := range s.Location {
374 | 			sv = sv + fmt.Sprintf("%d ", l.ID)
375 | 		}
376 | 		ss = append(ss, sv)
377 | 		const labelHeader = "                "
378 | 		if len(s.Label) > 0 {
379 | 			ls := labelHeader
380 | 			for k, v := range s.Label {
381 | 				ls = ls + fmt.Sprintf("%s:%v ", k, v)
382 | 			}
383 | 			ss = append(ss, ls)
384 | 		}
385 | 		if len(s.NumLabel) > 0 {
386 | 			ls := labelHeader
387 | 			for k, v := range s.NumLabel {
388 | 				ls = ls + fmt.Sprintf("%s:%v ", k, v)
389 | 			}
390 | 			ss = append(ss, ls)
391 | 		}
392 | 	}
393 | 
394 | 	ss = append(ss, "Locations")
395 | 	for _, l := range p.Location {
396 | 		locStr := fmt.Sprintf("%6d: %#x ", l.ID, l.Address)
397 | 		if m := l.Mapping; m != nil {
398 | 			locStr = locStr + fmt.Sprintf("M=%d ", m.ID)
399 | 		}
400 | 		if len(l.Line) == 0 {
401 | 			ss = append(ss, locStr)
402 | 		}
403 | 		for li := range l.Line {
404 | 			lnStr := "??"
405 | 			if fn := l.Line[li].Function; fn != nil {
406 | 				lnStr = fmt.Sprintf("%s %s:%d s=%d",
407 | 					fn.Name,
408 | 					fn.Filename,
409 | 					l.Line[li].Line,
410 | 					fn.StartLine)
411 | 				if fn.Name != fn.SystemName {
412 | 					lnStr = lnStr + "(" + fn.SystemName + ")"
413 | 				}
414 | 			}
415 | 			ss = append(ss, locStr+lnStr)
416 | 			// Do not print location details past the first line
417 | 			locStr = "             "
418 | 		}
419 | 	}
420 | 
421 | 	ss = append(ss, "Mappings")
422 | 	for _, m := range p.Mapping {
423 | 		bits := ""
424 | 		if m.HasFunctions {
425 | 			bits += "[FN]"
426 | 		}
427 | 		if m.HasFilenames {
428 | 			bits += "[FL]"
429 | 		}
430 | 		if m.HasLineNumbers {
431 | 			bits += "[LN]"
432 | 		}
433 | 		if m.HasInlineFrames {
434 | 			bits += "[IN]"
435 | 		}
436 | 		ss = append(ss, fmt.Sprintf("%d: %#x/%#x/%#x %s %s %s",
437 | 			m.ID,
438 | 			m.Start, m.Limit, m.Offset,
439 | 			m.File,
440 | 			m.BuildID,
441 | 			bits))
442 | 	}
443 | 
444 | 	return strings.Join(ss, "\n") + "\n"
445 | }
446 | 
447 | // Merge adds profile p adjusted by ratio r into profile p. Profiles
448 | // must be compatible (same Type and SampleType).
449 | // TODO(rsilvera): consider normalizing the profiles based on the
450 | // total samples collected.
451 | func (p *Profile) Merge(pb *Profile, r float64) error {
452 | 	if err := p.Compatible(pb); err != nil {
453 | 		return err
454 | 	}
455 | 
456 | 	pb = pb.Copy()
457 | 
458 | 	// Keep the largest of the two periods.
459 | 	if pb.Period > p.Period {
460 | 		p.Period = pb.Period
461 | 	}
462 | 
463 | 	p.DurationNanos += pb.DurationNanos
464 | 
465 | 	p.Mapping = append(p.Mapping, pb.Mapping...)
466 | 	for i, m := range p.Mapping {
467 | 		m.ID = uint64(i + 1)
468 | 	}
469 | 	p.Location = append(p.Location, pb.Location...)
470 | 	for i, l := range p.Location {
471 | 		l.ID = uint64(i + 1)
472 | 	}
473 | 	p.Function = append(p.Function, pb.Function...)
474 | 	for i, f := range p.Function {
475 | 		f.ID = uint64(i + 1)
476 | 	}
477 | 
478 | 	if r != 1.0 {
479 | 		for _, s := range pb.Sample {
480 | 			for i, v := range s.Value {
481 | 				s.Value[i] = int64((float64(v) * r))
482 | 			}
483 | 		}
484 | 	}
485 | 	p.Sample = append(p.Sample, pb.Sample...)
486 | 	return p.CheckValid()
487 | }
488 | 
489 | // Compatible determines if two profiles can be compared/merged.
490 | // returns nil if the profiles are compatible; otherwise an error with
491 | // details on the incompatibility.
492 | func (p *Profile) Compatible(pb *Profile) error {
493 | 	if !compatibleValueTypes(p.PeriodType, pb.PeriodType) {
494 | 		return fmt.Errorf("incompatible period types %v and %v", p.PeriodType, pb.PeriodType)
495 | 	}
496 | 
497 | 	if len(p.SampleType) != len(pb.SampleType) {
498 | 		return fmt.Errorf("incompatible sample types %v and %v", p.SampleType, pb.SampleType)
499 | 	}
500 | 
501 | 	for i := range p.SampleType {
502 | 		if !compatibleValueTypes(p.SampleType[i], pb.SampleType[i]) {
503 | 			return fmt.Errorf("incompatible sample types %v and %v", p.SampleType, pb.SampleType)
504 | 		}
505 | 	}
506 | 
507 | 	return nil
[TRUNCATED]
```

framework/rest/profile/profile_test.go
```
1 | // Copyright 2015 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | package profile
6 | 
7 | import (
8 | 	"testing"
9 | )
10 | 
11 | func TestParseContention(t *testing.T) {
12 | 	tests := []struct {
13 | 		name    string
14 | 		in      string
15 | 		wantErr bool
16 | 	}{
17 | 		{
18 | 			name: "valid",
19 | 			in: `--- mutex:
20 | cycles/second=3491920901
21 | sampling period=1
22 | 43227965305 1659640 @ 0x45e851 0x45f764 0x4a2be1 0x44ea31
23 | 34035731690 15760 @ 0x45e851 0x45f764 0x4a2b17 0x44ea31
24 | `,
25 | 		},
26 | 		{
27 | 			name: "valid with comment",
28 | 			in: `--- mutex:
29 | cycles/second=3491920901
30 | sampling period=1
31 | 43227965305 1659640 @ 0x45e851 0x45f764 0x4a2be1 0x44ea31
32 | #	0x45e850	sync.(*Mutex).Unlock+0x80	/go/src/sync/mutex.go:126
33 | #	0x45f763	sync.(*RWMutex).Unlock+0x83	/go/src/sync/rwmutex.go:125
34 | #	0x4a2be0	main.main.func3+0x70		/go/src/internal/pprof/profile/a_binary.go:58
35 | 
36 | 34035731690 15760 @ 0x45e851 0x45f764 0x4a2b17 0x44ea31
37 | #	0x45e850	sync.(*Mutex).Unlock+0x80	/go/src/sync/mutex.go:126
38 | #	0x45f763	sync.(*RWMutex).Unlock+0x83	/go/src/sync/rwmutex.go:125
39 | #	0x4a2b16	main.main.func2+0xd6		/go/src/internal/pprof/profile/a_binary.go:48
40 | `,
41 | 		},
42 | 		{
43 | 			name:    "empty",
44 | 			in:      `--- mutex:`,
45 | 			wantErr: true,
46 | 		},
47 | 		{
48 | 			name: "invalid header",
49 | 			in: `--- channel:
50 | 43227965305 1659640 @ 0x45e851 0x45f764 0x4a2be1 0x44ea31`,
51 | 			wantErr: true,
52 | 		},
53 | 	}
54 | 	for _, tc := range tests {
55 | 		_, err := parseContention([]byte(tc.in))
56 | 		if tc.wantErr && err == nil {
57 | 			t.Errorf("parseContention(%q) succeeded unexpectedly", tc.name)
58 | 		}
59 | 		if !tc.wantErr && err != nil {
60 | 			t.Errorf("parseContention(%q) failed unexpectedly: %v", tc.name, err)
61 | 		}
62 | 	}
63 | 
64 | }
```

framework/rest/profile/proto.go
```
1 | // Copyright 2014 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | // This file is a simple protocol buffer encoder and decoder.
6 | //
7 | // A protocol message must implement the message interface:
8 | //   decoder() []decoder
9 | //   encode(*buffer)
10 | //
11 | // The decode method returns a slice indexed by field number that gives the
12 | // function to decode that field.
13 | // The encode method encodes its receiver into the given buffer.
14 | //
15 | // The two methods are simple enough to be implemented by hand rather than
16 | // by using a protocol compiler.
17 | //
18 | // See profile.go for examples of messages implementing this interface.
19 | //
20 | // There is no support for groups, message sets, or "has" bits.
21 | 
22 | package profile
23 | 
24 | import (
25 | 	"errors"
26 | 	"fmt"
27 | )
28 | 
29 | type buffer struct {
30 | 	field int
31 | 	typ   int
32 | 	u64   uint64
33 | 	data  []byte
34 | 	tmp   [16]byte
35 | }
36 | 
37 | type decoder func(*buffer, message) error
38 | 
39 | type message interface {
40 | 	decoder() []decoder
41 | 	encode(*buffer)
42 | }
43 | 
44 | func marshal(m message) []byte {
45 | 	var b buffer
46 | 	m.encode(&b)
47 | 	return b.data
48 | }
49 | 
50 | func encodeVarint(b *buffer, x uint64) {
51 | 	for x >= 128 {
52 | 		b.data = append(b.data, byte(x)|0x80)
53 | 		x >>= 7
54 | 	}
55 | 	b.data = append(b.data, byte(x))
56 | }
57 | 
58 | func encodeLength(b *buffer, tag int, len int) {
59 | 	encodeVarint(b, uint64(tag)<<3|2)
60 | 	encodeVarint(b, uint64(len))
61 | }
62 | 
63 | func encodeUint64(b *buffer, tag int, x uint64) {
64 | 	// append varint to b.data
65 | 	encodeVarint(b, uint64(tag)<<3|0)
66 | 	encodeVarint(b, x)
67 | }
68 | 
69 | func encodeUint64s(b *buffer, tag int, x []uint64) {
70 | 	if len(x) > 2 {
71 | 		// Use packed encoding
72 | 		n1 := len(b.data)
73 | 		for _, u := range x {
74 | 			encodeVarint(b, u)
75 | 		}
76 | 		n2 := len(b.data)
77 | 		encodeLength(b, tag, n2-n1)
78 | 		n3 := len(b.data)
79 | 		copy(b.tmp[:], b.data[n2:n3])
80 | 		copy(b.data[n1+(n3-n2):], b.data[n1:n2])
81 | 		copy(b.data[n1:], b.tmp[:n3-n2])
82 | 		return
83 | 	}
84 | 	for _, u := range x {
85 | 		encodeUint64(b, tag, u)
86 | 	}
87 | }
88 | 
89 | func encodeUint64Opt(b *buffer, tag int, x uint64) {
90 | 	if x == 0 {
91 | 		return
92 | 	}
93 | 	encodeUint64(b, tag, x)
94 | }
95 | 
96 | func encodeInt64(b *buffer, tag int, x int64) {
97 | 	u := uint64(x)
98 | 	encodeUint64(b, tag, u)
99 | }
100 | 
101 | func encodeInt64Opt(b *buffer, tag int, x int64) {
102 | 	if x == 0 {
103 | 		return
104 | 	}
105 | 	encodeInt64(b, tag, x)
106 | }
107 | 
108 | func encodeInt64s(b *buffer, tag int, x []int64) {
109 | 	if len(x) > 2 {
110 | 		// Use packed encoding
111 | 		n1 := len(b.data)
112 | 		for _, u := range x {
113 | 			encodeVarint(b, uint64(u))
114 | 		}
115 | 		n2 := len(b.data)
116 | 		encodeLength(b, tag, n2-n1)
117 | 		n3 := len(b.data)
118 | 		copy(b.tmp[:], b.data[n2:n3])
119 | 		copy(b.data[n1+(n3-n2):], b.data[n1:n2])
120 | 		copy(b.data[n1:], b.tmp[:n3-n2])
121 | 		return
122 | 	}
123 | 	for _, u := range x {
124 | 		encodeInt64(b, tag, u)
125 | 	}
126 | }
127 | 
128 | func encodeString(b *buffer, tag int, x string) {
129 | 	encodeLength(b, tag, len(x))
130 | 	b.data = append(b.data, x...)
131 | }
132 | 
133 | func encodeStrings(b *buffer, tag int, x []string) {
134 | 	for _, s := range x {
135 | 		encodeString(b, tag, s)
136 | 	}
137 | }
138 | 
139 | func encodeBool(b *buffer, tag int, x bool) {
140 | 	if x {
141 | 		encodeUint64(b, tag, 1)
142 | 	} else {
143 | 		encodeUint64(b, tag, 0)
144 | 	}
145 | }
146 | 
147 | func encodeBoolOpt(b *buffer, tag int, x bool) {
148 | 	if !x {
149 | 		return
150 | 	}
151 | 	encodeBool(b, tag, x)
152 | }
153 | 
154 | func encodeMessage(b *buffer, tag int, m message) {
155 | 	n1 := len(b.data)
156 | 	m.encode(b)
157 | 	n2 := len(b.data)
158 | 	encodeLength(b, tag, n2-n1)
159 | 	n3 := len(b.data)
160 | 	copy(b.tmp[:], b.data[n2:n3])
161 | 	copy(b.data[n1+(n3-n2):], b.data[n1:n2])
162 | 	copy(b.data[n1:], b.tmp[:n3-n2])
163 | }
164 | 
165 | func unmarshal(data []byte, m message) (err error) {
166 | 	b := buffer{data: data, typ: 2}
167 | 	return decodeMessage(&b, m)
168 | }
169 | 
170 | func le64(p []byte) uint64 {
171 | 	return uint64(p[0]) | uint64(p[1])<<8 | uint64(p[2])<<16 | uint64(p[3])<<24 | uint64(p[4])<<32 | uint64(p[5])<<40 | uint64(p[6])<<48 | uint64(p[7])<<56
172 | }
173 | 
174 | func le32(p []byte) uint32 {
175 | 	return uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 | uint32(p[3])<<24
176 | }
177 | 
178 | func decodeVarint(data []byte) (uint64, []byte, error) {
179 | 	var i int
180 | 	var u uint64
181 | 	for i = 0; ; i++ {
182 | 		if i >= 10 || i >= len(data) {
183 | 			return 0, nil, errors.New("bad varint")
184 | 		}
185 | 		u |= uint64(data[i]&0x7F) << uint(7*i)
186 | 		if data[i]&0x80 == 0 {
187 | 			return u, data[i+1:], nil
188 | 		}
189 | 	}
190 | }
191 | 
192 | func decodeField(b *buffer, data []byte) ([]byte, error) {
193 | 	x, data, err := decodeVarint(data)
194 | 	if err != nil {
195 | 		return nil, err
196 | 	}
197 | 	b.field = int(x >> 3)
198 | 	b.typ = int(x & 7)
199 | 	b.data = nil
200 | 	b.u64 = 0
201 | 	switch b.typ {
202 | 	case 0:
203 | 		b.u64, data, err = decodeVarint(data)
204 | 		if err != nil {
205 | 			return nil, err
206 | 		}
207 | 	case 1:
208 | 		if len(data) < 8 {
209 | 			return nil, errors.New("not enough data")
210 | 		}
211 | 		b.u64 = le64(data[:8])
212 | 		data = data[8:]
213 | 	case 2:
214 | 		var n uint64
215 | 		n, data, err = decodeVarint(data)
216 | 		if err != nil {
217 | 			return nil, err
218 | 		}
219 | 		if n > uint64(len(data)) {
220 | 			return nil, errors.New("too much data")
221 | 		}
222 | 		b.data = data[:n]
223 | 		data = data[n:]
224 | 	case 5:
225 | 		if len(data) < 4 {
226 | 			return nil, errors.New("not enough data")
227 | 		}
228 | 		b.u64 = uint64(le32(data[:4]))
229 | 		data = data[4:]
230 | 	default:
231 | 		return nil, fmt.Errorf("unknown wire type: %d", b.typ)
232 | 	}
233 | 
234 | 	return data, nil
235 | }
236 | 
237 | func checkType(b *buffer, typ int) error {
238 | 	if b.typ != typ {
239 | 		return errors.New("type mismatch")
240 | 	}
241 | 	return nil
242 | }
243 | 
244 | func decodeMessage(b *buffer, m message) error {
245 | 	if err := checkType(b, 2); err != nil {
246 | 		return err
247 | 	}
248 | 	dec := m.decoder()
249 | 	data := b.data
250 | 	for len(data) > 0 {
251 | 		// pull varint field# + type
252 | 		var err error
253 | 		data, err = decodeField(b, data)
254 | 		if err != nil {
255 | 			return err
256 | 		}
257 | 		if b.field >= len(dec) || dec[b.field] == nil {
258 | 			continue
259 | 		}
260 | 		if err := dec[b.field](b, m); err != nil {
261 | 			return err
262 | 		}
263 | 	}
264 | 	return nil
265 | }
266 | 
267 | func decodeInt64(b *buffer, x *int64) error {
268 | 	if err := checkType(b, 0); err != nil {
269 | 		return err
270 | 	}
271 | 	*x = int64(b.u64)
272 | 	return nil
273 | }
274 | 
275 | func decodeInt64s(b *buffer, x *[]int64) error {
276 | 	if b.typ == 2 {
277 | 		// Packed encoding
278 | 		data := b.data
279 | 		for len(data) > 0 {
280 | 			var u uint64
281 | 			var err error
282 | 
283 | 			if u, data, err = decodeVarint(data); err != nil {
284 | 				return err
285 | 			}
286 | 			*x = append(*x, int64(u))
287 | 		}
288 | 		return nil
289 | 	}
290 | 	var i int64
291 | 	if err := decodeInt64(b, &i); err != nil {
292 | 		return err
293 | 	}
294 | 	*x = append(*x, i)
295 | 	return nil
296 | }
297 | 
298 | func decodeUint64(b *buffer, x *uint64) error {
299 | 	if err := checkType(b, 0); err != nil {
300 | 		return err
301 | 	}
302 | 	*x = b.u64
303 | 	return nil
304 | }
305 | 
306 | func decodeUint64s(b *buffer, x *[]uint64) error {
307 | 	if b.typ == 2 {
308 | 		data := b.data
309 | 		// Packed encoding
310 | 		for len(data) > 0 {
311 | 			var u uint64
312 | 			var err error
313 | 
314 | 			if u, data, err = decodeVarint(data); err != nil {
315 | 				return err
316 | 			}
317 | 			*x = append(*x, u)
318 | 		}
319 | 		return nil
320 | 	}
321 | 	var u uint64
322 | 	if err := decodeUint64(b, &u); err != nil {
323 | 		return err
324 | 	}
325 | 	*x = append(*x, u)
326 | 	return nil
327 | }
328 | 
329 | func decodeString(b *buffer, x *string) error {
330 | 	if err := checkType(b, 2); err != nil {
331 | 		return err
332 | 	}
333 | 	*x = string(b.data)
334 | 	return nil
335 | }
336 | 
337 | func decodeStrings(b *buffer, x *[]string) error {
338 | 	var s string
339 | 	if err := decodeString(b, &s); err != nil {
340 | 		return err
341 | 	}
342 | 	*x = append(*x, s)
343 | 	return nil
344 | }
345 | 
346 | func decodeBool(b *buffer, x *bool) error {
347 | 	if err := checkType(b, 0); err != nil {
348 | 		return err
349 | 	}
350 | 	if int64(b.u64) == 0 {
351 | 		*x = false
352 | 	} else {
353 | 		*x = true
354 | 	}
355 | 	return nil
356 | }
```

framework/rest/profile/proto_test.go
```
1 | // Copyright 2016 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | package profile
6 | 
7 | import (
8 | 	"reflect"
9 | 	"testing"
10 | )
11 | 
12 | func TestPackedEncoding(t *testing.T) {
13 | 
14 | 	type testcase struct {
15 | 		uint64s []uint64
16 | 		int64s  []int64
17 | 		encoded []byte
18 | 	}
19 | 	for i, tc := range []testcase{
20 | 		{
21 | 			[]uint64{0, 1, 10, 100, 1000, 10000},
22 | 			[]int64{1000, 0, 1000},
23 | 			[]byte{10, 8, 0, 1, 10, 100, 232, 7, 144, 78, 18, 5, 232, 7, 0, 232, 7},
24 | 		},
25 | 		{
26 | 			[]uint64{10000},
27 | 			nil,
28 | 			[]byte{8, 144, 78},
29 | 		},
30 | 		{
31 | 			nil,
32 | 			[]int64{-10000},
33 | 			[]byte{16, 240, 177, 255, 255, 255, 255, 255, 255, 255, 1},
34 | 		},
35 | 	} {
36 | 		source := &packedInts{tc.uint64s, tc.int64s}
37 | 		if got, want := marshal(source), tc.encoded; !reflect.DeepEqual(got, want) {
38 | 			t.Errorf("failed encode %d, got %v, want %v", i, got, want)
39 | 		}
40 | 
41 | 		dest := new(packedInts)
42 | 		if err := unmarshal(tc.encoded, dest); err != nil {
43 | 			t.Errorf("failed decode %d: %v", i, err)
44 | 			continue
45 | 		}
46 | 		if got, want := dest.uint64s, tc.uint64s; !reflect.DeepEqual(got, want) {
47 | 			t.Errorf("failed decode uint64s %d, got %v, want %v", i, got, want)
48 | 		}
49 | 		if got, want := dest.int64s, tc.int64s; !reflect.DeepEqual(got, want) {
50 | 			t.Errorf("failed decode int64s %d, got %v, want %v", i, got, want)
51 | 		}
52 | 	}
53 | }
54 | 
55 | type packedInts struct {
56 | 	uint64s []uint64
57 | 	int64s  []int64
58 | }
59 | 
60 | func (u *packedInts) decoder() []decoder {
61 | 	return []decoder{
62 | 		nil,
63 | 		func(b *buffer, m message) error { return decodeUint64s(b, &m.(*packedInts).uint64s) },
64 | 		func(b *buffer, m message) error { return decodeInt64s(b, &m.(*packedInts).int64s) },
65 | 	}
66 | }
67 | 
68 | func (u *packedInts) encode(b *buffer) {
69 | 	encodeUint64s(b, 1, u.uint64s)
70 | 	encodeInt64s(b, 2, u.int64s)
71 | }
```

framework/rest/profile/prune.go
```
1 | // Copyright 2014 The Go Authors. All rights reserved.
2 | // Use of this source code is governed by a BSD-style
3 | // license that can be found in the LICENSE file.
4 | 
5 | // Implements methods to remove frames from profiles.
6 | 
7 | package profile
8 | 
9 | import (
10 | 	"fmt"
11 | 	"regexp"
12 | )
13 | 
14 | // Prune removes all nodes beneath a node matching dropRx, and not
15 | // matching keepRx. If the root node of a Sample matches, the sample
16 | // will have an empty stack.
17 | func (p *Profile) Prune(dropRx, keepRx *regexp.Regexp) {
18 | 	prune := make(map[uint64]bool)
19 | 	pruneBeneath := make(map[uint64]bool)
20 | 
21 | 	for _, loc := range p.Location {
22 | 		var i int
23 | 		for i = len(loc.Line) - 1; i >= 0; i-- {
24 | 			if fn := loc.Line[i].Function; fn != nil && fn.Name != "" {
25 | 				funcName := fn.Name
26 | 				// Account for leading '.' on the PPC ELF v1 ABI.
27 | 				if funcName[0] == '.' {
28 | 					funcName = funcName[1:]
29 | 				}
30 | 				if dropRx.MatchString(funcName) {
31 | 					if keepRx == nil || !keepRx.MatchString(funcName) {
32 | 						break
33 | 					}
34 | 				}
35 | 			}
36 | 		}
37 | 
38 | 		if i >= 0 {
39 | 			// Found matching entry to prune.
40 | 			pruneBeneath[loc.ID] = true
41 | 
42 | 			// Remove the matching location.
43 | 			if i == len(loc.Line)-1 {
44 | 				// Matched the top entry: prune the whole location.
45 | 				prune[loc.ID] = true
46 | 			} else {
47 | 				loc.Line = loc.Line[i+1:]
48 | 			}
49 | 		}
50 | 	}
51 | 
52 | 	// Prune locs from each Sample
53 | 	for _, sample := range p.Sample {
54 | 		// Scan from the root to the leaves to find the prune location.
55 | 		// Do not prune frames before the first user frame, to avoid
56 | 		// pruning everything.
57 | 		foundUser := false
58 | 		for i := len(sample.Location) - 1; i >= 0; i-- {
59 | 			id := sample.Location[i].ID
60 | 			if !prune[id] && !pruneBeneath[id] {
61 | 				foundUser = true
62 | 				continue
63 | 			}
64 | 			if !foundUser {
65 | 				continue
66 | 			}
67 | 			if prune[id] {
68 | 				sample.Location = sample.Location[i+1:]
69 | 				break
70 | 			}
71 | 			if pruneBeneath[id] {
72 | 				sample.Location = sample.Location[i:]
73 | 				break
74 | 			}
75 | 		}
76 | 	}
77 | }
78 | 
79 | // RemoveUninteresting prunes and elides profiles using built-in
80 | // tables of uninteresting function names.
81 | func (p *Profile) RemoveUninteresting() error {
82 | 	var keep, drop *regexp.Regexp
83 | 	var err error
84 | 
85 | 	if p.DropFrames != "" {
86 | 		if drop, err = regexp.Compile("^(" + p.DropFrames + ")$"); err != nil {
87 | 			return fmt.Errorf("failed to compile regexp %s: %v", p.DropFrames, err)
88 | 		}
89 | 		if p.KeepFrames != "" {
90 | 			if keep, err = regexp.Compile("^(" + p.KeepFrames + ")$"); err != nil {
91 | 				return fmt.Errorf("failed to compile regexp %s: %v", p.KeepFrames, err)
92 | 			}
93 | 		}
94 | 		p.Prune(drop, keep)
95 | 	}
96 | 	return nil
97 | }
```

framework/testdata/change/change.go
```
1 | test
```

framework/testdata/checkIc2/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"mime/multipart"
6 | 
7 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
8 | )
9 | 
10 | // 用户服务接口
11 | // v1版本
12 | type Usersvc interface {
13 | 	// comment4
14 | 	UploadAvatar(context.Context, *multipart.FileHeader, v3.FileModel, string, []*multipart.FileHeader, []*multipart.FileHeader) (int, string, error)
15 | }
```

framework/testdata/inputanonystruct/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 
6 | 	"github.com/unionj-cloud/go-doudou/v2/framework/testdata/vo"
7 | )
8 | 
9 | // 用户服务接口
10 | // v1版本
11 | type Usersvc interface {
12 | 	// You can define your service methods as your need. Below is an example.
13 | 	PageUsers(ctx context.Context, query struct {
14 | 		Filter vo.PageFilter
15 | 		Page   vo.Page
16 | 	}) (code int, data vo.PageRet, msg error)
17 | }
```

framework/testdata/nosvc/svc.go
```
1 | package service
```

framework/testdata/novo/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"mime/multipart"
6 | 	"os"
7 | 
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/testdata/vo"
9 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
10 | )
11 | 
12 | // 用户服务接口
13 | // v1版本
14 | type Usersvc interface {
15 | 	// You can define your service methods as your need. Below is an example.
16 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, msg error)
17 | 
18 | 	// comment1
19 | 	// comment2
20 | 	GetUser(ctx context.Context,
21 | 		// 用户ID
22 | 		userId string,
23 | 		// 图片地址
24 | 		photo string,
25 | 	) (code int, data string, msg error)
26 | 
27 | 	// comment3
28 | 	SignUp(ctx context.Context, username string, password int, actived bool, score float64) (code int, data string, msg error)
29 | 
30 | 	// comment4
31 | 	UploadAvatar(context.Context, []*multipart.FileHeader, []*multipart.FileHeader, *multipart.FileHeader, v3.FileModel, string) (int, string, error)
32 | 
33 | 	// comment5
34 | 	DownloadAvatar(ctx context.Context, userId string) (*os.File, error)
35 | }
```

framework/testdata/outputanonystruct/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 
6 | 	"github.com/unionj-cloud/go-doudou/v2/framework/testdata/vo"
7 | )
8 | 
9 | // 用户服务接口
10 | // v1版本
11 | type Usersvc interface {
12 | 	// You can define your service methods as your need. Below is an example.
13 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data struct {
14 | 		Items    interface{}
15 | 		PageNo   int
16 | 		PageSize int
17 | 		Total    int
18 | 		HasNext  bool
19 | 	}, msg error)
20 | }
```

framework/testdata/openapi/testfilesdoc1_openapi3.json
```
1 | {"openapi":"3.0.2","info":{"title":"Testdatadoc1","version":"v20210625"},"paths":{"/testdatadoc1/pageusers":{"post":{"summary":"You can define your service methods as your need. Below is an example.","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageQuery"}}},"required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageUsersResp"}}}}}}}},"components":{"schemas":{"Order":{"title":"Order","type":"object","properties":{"Col":{"type":"string"},"Sort":{"type":"string"}}},"Page":{"title":"Page","type":"object","properties":{"Orders":{"type":"array","items":{"$ref":"#/components/schemas/Order"},"description":"排序规则"},"PageNo":{"type":"integer","format":"int32","description":"页码"},"Size":{"type":"integer","format":"int32","description":"每页行数"}}},"PageFilter":{"title":"PageFilter","type":"object","properties":{"Dept":{"type":"integer","format":"int32","description":"所属部门ID"},"Name":{"type":"string","description":"真实姓名，前缀匹配"}}},"PageQuery":{"title":"PageQuery","type":"object","properties":{"Filter":{"$ref":"#/components/schemas/PageFilter"},"Page":{"$ref":"#/components/schemas/Page"}},"description":"分页筛选条件"},"PageRet":{"title":"PageRet","type":"object","properties":{"HasNext":{"type":"boolean"},"Items":{"type":"object"},"PageNo":{"type":"integer","format":"int32"},"PageSize":{"type":"integer","format":"int32"},"Total":{"type":"integer","format":"int32"}}},"PageUsersResp":{"title":"PageUsersResp","type":"object","properties":{"code":{"type":"integer","format":"int32"},"data":{"$ref":"#/components/schemas/PageRet"},"msg":{"type":"string"}}},"UserVo":{"title":"UserVo","type":"object","properties":{"Dept":{"type":"string"},"Id":{"type":"integer","format":"int32"},"Name":{"type":"string"},"Phone":{"type":"string"}}}}}}
```

framework/testdata/vo/vo.go
```
1 | package vo
2 | 
3 | //go:generate go-doudou name --file $GOFILE -o
4 | 
5 | // 筛选条件
6 | type PageFilter struct {
7 | 	// 真实姓名，前缀匹配
8 | 	Name string
9 | 	// 所属部门ID
10 | 	Dept int
11 | }
12 | 
13 | // 排序条件
14 | type Order struct {
15 | 	Col  string
16 | 	Sort string
17 | }
18 | 
19 | type Page struct {
20 | 	// 排序规则
21 | 	Orders []Order
22 | 	// 页码
23 | 	PageNo int
24 | 	// 每页行数
25 | 	Size int
26 | 	User UserVo
27 | }
28 | 
29 | // 分页筛选条件
30 | type PageQuery struct {
31 | 	Filter  PageFilter
32 | 	Page    Page
33 | 	Options []struct {
34 | 		Label string `json:"label" form:"label"`
35 | 		Value string `json:"value" form:"value"`
36 | 	} `json:"options" form:"options"`
37 | }
38 | 
39 | type PageRet struct {
40 | 	Items    interface{}
41 | 	PageNo   int
42 | 	PageSize int
43 | 	Total    int
44 | 	HasNext  bool
45 | }
46 | 
47 | type UserVo struct {
48 | 	Id    int
49 | 	Name  string
50 | 	Phone string
51 | 	Dept  string
52 | }
```

cmd/internal/ddl/exec.go
```
1 | package ddl
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"os"
7 | 	"path/filepath"
8 | 	"strings"
9 | 	"time"
10 | 
11 | 	"github.com/pkg/errors"
12 | 	"github.com/sirupsen/logrus"
13 | 	"github.com/unionj-cloud/toolkit/astutils"
14 | 	"github.com/unionj-cloud/toolkit/caller"
15 | 
16 | 	// here must import mysql
17 | 	_ "github.com/go-sql-driver/mysql"
18 | 	"github.com/iancoleman/strcase"
19 | 	"github.com/jmoiron/sqlx"
20 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/codegen"
21 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/config"
22 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/table"
23 | )
24 | 
25 | // Ddl is for ddl command
26 | type Ddl struct {
27 | 	Dir     string
28 | 	Reverse bool
29 | 	Dao     bool
30 | 	Pre     string
31 | 	Df      string
32 | 	Conf    config.DbConfig
33 | }
34 | 
35 | // Exec executes the logic for ddl command
36 | // if Reverse is true, it will generate code from database tables,
37 | // otherwise it will update database tables from structs defined in entity pkg
38 | func (d Ddl) Exec() {
39 | 	var db *sqlx.DB
40 | 	var err error
41 | 	conf := d.Conf
42 | 	conn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=%s",
43 | 		conf.User,
44 | 		conf.Passwd,
45 | 		conf.Host,
46 | 		conf.Port,
47 | 		conf.Schema,
48 | 		conf.Charset)
49 | 	conn += `&loc=Asia%2FShanghai&parseTime=True`
50 | 	db, err = sqlx.Connect("mysql", conn)
51 | 	if err != nil {
52 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
53 | 	}
54 | 	defer db.Close()
55 | 	db.MapperFunc(strcase.ToSnake)
56 | 	db = db.Unsafe()
57 | 
58 | 	var existTables []string
59 | 	if err = db.Select(&existTables, "show tables"); err != nil {
60 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
61 | 	}
62 | 
63 | 	var tables []table.Table
64 | 	timeoutCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
65 | 	defer cancel()
66 | 	_ = os.MkdirAll(d.Dir, os.ModePerm)
67 | 	if !d.Reverse {
68 | 		tables = table.Struct2Table(timeoutCtx, d.Dir, d.Pre, existTables, db, d.Conf.Schema)
69 | 	} else {
70 | 		tables = table.Table2struct(timeoutCtx, d.Pre, d.Conf.Schema, existTables, db)
71 | 		var entities []astutils.StructMeta
72 | 		for _, item := range tables {
73 | 			dfile := filepath.Join(d.Dir, strings.ToLower(item.Meta.Name)+".go")
74 | 			if _, err = os.Stat(dfile); os.IsNotExist(err) {
75 | 				codegen.GenEntityGo(d.Dir, item.Meta)
76 | 				entities = append(entities, item.Meta)
77 | 			} else {
78 | 				logrus.Warnf("file %s already exists", dfile)
79 | 			}
80 | 		}
81 | 		codegen.GenDto(d.Dir, entities)
82 | 	}
83 | 
84 | 	if d.Dao {
85 | 		genDao(d, tables)
86 | 	}
87 | }
88 | 
89 | func genDao(d Ddl, tables []table.Table) {
90 | 	var err error
91 | 	for _, t := range tables {
92 | 		if err = codegen.GenIDaoGo(d.Dir, t, d.Df); err != nil {
93 | 			panic(errors.Wrap(err, caller.NewCaller().String()))
94 | 		}
95 | 		if err = codegen.GenDaoGo(d.Dir, t, d.Df); err != nil {
96 | 			panic(errors.Wrap(err, caller.NewCaller().String()))
97 | 		}
98 | 		if err = codegen.GenDaoSQL(d.Dir, t, d.Df); err != nil {
99 | 			panic(errors.Wrap(err, caller.NewCaller().String()))
100 | 		}
101 | 	}
102 | }
```

cmd/internal/enum/generator.go
```
1 | package enum
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"sort"
8 | 	"strings"
9 | 	"text/template"
10 | 
11 | 	"github.com/pkg/errors"
12 | 	"github.com/sirupsen/logrus"
13 | 	"github.com/unionj-cloud/toolkit/astutils"
14 | 	"github.com/unionj-cloud/toolkit/stringutils"
15 | 	"github.com/unionj-cloud/go-doudou/v2/version"
16 | )
17 | 
18 | var enumsTmpl = `/**
19 | * Generated by go-doudou {{.Version}}.
20 | * Don't edit!
21 | */
22 | package {{.Package}}
23 | 
24 | import "encoding/json"
25 | 
26 | {{- range $m := .Enums }}
27 | 
28 | func ({{$m.Receiver}} *{{$m.Name}}) StringSetter(value string) {
29 | 	switch value {
30 | 	{{- range $v := $m.Values}}
31 | 	case "{{$v}}":
32 | 		*{{$m.Receiver}} = {{$v}}
33 | 	{{- end }}
34 | 	default:
35 | 		*{{$m.Receiver}} = {{index $m.Values 0}}
36 | 	}
37 | }
38 | 
39 | func ({{$m.Receiver}} *{{$m.Name}}) StringGetter() string {
40 | 	switch *{{$m.Receiver}} {
41 | 	{{- range $v := $m.Values}}
42 | 	case {{$v}}:
43 | 		return "{{$v}}"
44 | 	{{- end }}
45 | 	default:
46 | 		return "{{index $m.Values 0}}"
47 | 	}
48 | }
49 | 
50 | func ({{$m.Receiver}} *{{$m.Name}}) UnmarshalJSON(bytes []byte) error {
51 | 	var _{{$m.Receiver}} string
52 | 	err := json.Unmarshal(bytes, &_{{$m.Receiver}})
53 | 	if err != nil {
54 | 		return err
55 | 	}
56 | 	{{$m.Receiver}}.StringSetter(_{{$m.Receiver}})
57 | 	return nil
58 | }
59 | 
60 | func ({{$m.Receiver}} *{{$m.Name}}) MarshalJSON() ([]byte, error) {
61 | 	return json.Marshal({{$m.Receiver}}.StringGetter())
62 | }
63 | {{- end }}
64 | `
65 | 
66 | type Generator struct {
67 | 	_    [0]int
68 | 	File string
69 | }
70 | 
71 | type Enum struct {
72 | 	astutils.EnumMeta
73 | 	Receiver string
74 | }
75 | 
76 | func (receiver Generator) Generate() {
77 | 	var (
78 | 		f       *os.File
79 | 		err     error
80 | 		codeBuf bytes.Buffer
81 | 		fi      os.FileInfo
82 | 	)
83 | 	if stringutils.IsEmpty(receiver.File) {
84 | 		panic(errors.New("file flag should not be empty"))
85 | 	}
86 | 	sc := astutils.EnumsOf(receiver.File, astutils.ExprString)
87 | 	getReceiver := func(s string) string {
88 | 		return strings.ToLower(string([]rune(s)[0]))
89 | 	}
90 | 	var enums []Enum
91 | 	for k, v := range sc.Consts {
92 | 		enums = append(enums, Enum{
93 | 			EnumMeta: astutils.EnumMeta{
94 | 				Name:   k,
95 | 				Values: v,
96 | 			},
97 | 			Receiver: getReceiver(k),
98 | 		})
99 | 	}
100 | 	sort.SliceStable(enums, func(i, j int) bool {
101 | 		return enums[i].Name < enums[j].Name
102 | 	})
103 | 	dir := filepath.Dir(receiver.File)
104 | 	enumsFile := filepath.Join(dir, "enums_gen.go")
105 | 	fi, err = os.Stat(enumsFile)
106 | 	if err != nil && !os.IsNotExist(err) {
107 | 		panic(err)
108 | 	}
109 | 	if fi != nil {
110 | 		logrus.Warningln("file enums_gen.go will be overwritten")
111 | 	}
112 | 	if f, err = os.Create(enumsFile); err != nil {
113 | 		panic(err)
114 | 	}
115 | 	defer f.Close()
116 | 	tpl := template.New("enums.tmpl")
117 | 	if tpl, err = tpl.Parse(enumsTmpl); err != nil {
118 | 		panic(err)
119 | 	}
120 | 	if err = tpl.Execute(&codeBuf, struct {
121 | 		Package string
122 | 		Enums   []Enum
123 | 		Version string
124 | 	}{
125 | 		Package: sc.Package.Name,
126 | 		Enums:   enums,
127 | 		Version: version.Release,
128 | 	}); err != nil {
129 | 		panic(err)
130 | 	}
131 | 	source := strings.TrimSpace(codeBuf.String())
132 | 	astutils.FixImport([]byte(source), enumsFile)
133 | }
```

cmd/internal/enum/generator_test.go
```
1 | package enum
2 | 
3 | import (
4 | 	"path/filepath"
5 | 	"testing"
6 | )
7 | 
8 | func TestGenerator_Generate(t *testing.T) {
9 | 	file := filepath.Join("./testdata", "dto.go")
10 | 	receiver := Generator{
11 | 		File: file,
12 | 	}
13 | 	receiver.Generate()
14 | }
```

cmd/internal/modular/work.go
```
1 | package modular
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"text/template"
7 | 
8 | 	"github.com/sirupsen/logrus"
9 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
10 | 	"github.com/unionj-cloud/toolkit/common"
11 | 	"github.com/unionj-cloud/toolkit/executils"
12 | 	"github.com/unionj-cloud/toolkit/stringutils"
13 | 	"github.com/unionj-cloud/go-doudou/v2/version"
14 | )
15 | 
16 | const (
17 | 	mainDirName = "main"
18 | 	cmdDirName  = "cmd"
19 | )
20 | 
21 | type WorkConfig struct {
22 | 	WorkDir string
23 | }
24 | 
25 | type Work struct {
26 | 	conf   WorkConfig
27 | 	runner executils.Runner
28 | }
29 | 
30 | func NewWork(conf WorkConfig, runner executils.Runner) *Work {
31 | 	return &Work{
32 | 		conf:   conf,
33 | 		runner: runner,
34 | 	}
35 | }
36 | 
37 | func (receiver *Work) GetWorkDir() string {
38 | 	return receiver.conf.WorkDir
39 | }
40 | 
41 | func (receiver *Work) SetWorkDir(workDir string) {
42 | 	receiver.conf.WorkDir = workDir
43 | }
44 | 
45 | const workTmpl = `go 1.22.2
46 | 
47 | toolchain go1.22.3
48 | `
49 | 
50 | func (receiver *Work) goModInMainPkg(dir, modName, goVersion string) {
51 | 	modfile := filepath.Join(dir, "go.mod")
52 | 	if _, err := os.Stat(modfile); os.IsNotExist(err) {
53 | 		f, err := os.Create(modfile)
54 | 		if err != nil {
55 | 			panic(err)
56 | 		}
57 | 		defer f.Close()
58 | 
59 | 		tpl, _ := template.New(templates.MainPkgModTmpl).Parse(templates.MainPkgModTmpl)
60 | 		_ = tpl.Execute(f, struct {
61 | 			ModName         string
62 | 			GoVersion       string
63 | 			GoDoudouVersion string
64 | 		}{
65 | 			ModName:         modName,
66 | 			GoVersion:       goVersion,
67 | 			GoDoudouVersion: version.Release,
68 | 		})
69 | 	} else {
70 | 		logrus.Warnf("file %s already exists", modfile)
71 | 	}
72 | }
73 | 
74 | const envTmpl = ``
75 | 
76 | func (receiver *Work) dotenv(dir string) {
77 | 	envfile := filepath.Join(dir, ".env")
78 | 	if _, err := os.Stat(envfile); os.IsNotExist(err) {
79 | 		f, err := os.Create(envfile)
80 | 		if err != nil {
81 | 			panic(err)
82 | 		}
83 | 		defer f.Close()
84 | 
85 | 		tpl, _ := template.New(envTmpl).Parse(envTmpl)
86 | 		_ = tpl.Execute(f, struct{}{})
87 | 	} else {
88 | 		logrus.Warnf("file %s already exists", envfile)
89 | 	}
90 | }
91 | 
92 | func (receiver *Work) mainGo(dir string) {
93 | 	mainGoFile := filepath.Join(dir, "main.go")
94 | 	if _, err := os.Stat(mainGoFile); os.IsNotExist(err) {
95 | 		f, err := os.Create(mainGoFile)
96 | 		if err != nil {
97 | 			panic(err)
98 | 		}
99 | 		defer f.Close()
100 | 
101 | 		tpl, _ := template.New(templates.MainMainTmpl).Parse(templates.MainMainTmpl)
102 | 		_ = tpl.Execute(f, struct {
103 | 			Version string
104 | 		}{
105 | 			Version: version.Release,
106 | 		})
107 | 	} else {
108 | 		logrus.Warnf("file %s already exists", mainGoFile)
109 | 	}
110 | }
111 | 
112 | func (receiver *Work) cmdPkg(dir string) {
113 | 	cmdDir := filepath.Join(dir, cmdDirName)
114 | 	if _, err := os.Stat(cmdDir); os.IsNotExist(err) {
115 | 		err = os.MkdirAll(cmdDir, os.ModePerm)
116 | 		if err != nil {
117 | 			panic(err)
118 | 		}
119 | 		receiver.mainGo(cmdDir)
120 | 	} else {
121 | 		logrus.Warnf("directory %s already exists", cmdDir)
122 | 	}
123 | }
124 | 
125 | func (receiver *Work) mainPkg(goVersion string) {
126 | 	mainDir := filepath.Join(receiver.GetWorkDir(), mainDirName)
127 | 	if _, err := os.Stat(mainDir); os.IsNotExist(err) {
128 | 		err = os.MkdirAll(mainDir, os.ModePerm)
129 | 		if err != nil {
130 | 			panic(err)
131 | 		}
132 | 		modName := filepath.Base(receiver.GetWorkDir()) + "/" + mainDirName
133 | 		receiver.goModInMainPkg(mainDir, modName, goVersion)
134 | 		receiver.dotenv(mainDir)
135 | 		receiver.cmdPkg(mainDir)
136 | 	} else {
137 | 		logrus.Warnf("directory %s already exists", mainDir)
138 | 	}
139 | }
140 | 
141 | func (receiver *Work) Init() {
142 | 	if stringutils.IsEmpty(receiver.GetWorkDir()) {
143 | 		wd, _ := os.Getwd()
144 | 		receiver.SetWorkDir(wd)
145 | 	}
146 | 	workDir := receiver.GetWorkDir()
147 | 	_ = os.MkdirAll(workDir, os.ModePerm)
148 | 
149 | 	goVersion, err := common.GetGoVersionNum(receiver.runner)
150 | 	if err != nil {
151 | 		panic(err)
152 | 	}
153 | 	workFile := filepath.Join(receiver.GetWorkDir(), "go.work")
154 | 	if _, err = os.Stat(workFile); os.IsNotExist(err) {
155 | 		f, err := os.Create(workFile)
156 | 		if err != nil {
157 | 			panic(err)
158 | 		}
159 | 		defer f.Close()
160 | 
161 | 		tpl, _ := template.New(workTmpl).Parse(workTmpl)
162 | 		_ = tpl.Execute(f, struct {
163 | 			GoVersion string
164 | 		}{
165 | 			GoVersion: goVersion,
166 | 		})
167 | 	} else {
168 | 		logrus.Warnf("file %s already exists", workFile)
169 | 	}
170 | 
171 | 	receiver.mainPkg(goVersion)
172 | 
173 | 	if err = os.Chdir(receiver.GetWorkDir()); err != nil {
174 | 		panic(err)
175 | 	}
176 | 	if err = receiver.runner.Run("go", "work", "use", "main"); err != nil {
177 | 		panic(err)
178 | 	}
179 | 	// Comment below code due to performance issue
180 | 	//if err = receiver.runner.Run("go", "work", "sync"); err != nil {
181 | 	//	panic(err)
182 | 	//}
183 | }
```

cmd/internal/name/exec.go
```
1 | package name
2 | 
3 | import (
4 | 	"github.com/iancoleman/strcase"
5 | 	"github.com/pkg/errors"
6 | 	"github.com/unionj-cloud/toolkit/astutils"
7 | 	"github.com/unionj-cloud/toolkit/stringutils"
8 | )
9 | 
10 | // Name wraps config properties for name command
11 | type Name struct {
12 | 	File      string
13 | 	Strategy  string
14 | 	Omitempty bool
15 | 	Form      bool
16 | }
17 | 
18 | const (
19 | 	lowerCamelStrategy = "lowerCamel"
20 | 	snakeStrategy      = "snake"
21 | )
22 | 
23 | // Exec rewrites the json tag of each field of all structs in the file as snake case or lower camel case.
24 | // Unexported or ignored fields will be skipped.
25 | func (receiver Name) Exec() {
26 | 	if stringutils.IsEmpty(receiver.File) {
27 | 		panic(errors.New("file flag should not be empty"))
28 | 	}
29 | 
30 | 	var convert func(string) string
31 | 	switch receiver.Strategy {
32 | 	case lowerCamelStrategy:
33 | 		convert = strcase.ToLowerCamel
34 | 	case snakeStrategy:
35 | 		convert = strcase.ToSnake
36 | 	default:
37 | 		panic(errors.New(`unknown strategy. currently only support "lowerCamel" and "snake"`))
38 | 	}
39 | 
40 | 	newcode, err := astutils.RewriteTag(astutils.RewriteTagConfig{
41 | 		File:        receiver.File,
42 | 		Omitempty:   receiver.Omitempty,
43 | 		ConvertFunc: convert,
44 | 		Form:        receiver.Form,
45 | 	})
46 | 	if err != nil {
47 | 		panic(err)
48 | 	}
49 | 	astutils.FixImport([]byte(newcode), receiver.File)
50 | }
```

cmd/internal/name/exec_test.go
```
1 | package name
2 | 
3 | import (
4 | 	"io/ioutil"
5 | 	"os"
6 | 	"testing"
7 | 
8 | 	"github.com/stretchr/testify/assert"
9 | 	"github.com/unionj-cloud/toolkit/pathutils"
10 | )
11 | 
12 | const initCode = `package testdata
13 | 
14 | // 筛选条件
15 | type PageFilter struct {
16 | 	// 真实姓名，前缀匹配
17 | 	Name string
18 | 	// 所属部门ID
19 | 	Dept int
20 | }
21 | 
22 | //排序条件
23 | type Order struct {
24 | 	Col  string	` + "`" + `json:"-"` + "`" + `
25 | 	sort string
26 | }
27 | 
28 | type PageRet struct {
29 | 	Items    interface{}
30 | 	PageNo   int
31 | 	PageSize int
32 | 	Total    int
33 | 	HasNext  bool
34 | }
35 | 
36 | type Field struct {
37 | 	Name   string
38 | 	Type   string
39 | 	Format string
40 | }
41 | 
42 | type Base struct {
43 | 	Index string
44 | 	Type  string
45 | }
46 | 
47 | type MappingPayload struct {
48 | 	Base
49 | 	Fields []Field
50 | 	Index  string
51 | }
52 | `
53 | 
54 | func TestName_Exec(t *testing.T) {
55 | 	type fields struct {
56 | 		File      string
57 | 		Strategy  string
58 | 		Omitempty bool
59 | 	}
60 | 	tests := []struct {
61 | 		name     string
62 | 		fields   fields
63 | 		want     string
64 | 		initCode string
65 | 	}{
66 | 		{
67 | 			name: "",
68 | 			fields: fields{
69 | 				File:     pathutils.Abs("testdata/vo.go"),
70 | 				Strategy: lowerCamelStrategy,
71 | 			},
72 | 			initCode: initCode,
73 | 			want: `package testdata
74 | 
75 | // 筛选条件
76 | type PageFilter struct {
77 | 	// 真实姓名，前缀匹配
78 | 	Name string ` + "`" + `json:"name"` + "`" + `
79 | 	// 所属部门ID
80 | 	Dept int ` + "`" + `json:"dept"` + "`" + `
81 | }
82 | 
83 | //排序条件
84 | type Order struct {
85 | 	Col  string ` + "`" + `json:"-"` + "`" + `
86 | 	sort string
87 | }
88 | 
89 | type PageRet struct {
90 | 	Items    interface{} ` + "`" + `json:"items"` + "`" + `
91 | 	PageNo   int         ` + "`" + `json:"pageNo"` + "`" + `
92 | 	PageSize int         ` + "`" + `json:"pageSize"` + "`" + `
93 | 	Total    int         ` + "`" + `json:"total"` + "`" + `
94 | 	HasNext  bool        ` + "`" + `json:"hasNext"` + "`" + `
95 | }
96 | 
97 | type Field struct {
98 | 	Name   string ` + "`" + `json:"name"` + "`" + `
99 | 	Type   string ` + "`" + `json:"type"` + "`" + `
100 | 	Format string ` + "`" + `json:"format"` + "`" + `
101 | }
102 | 
103 | type Base struct {
104 | 	Index string ` + "`" + `json:"index"` + "`" + `
105 | 	Type  string ` + "`" + `json:"type"` + "`" + `
106 | }
107 | 
108 | type MappingPayload struct {
109 | 	Base
110 | 	Fields []Field ` + "`" + `json:"fields"` + "`" + `
111 | 	Index  string  ` + "`" + `json:"index"` + "`" + `
112 | }
113 | `,
114 | 		},
115 | 		{
116 | 			name: "",
117 | 			fields: fields{
118 | 				File:      pathutils.Abs("testdata/vo.go"),
119 | 				Strategy:  lowerCamelStrategy,
120 | 				Omitempty: true,
121 | 			},
122 | 			initCode: initCode,
123 | 			want: `package testdata
124 | 
125 | // 筛选条件
126 | type PageFilter struct {
127 | 	// 真实姓名，前缀匹配
128 | 	Name string ` + "`" + `json:"name,omitempty"` + "`" + `
129 | 	// 所属部门ID
130 | 	Dept int ` + "`" + `json:"dept,omitempty"` + "`" + `
131 | }
132 | 
133 | //排序条件
134 | type Order struct {
135 | 	Col  string ` + "`" + `json:"-"` + "`" + `
136 | 	sort string
137 | }
138 | 
139 | type PageRet struct {
140 | 	Items    interface{} ` + "`" + `json:"items,omitempty"` + "`" + `
141 | 	PageNo   int         ` + "`" + `json:"pageNo,omitempty"` + "`" + `
142 | 	PageSize int         ` + "`" + `json:"pageSize,omitempty"` + "`" + `
143 | 	Total    int         ` + "`" + `json:"total,omitempty"` + "`" + `
144 | 	HasNext  bool        ` + "`" + `json:"hasNext,omitempty"` + "`" + `
145 | }
146 | 
147 | type Field struct {
148 | 	Name   string ` + "`" + `json:"name,omitempty"` + "`" + `
149 | 	Type   string ` + "`" + `json:"type,omitempty"` + "`" + `
150 | 	Format string ` + "`" + `json:"format,omitempty"` + "`" + `
151 | }
152 | 
153 | type Base struct {
154 | 	Index string ` + "`" + `json:"index,omitempty"` + "`" + `
155 | 	Type  string ` + "`" + `json:"type,omitempty"` + "`" + `
156 | }
157 | 
158 | type MappingPayload struct {
159 | 	Base
160 | 	Fields []Field ` + "`" + `json:"fields,omitempty"` + "`" + `
161 | 	Index  string  ` + "`" + `json:"index,omitempty"` + "`" + `
162 | }
163 | `,
164 | 		},
165 | 		{
166 | 			name: "",
167 | 			fields: fields{
168 | 				File:      pathutils.Abs("testdata/vo.go"),
169 | 				Strategy:  snakeStrategy,
170 | 				Omitempty: false,
171 | 			},
172 | 			initCode: initCode,
173 | 			want: `package testdata
174 | 
175 | // 筛选条件
176 | type PageFilter struct {
177 | 	// 真实姓名，前缀匹配
178 | 	Name string ` + "`" + `json:"name"` + "`" + `
179 | 	// 所属部门ID
180 | 	Dept int ` + "`" + `json:"dept"` + "`" + `
181 | }
182 | 
183 | //排序条件
184 | type Order struct {
185 | 	Col  string ` + "`" + `json:"-"` + "`" + `
186 | 	sort string
187 | }
188 | 
189 | type PageRet struct {
190 | 	Items    interface{} ` + "`" + `json:"items"` + "`" + `
191 | 	PageNo   int         ` + "`" + `json:"page_no"` + "`" + `
192 | 	PageSize int         ` + "`" + `json:"page_size"` + "`" + `
193 | 	Total    int         ` + "`" + `json:"total"` + "`" + `
194 | 	HasNext  bool        ` + "`" + `json:"has_next"` + "`" + `
195 | }
196 | 
197 | type Field struct {
198 | 	Name   string ` + "`" + `json:"name"` + "`" + `
199 | 	Type   string ` + "`" + `json:"type"` + "`" + `
200 | 	Format string ` + "`" + `json:"format"` + "`" + `
201 | }
202 | 
203 | type Base struct {
204 | 	Index string ` + "`" + `json:"index"` + "`" + `
205 | 	Type  string ` + "`" + `json:"type"` + "`" + `
206 | }
207 | 
208 | type MappingPayload struct {
209 | 	Base
210 | 	Fields []Field ` + "`" + `json:"fields"` + "`" + `
211 | 	Index  string  ` + "`" + `json:"index"` + "`" + `
212 | }
213 | `,
214 | 		},
215 | 		{
216 | 			name: "",
217 | 			fields: fields{
218 | 				File:      pathutils.Abs("testdata/vo1.go"),
219 | 				Strategy:  snakeStrategy,
220 | 				Omitempty: false,
221 | 			},
222 | 			initCode: `package testdata
223 | 
224 | import "time"
225 | 
226 | // comment for alia age
227 | type age int
228 | 
229 | type Event struct {
230 | 	Name      string
231 | 	EventType int
232 | }
233 | 
234 | type TestAlias struct {
235 | 	Age    age
236 | 	School []struct {
237 | 		Name string
238 | 		Addr struct {
239 | 			Zip   string
240 | 			Block string
241 | 			Full  string
242 | 		}
243 | 	}
244 | 	EventChan chan Event
245 | 	SigChan   chan int
246 | 	Callback  func(string) bool
247 | 	CallbackN func(param string) bool
248 | }
249 | 
250 | type ta TestAlias
251 | 
252 | type tt time.Time
253 | 
254 | type mm map[string]interface{}
255 | 
256 | type MyInter interface {
257 | 	Speak() error
258 | }
259 | 
260 | type starM *time.Time
261 | `,
262 | 			want: `package testdata
263 | 
264 | import "time"
265 | 
266 | // comment for alia age
267 | type age int
268 | 
269 | type Event struct {
270 | 	Name      string ` + "`" + `json:"name"` + "`" + `
271 | 	EventType int    ` + "`" + `json:"event_type"` + "`" + `
272 | }
273 | 
274 | type TestAlias struct {
275 | 	Age    age ` + "`" + `json:"age"` + "`" + `
276 | 	School []struct {
277 | 		Name string ` + "`" + `json:"name"` + "`" + `
278 | 		Addr struct {
279 | 			Zip   string ` + "`" + `json:"zip"` + "`" + `
280 | 			Block string ` + "`" + `json:"block"` + "`" + `
281 | 			Full  string ` + "`" + `json:"full"` + "`" + `
282 | 		} ` + "`" + `json:"addr"` + "`" + `
283 | 	} ` + "`" + `json:"school"` + "`" + `
284 | 	EventChan chan Event              ` + "`" + `json:"event_chan"` + "`" + `
285 | 	SigChan   chan int                ` + "`" + `json:"sig_chan"` + "`" + `
286 | 	Callback  func(string) bool       ` + "`" + `json:"callback"` + "`" + `
287 | 	CallbackN func(param string) bool ` + "`" + `json:"callback_n"` + "`" + `
288 | }
289 | 
290 | type ta TestAlias
291 | 
292 | type tt time.Time
293 | 
294 | type mm map[string]interface{}
295 | 
296 | type MyInter interface {
297 | 	Speak() error
298 | }
299 | 
300 | type starM *time.Time
301 | `,
302 | 		},
303 | 	}
304 | 	for _, tt := range tests {
305 | 		t.Run(tt.name, func(t *testing.T) {
306 | 			receiver := Name{
307 | 				File:      tt.fields.File,
308 | 				Strategy:  tt.fields.Strategy,
309 | 				Omitempty: tt.fields.Omitempty,
310 | 			}
311 | 			receiver.Exec()
312 | 			f, err := os.Open(tt.fields.File)
313 | 			if err != nil {
314 | 				t.Fatal(err)
315 | 			}
316 | 			content, err := ioutil.ReadAll(f)
317 | 			if err != nil {
318 | 				t.Fatal(err)
319 | 			}
320 | 			assert.Equal(t, tt.want, string(content))
321 | 			ioutil.WriteFile(tt.fields.File, []byte(tt.initCode), os.ModePerm)
322 | 		})
323 | 	}
324 | }
325 | 
326 | func TestPanic(t *testing.T) {
327 | 	receiver := Name{
328 | 		File:      pathutils.Abs("testdata/vo1.go"),
329 | 		Strategy:  "unknownstrategy",
330 | 		Omitempty: false,
331 | 	}
332 | 	assert.Panics(t, func() {
333 | 		receiver.Exec()
334 | 	})
335 | }
336 | 
337 | func TestPanic2(t *testing.T) {
338 | 	receiver := Name{
339 | 		File:      pathutils.Abs("testdata/vo2"),
340 | 		Strategy:  lowerCamelStrategy,
341 | 		Omitempty: false,
342 | 	}
343 | 	assert.Panics(t, func() {
344 | 		receiver.Exec()
345 | 	})
346 | }
347 | 
348 | func ExampleNameForm_Exec() {
349 | 	receiver := Name{
350 | 		File:      pathutils.Abs("testdata/vo.go"),
351 | 		Strategy:  lowerCamelStrategy,
352 | 		Omitempty: false,
353 | 		Form:      true,
354 | 	}
355 | 	receiver.Exec()
356 | 	// output:
357 | }
```

cmd/internal/svc/svc.go
```
1 | package svc
2 | 
3 | import (
4 | 	"fmt"
5 | 	"os"
6 | 	"os/exec"
7 | 	"os/user"
8 | 	"path/filepath"
9 | 	"regexp"
10 | 	"strings"
11 | 	"syscall"
12 | 	"time"
13 | 
14 | 	"github.com/radovskyb/watcher"
15 | 	"github.com/sirupsen/logrus"
16 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/openapi/v3/codegen/client"
17 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/codegen"
18 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/codegen/database"
19 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/parser"
20 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/validate"
21 | 	"github.com/unionj-cloud/toolkit/assert"
22 | 	"github.com/unionj-cloud/toolkit/astutils"
23 | 	"github.com/unionj-cloud/toolkit/executils"
24 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
25 | 	"github.com/unionj-cloud/toolkit/stringutils"
26 | )
27 | 
28 | //go:generate mockgen -destination ../../mock/mock_svc.go -package mock -source=./svc.go
29 | 
30 | type ISvc interface {
31 | 	SetWatcher(w *watcher.Watcher)
32 | 	GetWatcher() *watcher.Watcher
33 | 	GetDir() string
34 | 	Http()
35 | 	Init()
36 | 	Crud()
37 | 	Push(cfg PushConfig)
38 | 	Deploy(k8sfile string)
39 | 	Shutdown(k8sfile string)
40 | 	GenClient()
41 | 	DoRun()
42 | 	DoRestart()
43 | 	DoWatch()
44 | 	Run(watch bool)
45 | 	Upgrade(version string)
46 | 	Grpc()
47 | }
48 | 
49 | // Svc wraps all config properties for commands
50 | type Svc struct {
51 | 	// dir is project root path
52 | 	dir string
53 | 	// Handler indicates whether generate default http handler implementation code or not
54 | 	Handler bool
55 | 	// Client is client language name
56 | 	Client bool
57 | 	// Omitempty indicates whether omit empty when marshal structs to json
58 | 	Omitempty bool
59 | 	// Doc indicates whether generate OpenAPI 3.0 json doc file
60 | 	Doc bool
61 | 	// DocPath is OpenAPI 3.0 json doc file path used for generating client code
62 | 	DocPath string
63 | 	// Env is service base url environment variable name used for generating client code
64 | 	Env string
65 | 	// ClientPkg is client package name
66 | 	ClientPkg string
67 | 
68 | 	cmd        *exec.Cmd
69 | 	restartSig chan int
70 | 
71 | 	// for being compatible with legacy code purpose only
72 | 	RoutePatternStrategy int
73 | 
74 | 	runner executils.Runner
75 | 	w      *watcher.Watcher
76 | 
77 | 	// ModName is go module name
78 | 	ModName string
79 | 
80 | 	// PostmanCollectionPath is postman collection v2.1 compatible file disk path
81 | 	PostmanCollectionPath string
82 | 	// DotenvPath dotenv format config file disk path only for integration testing purpose
83 | 	DotenvPath string
84 | 
85 | 	// AllowGetWithReqBody indicates whether allow get http request with request body.
86 | 	// If true, when you defined a get api with struct type parameter in svc.go file,
87 | 	// it will try to decode json format encoded request body.
88 | 	AllowGetWithReqBody bool
89 | 
90 | 	DbConfig *DbConfig
91 | 
92 | 	module         bool
93 | 	protoGenerator v3.ProtoGenerator
94 | 
95 | 	JsonCase      string
96 | 	CaseConverter func(string) string
97 | 
98 | 	http2grpc   bool
99 | 	projectType string
100 | }
101 | 
102 | type DbConfig struct {
103 | 	Driver string
104 | 	Dsn    string
105 | 	// or schema for pg
106 | 	TablePrefix      string
107 | 	TableGlob        string
108 | 	TableExcludeGlob string
109 | 	// whether generate gen.go file
110 | 	GenGenGo    bool
111 | 	Orm         string
112 | 	Soft        string
113 | 	Service     string
114 | 	Omitempty   bool
115 | 	TypeMapping string
116 | }
117 | 
118 | func (receiver *Svc) SetWatcher(w *watcher.Watcher) {
119 | 	receiver.w = w
120 | }
121 | 
122 | func (receiver *Svc) GetWatcher() *watcher.Watcher {
123 | 	return receiver.w
124 | }
125 | 
126 | func (receiver *Svc) GetDir() string {
127 | 	return receiver.dir
128 | }
129 | 
130 | func (receiver *Svc) SetRunner(runner executils.Runner) {
131 | 	receiver.runner = runner
132 | }
133 | 
134 | // Http generates main function, config files, db connection function, http routes, http handlers, service interface and service implementation
135 | // from the result of ast parsing svc.go file in the project root. It may panic if validation failed
136 | func (receiver *Svc) Http() {
137 | 	dir := receiver.dir
138 | 	parser.ParseDto(dir, parser.DEFAULT_DTO_PKGS...)
139 | 	validate.DataType(dir, parser.DEFAULT_DTO_PKGS...)
140 | 
141 | 	ic := astutils.BuildInterfaceCollector(filepath.Join(dir, "svc.go"), astutils.ExprString)
142 | 	validate.RestApi(dir, ic)
143 | 
144 | 	codegen.GenConfig(dir, ic)
145 | 	codegen.GenHttpMiddleware(dir)
146 | 
147 | 	codegen.GenMain(dir, ic)
148 | 	codegen.GenHttpHandler(dir, ic, receiver.RoutePatternStrategy)
149 | 	codegen.GenHttpHandlerImpl(dir, ic, codegen.GenHttpHandlerImplConfig{
150 | 		Omitempty:           receiver.Omitempty,
151 | 		AllowGetWithReqBody: receiver.AllowGetWithReqBody,
152 | 		CaseConvertor:       receiver.CaseConverter,
153 | 	})
154 | 	if receiver.Client {
155 | 		codegen.GenGoIClient(dir, ic)
156 | 		codegen.GenGoClient(dir, ic, codegen.GenGoClientConfig{
157 | 			Env:                  receiver.Env,
158 | 			RoutePatternStrategy: receiver.RoutePatternStrategy,
159 | 			AllowGetWithReqBody:  receiver.AllowGetWithReqBody,
160 | 			CaseConvertor:        receiver.CaseConverter,
161 | 		})
162 | 		codegen.GenGoClientProxy(dir, ic)
163 | 	}
164 | 	codegen.GenSvcImpl(dir, ic)
165 | 	parser.GenDoc(dir, ic, parser.GenDocConfig{
166 | 		RoutePatternStrategy: receiver.RoutePatternStrategy,
167 | 		AllowGetWithReqBody:  receiver.AllowGetWithReqBody,
168 | 	})
169 | 	// here go mod tidy cause performance issue on some computer
170 | 	//runner := receiver.runner
171 | 	//if runner == nil {
172 | 	//	runner = executils.CmdRunner{}
173 | 	//}
174 | 	//runner.Run("go", "mod", "tidy")
175 | }
176 | 
177 | // Init inits a project
178 | func (receiver *Svc) Init() {
179 | 	codegen.InitProj(codegen.InitProjConfig{
180 | 		Dir:            receiver.dir,
181 | 		ModName:        receiver.ModName,
182 | 		Runner:         receiver.runner,
183 | 		Module:         receiver.module,
184 | 		ProtoGenerator: receiver.protoGenerator,
185 | 		JsonCase:       receiver.JsonCase,
186 | 		ProjectType:    receiver.projectType,
187 | 	})
188 | }
189 | 
190 | func (receiver *Svc) Crud() {
191 | 	gen := database.GetOrmGenerator(database.OrmKind(receiver.DbConfig.Orm))
192 | 	assert.NotNil(gen, "Unknown orm kind")
193 | 	gen.Initialize(database.OrmGeneratorConfig{
194 | 		Driver:           receiver.DbConfig.Driver,
195 | 		Dsn:              receiver.DbConfig.Dsn,
196 | 		TablePrefix:      receiver.DbConfig.TablePrefix,
197 | 		TableGlob:        receiver.DbConfig.TableGlob,
198 | 		TableExcludeGlob: receiver.DbConfig.TableExcludeGlob,
199 | 		GenGenGo:         receiver.DbConfig.GenGenGo,
200 | 		CaseConverter:    receiver.CaseConverter,
201 | 		Dir:              receiver.dir,
202 | 		Soft:             receiver.DbConfig.Soft,
203 | 		ProtoGenerator:   receiver.protoGenerator,
204 | 		Omitempty:        receiver.DbConfig.Omitempty,
205 | 		TypeMapping:      receiver.DbConfig.TypeMapping,
206 | 	})
207 | 	if stringutils.IsNotEmpty(receiver.DbConfig.Service) {
208 | 		switch receiver.DbConfig.Service {
209 | 		case "grpc":
210 | 			gen.GenGrpc()
211 | 		case "rest":
212 | 			gen.GenRest()
213 | 		}
214 | 	} else {
215 | 		gen.GenDao()
216 | 	}
217 | }
218 | 
219 | type SvcOption func(svc *Svc)
220 | 
221 | func WithHttp2Grpc(http2grpc bool) SvcOption {
222 | 	return func(svc *Svc) {
223 | 		svc.http2grpc = http2grpc
224 | 	}
225 | }
226 | 
227 | func WithAllowGetWithReqBody(allowGetWithReqBody bool) SvcOption {
228 | 	return func(svc *Svc) {
229 | 		svc.AllowGetWithReqBody = allowGetWithReqBody
230 | 	}
231 | }
232 | 
233 | func WithRunner(runner executils.Runner) SvcOption {
234 | 	return func(svc *Svc) {
235 | 		svc.runner = runner
236 | 	}
237 | }
238 | 
239 | func WithModName(modName string) SvcOption {
240 | 	return func(svc *Svc) {
241 | 		svc.ModName = modName
242 | 	}
243 | }
244 | 
245 | func WithDocPath(docfile string) SvcOption {
246 | 	return func(svc *Svc) {
247 | 		svc.DocPath = docfile
248 | 	}
249 | }
250 | 
251 | func WithDbConfig(dbConfig *DbConfig) SvcOption {
252 | 	return func(svc *Svc) {
253 | 		svc.DbConfig = dbConfig
254 | 	}
255 | }
256 | 
257 | func WithModule(module bool) SvcOption {
258 | 	return func(svc *Svc) {
259 | 		svc.module = module
260 | 	}
261 | }
262 | 
263 | func WithCaseConverter(fn func(string) string) SvcOption {
264 | 	return func(svc *Svc) {
265 | 		svc.CaseConverter = fn
266 | 	}
267 | }
268 | 
269 | func WithOmitempty(omitempty bool) SvcOption {
270 | 	return func(svc *Svc) {
271 | 		svc.Omitempty = omitempty
272 | 	}
273 | }
274 | 
275 | func WithJsonCase(jsonCase string) SvcOption {
276 | 	return func(svc *Svc) {
277 | 		svc.JsonCase = jsonCase
278 | 	}
279 | }
280 | 
281 | func WithProjectType(projectType string) SvcOption {
282 | 	return func(svc *Svc) {
283 | 		svc.projectType = projectType
284 | 	}
285 | }
286 | 
287 | func WithProtoGenerator(protoGenerator v3.ProtoGenerator) SvcOption {
288 | 	return func(svc *Svc) {
289 | 		svc.protoGenerator = protoGenerator
290 | 	}
291 | }
292 | 
293 | // NewSvc new Svc instance
294 | func NewSvc(dir string, opts ...SvcOption) ISvc {
295 | 	ret := Svc{
296 | 		dir:        dir,
297 | 		runner:     executils.CmdRunner{},
298 | 		restartSig: make(chan int),
299 | 	}
300 | 	for _, opt := range opts {
301 | 		opt(&ret)
302 | 	}
303 | 	return &ret
304 | }
305 | 
306 | type PushConfig struct {
307 | 	Repo   string
308 | 	Prefix string
309 | 	Ver    string
310 | }
311 | 
312 | // Push executes go mod vendor command first, then build docker image and push to remote image repository
313 | // It also generates deployment kind and statefulset kind yaml files for kubernetes deploy, if these files already exist,
314 | // it will only change the image version in each file, so you can edit these files manually to fit your need.
315 | func (receiver *Svc) Push(cfg PushConfig) {
316 | 	ic := astutils.BuildInterfaceCollector(filepath.Join(receiver.dir, "svc.go"), astutils.ExprString)
317 | 	svcname := strings.ToLower(ic.Interfaces[0].Name)
318 | 	imageName := fmt.Sprintf("%s%s", cfg.Prefix, svcname)
319 | 	if stringutils.IsNotEmpty(cfg.Ver) {
320 | 		imageName += ":" + cfg.Ver
321 | 	}
322 | 	loginUser, _ := user.Current()
323 | 	var err error
324 | 	if loginUser != nil {
325 | 		err = receiver.runner.Run("docker", "build", "--build-arg", fmt.Sprintf("user=%s", loginUser.Username), "-t", imageName, ".")
326 | 		if err != nil {
327 | 			panic(err)
328 | 		}
329 | 	} else {
330 | 		err = receiver.runner.Run("docker", "build", "-t", imageName, ".")
331 | 		if err != nil {
332 | 			panic(err)
333 | 		}
334 | 	}
335 | 
336 | 	if stringutils.IsNotEmpty(cfg.Repo) {
337 | 		remoteImageName := cfg.Repo + "/" + imageName
338 | 		err = receiver.runner.Run("docker", "tag", imageName, remoteImageName)
339 | 		if err != nil {
340 | 			panic(err)
341 | 		}
342 | 		err = receiver.runner.Run("docker", "push", remoteImageName)
343 | 		if err != nil {
344 | 			panic(err)
345 | 		}
346 | 		logrus.Infof("image %s has been pushed successfully\n", remoteImageName)
347 | 		imageName = remoteImageName
348 | 	}
349 | 
350 | 	codegen.GenK8sDeployment(receiver.dir, svcname, imageName)
351 | 	codegen.GenK8sStatefulset(receiver.dir, svcname, imageName)
352 | 	logrus.Infof("k8s yaml has been created/updated successfully. execute command 'go-doudou svc deploy' to deploy service %s to k8s cluster\n", svcname)
353 | }
354 | 
355 | // Deploy deploys project to kubernetes. If k8sfile flag not set, it will be deployed as deployment kind using *_deployment.yaml file in the project root,
356 | func (receiver *Svc) Deploy(k8sfile string) {
357 | 	ic := astutils.BuildInterfaceCollector(filepath.Join(receiver.dir, "svc.go"), astutils.ExprString)
358 | 	svcname := strings.ToLower(ic.Interfaces[0].Name)
359 | 	if stringutils.IsEmpty(k8sfile) {
360 | 		k8sfile = filepath.Join(receiver.dir, svcname+"_deployment.yaml")
361 | 	}
362 | 	logrus.Infof("Execute command: kubectl apply -f %s\n", k8sfile)
363 | 	if err := receiver.runner.Run("kubectl", "apply", "-f", k8sfile); err != nil {
364 | 		panic(err)
365 | 	}
366 | }
367 | 
368 | // Shutdown stops and removes the project from kubernetes. If k8sfile flag not set, it will use *_deployment.yaml file in the project root,
369 | // so if you had already set k8sfile flag when you deploy the project, you should set the same k8sfile flag.
370 | func (receiver *Svc) Shutdown(k8sfile string) {
371 | 	ic := astutils.BuildInterfaceCollector(filepath.Join(receiver.dir, "svc.go"), astutils.ExprString)
372 | 	svcname := strings.ToLower(ic.Interfaces[0].Name)
373 | 	if stringutils.IsEmpty(k8sfile) {
374 | 		k8sfile = filepath.Join(receiver.dir, svcname+"_deployment.yaml")
375 | 	}
376 | 	logrus.Infof("Execute command: kubectl delete -f %s\n", k8sfile)
377 | 	if err := receiver.runner.Run("kubectl", "delete", "-f", k8sfile); err != nil {
378 | 		panic(err)
379 | 	}
380 | }
381 | 
382 | // GenClient generates http client code from OpenAPI3.0 description json file, only support Golang currently.
383 | func (receiver *Svc) GenClient() {
384 | 	docpath := receiver.DocPath
385 | 	if stringutils.IsEmpty(docpath) {
386 | 		matches, _ := filepath.Glob(filepath.Join(receiver.dir, "*_openapi3.json"))
387 | 		if len(matches) > 0 {
388 | 			docpath = matches[0]
389 | 		}
390 | 	}
391 | 	if stringutils.IsEmpty(docpath) {
392 | 		panic("openapi 3.0 spec json file path is empty")
393 | 	}
394 | 	client.GenGoClient(receiver.dir, docpath, receiver.Omitempty, receiver.Env, receiver.ClientPkg)
395 | }
396 | 
397 | // GenIntegrationTestingCode generates integration testing code from postman collection v2.1 compatible file
398 | func (receiver *Svc) GenIntegrationTestingCode() {
399 | 	ic := astutils.BuildInterfaceCollector(filepath.Join(receiver.dir, "svc.go"), astutils.ExprString)
400 | 	codegen.GenHttpIntegrationTesting(receiver.dir, ic, receiver.PostmanCollectionPath, receiver.DotenvPath)
401 | }
402 | 
403 | func (receiver *Svc) DoRun() {
404 | 	err := receiver.runner.Run("go", "build", filepath.FromSlash("cmd/main.go"))
405 | 	if err != nil {
406 | 		panic(err)
407 | 	}
408 | 	start, err := receiver.runner.Start(filepath.FromSlash("./main"))
409 | 	if err != nil {
410 | 		panic(err)
411 | 	}
412 | 	receiver.cmd = start
413 | }
414 | 
415 | //func terminateWinProc(pid int) error {
416 | //	dll, err := windows.LoadDLL("kernel32.dll")
417 | //	if err != nil {
418 | //		return err
419 | //	}
420 | //	defer dll.Release()
421 | //	f, err := dll.FindProc("GenerateConsoleCtrlEvent")
422 | //	if err != nil {
423 | //		return err
424 | //	}
425 | //	r1, _, err := f.Call(windows.CTRL_BREAK_EVENT, uintptr(pid))
426 | //	if r1 == 0 {
427 | //		return err
428 | //	}
429 | //	return nil
430 | //}
431 | 
432 | // TODO there is a bug here on windows
433 | func (receiver *Svc) DoRestart() {
434 | 	//if runtime.GOOS == "windows" {
435 | 	//	if err := terminateWinProc(receiver.Cmd.Process.Pid); err != nil {
436 | 	//		panic(err)
437 | 	//	}
438 | 	//} else {
439 | 	//	if err := receiver.Cmd.Process.Signal(syscall.SIGINT); err != nil {
440 | 	//		panic(err)
441 | 	//	}
442 | 	//}
443 | 	if receiver.cmd != nil {
444 | 		if err := receiver.cmd.Process.Signal(syscall.SIGINT); err != nil {
445 | 			panic(err)
446 | 		}
447 | 	}
448 | 	receiver.DoRun()
449 | }
450 | 
451 | func (receiver *Svc) DoWatch() {
452 | 	w := receiver.w
453 | 	// SetMaxEvents to 1 to allow at most 1 event's to be received
454 | 	// on the Event channel per watching cycle.
455 | 	//
456 | 	// If SetMaxEvents is not set, the default is to send all events.
457 | 	w.SetMaxEvents(1)
458 | 
459 | 	// Only notify write events.
460 | 	w.FilterOps(watcher.Write)
461 | 
462 | 	// Only files that match the regular expression during file listings
463 | 	// will be watched.
464 | 	r := regexp.MustCompile("\\.go$")
465 | 	w.AddFilterHook(watcher.RegexFilterHook(r, false))
466 | 
467 | 	go func() {
468 | 		for {
469 | 			select {
470 | 			case event := <-w.Event:
471 | 				fmt.Println(event) // Print the event's info.
472 | 				if err := receiver.runner.Run("go", "build", "cmd/main.go"); err != nil {
473 | 					logrus.Warnln(err)
474 | 					continue
475 | 				}
476 | 				_ = os.Remove("main")
477 | 				receiver.restartSig <- 1
478 | 			case err := <-w.Error:
479 | 				logrus.Panicln(err)
480 | 			case <-w.Closed:
481 | 				return
482 | 			}
483 | 		}
484 | 	}()
485 | 
486 | 	// Watch this folder for changes.
487 | 	if err := w.AddRecursive(receiver.dir); err != nil {
488 | 		logrus.Panicln(err)
489 | 	}
490 | 
491 | 	// Print a list of all of the files and folders currently
492 | 	// being watched and their paths.
493 | 	for path, f := range w.WatchedFiles() {
494 | 		logrus.Tracef("%s: %s\n", path, f.Name())
495 | 	}
496 | 
497 | 	// Start the watching process - it'll check for changes every 100ms.
498 | 	if err := w.Start(time.Millisecond * 100); err != nil {
499 | 		logrus.Panicln(err)
500 | 	}
501 | }
502 | 
503 | // Run runs the project locally. Recommend to set watch flag to enable watch mode for rapid development.
504 | func (receiver *Svc) Run(watch bool) {
505 | 	receiver.DoRun()
506 | 	if watch {
507 | 		if receiver.w == nil {
[TRUNCATED]
```

cmd/internal/svc/svc_test.go
```
1 | package svc_test
2 | 
3 | import (
4 | 	"fmt"
5 | 	"github.com/iancoleman/strcase"
6 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/codegen"
7 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/parser"
8 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
9 | 	"os"
10 | 	"os/exec"
11 | 	"path/filepath"
12 | 	"testing"
13 | 	"time"
14 | 
15 | 	"github.com/radovskyb/watcher"
16 | 	"github.com/stretchr/testify/assert"
17 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc"
18 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/validate"
19 | 	"github.com/unionj-cloud/toolkit/astutils"
20 | 	"github.com/unionj-cloud/toolkit/executils"
21 | 	"github.com/unionj-cloud/toolkit/pathutils"
22 | )
23 | 
24 | var testDir string
25 | 
26 | func init() {
27 | 	testDir = pathutils.Abs("testdata")
28 | }
29 | 
30 | // NewMockSvc new Svc instance for unit test purpose
31 | func NewMockSvc(dir string, opts ...svc.SvcOption) svc.ISvc {
32 | 	return svc.NewSvc(dir, svc.WithRunner(mockRunner{}))
33 | }
34 | 
35 | type mockRunner struct {
36 | }
37 | 
38 | func (r mockRunner) Output(command string, args ...string) ([]byte, error) {
39 | 	return []byte("go version go1.17.8 darwin/amd64"), nil
40 | }
41 | 
42 | func (r mockRunner) Run(command string, args ...string) error {
43 | 	cs := []string{"-test.run=TestHelperProcess", "--"}
44 | 	cs = append(cs, args...)
45 | 	cmd := exec.Command(os.Args[0], cs...)
46 | 	cmd.Env = []string{"GO_WANT_HELPER_PROCESS=1"}
47 | 	cmd.Stdout = os.Stdout
48 | 	cmd.Stderr = os.Stderr
49 | 	if err := cmd.Run(); err != nil {
50 | 		panic(err)
51 | 	}
52 | 	return nil
53 | }
54 | 
55 | func (r mockRunner) Start(command string, args ...string) (*exec.Cmd, error) {
56 | 	cs := []string{"-test.run=TestHelperProcess", "--"}
57 | 	cs = append(cs, args...)
58 | 	cmd := exec.Command(os.Args[0], cs...)
59 | 	cmd.Env = []string{"GO_WANT_HELPER_PROCESS=1"}
60 | 	cmd.Stdout = os.Stdout
61 | 	cmd.Stderr = os.Stderr
62 | 	if err := cmd.Start(); err != nil {
63 | 		panic(err)
64 | 	}
65 | 	return cmd, nil
66 | }
67 | 
68 | func TestSvc_Create(t *testing.T) {
69 | 	type fields struct {
70 | 		Dir string
71 | 	}
72 | 	tests := []struct {
73 | 		name   string
74 | 		fields fields
75 | 	}{
76 | 		{
77 | 			name: "1",
78 | 			fields: fields{
79 | 				Dir: testDir + "1",
80 | 			},
81 | 		},
82 | 	}
83 | 	for _, tt := range tests {
84 | 		t.Run(tt.name, func(t *testing.T) {
85 | 			receiver := svc.NewSvc(tt.fields.Dir)
86 | 			receiver.Init()
87 | 			defer os.RemoveAll(tt.fields.Dir)
88 | 		})
89 | 	}
90 | }
91 | 
92 | func TestSvc_Http(t *testing.T) {
93 | 	type fields struct {
94 | 		Dir          string
95 | 		Handler      bool
96 | 		Client       bool
97 | 		Omitempty    bool
98 | 		Doc          bool
99 | 		Jsonattrcase string
100 | 	}
101 | 	tests := []struct {
102 | 		name   string
103 | 		fields fields
104 | 	}{
105 | 		{
106 | 			name: "",
107 | 			fields: fields{
108 | 				Dir:          testDir + "2",
109 | 				Handler:      true,
110 | 				Client:       true,
111 | 				Omitempty:    true,
112 | 				Doc:          true,
113 | 				Jsonattrcase: "snake",
114 | 			},
115 | 		},
116 | 		{
117 | 			name: "",
118 | 			fields: fields{
119 | 				Dir:       testDir + "3",
120 | 				Handler:   true,
121 | 				Client:    true,
122 | 				Omitempty: false,
123 | 				Doc:       false,
124 | 			},
125 | 		},
126 | 		{
127 | 			name: "",
128 | 			fields: fields{
129 | 				Dir:       testDir + "4",
130 | 				Handler:   false,
131 | 				Client:    true,
132 | 				Omitempty: false,
133 | 				Doc:       false,
134 | 			},
135 | 		},
136 | 	}
137 | 	for _, tt := range tests {
138 | 		t.Run(tt.name, func(t *testing.T) {
139 | 			receiver := svc.NewSvc(tt.fields.Dir)
140 | 			s := receiver.(*svc.Svc)
141 | 			s.Handler = tt.fields.Handler
142 | 			s.Client = tt.fields.Client
143 | 			s.Omitempty = tt.fields.Omitempty
144 | 			s.Doc = tt.fields.Doc
145 | 			s.JsonCase = tt.fields.Jsonattrcase
146 | 			assert.NotPanics(t, func() {
147 | 				receiver.Init()
148 | 			})
149 | 			defer os.RemoveAll(tt.fields.Dir)
150 | 			assert.NotPanics(t, func() {
151 | 				receiver.Http()
152 | 			})
153 | 		})
154 | 	}
155 | }
156 | 
157 | func Test_checkIc(t *testing.T) {
158 | 	svcfile := testDir + "/svc.go"
159 | 	ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
160 | 	type args struct {
161 | 		ic astutils.InterfaceCollector
162 | 	}
163 | 	tests := []struct {
164 | 		name string
165 | 		args args
166 | 	}{
167 | 		{
168 | 			name: "",
169 | 			args: args{
170 | 				ic: ic,
171 | 			},
172 | 		},
173 | 	}
174 | 	for _, tt := range tests {
175 | 		t.Run(tt.name, func(t *testing.T) {
176 | 			assert.NotPanics(t, func() {
177 | 				validate.RestApi(testDir, ic)
178 | 			})
179 | 		})
180 | 	}
181 | }
182 | 
183 | func Test_checkIc2(t *testing.T) {
184 | 	svcfile := filepath.Join(testDir, "checkIc2", "svc.go")
185 | 	ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
186 | 	type args struct {
187 | 		ic astutils.InterfaceCollector
188 | 	}
189 | 	tests := []struct {
190 | 		name string
191 | 		args args
192 | 	}{
193 | 		{
194 | 			name: "",
195 | 			args: args{
196 | 				ic: ic,
197 | 			},
198 | 		},
199 | 	}
200 | 	for _, tt := range tests {
201 | 		t.Run(tt.name, func(t *testing.T) {
202 | 			assert.NotPanics(t, func() {
203 | 				validate.RestApi(testDir, ic)
204 | 			})
205 | 		})
206 | 	}
207 | }
208 | 
209 | func Test_checkIc1(t *testing.T) {
210 | 	svcfile := testDir + "/svcp.go"
211 | 	ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
212 | 	type args struct {
213 | 		ic astutils.InterfaceCollector
214 | 	}
215 | 	tests := []struct {
216 | 		name string
217 | 		args args
218 | 	}{
219 | 		{
220 | 			name: "",
221 | 			args: args{
222 | 				ic: ic,
223 | 			},
224 | 		},
225 | 	}
226 | 	for _, tt := range tests {
227 | 		t.Run(tt.name, func(t *testing.T) {
228 | 			assert.Panics(t, func() {
229 | 				validate.RestApi(testDir, ic)
230 | 			})
231 | 		})
232 | 	}
233 | }
234 | 
235 | func Test_checkIc_no_interface(t *testing.T) {
236 | 	svcfile := filepath.Join(testDir, "nosvc", "svc.go")
237 | 	ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
238 | 	type args struct {
239 | 		ic astutils.InterfaceCollector
240 | 	}
241 | 	tests := []struct {
242 | 		name string
243 | 		args args
244 | 	}{
245 | 		{
246 | 			name: "",
247 | 			args: args{
248 | 				ic: ic,
249 | 			},
250 | 		},
251 | 	}
252 | 	for _, tt := range tests {
253 | 		t.Run(tt.name, func(t *testing.T) {
254 | 			assert.Panics(t, func() {
255 | 				validate.RestApi(testDir, ic)
256 | 			})
257 | 		})
258 | 	}
259 | }
260 | 
261 | func Test_checkIc_input_anonystruct(t *testing.T) {
262 | 	svcfile := filepath.Join(testDir, "inputanonystruct", "svc.go")
263 | 	ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
264 | 	type args struct {
265 | 		ic astutils.InterfaceCollector
266 | 	}
267 | 	tests := []struct {
268 | 		name string
269 | 		args args
270 | 	}{
271 | 		{
272 | 			name: "",
273 | 			args: args{
274 | 				ic: ic,
275 | 			},
276 | 		},
277 | 	}
278 | 	for _, tt := range tests {
279 | 		t.Run(tt.name, func(t *testing.T) {
280 | 			assert.Panics(t, func() {
281 | 				validate.RestApi(testDir, ic)
282 | 			})
283 | 		})
284 | 	}
285 | }
286 | 
287 | func Test_checkIc_output_anonystruct(t *testing.T) {
288 | 	svcfile := filepath.Join(testDir, "outputanonystruct", "svc.go")
289 | 	ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
290 | 	type args struct {
291 | 		ic astutils.InterfaceCollector
292 | 	}
293 | 	tests := []struct {
294 | 		name string
295 | 		args args
296 | 	}{
297 | 		{
298 | 			name: "",
299 | 			args: args{
300 | 				ic: ic,
301 | 			},
302 | 		},
303 | 	}
304 | 	dir := filepath.Join(testDir, "outputanonystruct")
305 | 	pg := v3.NewProtoGenerator(v3.WithFieldNamingFunc(strcase.ToSnake))
306 | 	for _, tt := range tests {
307 | 		t.Run(tt.name, func(t *testing.T) {
308 | 			parser.ParseDtoGrpc(dir, pg, parser.DEFAULT_DTO_PKGS...)
309 | 			codegen.GenGrpcProto(dir, ic, pg)
310 | 		})
311 | 	}
312 | }
313 | 
314 | func TestSvc_Deploy(t *testing.T) {
315 | 	dir := testDir + "/deploy"
316 | 	receiver := NewMockSvc(dir)
317 | 	receiver.Init()
318 | 	defer os.RemoveAll(dir)
319 | 	receiver.Deploy("")
320 | }
321 | 
322 | func TestSvc_Shutdown(t *testing.T) {
323 | 	dir := testDir + "/shutdown"
324 | 	receiver := NewMockSvc(dir)
325 | 	receiver.Init()
326 | 	defer os.RemoveAll(dir)
327 | 	receiver.Shutdown("")
328 | }
329 | 
330 | func Test_validateDataType(t *testing.T) {
331 | 	assert.NotPanics(t, func() {
332 | 		validate.DataType(testDir)
333 | 	})
334 | }
335 | 
336 | func Test_validateDataType_shouldpanic(t *testing.T) {
337 | 	assert.Panics(t, func() {
338 | 		validate.DataType(pathutils.Abs("testdata1"))
339 | 	})
340 | }
341 | 
342 | func Test_GenClient(t *testing.T) {
343 | 	defer os.RemoveAll(filepath.Join(testDir, "client"))
344 | 	receiver := svc.NewSvc(testDir)
345 | 	s := receiver.(*svc.Svc)
346 | 	s.DocPath = filepath.Join(testDir, "testfilesdoc1_openapi3.json")
347 | 	s.ClientPkg = "client"
348 | 	s.Omitempty = true
349 | 	assert.NotPanics(t, func() {
350 | 		s.GenClient()
351 | 	})
352 | }
353 | 
354 | func TestSvc_Push(t *testing.T) {
355 | 	receiver := NewMockSvc(pathutils.Abs("./testdata"))
356 | 	s := receiver.(*svc.Svc)
357 | 	s.Push(svc.PushConfig{
358 | 		Repo:   "wubin1989",
359 | 		Prefix: "go-doudou-",
360 | 	})
361 | }
362 | 
363 | func TestHelperProcess(*testing.T) {
364 | 	if os.Getenv("GO_WANT_HELPER_PROCESS") != "1" {
365 | 		return
366 | 	}
367 | 	defer os.Exit(0)
368 | 	fmt.Println("testing helper process")
369 | }
370 | 
371 | func TestSvc_run(t *testing.T) {
372 | 	s := NewMockSvc(pathutils.Abs("./testdata"))
373 | 	s.DoRun()
374 | }
375 | 
376 | func TestSvc_restart(t *testing.T) {
377 | 	s := NewMockSvc(pathutils.Abs("./testdata"))
378 | 	s.DoRun()
379 | 	s.DoRestart()
380 | }
381 | 
382 | func TestSvc_watch(t *testing.T) {
383 | 	s := NewMockSvc(pathutils.Abs("./testdata/change"))
384 | 	s.SetWatcher(watcher.New())
385 | 	go s.DoWatch()
386 | 	time.Sleep(1 * time.Second)
387 | 	f, _ := os.Create(filepath.Join(s.GetDir(), "change.go"))
388 | 	defer f.Close()
389 | 	f.WriteString("test")
390 | 	time.Sleep(6 * time.Second)
391 | 	s.GetWatcher().Close()
392 | }
393 | 
394 | func TestSvc_Run(t *testing.T) {
395 | 	s := NewMockSvc(pathutils.Abs("./testdata/change"))
396 | 	s.SetWatcher(watcher.New())
397 | 	defer s.GetWatcher().Close()
398 | 	go s.Run(true)
399 | 	time.Sleep(1 * time.Second)
400 | 	f, _ := os.Create(filepath.Join(s.GetDir(), "change.go"))
401 | 	defer f.Close()
402 | 	f.WriteString("test")
403 | 	time.Sleep(6 * time.Second)
404 | }
405 | 
406 | func TestSvc_Run_unwatch(t *testing.T) {
407 | 	s := NewMockSvc("")
408 | 	s.Run(false)
409 | }
410 | 
411 | func TestSvc_GenClient_DocPathEmpty2(t *testing.T) {
412 | 	type fields struct {
413 | 		dir                  string
414 | 		Handler              bool
415 | 		Client               string
416 | 		Omitempty            bool
417 | 		Doc                  bool
418 | 		Jsonattrcase         string
419 | 		DocPath              string
420 | 		Env                  string
421 | 		ClientPkg            string
422 | 		cmd                  *exec.Cmd
423 | 		restartSig           chan int
424 | 		RoutePatternStrategy int
425 | 		runner               executils.Runner
426 | 		w                    *watcher.Watcher
427 | 		ModName              string
428 | 	}
429 | 	tests := []struct {
430 | 		name   string
431 | 		fields fields
432 | 	}{
433 | 		{
434 | 			name:   "",
435 | 			fields: fields{},
436 | 		},
437 | 	}
438 | 	for _, tt := range tests {
439 | 		t.Run(tt.name, func(t *testing.T) {
440 | 			receiver := svc.Svc{}
441 | 			assert.Panics(t, func() {
442 | 				receiver.GenClient()
443 | 			})
444 | 		})
445 | 	}
446 | }
447 | 
448 | func TestSvc_GenClient_DocPathEmpty1(t *testing.T) {
449 | 	defer os.RemoveAll(filepath.Join(testDir, "openapi", "client"))
450 | 	receiver := svc.NewSvc(filepath.Join(testDir, "openapi"))
451 | 	s := receiver.(*svc.Svc)
452 | 	s.ClientPkg = "client"
453 | 	assert.NotPanics(t, func() {
454 | 		receiver.GenClient()
455 | 	})
456 | }
457 | 
458 | func TestNewSvc(t *testing.T) {
459 | 	assert.NotPanics(t, func() {
460 | 		svc.NewSvc("")
461 | 	})
462 | }
```

cmd/internal/templates/header.go
```
1 | package templates
2 | 
3 | const EditableHeaderTmpl = `/**
4 | * Generated by go-doudou {{.Version}}.
5 | * You can edit it as your need.
6 | */
7 | `
```

cmd/internal/templates/mainmain.go
```
1 | package templates
2 | 
3 | const MainMainTmpl = EditableHeaderTmpl + `package main
4 | 
5 | import (
6 | 	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
7 | 	grpczerolog "github.com/grpc-ecosystem/go-grpc-middleware/providers/zerolog/v2"
8 | 	grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
9 | 	grpc_ctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
10 | 	grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
11 | 	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
12 | 	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/tags"
13 | 	grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
14 | 	"github.com/unionj-cloud/go-doudou/v2/framework/grpcx"
15 | 	"github.com/unionj-cloud/go-doudou/v2/framework/plugin"
16 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
17 | 	"github.com/unionj-cloud/toolkit/pipeconn"
18 | 	"github.com/unionj-cloud/toolkit/zlogger"
19 | 	"google.golang.org/grpc"
20 | )
21 | 
22 | func main() {
23 | 	srv := rest.NewRestServer()
24 | 	grpcServer := grpcx.NewGrpcServer(
25 | 		grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
26 | 			grpc_ctxtags.StreamServerInterceptor(),
27 | 			grpc_opentracing.StreamServerInterceptor(),
28 | 			grpc_prometheus.StreamServerInterceptor,
29 | 			tags.StreamServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
30 | 			logging.StreamServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
31 | 			grpc_recovery.StreamServerInterceptor(),
32 | 		)),
33 | 		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
34 | 			grpc_ctxtags.UnaryServerInterceptor(),
35 | 			grpc_opentracing.UnaryServerInterceptor(),
36 | 			grpc_prometheus.UnaryServerInterceptor,
37 | 			tags.UnaryServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
38 | 			logging.UnaryServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
39 | 			grpc_recovery.UnaryServerInterceptor(),
40 | 		)),
41 | 	)
42 | 	lis, dialCtx := pipeconn.NewPipeListener()
43 | 	plugins := plugin.GetServicePlugins()
44 | 	for _, key := range plugins.Keys() {
45 | 		value, _ := plugins.Get(key)
46 | 		value.Initialize(srv, grpcServer, dialCtx)
47 | 	}
48 | 	defer func() {
49 | 		if r := recover(); r != nil {
50 | 			zlogger.Info().Msgf("Recovered. Error: %v\n", r)
51 | 		}
52 | 		for _, key := range plugins.Keys() {
53 | 			value, _ := plugins.Get(key)
54 | 			value.Close()
55 | 		}
56 | 	}()
57 | 	go func() {
58 | 		grpcServer.RunWithPipe(lis)
59 | 	}()
60 | 	srv.AddRoutes(rest.DocRoutes(""))
61 | 	srv.Run()
62 | }
63 | `
```

cmd/internal/templates/mainmodule.go
```
1 | package templates
2 | 
3 | var MainTmpl = EditableHeaderTmpl + `package main
4 | 
5 | import (
6 | 	{{- if ne .ProjectType "rest" }}
7 | 	"github.com/unionj-cloud/go-doudou/v2/framework/grpcx"
8 | 	{{- end }}
9 | 	"github.com/unionj-cloud/go-doudou/v2/framework/plugin"
10 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
11 | 	"github.com/unionj-cloud/toolkit/zlogger"
12 | 	_ "{{.PluginPackage}}"
13 | )
14 | 
15 | func main() {
16 | 	srv := rest.NewRestServer()
17 | 	{{- if ne .ProjectType "rest" }}
18 | 	grpcServer := grpcx.NewEmptyGrpcServer()
19 | 	{{- end }}
20 | 	plugins := plugin.GetServicePlugins()
21 | 	for _, key := range plugins.Keys() {
22 | 		value, _ := plugins.Get(key)
23 | 		{{- if eq .ProjectType "rest" }}
24 | 		value.Initialize(srv, nil, nil)
25 | 		{{- else }}
26 | 		value.Initialize(srv, grpcServer, nil)
27 | 		{{- end }}
28 | 	}
29 | 	defer func() {
30 | 		if r := recover(); r != nil {
31 | 			zlogger.Info().Msgf("Recovered. Error: %v\n", r)
32 | 		}
33 | 		for _, key := range plugins.Keys() {
34 | 			value, _ := plugins.Get(key)
35 | 			value.Close()
36 | 		}
37 | 	}()
38 | 	{{- if ne .ProjectType "rest" }}
39 | 	go func() {
40 | 		grpcServer.Run()
41 | 	}()
42 | 	{{- end }}
43 | 	srv.Run()
44 | }
45 | `
```

cmd/internal/templates/mainpkgmod.go
```
1 | package templates
2 | 
3 | const MainPkgModTmpl = `module {{.ModName}}
4 | 
5 | go {{.GoVersion}}
6 | 
7 | require (
8 | 	github.com/grpc-ecosystem/go-grpc-middleware v1.4.0
9 | 	github.com/grpc-ecosystem/go-grpc-middleware/providers/zerolog/v2 v2.0.0-rc.2
10 | 	github.com/grpc-ecosystem/go-grpc-middleware/v2 v2.0.0-rc.2
11 | 	github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0
12 | 	github.com/unionj-cloud/go-doudou/v2 {{.GoDoudouVersion}}
13 | 	google.golang.org/grpc v1.59.0
14 | )
15 | 
16 | require (
17 | 	github.com/aliyun/alibaba-cloud-sdk-go v1.61.1704 // indirect
18 | 	github.com/antlr/antlr4 v0.0.0-20200124162019-2d7f727a00b7 // indirect
19 | 	github.com/apolloconfig/agollo/v4 v4.1.1-0.20220323095621-60ed86180f24 // indirect
20 | 	github.com/arl/statsviz v0.5.1 // indirect
21 | 	github.com/armon/go-metrics v0.4.1 // indirect
22 | 	github.com/ascarter/requestid v0.0.0-20170313220838-5b76ab3d4aee // indirect
23 | 	github.com/beorn7/perks v1.0.1 // indirect
24 | 	github.com/buger/jsonparser v1.1.1 // indirect
25 | 	github.com/cespare/xxhash/v2 v2.1.2 // indirect
26 | 	github.com/common-nighthawk/go-figure v0.0.0-20200609044655-c4b36f998cf2 // indirect
27 | 	github.com/coreos/go-semver v0.3.0 // indirect
28 | 	github.com/coreos/go-systemd/v22 v22.3.3-0.20220203105225-a9a7ef127534 // indirect
29 | 	github.com/felixge/httpsnoop v1.0.3 // indirect
30 | 	github.com/fsnotify/fsnotify v1.4.9 // indirect
31 | 	github.com/ghodss/yaml v1.0.0 // indirect
32 | 	github.com/go-ole/go-ole v1.2.6 // indirect
33 | 	github.com/go-playground/locales v0.14.1 // indirect
34 | 	github.com/go-playground/universal-translator v0.18.1 // indirect
35 | 	github.com/go-playground/validator/v10 v10.11.2 // indirect
36 | 	github.com/go-zookeeper/zk v1.0.3 // indirect
37 | 	github.com/gogo/protobuf v1.3.2 // indirect
38 | 	github.com/golang/mock v1.6.0 // indirect
39 | 	github.com/golang/protobuf v1.5.2 // indirect
40 | 	github.com/google/btree v1.1.2 // indirect
41 | 	github.com/google/go-cmp v0.5.9 // indirect
42 | 	github.com/google/uuid v1.3.0 // indirect
43 | 	github.com/gorilla/handlers v1.5.1 // indirect
44 | 	github.com/gorilla/websocket v1.4.2 // indirect
45 | 	github.com/hako/durafmt v0.0.0-20210608085754-5c1018a4e16b // indirect
46 | 	github.com/hashicorp/errwrap v1.1.0 // indirect
47 | 	github.com/hashicorp/go-immutable-radix v1.3.1 // indirect
48 | 	github.com/hashicorp/go-msgpack v1.1.5 // indirect
49 | 	github.com/hashicorp/go-multierror v1.1.1 // indirect
50 | 	github.com/hashicorp/go-sockaddr v1.0.2 // indirect
51 | 	github.com/hashicorp/go-uuid v1.0.2 // indirect
52 | 	github.com/hashicorp/golang-lru v0.5.4 // indirect
53 | 	github.com/hashicorp/hcl v1.0.0 // indirect
54 | 	github.com/hashicorp/logutils v1.0.0 // indirect
55 | 	github.com/hyperjumptech/jiffy v1.0.0 // indirect
56 | 	github.com/jeremywohl/flatten v1.0.1 // indirect
57 | 	github.com/jmespath/go-jmespath v0.0.0-20180206201540-c2b33e8439af // indirect
58 | 	github.com/joho/godotenv v1.5.1 // indirect
59 | 	github.com/json-iterator/go v1.1.12 // indirect
60 | 	github.com/klauspost/compress v1.16.3 // indirect
61 | 	github.com/kr/text v0.2.0 // indirect
62 | 	github.com/leodido/go-urn v1.2.1 // indirect
63 | 	github.com/magiconair/properties v1.8.1 // indirect
64 | 	github.com/mattn/go-colorable v0.1.13 // indirect
65 | 	github.com/mattn/go-isatty v0.0.16 // indirect
66 | 	github.com/mattn/go-runewidth v0.0.10 // indirect
67 | 	github.com/matttproud/golang_protobuf_extensions v1.0.4 // indirect
68 | 	github.com/miekg/dns v1.1.54 // indirect
69 | 	github.com/mitchellh/mapstructure v1.1.2 // indirect
70 | 	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
71 | 	github.com/modern-go/reflect2 v1.0.2 // indirect
72 | 	github.com/olekukonko/tablewriter v0.0.5 // indirect
73 | 	github.com/opentracing-contrib/go-stdlib v1.0.0 // indirect
74 | 	github.com/opentracing/opentracing-go v1.2.0 // indirect
75 | 	github.com/pelletier/go-toml v1.8.1 // indirect
76 | 	github.com/pkg/errors v0.9.1 // indirect
77 | 	github.com/prometheus/client_golang v1.14.0 // indirect
78 | 	github.com/prometheus/client_model v0.3.0 // indirect
79 | 	github.com/prometheus/common v0.37.0 // indirect
80 | 	github.com/prometheus/procfs v0.8.0 // indirect
81 | 	github.com/rivo/uniseg v0.1.0 // indirect
82 | 	github.com/rs/cors v1.9.0 // indirect
83 | 	github.com/rs/zerolog v1.28.0 // indirect
84 | 	github.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529 // indirect
85 | 	github.com/shirou/gopsutil v3.21.11+incompatible // indirect
86 | 	github.com/shopspring/decimal v1.3.1 // indirect
87 | 	github.com/sirupsen/logrus v1.9.0 // indirect
88 | 	github.com/slok/goresilience v0.2.0 // indirect
89 | 	github.com/spf13/afero v1.2.2 // indirect
90 | 	github.com/spf13/cast v1.3.0 // indirect
91 | 	github.com/spf13/jwalterweatherman v1.0.0 // indirect
92 | 	github.com/spf13/pflag v1.0.5 // indirect
93 | 	github.com/spf13/viper v1.7.1 // indirect
94 | 	github.com/stretchr/objx v0.5.0 // indirect
95 | 	github.com/subosito/gotenv v1.2.0 // indirect
96 | 	github.com/tklauser/go-sysconf v0.3.10 // indirect
97 | 	github.com/tklauser/numcpus v0.4.0 // indirect
98 | 	github.com/uber/jaeger-client-go v2.30.0+incompatible // indirect
99 | 	github.com/uber/jaeger-lib v2.4.1+incompatible // indirect
100 | 	github.com/ucarion/urlpath v0.0.0-20200424170820-7ccc79b76bbb // indirect
101 | 	github.com/wubin1989/nacos-sdk-go/v2 v2.1.2-0.20221024120645-0288f53fdaa8 // indirect
102 | 	github.com/yusufpapurcu/wmi v1.2.2 // indirect
103 | 	go.etcd.io/etcd/api/v3 v3.5.7 // indirect
104 | 	go.etcd.io/etcd/client/pkg/v3 v3.5.7 // indirect
105 | 	go.etcd.io/etcd/client/v3 v3.5.7 // indirect
106 | 	go.uber.org/atomic v1.10.0 // indirect
107 | 	go.uber.org/automaxprocs v1.5.2 // indirect
108 | 	go.uber.org/goleak v1.1.12 // indirect
109 | 	go.uber.org/multierr v1.8.0 // indirect
110 | 	go.uber.org/zap v1.23.0 // indirect
111 | 	golang.org/x/crypto v0.8.0 // indirect
112 | 	golang.org/x/exp v0.0.0-20210916165020-5cb4fee858ee // indirect
113 | 	golang.org/x/mod v0.8.0 // indirect
114 | 	golang.org/x/net v0.9.0 // indirect
115 | 	golang.org/x/sync v0.1.0 // indirect
116 | 	golang.org/x/sys v0.7.0 // indirect
117 | 	golang.org/x/text v0.9.0 // indirect
118 | 	golang.org/x/time v0.0.0-20220722155302-e5dcc9cfc0b9 // indirect
119 | 	golang.org/x/tools v0.6.0 // indirect
120 | 	google.golang.org/genproto v0.0.0-20221010155953-15ba04fc1c0e // indirect
121 | 	google.golang.org/protobuf v1.28.1 // indirect
122 | 	gopkg.in/ini.v1 v1.66.2 // indirect
123 | 	gopkg.in/natefinch/lumberjack.v2 v2.0.0 // indirect
124 | 	gopkg.in/yaml.v2 v2.4.0 // indirect
125 | 	github.com/wubin1989/gorm v0.0.4 // indirect
126 | )`
```

cmd/internal/templates/plugin.go
```
1 | package templates
2 | 
3 | var PluginTmpl = EditableHeaderTmpl + `package plugin
4 | 
5 | import (
6 | 	"github.com/unionj-cloud/go-doudou/v2/framework/grpcx"
7 | 	"github.com/unionj-cloud/go-doudou/v2/framework/plugin"
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
9 | 	"github.com/unionj-cloud/toolkit/pipeconn"
10 | 	"github.com/unionj-cloud/toolkit/stringutils"
11 | 	{{.ServiceAlias}} "{{.ServicePackage}}"
12 | 	"{{.ConfigPackage}}"
13 | 	"{{.TransportHttpPackage}}"
14 | 	"google.golang.org/grpc"
15 | 	"os"
16 | 	{{- if ne .ProjectType "rest" }}
17 | 	pb "{{.TransportGrpcPackage}}"
18 | 	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
19 | 	grpczerolog "github.com/grpc-ecosystem/go-grpc-middleware/providers/zerolog/v2"
20 | 	grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
21 | 	grpc_ctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
22 | 	grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
23 | 	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
24 | 	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/tags"
25 | 	grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
26 | 	"github.com/unionj-cloud/toolkit/zlogger"
27 | 	{{- end }}
28 | )
29 | 
30 | var _ plugin.ServicePlugin = (*{{.SvcName}}Plugin)(nil)
31 | 
32 | type {{.SvcName}}Plugin struct {
33 | 	grpcConns []*grpc.ClientConn
34 | }
35 | 
36 | func (receiver *{{.SvcName}}Plugin) Close() {
37 | 	for _, item := range receiver.grpcConns {
38 | 		item.Close()
39 | 	}
40 | }
41 | 
42 | func (receiver *{{.SvcName}}Plugin) GoDoudouServicePlugin() {
43 | 
44 | }
45 | 
46 | func (receiver *{{.SvcName}}Plugin) GetName() string {
47 | 	name := os.Getenv("GDD_SERVICE_NAME")
48 | 	if stringutils.IsEmpty(name) {
49 | 		name = "cloud.unionj.{{.SvcName}}"
50 | 	}
51 | 	return name
52 | }
53 | 
54 | func (receiver *{{.SvcName}}Plugin) Initialize(restServer *rest.RestServer, grpcServer *grpcx.GrpcServer, dialCtx pipeconn.DialContextFunc) {
55 | 	conf := config.LoadFromEnv()
56 | 	svc := {{.ServiceAlias}}.New{{.SvcName}}(conf)
57 | 	{{- if eq .ProjectType "rest" }}
58 | 	routes := httpsrv.Routes(httpsrv.New{{.SvcName}}Handler(svc))
59 | 	{{- else }}
60 | 	routes := httpsrv.Routes(httpsrv.New{{.SvcName}}Http2Grpc(svc))
61 | 	{{- end }}
62 | 	restServer.GroupRoutes("/{{.SvcName | toLower}}", routes)
63 | 	restServer.GroupRoutes("/{{.SvcName | toLower}}", rest.DocRoutes(service.Oas))
64 | 	{{- if ne .ProjectType "rest" }}
65 | 	if grpcServer.Server == nil {
66 | 		grpcServer.Server = grpc.NewServer(
67 | 			grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
68 | 				grpc_ctxtags.StreamServerInterceptor(),
69 | 				grpc_opentracing.StreamServerInterceptor(),
70 | 				grpc_prometheus.StreamServerInterceptor,
71 | 				tags.StreamServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
72 | 				logging.StreamServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
73 | 				grpc_recovery.StreamServerInterceptor(),
74 | 			)),
75 | 			grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
76 | 				grpc_ctxtags.UnaryServerInterceptor(),
77 | 				grpc_opentracing.UnaryServerInterceptor(),
78 | 				grpc_prometheus.UnaryServerInterceptor,
79 | 				tags.UnaryServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
80 | 				logging.UnaryServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
81 | 				grpc_recovery.UnaryServerInterceptor(),
82 | 			)),
83 | 		)
84 | 	}
85 | 	pb.Register{{.SvcName}}ServiceServer(grpcServer, svc)
86 | 	{{- end }}
87 | }
88 | 
89 | func init() {
90 | 	plugin.RegisterServicePlugin(&{{.SvcName}}Plugin{})
91 | }
92 | `
```

cmd/testdata/testsvc/Dockerfile
```
1 | FROM golang:1.21rc3-alpine AS builder
2 | 
3 | ENV GO111MODULE=on
4 | ARG user
5 | ENV HOST_USER=$user
6 | 
7 | WORKDIR /repo
8 | 
9 | ADD go.mod .
10 | ADD go.sum .
11 | 
12 | ADD . ./
13 | 
14 | RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories
15 | RUN apk add --no-cache bash tzdata
16 | 
17 | ENV TZ="Asia/Shanghai"
18 | 
19 | RUN export GDD_VER=$(go list -mod=vendor -m -f '{{ .Version }}' github.com/unionj-cloud/go-doudou/v2) && \
20 | CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -v -ldflags="-X 'github.com/unionj-cloud/go-doudou/v2/framework/internal/config.BuildUser=$HOST_USER' -X 'github.com/unionj-cloud/go-doudou/v2/framework/internal/config.BuildTime=$(date)' -X 'github.com/unionj-cloud/go-doudou/v2/framework/internal/config.GddVer=$GDD_VER'" -mod vendor -o api cmd/main.go
21 | 
22 | ENTRYPOINT ["/repo/api"]
```

cmd/testdata/testsvc/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"testsvc/vo"
6 | )
7 | 
8 | type Testsvc interface {
9 | 	// You can define your service methods as your need. Below is an example.
10 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, err error)
11 | }
```

cmd/testdata/testsvc/svcimpl.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"testsvc/config"
6 | 	"testsvc/vo"
7 | )
8 | 
9 | var _ Testsvc = (*TestsvcImpl)(nil)
10 | 
11 | type TestsvcImpl struct {
12 | 	conf *config.Config
13 | }
14 | 
15 | func (receiver *TestsvcImpl) PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, err error) {
16 | 	panic("implement me")
17 | }
18 | 
19 | func NewTestsvc(conf *config.Config) Testsvc {
20 | 	return &TestsvcImpl{
21 | 		conf,
22 | 	}
23 | }
```

cmd/testdata/testsvc/testsvc_openapi3.go
```
1 | package service
2 | 
3 | import "github.com/unionj-cloud/go-doudou/v2/framework/rest"
4 | 
5 | func init() {
6 | 	rest.Oas = `{"openapi":"3.0.2","info":{"title":"Testsvc","version":"v20221018"},"servers":[{"url":"http://localhost:6060"}],"paths":{"/page/users":{"post":{"description":"You can define your service methods as your need. Below is an example.","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageQuery"}}},"required":true},"responses":{"200":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageUsersResp"}}}}}}}},"components":{"schemas":{"Order":{"title":"Order","type":"object","properties":{"Col":{"type":"string"},"Sort":{"type":"string"}},"required":["Col","Sort"]},"Page":{"title":"Page","type":"object","properties":{"Orders":{"type":"array","items":{"$ref":"#/components/schemas/Order"},"description":"排序规则"},"PageNo":{"type":"integer","format":"int32","description":"页码"},"Size":{"type":"integer","format":"int32","description":"每页行数"}},"required":["Orders","PageNo","Size"]},"PageFilter":{"title":"PageFilter","type":"object","properties":{"Dept":{"type":"integer","format":"int32","description":"所属部门ID"},"Name":{"type":"string","description":"真实姓名，前缀匹配"}},"required":["Name","Dept"]},"PageQuery":{"title":"PageQuery","type":"object","properties":{"Filter":{"$ref":"#/components/schemas/PageFilter"},"Page":{"$ref":"#/components/schemas/Page"}},"description":"\n分页筛选条件","required":["Filter","Page"]},"PageRet":{"title":"PageRet","type":"object","properties":{"HasNext":{"type":"boolean"},"Items":{"type":"object"},"PageNo":{"type":"integer","format":"int32"},"PageSize":{"type":"integer","format":"int32"},"Total":{"type":"integer","format":"int32"}},"description":"\n","required":["Items","PageNo","PageSize","Total","HasNext"]},"PageUsersResp":{"title":"PageUsersResp","type":"object","properties":{"code":{"type":"integer","format":"int32"},"data":{"$ref":"#/components/schemas/PageRet"}},"required":["code","data"]},"UserVo":{"title":"UserVo","type":"object","properties":{"Dept":{"type":"string"},"Id":{"type":"integer","format":"int32"},"Name":{"type":"string"},"Phone":{"type":"string"}},"required":["Id","Name","Phone","Dept"]}}}}`
7 | }
```

cmd/testdata/testsvc/testsvc_openapi3.json
```
1 | {"openapi":"3.0.2","info":{"title":"Testsvc","version":"v20221018"},"servers":[{"url":"http://localhost:6060"}],"paths":{"/page/users":{"post":{"description":"You can define your service methods as your need. Below is an example.","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageQuery"}}},"required":true},"responses":{"200":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageUsersResp"}}}}}}}},"components":{"schemas":{"Order":{"title":"Order","type":"object","properties":{"Col":{"type":"string"},"Sort":{"type":"string"}},"required":["Col","Sort"]},"Page":{"title":"Page","type":"object","properties":{"Orders":{"type":"array","items":{"$ref":"#/components/schemas/Order"},"description":"排序规则"},"PageNo":{"type":"integer","format":"int32","description":"页码"},"Size":{"type":"integer","format":"int32","description":"每页行数"}},"required":["Orders","PageNo","Size"]},"PageFilter":{"title":"PageFilter","type":"object","properties":{"Dept":{"type":"integer","format":"int32","description":"所属部门ID"},"Name":{"type":"string","description":"真实姓名，前缀匹配"}},"required":["Name","Dept"]},"PageQuery":{"title":"PageQuery","type":"object","properties":{"Filter":{"$ref":"#/components/schemas/PageFilter"},"Page":{"$ref":"#/components/schemas/Page"}},"description":"\n分页筛选条件","required":["Filter","Page"]},"PageRet":{"title":"PageRet","type":"object","properties":{"HasNext":{"type":"boolean"},"Items":{"type":"object"},"PageNo":{"type":"integer","format":"int32"},"PageSize":{"type":"integer","format":"int32"},"Total":{"type":"integer","format":"int32"}},"description":"\n","required":["Items","PageNo","PageSize","Total","HasNext"]},"PageUsersResp":{"title":"PageUsersResp","type":"object","properties":{"code":{"type":"integer","format":"int32"},"data":{"$ref":"#/components/schemas/PageRet"}},"required":["code","data"]},"UserVo":{"title":"UserVo","type":"object","properties":{"Dept":{"type":"string"},"Id":{"type":"integer","format":"int32"},"Name":{"type":"string"},"Phone":{"type":"string"}},"required":["Id","Name","Phone","Dept"]}}}}
```

framework/grpcx/interceptors/grpcx_auth/auth.go
```
1 | package grpcx_auth
2 | 
3 | import (
4 | 	"context"
5 | 
6 | 	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
7 | 	"google.golang.org/grpc"
8 | )
9 | 
10 | type Authorizer interface {
11 | 	Authorize(ctx context.Context, fullMethod string) (context.Context, error)
12 | }
13 | 
14 | // UnaryServerInterceptor returns a server interceptor function to authenticate and authorize unary RPC
15 | func UnaryServerInterceptor(authorizer Authorizer) grpc.UnaryServerInterceptor {
16 | 	return func(
17 | 		ctx context.Context,
18 | 		req interface{},
19 | 		info *grpc.UnaryServerInfo,
20 | 		handler grpc.UnaryHandler,
21 | 	) (interface{}, error) {
22 | 		newCtx, err := authorizer.Authorize(ctx, info.FullMethod)
23 | 		if err != nil {
24 | 			return nil, err
25 | 		}
26 | 		return handler(newCtx, req)
27 | 	}
28 | }
29 | 
30 | // StreamServerInterceptor returns a server interceptor function to authenticate and authorize stream RPC
31 | func StreamServerInterceptor(authorizer Authorizer) grpc.StreamServerInterceptor {
32 | 	return func(
33 | 		srv interface{},
34 | 		stream grpc.ServerStream,
35 | 		info *grpc.StreamServerInfo,
36 | 		handler grpc.StreamHandler,
37 | 	) error {
38 | 		newCtx, err := authorizer.Authorize(stream.Context(), info.FullMethod)
39 | 		if err != nil {
40 | 			return err
41 | 		}
42 | 		wrapped := grpc_middleware.WrapServerStream(stream)
43 | 		wrapped.WrappedContext = newCtx
44 | 		return handler(srv, wrapped)
45 | 	}
46 | }
```

framework/grpcx/interceptors/grpcx_ratelimit/ratelimit.go
```
1 | package grpcx_ratelimit
2 | 
3 | import (
4 | 	"context"
5 | 	"time"
6 | 
7 | 	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/ratelimit"
9 | 	"github.com/unionj-cloud/go-doudou/v2/framework/ratelimit/memrate"
10 | 	"github.com/unionj-cloud/go-doudou/v2/framework/ratelimit/redisrate"
11 | 	"google.golang.org/grpc"
12 | 	"google.golang.org/grpc/codes"
13 | 	"google.golang.org/grpc/status"
14 | )
15 | 
16 | type KeyGetter interface {
17 | 	GetKey(ctx context.Context, fullMethod string) string
18 | }
19 | 
20 | type RateLimitInterceptor struct {
21 | 	mstore *memrate.MemoryStore
22 | 	rdb    redisrate.Rediser
23 | 	fn     redisrate.LimitFn
24 | }
25 | 
26 | const (
27 | 	limit = 1000
28 | 	burst = 10000
29 | 	ttl   = 60 * time.Second
30 | )
31 | 
32 | func (r *RateLimitInterceptor) limitKey(key string) bool {
33 | 	if r == nil {
34 | 		r = &RateLimitInterceptor{
35 | 			mstore: memrate.NewMemoryStore(func(_ context.Context, store *memrate.MemoryStore, key string) ratelimit.Limiter {
36 | 				return memrate.NewLimiter(limit, burst, memrate.WithTimer(10*time.Second, func() {
37 | 					store.DeleteKey(key)
38 | 				}))
39 | 			}),
40 | 		}
41 | 	}
42 | 	if r.rdb != nil && r.fn != nil {
43 | 		return redisrate.NewGcraLimiterLimitFn(r.rdb, key, r.fn).Allow()
44 | 	} else if r.mstore != nil {
45 | 		return r.mstore.GetLimiter(key).Allow()
46 | 	}
47 | 	return false
48 | }
49 | 
50 | type RateLimitInterceptorOption func(*RateLimitInterceptor)
51 | 
52 | func WithMemoryStore(mstore *memrate.MemoryStore) RateLimitInterceptorOption {
53 | 	return func(interceptor *RateLimitInterceptor) {
54 | 		interceptor.mstore = mstore
55 | 	}
56 | }
57 | 
58 | func WithRedisStore(rdb redisrate.Rediser, fn redisrate.LimitFn) RateLimitInterceptorOption {
59 | 	return func(interceptor *RateLimitInterceptor) {
60 | 		interceptor.rdb = rdb
61 | 		interceptor.fn = fn
62 | 	}
63 | }
64 | 
65 | func NewRateLimitInterceptor(options ...RateLimitInterceptorOption) *RateLimitInterceptor {
66 | 	interceptor := RateLimitInterceptor{
67 | 		mstore: memrate.NewMemoryStore(func(_ context.Context, store *memrate.MemoryStore, key string) ratelimit.Limiter {
68 | 			return memrate.NewLimiter(limit, burst, memrate.WithTimer(ttl, func() {
69 | 				store.DeleteKey(key)
70 | 			}))
71 | 		}),
72 | 	}
73 | 	for i := range options {
74 | 		options[i](&interceptor)
75 | 	}
76 | 	return &interceptor
77 | }
78 | 
79 | func (r *RateLimitInterceptor) UnaryServerInterceptor(keyGetter KeyGetter) grpc.UnaryServerInterceptor {
80 | 	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
81 | 		key := keyGetter.GetKey(ctx, info.FullMethod)
82 | 		if !r.limitKey(key) {
83 | 			return nil, status.Errorf(codes.ResourceExhausted, "%s is rejected by grpcx_ratelimit middleware, please retry later.", key)
84 | 		}
85 | 		return handler(ctx, req)
86 | 	}
87 | }
88 | 
89 | func (r *RateLimitInterceptor) StreamServerInterceptor(keyGetter KeyGetter) grpc.StreamServerInterceptor {
90 | 	return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
91 | 		ctx := stream.Context()
92 | 		if stream1, ok := stream.(*grpc_middleware.WrappedServerStream); ok {
93 | 			ctx = stream1.WrappedContext
94 | 		}
95 | 		key := keyGetter.GetKey(ctx, info.FullMethod)
96 | 		if !r.limitKey(key) {
97 | 			return status.Errorf(codes.ResourceExhausted, "%s is rejected by grpcx_ratelimit middleware, please retry later.", key)
98 | 		}
99 | 		return handler(srv, stream)
100 | 	}
101 | }
```

framework/registry/nacos/mock/mock_naming_client_interface.go
```
1 | // Code generated by MockGen. DO NOT EDIT.
2 | // Source: ./naming_client_interface.go
3 | 
4 | // Package mock is a generated GoMock package.
5 | package mock
6 | 
7 | import (
8 | 	reflect "reflect"
9 | 
10 | 	gomock "github.com/golang/mock/gomock"
11 | 	model "github.com/wubin1989/nacos-sdk-go/v2/model"
12 | 	vo "github.com/wubin1989/nacos-sdk-go/v2/vo"
13 | )
14 | 
15 | // MockINamingClient is a mock of INamingClient interface.
16 | type MockINamingClient struct {
17 | 	ctrl     *gomock.Controller
18 | 	recorder *MockINamingClientMockRecorder
19 | }
20 | 
21 | // MockINamingClientMockRecorder is the mock recorder for MockINamingClient.
22 | type MockINamingClientMockRecorder struct {
23 | 	mock *MockINamingClient
24 | }
25 | 
26 | // NewMockINamingClient creates a new mock instance.
27 | func NewMockINamingClient(ctrl *gomock.Controller) *MockINamingClient {
28 | 	mock := &MockINamingClient{ctrl: ctrl}
29 | 	mock.recorder = &MockINamingClientMockRecorder{mock}
30 | 	return mock
31 | }
32 | 
33 | // EXPECT returns an object that allows the caller to indicate expected use.
34 | func (m *MockINamingClient) EXPECT() *MockINamingClientMockRecorder {
35 | 	return m.recorder
36 | }
37 | 
38 | // CloseClient mocks base method.
39 | func (m *MockINamingClient) CloseClient() {
40 | 	m.ctrl.T.Helper()
41 | 	m.ctrl.Call(m, "CloseClient")
42 | }
43 | 
44 | // CloseClient indicates an expected call of CloseClient.
45 | func (mr *MockINamingClientMockRecorder) CloseClient() *gomock.Call {
46 | 	mr.mock.ctrl.T.Helper()
47 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseClient", reflect.TypeOf((*MockINamingClient)(nil).CloseClient))
48 | }
49 | 
50 | // DeregisterInstance mocks base method.
51 | func (m *MockINamingClient) DeregisterInstance(param vo.DeregisterInstanceParam) (bool, error) {
52 | 	m.ctrl.T.Helper()
53 | 	ret := m.ctrl.Call(m, "DeregisterInstance", param)
54 | 	ret0, _ := ret[0].(bool)
55 | 	ret1, _ := ret[1].(error)
56 | 	return ret0, ret1
57 | }
58 | 
59 | // DeregisterInstance indicates an expected call of DeregisterInstance.
60 | func (mr *MockINamingClientMockRecorder) DeregisterInstance(param interface{}) *gomock.Call {
61 | 	mr.mock.ctrl.T.Helper()
62 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeregisterInstance", reflect.TypeOf((*MockINamingClient)(nil).DeregisterInstance), param)
63 | }
64 | 
65 | // GetAllServicesInfo mocks base method.
66 | func (m *MockINamingClient) GetAllServicesInfo(param vo.GetAllServiceInfoParam) (model.ServiceList, error) {
67 | 	m.ctrl.T.Helper()
68 | 	ret := m.ctrl.Call(m, "GetAllServicesInfo", param)
69 | 	ret0, _ := ret[0].(model.ServiceList)
70 | 	ret1, _ := ret[1].(error)
71 | 	return ret0, ret1
72 | }
73 | 
74 | // GetAllServicesInfo indicates an expected call of GetAllServicesInfo.
75 | func (mr *MockINamingClientMockRecorder) GetAllServicesInfo(param interface{}) *gomock.Call {
76 | 	mr.mock.ctrl.T.Helper()
77 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllServicesInfo", reflect.TypeOf((*MockINamingClient)(nil).GetAllServicesInfo), param)
78 | }
79 | 
80 | // GetService mocks base method.
81 | func (m *MockINamingClient) GetService(param vo.GetServiceParam) (model.Service, error) {
82 | 	m.ctrl.T.Helper()
83 | 	ret := m.ctrl.Call(m, "GetService", param)
84 | 	ret0, _ := ret[0].(model.Service)
85 | 	ret1, _ := ret[1].(error)
86 | 	return ret0, ret1
87 | }
88 | 
89 | // GetService indicates an expected call of GetService.
90 | func (mr *MockINamingClientMockRecorder) GetService(param interface{}) *gomock.Call {
91 | 	mr.mock.ctrl.T.Helper()
92 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetService", reflect.TypeOf((*MockINamingClient)(nil).GetService), param)
93 | }
94 | 
95 | // RegisterInstance mocks base method.
96 | func (m *MockINamingClient) RegisterInstance(param vo.RegisterInstanceParam) (bool, error) {
97 | 	m.ctrl.T.Helper()
98 | 	ret := m.ctrl.Call(m, "RegisterInstance", param)
99 | 	ret0, _ := ret[0].(bool)
100 | 	ret1, _ := ret[1].(error)
101 | 	return ret0, ret1
102 | }
103 | 
104 | // RegisterInstance indicates an expected call of RegisterInstance.
105 | func (mr *MockINamingClientMockRecorder) RegisterInstance(param interface{}) *gomock.Call {
106 | 	mr.mock.ctrl.T.Helper()
107 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterInstance", reflect.TypeOf((*MockINamingClient)(nil).RegisterInstance), param)
108 | }
109 | 
110 | // SelectAllInstances mocks base method.
111 | func (m *MockINamingClient) SelectAllInstances(param vo.SelectAllInstancesParam) ([]model.Instance, error) {
112 | 	m.ctrl.T.Helper()
113 | 	ret := m.ctrl.Call(m, "SelectAllInstances", param)
114 | 	ret0, _ := ret[0].([]model.Instance)
115 | 	ret1, _ := ret[1].(error)
116 | 	return ret0, ret1
117 | }
118 | 
119 | // SelectAllInstances indicates an expected call of SelectAllInstances.
120 | func (mr *MockINamingClientMockRecorder) SelectAllInstances(param interface{}) *gomock.Call {
121 | 	mr.mock.ctrl.T.Helper()
122 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectAllInstances", reflect.TypeOf((*MockINamingClient)(nil).SelectAllInstances), param)
123 | }
124 | 
125 | // SelectInstances mocks base method.
126 | func (m *MockINamingClient) SelectInstances(param vo.SelectInstancesParam) ([]model.Instance, error) {
127 | 	m.ctrl.T.Helper()
128 | 	ret := m.ctrl.Call(m, "SelectInstances", param)
129 | 	ret0, _ := ret[0].([]model.Instance)
130 | 	ret1, _ := ret[1].(error)
131 | 	return ret0, ret1
132 | }
133 | 
134 | // SelectInstances indicates an expected call of SelectInstances.
135 | func (mr *MockINamingClientMockRecorder) SelectInstances(param interface{}) *gomock.Call {
136 | 	mr.mock.ctrl.T.Helper()
137 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectInstances", reflect.TypeOf((*MockINamingClient)(nil).SelectInstances), param)
138 | }
139 | 
140 | // SelectOneHealthyInstance mocks base method.
141 | func (m *MockINamingClient) SelectOneHealthyInstance(param vo.SelectOneHealthInstanceParam) (*model.Instance, error) {
142 | 	m.ctrl.T.Helper()
143 | 	ret := m.ctrl.Call(m, "SelectOneHealthyInstance", param)
144 | 	ret0, _ := ret[0].(*model.Instance)
145 | 	ret1, _ := ret[1].(error)
146 | 	return ret0, ret1
147 | }
148 | 
149 | // SelectOneHealthyInstance indicates an expected call of SelectOneHealthyInstance.
150 | func (mr *MockINamingClientMockRecorder) SelectOneHealthyInstance(param interface{}) *gomock.Call {
151 | 	mr.mock.ctrl.T.Helper()
152 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectOneHealthyInstance", reflect.TypeOf((*MockINamingClient)(nil).SelectOneHealthyInstance), param)
153 | }
154 | 
155 | // Subscribe mocks base method.
156 | func (m *MockINamingClient) Subscribe(param *vo.SubscribeParam) error {
157 | 	m.ctrl.T.Helper()
158 | 	ret := m.ctrl.Call(m, "Subscribe", param)
159 | 	ret0, _ := ret[0].(error)
160 | 	return ret0
161 | }
162 | 
163 | // Subscribe indicates an expected call of Subscribe.
164 | func (mr *MockINamingClientMockRecorder) Subscribe(param interface{}) *gomock.Call {
165 | 	mr.mock.ctrl.T.Helper()
166 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockINamingClient)(nil).Subscribe), param)
167 | }
168 | 
169 | // Unsubscribe mocks base method.
170 | func (m *MockINamingClient) Unsubscribe(param *vo.SubscribeParam) error {
171 | 	m.ctrl.T.Helper()
172 | 	ret := m.ctrl.Call(m, "Unsubscribe", param)
173 | 	ret0, _ := ret[0].(error)
174 | 	return ret0
175 | }
176 | 
177 | // Unsubscribe indicates an expected call of Unsubscribe.
178 | func (mr *MockINamingClientMockRecorder) Unsubscribe(param interface{}) *gomock.Call {
179 | 	mr.mock.ctrl.T.Helper()
180 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockINamingClient)(nil).Unsubscribe), param)
181 | }
182 | 
183 | // UpdateInstance mocks base method.
184 | func (m *MockINamingClient) UpdateInstance(param vo.UpdateInstanceParam) (bool, error) {
185 | 	m.ctrl.T.Helper()
186 | 	ret := m.ctrl.Call(m, "UpdateInstance", param)
187 | 	ret0, _ := ret[0].(bool)
188 | 	ret1, _ := ret[1].(error)
189 | 	return ret0, ret1
190 | }
191 | 
192 | // UpdateInstance indicates an expected call of UpdateInstance.
193 | func (mr *MockINamingClientMockRecorder) UpdateInstance(param interface{}) *gomock.Call {
194 | 	mr.mock.ctrl.T.Helper()
195 | 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateInstance", reflect.TypeOf((*MockINamingClient)(nil).UpdateInstance), param)
196 | }
```

cmd/internal/ddl/codegen/dao.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"strings"
7 | 	"text/template"
8 | 
9 | 	"github.com/iancoleman/strcase"
10 | 	log "github.com/sirupsen/logrus"
11 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/table"
12 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
13 | 	"github.com/unionj-cloud/toolkit/astutils"
14 | 	"github.com/unionj-cloud/go-doudou/v2/version"
15 | )
16 | 
17 | var daoTmpl = templates.EditableHeaderTmpl + `package dao
18 | 
19 | import (
20 | 	"context"
21 | 	"database/sql"
22 | 	"fmt"
23 | 	"github.com/pkg/errors"
24 | 	"{{.EntityPackage}}"
25 | 	"github.com/unionj-cloud/toolkit/caller"
26 | 	"github.com/unionj-cloud/toolkit/sqlext/query"
27 | 	"github.com/unionj-cloud/toolkit/sqlext/wrapper"
28 | 	"github.com/unionj-cloud/toolkit/reflectutils"
29 | 	"github.com/unionj-cloud/toolkit/stringutils"
30 | 	"github.com/unionj-cloud/toolkit/templateutils"
31 | 	"strings"
32 | 	"math"
33 | 	"time"
34 | )
35 | 
36 | var _ I{{.EntityName}}Dao = (*{{.EntityName}}Dao)(nil)
37 | 
38 | type {{.EntityName}}Dao struct {
39 | 	db wrapper.GddDB
40 | }
41 | 
42 | func New{{.EntityName}}Dao(querier wrapper.GddDB) *{{.EntityName}}Dao {
43 | 	return &{{.EntityName}}Dao{
44 | 		db: querier,
45 | 	}
46 | }
47 | 
48 | func (receiver *{{.EntityName}}Dao) BeforeSaveHook(ctx context.Context, data *entity.{{.EntityName}}) {
49 | 	// implement your business logic
50 | }
51 | 
52 | func (receiver *{{.EntityName}}Dao) BeforeBulkSaveHook(ctx context.Context, data []*entity.{{.EntityName}}) {
53 | 	// implement your business logic
54 | }
55 | 
56 | func (receiver *{{.EntityName}}Dao) AfterSaveHook(ctx context.Context, data *entity.{{.EntityName}}, lastInsertID int64, affected int64) {
57 | 	// implement your business logic
58 | }
59 | 
60 | func (receiver *{{.EntityName}}Dao) AfterBulkSaveHook(ctx context.Context, data []*entity.{{.EntityName}}, lastInsertID int64, affected int64) {
61 | 	// implement your business logic
62 | }
63 | 
64 | func (receiver *{{.EntityName}}Dao) BeforeUpdateManyHook(ctx context.Context, data []*entity.{{.EntityName}}, where *query.Where) {
65 | 	// implement your business logic
66 | }
67 | 
68 | func (receiver *{{.EntityName}}Dao) AfterUpdateManyHook(ctx context.Context, data []*entity.{{.EntityName}}, where *query.Where, affected int64) {
69 | 	// implement your business logic
70 | }
71 | 
72 | func (receiver *{{.EntityName}}Dao) BeforeDeleteManyHook(ctx context.Context, data []*entity.{{.EntityName}}, where *query.Where) {
73 | 	// implement your business logic
74 | }
75 | 
76 | func (receiver *{{.EntityName}}Dao) AfterDeleteManyHook(ctx context.Context, data []*entity.{{.EntityName}}, where *query.Where, affected int64) {
77 | 	// implement your business logic
78 | }
79 | 
80 | func (receiver *{{.EntityName}}Dao) BeforeReadManyHook(ctx context.Context, page *query.Page, where *query.Where) {
81 | 	// implement your business logic
82 | }
83 | 
84 | func (receiver *{{.EntityName}}Dao) Insert(ctx context.Context, data *entity.{{.EntityName}}) (int64, error) {
85 | 	var (
86 | 		statement    string
87 | 		err          error
88 | 		result       sql.Result
89 | 		{{- if .PkCol.Autoincrement }}
90 | 		lastInsertID int64
91 | 		{{- end }}
92 | 		affected     int64
93 | 	)
94 | 	receiver.BeforeSaveHook(ctx, data)
95 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "Insert{{.EntityName}}", nil); err != nil {
96 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
97 | 	}
98 | 	if result, err = receiver.db.NamedExecContext(ctx, statement, data); err != nil {
99 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
100 | 	}
101 | 	{{- if .PkCol.Autoincrement }}
102 | 	if lastInsertID, err = result.LastInsertId(); err != nil {
103 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
104 | 	}
105 | 	if lastInsertID > 0 {
106 | 		{{- if eq .PkField.Type "int64"}}
107 | 		data.{{.PkField.Name}} = lastInsertID
108 | 		{{- else }}
109 | 		data.{{.PkField.Name}} = {{.PkField.Type}}(lastInsertID)
110 | 		{{- end }}
111 | 	}
112 | 	{{- end }}
113 | 	if affected, err = result.RowsAffected(); err == nil {
114 | 		{{- if .PkCol.Autoincrement }}
115 | 		receiver.AfterSaveHook(ctx, data, lastInsertID, affected)
116 | 		{{- else }}
117 | 		receiver.AfterSaveHook(ctx, data, 0, affected)
118 | 		{{- end }}
119 | 	}
120 | 	return affected, err
121 | }
122 | 
123 | func (receiver *{{.EntityName}}Dao) InsertIgnore(ctx context.Context, data *entity.{{.EntityName}}) (int64, error) {
124 | 	var (
125 | 		statement    string
126 | 		err          error
127 | 		result       sql.Result
128 | 		affected     int64
129 | 	)
130 | 	receiver.BeforeSaveHook(ctx, data)
131 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "InsertIgnore{{.EntityName}}", nil); err != nil {
132 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
133 | 	}
134 | 	if result, err = receiver.db.NamedExecContext(ctx, statement, data); err != nil {
135 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
136 | 	}
137 | 	if affected, err = result.RowsAffected(); err == nil {
138 | 		receiver.AfterSaveHook(ctx, data, 0, affected)
139 | 	}
140 | 	return affected, err
141 | }
142 | 
143 | func (receiver *{{.EntityName}}Dao) BulkInsert(ctx context.Context, data []*entity.{{.EntityName}}) (int64, error) {
144 | 	var (
145 | 		statement    string
146 | 		err          error
147 | 		result       sql.Result
148 | 		{{- if .PkCol.Autoincrement }}
149 | 		lastInsertID int64
150 | 		{{- end }}
151 | 		affected     int64
152 | 	)
153 | 	receiver.BeforeBulkSaveHook(ctx, data)
154 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "Insert{{.EntityName}}", nil); err != nil {
155 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
156 | 	}
157 | 	if result, err = receiver.db.NamedExecContext(ctx, statement, data); err != nil {
158 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
159 | 	}
160 | 	{{- if .PkCol.Autoincrement }}
161 | 	if lastInsertID, err = result.LastInsertId(); err != nil {
162 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
163 | 	}
164 | 	if lastInsertID > 0 {
165 | 		for i, item :=range data {
166 | 			{{- if eq .PkField.Type "int64"}}
167 | 			item.{{.PkField.Name}} = lastInsertID + int64(i)
168 | 			{{- else }}
169 | 			item.{{.PkField.Name}} = {{.PkField.Type}}(lastInsertID) + {{.PkField.Type}}(i)
170 | 			{{- end }}
171 | 		}
172 | 	}
173 | 	{{- end }}
174 | 	if affected, err = result.RowsAffected(); err == nil {
175 | 		{{- if .PkCol.Autoincrement }}
176 | 		receiver.AfterBulkSaveHook(ctx, data, lastInsertID, affected)
177 | 		{{- else }}
178 | 		receiver.AfterBulkSaveHook(ctx, data, 0, affected)
179 | 		{{- end }}
180 | 	}
181 | 	return affected, err
182 | }
183 | 
184 | func (receiver *{{.EntityName}}Dao) BulkInsertIgnore(ctx context.Context, data []*entity.{{.EntityName}}) (int64, error) {
185 | 	var (
186 | 		statement    string
187 | 		err          error
188 | 		result       sql.Result
189 | 		affected     int64
190 | 	)
191 | 	receiver.BeforeBulkSaveHook(ctx, data)
192 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "InsertIgnore{{.EntityName}}", nil); err != nil {
193 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
194 | 	}
195 | 	if result, err = receiver.db.NamedExecContext(ctx, statement, data); err != nil {
196 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
197 | 	}
198 | 	if affected, err = result.RowsAffected(); err == nil {
199 | 		receiver.AfterBulkSaveHook(ctx, data, 0, affected)
200 | 	}
201 | 	return affected, err
202 | }
203 | 
204 | // Upsert With ON DUPLICATE KEY UPDATE, the affected-rows value per row is 1 if the row is inserted as a new row,
205 | // 2 if an existing row is updated, and 0 if an existing row is set to its current values.
206 | // If you specify the CLIENT_FOUND_ROWS flag to the mysql_real_connect() C API function when connecting to mysqld,
207 | // the affected-rows value is 1 (not 0) if an existing row is set to its current values.
208 | // https://dev.mysql.com/doc/refman/5.7/en/insert-on-duplicate.html
209 | func (receiver *{{.EntityName}}Dao) Upsert(ctx context.Context, data *entity.{{.EntityName}}) (int64, error) {
210 | 	var (
211 | 		statement    string
212 | 		err          error
213 | 		result       sql.Result
214 | 		{{- if .PkCol.Autoincrement }}
215 | 		lastInsertID int64
216 | 		{{- end }}
217 | 		affected     int64
218 | 	)
219 | 	receiver.BeforeSaveHook(ctx, data)
220 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "Upsert{{.EntityName}}", nil); err != nil {
221 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
222 | 	}
223 | 	if result, err = receiver.db.NamedExecContext(ctx, statement, data); err != nil {
224 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
225 | 	}
226 | 	{{- if .PkCol.Autoincrement }}
227 | 	if lastInsertID, err = result.LastInsertId(); err != nil {
228 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
229 | 	}
230 | 	if lastInsertID > 0 {
231 | 		{{- if eq .PkField.Type "int64"}}
232 | 		data.{{.PkField.Name}} = lastInsertID
233 | 		{{- else }}
234 | 		data.{{.PkField.Name}} = {{.PkField.Type}}(lastInsertID)
235 | 		{{- end }}
236 | 	}
237 | 	{{- end }}
238 | 	if affected, err = result.RowsAffected(); err == nil {
239 | 		{{- if .PkCol.Autoincrement }}
240 | 		receiver.AfterSaveHook(ctx, data, lastInsertID, affected)
241 | 		{{- else }}
242 | 		receiver.AfterSaveHook(ctx, data, 0, affected)
243 | 		{{- end }}
244 | 	}
245 | 	return affected, err
246 | }
247 | 
248 | func (receiver *{{.EntityName}}Dao) BulkUpsert(ctx context.Context, data []*entity.{{.EntityName}}) (int64, error) {
249 | 	var (
250 | 		statement    string
251 | 		updateClause string
252 | 		err          error
253 | 		result       sql.Result
254 | 		affected     int64
255 | 		args      []interface{}
256 | 	)
257 | 	receiver.BeforeBulkSaveHook(ctx, data)
258 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "Insert{{.EntityName}}", nil); err != nil {
259 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
260 | 	}
261 | 	statement, args, err = receiver.db.BindNamed(statement, data)
262 | 	if err != nil {
263 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
264 | 	}
265 | 	if updateClause, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "UpdateClause{{.EntityName}}", nil); err != nil {
266 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
267 | 	}
268 | 	statement += "\n" + updateClause
269 | 	if result, err = receiver.db.ExecContext(ctx, statement, args...); err != nil {
270 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
271 | 	}
272 | 	if affected, err = result.RowsAffected(); err == nil {
273 | 		receiver.AfterBulkSaveHook(ctx, data, 0, affected)
274 | 	}
275 | 	return affected, err
276 | }
277 | 
278 | func (receiver *{{.EntityName}}Dao) BulkUpsertSelect(ctx context.Context, data []*entity.{{.EntityName}}, columns []string) (int64, error) {
279 | 	var (
280 | 		statement    string
281 | 		updateClause string
282 | 		err          error
283 | 		result       sql.Result
284 | 		affected     int64
285 | 		args      []interface{}
286 | 	)
287 | 	receiver.BeforeBulkSaveHook(ctx, data)
288 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "Insert{{.EntityName}}", nil); err != nil {
289 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
290 | 	}
291 | 	statement, args, err = receiver.db.BindNamed(statement, data)
292 | 	if err != nil {
293 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
294 | 	}
295 | 	if updateClause, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "UpdateClauseSelect{{.EntityName}}", struct {
296 | 		Columns []string
297 | 	}{
298 | 		Columns: columns,
299 | 	}); err != nil {
300 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
301 | 	}
302 | 	statement += "\n" + updateClause
303 | 	if result, err = receiver.db.ExecContext(ctx, statement, args...); err != nil {
304 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
305 | 	}
306 | 	if affected, err = result.RowsAffected(); err == nil {
307 | 		receiver.AfterBulkSaveHook(ctx, data, 0, affected)
308 | 	}
309 | 	return affected, err
310 | }
311 | 
312 | func (receiver *{{.EntityName}}Dao) UpsertNoneZero(ctx context.Context, data *entity.{{.EntityName}}) (int64, error) {
313 | 	var (
314 | 		statement    string
315 | 		err          error
316 | 		result       sql.Result
317 | 		{{- if .PkCol.Autoincrement }}
318 | 		lastInsertID int64
319 | 		{{- end }}
320 | 		affected     int64
321 | 	)
322 | 	receiver.BeforeSaveHook(ctx, data)
323 | 	value := reflectutils.ValueOf(data).Interface()
324 | 	if _, ok := value.(entity.{{.EntityName}}); !ok {
325 | 		return 0, errors.New("underlying type of data should be entity.{{.EntityName}}")
326 | 	}
327 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "Upsert{{.EntityName}}NoneZero", data); err != nil {
328 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
329 | 	}
330 | 	if result, err = receiver.db.NamedExecContext(ctx, statement, data); err != nil {
331 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
332 | 	}
333 | 	{{- if .PkCol.Autoincrement }}
334 | 	if lastInsertID, err = result.LastInsertId(); err != nil {
335 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
336 | 	}
337 | 	if lastInsertID > 0 {
338 | 		{{- if eq .PkField.Type "int64"}}
339 | 		data.{{.PkField.Name}} = lastInsertID
340 | 		{{- else }}
341 | 		data.{{.PkField.Name}} = {{.PkField.Type}}(lastInsertID)
342 | 		{{- end }}
343 | 	}
344 | 	{{- end }}
345 | 	if affected, err = result.RowsAffected(); err == nil {
346 | 		{{- if .PkCol.Autoincrement }}
347 | 		receiver.AfterSaveHook(ctx, data, lastInsertID, affected)
348 | 		{{- else }}
349 | 		receiver.AfterSaveHook(ctx, data, 0, affected)
350 | 		{{- end }}
351 | 	}
352 | 	return affected, err
353 | }
354 | 
355 | func (receiver *{{.EntityName}}Dao) DeleteMany(ctx context.Context, where query.Where) (int64, error) {
356 | 	var (
357 | 		err    error
358 | 		result sql.Result
359 | 		w      string
360 | 		args   []interface{}
361 | 		affected int64
362 | 	)
363 | 	receiver.BeforeDeleteManyHook(ctx, nil, &where)
364 | 	w, args = where.Sql()
365 | 	if result, err = receiver.db.ExecContext(ctx, receiver.db.Rebind(fmt.Sprintf("delete from {{.TableName}} where %s;", w)), args...); err != nil {
366 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
367 | 	}
368 | 	if affected, err = result.RowsAffected(); err == nil {
369 | 		receiver.AfterDeleteManyHook(ctx, nil, &where, affected)
370 | 	}
371 | 	return affected, err
372 | }
373 | 
374 | func (receiver *{{.EntityName}}Dao) Update(ctx context.Context, data *entity.{{.EntityName}}) (int64, error) {
375 | 	var (
376 | 		statement string
377 | 		err       error
378 | 		result    sql.Result
379 | 		affected  int64
380 | 	)
381 | 	receiver.BeforeSaveHook(ctx, data)
382 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "Update{{.EntityName}}", nil); err != nil {
383 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
384 | 	}
385 | 	if result, err = receiver.db.NamedExecContext(ctx, statement, data); err != nil {
386 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
387 | 	}
388 | 	if affected, err = result.RowsAffected(); err == nil {
389 | 		receiver.AfterSaveHook(ctx, data, 0, affected)
390 | 	}
391 | 	return affected, err
392 | }
393 | 
394 | func (receiver *{{.EntityName}}Dao) UpdateNoneZero(ctx context.Context, data *entity.{{.EntityName}}) (int64, error) {
395 | 	var (
396 | 		statement string
397 | 		err       error
398 | 		result    sql.Result
399 | 		affected  int64
400 | 	)
401 | 	receiver.BeforeSaveHook(ctx, data)
402 | 	value := reflectutils.ValueOf(data).Interface()
403 | 	if _, ok := value.(entity.{{.EntityName}}); !ok {
404 | 		return 0, errors.New("underlying type of data should be entity.{{.EntityName}}")
405 | 	}
406 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "Update{{.EntityName}}NoneZero", data); err != nil {
407 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
408 | 	}
409 | 	if result, err = receiver.db.NamedExecContext(ctx, statement, data); err != nil {
410 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
411 | 	}
412 | 	if affected, err = result.RowsAffected(); err == nil {
413 | 		receiver.AfterSaveHook(ctx, data, 0, affected)
414 | 	}
415 | 	return affected, err
416 | }
417 | 
418 | func (receiver *{{.EntityName}}Dao) UpdateMany(ctx context.Context, data []*entity.{{.EntityName}}, where query.Where) (int64, error) {
419 | 	var (
420 | 		statement string
421 | 		err       error
422 | 		result    sql.Result
423 | 		q         string
424 | 		args      []interface{}
425 | 		wargs     []interface{}
426 | 		w         string
427 | 		affected  int64
428 | 	)
429 | 	receiver.BeforeUpdateManyHook(ctx, data, &where)
430 | 	if statement, err = templateutils.BlockMysql("{{.EntityName | ToLower}}dao.sql", {{.EntityName | ToLower}}daosql, "Update{{.EntityName}}s", nil); err != nil {
431 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
432 | 	}
433 | 	if q, args, err = receiver.db.BindNamed(statement, data); err != nil {
434 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
435 | 	}
436 | 	w, wargs = where.Sql()
437 | 	if stringutils.IsNotEmpty(w) {
438 | 		q += " where " + w
439 | 	}
440 | 	args = append(args, wargs...)
441 | 	if result, err = receiver.db.ExecContext(ctx, receiver.db.Rebind(q), args...); err != nil {
442 | 		return 0, errors.Wrap(err, caller.NewCaller().String())
443 | 	}
444 | 	if affected, err = result.RowsAffected(); err == nil {
445 | 		receiver.AfterUpdateManyHook(ctx, data, &where, affected)
446 | 	}
447 | 	return affected, err
448 | }
449 | 
[TRUNCATED]
```

cmd/internal/ddl/codegen/daosql.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/iancoleman/strcase"
11 | 	log "github.com/sirupsen/logrus"
12 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/table"
13 | 	"github.com/unionj-cloud/toolkit/astutils"
14 | 	"github.com/unionj-cloud/go-doudou/v2/version"
15 | )
16 | 
17 | var daosqltmpl = `{{` + "`" + `{{` + "`" + `}}define "NoneZeroSet"{{` + "`" + `}}` + "`" + `}}
18 | 	{{- range $i, $co := .UpdateColumns}}
19 | 	{{` + "`" + `{{` + "`" + `}}- if .{{$co.Meta.Name}}{{` + "`" + `}}` + "`" + `}}
20 | 	` + "`" + `{{$co.Name}}` + "`" + `=:{{$co.Name}},
21 | 	{{` + "`" + `{{` + "`" + `}}- end{{` + "`" + `}}` + "`" + `}}
22 | 	{{- end}}
23 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
24 | 
25 | {{` + "`" + `{{` + "`" + `}}define "Insert{{.EntityName}}"{{` + "`" + `}}` + "`" + `}}
26 | INSERT INTO ` + "`" + `{{.Schema}}` + "`" + `.` + "`" + `{{.TableName}}` + "`" + `
27 | ({{- range $i, $co := .InsertColumns}}
28 | {{- if $i}},{{end}}
29 | ` + "`" + `{{$co.Name}}` + "`" + `
30 | {{- end }})
31 | VALUES ({{- range $i, $co := .InsertColumns}}
32 | 	   {{- if $i}},{{end}}
33 | 	   :{{$co.Name}}
34 | 	   {{- end }})
35 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
36 | 
37 | {{` + "`" + `{{` + "`" + `}}define "Update{{.EntityName}}"{{` + "`" + `}}` + "`" + `}}
38 | UPDATE ` + "`" + `{{.Schema}}` + "`" + `.` + "`" + `{{.TableName}}` + "`" + `
39 | SET
40 | 	{{- range $i, $co := .UpdateColumns}}
41 | 	{{- if $i}},{{end}}
42 | 	` + "`" + `{{$co.Name}}` + "`" + `=:{{$co.Name}}
43 | 	{{- end }}
44 | WHERE
45 |     ` + "`" + `{{.Pk.Name}}` + "`" + ` =:{{.Pk.Name}}
46 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
47 | 
48 | {{` + "`" + `{{` + "`" + `}}define "Update{{.EntityName}}NoneZero"{{` + "`" + `}}` + "`" + `}}
49 | UPDATE ` + "`" + `{{.Schema}}` + "`" + `.` + "`" + `{{.TableName}}` + "`" + `
50 | SET
51 |     {{` + "`" + `{{` + "`" + `}}Eval "NoneZeroSet" . | TrimSuffix ","{{` + "`" + `}}` + "`" + `}}
52 | WHERE
53 |     ` + "`" + `{{.Pk.Name}}` + "`" + `=:{{.Pk.Name}}
54 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
55 | 
56 | {{` + "`" + `{{` + "`" + `}}define "Upsert{{.EntityName}}"{{` + "`" + `}}` + "`" + `}}
57 | INSERT INTO ` + "`" + `{{.Schema}}` + "`" + `.` + "`" + `{{.TableName}}` + "`" + `
58 | ({{- range $i, $co := .InsertColumns}}
59 | {{- if $i}},{{end}}
60 | ` + "`" + `{{$co.Name}}` + "`" + `
61 | {{- end }})
62 | VALUES ({{- range $i, $co := .InsertColumns}}
63 |         {{- if $i}},{{end}}
64 |         :{{$co.Name}}
65 |         {{- end }}) ON DUPLICATE KEY
66 | UPDATE
67 | 		{{- range $i, $co := .UpdateColumns}}
68 | 		{{- if $i}},{{end}}
69 | 		` + "`" + `{{$co.Name}}` + "`" + `=:{{$co.Name}}
70 | 		{{- end }}
71 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
72 | 
73 | {{` + "`" + `{{` + "`" + `}}define "Upsert{{.EntityName}}NoneZero"{{` + "`" + `}}` + "`" + `}}
74 | INSERT INTO ` + "`" + `{{.Schema}}` + "`" + `.` + "`" + `{{.TableName}}` + "`" + `
75 | ({{- range $i, $co := .InsertColumns}}
76 | {{- if $i}},{{end}}
77 | ` + "`" + `{{$co.Name}}` + "`" + `
78 | {{- end }})
79 | VALUES ({{- range $i, $co := .InsertColumns}}
80 |         {{- if $i}},{{end}}
81 |         :{{$co.Name}}
82 |         {{- end }}) ON DUPLICATE KEY
83 | UPDATE
84 | 		{{` + "`" + `{{` + "`" + `}}Eval "NoneZeroSet" . | TrimSuffix ","{{` + "`" + `}}` + "`" + `}}
85 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
86 | 
87 | {{` + "`" + `{{` + "`" + `}}define "Get{{.EntityName}}"{{` + "`" + `}}` + "`" + `}}
88 | select *
89 | from ` + "`" + `{{.Schema}}` + "`" + `.` + "`" + `{{.TableName}}` + "`" + `
90 | where ` + "`" + `{{.Pk.Name}}` + "`" + ` = ?
91 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
92 | 
93 | {{` + "`" + `{{` + "`" + `}}define "Update{{.EntityName}}s"{{` + "`" + `}}` + "`" + `}}
94 | UPDATE ` + "`" + `{{.Schema}}` + "`" + `.` + "`" + `{{.TableName}}` + "`" + `
95 | SET
96 | 	{{- range $i, $co := .UpdateColumns}}
97 | 	{{- if $i}},{{end}}
98 | 	` + "`" + `{{$co.Name}}` + "`" + `=:{{$co.Name}}
99 | 	{{- end }}
100 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
101 | 
102 | {{` + "`" + `{{` + "`" + `}}define "Update{{.EntityName}}sNoneZero"{{` + "`" + `}}` + "`" + `}}
103 | UPDATE ` + "`" + `{{.Schema}}` + "`" + `.` + "`" + `{{.TableName}}` + "`" + `
104 | SET
105 |     {{` + "`" + `{{` + "`" + `}}Eval "NoneZeroSet" . | TrimSuffix ","{{` + "`" + `}}` + "`" + `}}
106 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
107 | 
108 | {{` + "`" + `{{` + "`" + `}}define "InsertIgnore{{.EntityName}}"{{` + "`" + `}}` + "`" + `}}
109 | INSERT IGNORE INTO ` + "`" + `{{.Schema}}` + "`" + `.` + "`" + `{{.TableName}}` + "`" + `
110 | ({{- range $i, $co := .InsertColumns}}
111 | {{- if $i}},{{end}}
112 | ` + "`" + `{{$co.Name}}` + "`" + `
113 | {{- end }})
114 | VALUES ({{- range $i, $co := .InsertColumns}}
115 | 	   {{- if $i}},{{end}}
116 | 	   :{{$co.Name}}
117 | 	   {{- end }})
118 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
119 | 
120 | {{` + "`" + `{{` + "`" + `}}define "UpdateClause{{.EntityName}}"{{` + "`" + `}}` + "`" + `}}
121 | ON DUPLICATE KEY
122 | UPDATE
123 | 		{{- range $i, $co := .UpdateColumns}}
124 | 		{{- if $i}},{{end}}
125 | 		` + "`" + `{{$co.Name}}` + "`" + `=VALUES({{$co.Name}})
126 | 		{{- end }}
127 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
128 | 
129 | {{` + "`" + `{{` + "`" + `}}define "UpdateClauseSelect{{.EntityName}}"{{` + "`" + `}}` + "`" + `}}
130 | ON DUPLICATE KEY
131 | UPDATE
132 | 		{{` + "`" + `{{` + "`" + `}}- range $i, $co := .Columns{{` + "`" + `}}` + "`" + `}}
133 | 		{{` + "`" + `{{` + "`" + `}}- if $i{{` + "`" + `}}` + "`" + `}},{{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}
134 | 		` + "`" + `{{` + "`" + `{{` + "`" + `}}$co{{` + "`" + `}}` + "`" + `}}` + "`" + `=VALUES({{` + "`" + `{{` + "`" + `}}$co{{` + "`" + `}}` + "`" + `}})
135 | 		{{` + "`" + `{{` + "`" + `}}- end {{` + "`" + `}}` + "`" + `}}
136 | {{` + "`" + `{{` + "`" + `}}end{{` + "`" + `}}` + "`" + `}}`
137 | 
138 | // GenDaoSQL generates sql statements used by dao layer
139 | func GenDaoSQL(entityPath string, t table.Table, folder ...string) error {
140 | 	var (
141 | 		err      error
142 | 		daopath  string
143 | 		f        *os.File
144 | 		funcMap  map[string]interface{}
145 | 		tpl      *template.Template
146 | 		iColumns []table.Column
147 | 		uColumns []table.Column
148 | 		df       string
149 | 		sqlBuf   bytes.Buffer
150 | 	)
151 | 	df = "dao"
152 | 	if len(folder) > 0 {
153 | 		df = folder[0]
154 | 	}
155 | 	daopath = filepath.Join(filepath.Dir(entityPath), df)
156 | 	_ = os.MkdirAll(daopath, os.ModePerm)
157 | 	daofile := filepath.Join(daopath, strings.ToLower(t.Meta.Name)+"daosql.go")
158 | 	if _, err = os.Stat(daofile); os.IsNotExist(err) {
159 | 		f, _ = os.Create(daofile)
160 | 		defer f.Close()
161 | 
162 | 		funcMap = make(map[string]interface{})
163 | 		funcMap["ToSnake"] = strcase.ToSnake
164 | 		tpl, _ = template.New("daosql.tmpl").Funcs(funcMap).Parse(daosqltmpl)
165 | 
166 | 		for _, co := range t.Columns {
167 | 			if !co.AutoSet {
168 | 				iColumns = append(iColumns, co)
169 | 			}
170 | 			if !co.AutoSet && !co.Pk {
171 | 				uColumns = append(uColumns, co)
172 | 			}
173 | 		}
174 | 
175 | 		var pkColumn table.Column
176 | 		for _, co := range t.Columns {
177 | 			if co.Pk {
178 | 				pkColumn = co
179 | 				break
180 | 			}
181 | 		}
182 | 		_ = tpl.Execute(&sqlBuf, struct {
183 | 			Schema        string
184 | 			TableName     string
185 | 			EntityName    string
186 | 			InsertColumns []table.Column
187 | 			UpdateColumns []table.Column
188 | 			Pk            table.Column
189 | 		}{
190 | 			Schema:        os.Getenv("DB_SCHEMA"),
191 | 			TableName:     t.Name,
192 | 			EntityName:    t.Meta.Name,
193 | 			InsertColumns: iColumns,
194 | 			UpdateColumns: uColumns,
195 | 			Pk:            pkColumn,
196 | 		})
197 | 		sqlStr := strings.TrimSpace(sqlBuf.String())
198 | 		sqlStr = strings.ReplaceAll(sqlStr, "`", "`"+" + "+`"`+"`"+`"`+" + "+"`")
199 | 		sqlBuf.Reset()
200 | 		sqlBuf.WriteString(`/**
201 | * Generated by go-doudou ` + version.Release + `.
202 | * You can edit it as your need.
203 | */
204 | package dao
205 | `)
206 | 		sqlBuf.WriteString("var " + strings.ToLower(t.Meta.Name) + "daosql=`" + sqlStr + "`\n")
207 | 		astutils.FixImport(sqlBuf.Bytes(), daofile)
208 | 	} else {
209 | 		log.Warnf("file %s already exists", daofile)
210 | 	}
211 | 	return nil
212 | }
```

cmd/internal/ddl/codegen/dto.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"io/ioutil"
6 | 	"os"
7 | 	"path/filepath"
8 | 	"text/template"
9 | 
10 | 	"github.com/sirupsen/logrus"
11 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
12 | 	"github.com/unionj-cloud/toolkit/astutils"
13 | 	"github.com/unionj-cloud/go-doudou/v2/version"
14 | )
15 | 
16 | var appendDtoTmpl = `
17 | {{- range $m := .Entities}}
18 | 
19 | type {{$m.Name}} struct {
20 | {{- range $f := $m.Fields }}
21 | 	{{$f.Name}} {{$f.Type}}
22 | {{- end }}
23 | }
24 | {{- end }}
25 | `
26 | 
27 | var initDtoTmpl = templates.EditableHeaderTmpl + `package dto
28 | 
29 | import (
30 | 	"time"
31 | 
32 | 	"github.com/shopspring/decimal"
33 | )
34 | 
35 | //go:generate go-doudou name --file $GOFILE
36 | 
37 | ` + appendDtoTmpl
38 | 
39 | // GenDto generates structs code in dto pkg from database tables
40 | func GenDto(dir string, entities []astutils.StructMeta) {
41 | 	var (
42 | 		err  error
43 | 		f    *os.File
44 | 		fi   os.FileInfo
45 | 		tmpl string
46 | 		tpl  *template.Template
47 | 		buf  bytes.Buffer
48 | 	)
49 | 	dir = filepath.Join(filepath.Dir(dir), "dto")
50 | 	_ = os.MkdirAll(dir, os.ModePerm)
51 | 	dtoFile := filepath.Join(dir, "dto_gen.go")
52 | 	fi, err = os.Stat(dtoFile)
53 | 	if err != nil && !os.IsNotExist(err) {
54 | 		panic(err)
55 | 	}
56 | 	if fi != nil {
57 | 		logrus.Warningln("New content will be append to dto_gen.go file")
58 | 		if f, err = os.OpenFile(dtoFile, os.O_APPEND, os.ModePerm); err != nil {
59 | 			panic(err)
60 | 		}
61 | 		defer f.Close()
62 | 		tmpl = appendDtoTmpl
63 | 	} else {
64 | 		if f, err = os.Create(dtoFile); err != nil {
65 | 			panic(err)
66 | 		}
67 | 		defer f.Close()
68 | 		tmpl = initDtoTmpl
69 | 	}
70 | 	if tpl, err = template.New("dto_gen.go.tmpl").Parse(tmpl); err != nil {
71 | 		panic(err)
72 | 	}
73 | 	if err = tpl.Execute(&buf, struct {
74 | 		Entities []astutils.StructMeta
75 | 		Version  string
76 | 	}{
77 | 		Entities: entities,
78 | 		Version:  version.Release,
79 | 	}); err != nil {
80 | 		panic(err)
81 | 	}
82 | 	original, err := ioutil.ReadAll(f)
83 | 	if err != nil {
84 | 		panic(err)
85 | 	}
86 | 	original = append(original, buf.Bytes()...)
87 | 	astutils.FixImport(original, dtoFile)
88 | }
```

cmd/internal/ddl/codegen/entity.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"strings"
7 | 
8 | 	log "github.com/sirupsen/logrus"
9 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
10 | 	"github.com/unionj-cloud/toolkit/astutils"
11 | 	"github.com/unionj-cloud/toolkit/templateutils"
12 | 	"github.com/unionj-cloud/go-doudou/v2/version"
13 | )
14 | 
15 | var entityTmpl = templates.EditableHeaderTmpl + `package entity
16 | 
17 | import (
18 | 	"time"
19 | 
20 | 	"github.com/shopspring/decimal"
21 | )
22 | 
23 | //dd:table
24 | type {{.Name}} struct {
25 | {{- range $f := .Fields }}
26 | 	{{$f.Name}} {{$f.Type}} ` + "`" + `{{$f.Tag}}` + "`" + `
27 | {{- end }}
28 | }`
29 | 
30 | // GenEntityGo generates structs code in entity pkg from database tables
31 | func GenEntityGo(dpath string, entity astutils.StructMeta) {
32 | 	var (
33 | 		err error
34 | 		f   *os.File
35 | 	)
36 | 	_ = os.MkdirAll(dpath, os.ModePerm)
37 | 	dfile := filepath.Join(dpath, strings.ToLower(entity.Name)+".go")
38 | 	if _, err = os.Stat(dfile); os.IsNotExist(err) {
39 | 		f, _ = os.Create(dfile)
40 | 		defer f.Close()
41 | 		var source string
42 | 		entity.Version = version.Release
43 | 		source, _ = templateutils.String("entity.go.tmpl", entityTmpl, entity)
44 | 		astutils.FixImport([]byte(source), dfile)
45 | 	} else {
46 | 		log.Warnf("file %s already exists", dfile)
47 | 	}
48 | }
```

cmd/internal/ddl/codegen/idao.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"strings"
7 | 	"text/template"
8 | 
9 | 	log "github.com/sirupsen/logrus"
10 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/table"
11 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
12 | 	"github.com/unionj-cloud/toolkit/astutils"
13 | 	"github.com/unionj-cloud/go-doudou/v2/version"
14 | )
15 | 
16 | var idaoTmpl = templates.EditableHeaderTmpl + `package dao
17 | 
18 | import (
19 | 	"context"
20 | 	"github.com/unionj-cloud/toolkit/sqlext/query"
21 | 	"{{.EntityPackage}}"
22 | )
23 | 
24 | type I{{.EntityName}}Dao interface {
25 | 	// single table CRUD operations
26 | 	Insert(ctx context.Context, data *entity.{{.EntityName}}) (int64, error)
27 | 	InsertIgnore(ctx context.Context, data *entity.{{.EntityName}}) (int64, error)
28 | 	BulkInsert(ctx context.Context, data []*entity.{{.EntityName}}) (int64, error)
29 | 	BulkInsertIgnore(ctx context.Context, data []*entity.{{.EntityName}}) (int64, error)
30 | 	Upsert(ctx context.Context, data *entity.{{.EntityName}}) (int64, error)
31 | 	BulkUpsert(ctx context.Context, data []*entity.{{.EntityName}}) (int64, error)
32 | 	BulkUpsertSelect(ctx context.Context, data []*entity.{{.EntityName}}, columns []string) (int64, error)
33 | 	UpsertNoneZero(ctx context.Context, data *entity.{{.EntityName}}) (int64, error)
34 | 	DeleteMany(ctx context.Context, where query.Where) (int64, error)
35 | 	Update(ctx context.Context, data *entity.{{.EntityName}}) (int64, error)
36 | 	UpdateNoneZero(ctx context.Context, data *entity.{{.EntityName}}) (int64, error)
37 | 	UpdateMany(ctx context.Context, data []*entity.{{.EntityName}}, where query.Where) (int64, error)
38 | 	UpdateManyNoneZero(ctx context.Context, data []*entity.{{.EntityName}}, where query.Where) (int64, error)
39 | 	Get(ctx context.Context, dest *entity.{{.EntityName}}, id {{.PkField.Type}}) error
40 | 	SelectMany(ctx context.Context, dest *[]entity.{{.EntityName}}, where query.Where) error
41 | 	CountMany(ctx context.Context, where query.Where) (int, error)
42 | 	PageMany(ctx context.Context, dest *{{.EntityName}}PageRet, page query.Page, where query.Where) error
43 | 	DeleteManySoft(ctx context.Context, where query.Where) (int64, error)
44 | 
45 | 	// hooks
46 | 	BeforeSaveHook(ctx context.Context, data *entity.{{.EntityName}})
47 | 	BeforeBulkSaveHook(ctx context.Context, data []*entity.{{.EntityName}})
48 | 	AfterSaveHook(ctx context.Context, data *entity.{{.EntityName}}, lastInsertID int64, affected int64)
49 | 	AfterBulkSaveHook(ctx context.Context, data []*entity.{{.EntityName}}, lastInsertID int64, affected int64)
50 | 	BeforeUpdateManyHook(ctx context.Context, data []*entity.{{.EntityName}}, where *query.Where)
51 | 	AfterUpdateManyHook(ctx context.Context, data []*entity.{{.EntityName}}, where *query.Where, affected int64)
52 | 	BeforeDeleteManyHook(ctx context.Context, data []*entity.{{.EntityName}}, where *query.Where)
53 | 	AfterDeleteManyHook(ctx context.Context, data []*entity.{{.EntityName}}, where *query.Where, affected int64)
54 | 	BeforeReadManyHook(ctx context.Context, page *query.Page, where *query.Where)
55 | }`
56 | 
57 | // GenIDaoGo generates dao layer interface code
58 | func GenIDaoGo(entityPath string, t table.Table, folder ...string) error {
59 | 	var (
60 | 		err      error
61 | 		daopath  string
62 | 		f        *os.File
63 | 		tpl      *template.Template
64 | 		df       string
65 | 		dpkg     string
66 | 		pkColumn table.Column
67 | 	)
68 | 	df = "dao"
69 | 	if len(folder) > 0 {
70 | 		df = folder[0]
71 | 	}
72 | 	daopath = filepath.Join(filepath.Dir(entityPath), df)
73 | 	_ = os.MkdirAll(daopath, os.ModePerm)
74 | 	daofile := filepath.Join(daopath, "i"+strings.ToLower(t.Meta.Name)+"dao.go")
75 | 	if _, err = os.Stat(daofile); os.IsNotExist(err) {
76 | 		f, _ = os.Create(daofile)
77 | 		defer f.Close()
78 | 		dpkg = astutils.GetImportPath(entityPath)
79 | 		for _, column := range t.Columns {
80 | 			if column.Pk {
81 | 				pkColumn = column
82 | 				break
83 | 			}
84 | 		}
85 | 		tpl, _ = template.New("idao.go.tmpl").Parse(idaoTmpl)
86 | 		_ = tpl.Execute(f, struct {
87 | 			EntityName    string
88 | 			Version       string
89 | 			EntityPackage string
90 | 			PkField       astutils.FieldMeta
91 | 		}{
92 | 			EntityName:    t.Meta.Name,
93 | 			Version:       version.Release,
94 | 			EntityPackage: dpkg,
95 | 			PkField:       pkColumn.Meta,
96 | 		})
97 | 	} else {
98 | 		log.Warnf("file %s already exists", daofile)
99 | 	}
100 | 	return nil
101 | }
```

cmd/internal/ddl/columnenum/columnenum.go
```
1 | package columnenum
2 | 
3 | // ColumnType database data types
4 | type ColumnType string
5 | 
6 | const (
7 | 	// BitType bit
8 | 	BitType ColumnType = "BIT"
9 | 	// TextType text
10 | 	TextType ColumnType = "TEXT"
11 | 	// BlobType blob
12 | 	BlobType ColumnType = "BLOB"
13 | 	// DateType date
14 | 	DateType ColumnType = "DATE"
15 | 	// DatetimeType datatime
16 | 	DatetimeType ColumnType = "DATETIME"
17 | 	// DecimalType decimal
18 | 	DecimalType ColumnType = "DECIMAL"
19 | 	// DoubleType double
20 | 	DoubleType ColumnType = "DOUBLE"
21 | 	// EnumType enum
22 | 	EnumType ColumnType = "ENUM"
23 | 	// FloatType float
24 | 	FloatType ColumnType = "FLOAT"
25 | 	// GeometryType geometry
26 | 	GeometryType ColumnType = "GEOMETRY"
27 | 	// MediumintType medium int
28 | 	MediumintType ColumnType = "MEDIUMINT"
29 | 	// JSONType json
30 | 	JSONType ColumnType = "JSON"
31 | 	// IntType int
32 | 	IntType ColumnType = "INT"
33 | 	// LongtextType long text
34 | 	LongtextType ColumnType = "LONGTEXT"
35 | 	// LongblobType long blob
36 | 	LongblobType ColumnType = "LONGBLOB"
37 | 	// BigintType big int
38 | 	BigintType ColumnType = "BIGINT"
39 | 	// MediumtextType medium text
40 | 	MediumtextType ColumnType = "MEDIUMTEXT"
41 | 	// MediumblobType medium blob
42 | 	MediumblobType ColumnType = "MEDIUMBLOB"
43 | 	// SmallintType small int
44 | 	SmallintType ColumnType = "SMALLINT"
45 | 	// TinyintType tiny int
46 | 	TinyintType ColumnType = "TINYINT"
47 | 	// VarcharType varchar
48 | 	VarcharType ColumnType = "VARCHAR(255)"
49 | )
```

cmd/internal/ddl/config/config.go
```
1 | package config
2 | 
3 | // DbConfig store database connection parameters
4 | type DbConfig struct {
5 | 	Host    string
6 | 	Port    string
7 | 	User    string
8 | 	Passwd  string
9 | 	Schema  string
10 | 	Charset string
11 | }
```

cmd/internal/ddl/ddlast/ast.go
```
1 | package ddlast
2 | 
3 | import (
4 | 	"sort"
5 | 	"strings"
6 | 
7 | 	"github.com/unionj-cloud/toolkit/astutils"
8 | 	"github.com/unionj-cloud/toolkit/sliceutils"
9 | )
10 | 
11 | type sortableFieldMeta []astutils.FieldMeta
12 | 
13 | // Len return length of sortableFieldMeta
14 | func (it sortableFieldMeta) Len() int {
15 | 	return len(it)
16 | }
17 | 
18 | // Less define asc or desc order
19 | func (it sortableFieldMeta) Less(i, j int) bool {
20 | 	return it[i].Name < it[j].Name
21 | }
22 | 
23 | // Swap change position of elements at i and j
24 | func (it sortableFieldMeta) Swap(i, j int) {
25 | 	it[i], it[j] = it[j], it[i]
26 | }
27 | 
28 | // FlatEmbed flat embed struct
29 | func FlatEmbed(structs []astutils.StructMeta) []astutils.StructMeta {
30 | 	structMap := make(map[string]astutils.StructMeta)
31 | 	for _, structMeta := range structs {
32 | 		if _, exists := structMap[structMeta.Name]; !exists {
33 | 			structMap[structMeta.Name] = structMeta
34 | 		}
35 | 	}
36 | 	var result []astutils.StructMeta
37 | 	for _, structMeta := range structs {
38 | 		if sliceutils.IsEmpty(structMeta.Comments) {
39 | 			continue
40 | 		}
41 | 		if !strings.Contains(structMeta.Comments[0], "dd:table") {
42 | 			continue
43 | 		}
44 | 		_structMeta := astutils.StructMeta{
45 | 			Name:     structMeta.Name,
46 | 			Fields:   make([]astutils.FieldMeta, 0),
47 | 			Comments: make([]string, len(structMeta.Comments)),
48 | 		}
49 | 		copy(_structMeta.Comments, structMeta.Comments)
50 | 
51 | 		fieldMap := make(map[string]astutils.FieldMeta)
52 | 		embedFieldMap := make(map[string]astutils.FieldMeta)
53 | 		for _, fieldMeta := range structMeta.Fields {
54 | 			if strings.HasPrefix(fieldMeta.Type, "embed") {
55 | 				if embedded, exists := structMap[fieldMeta.Name]; exists {
56 | 					for _, field := range embedded.Fields {
57 | 						embedFieldMap[field.Name] = field
58 | 					}
59 | 				}
60 | 			} else {
61 | 				_structMeta.Fields = append(_structMeta.Fields, fieldMeta)
62 | 				fieldMap[fieldMeta.Name] = fieldMeta
63 | 			}
64 | 		}
65 | 
66 | 		var embedFields []astutils.FieldMeta
67 | 		for key, field := range embedFieldMap {
68 | 			if _, exists := fieldMap[key]; !exists {
69 | 				embedFields = append(embedFields, field)
70 | 			}
71 | 		}
72 | 
73 | 		sort.Stable(sortableFieldMeta(embedFields))
74 | 		_structMeta.Fields = append(_structMeta.Fields, embedFields...)
75 | 		result = append(result, _structMeta)
76 | 	}
77 | 
78 | 	return result
79 | }
```

cmd/internal/ddl/extraenum/extraenum.go
```
1 | package extraenum
2 | 
3 | // Extra part of defining column
4 | type Extra string
5 | 
6 | const (
7 | 	// Update used for update_at column
8 | 	Update Extra = "on update CURRENT_TIMESTAMP"
9 | )
```

cmd/internal/ddl/keyenum/keyenum.go
```
1 | package keyenum
2 | 
3 | // Key define index type
4 | type Key string
5 | 
6 | const (
7 | 	// Pri primary key
8 | 	Pri Key = "PRI"
9 | 	// Uni unique index
10 | 	Uni Key = "UNI"
11 | 	// Mul composite index
12 | 	Mul Key = "MUL"
13 | 	// Empty blank
14 | 	Empty Key = ""
15 | )
```

cmd/internal/ddl/nullenum/nullenum.go
```
1 | package nullenum
2 | 
3 | // Null nullable
4 | type Null string
5 | 
6 | const (
7 | 	// Yes nullable
8 | 	Yes Null = "YES"
9 | 	// No not null
10 | 	No Null = "NO"
11 | )
```

cmd/internal/ddl/sortenum/sortenum.go
```
1 | package sortenum
2 | 
3 | // Sort string alias for asc and desc
4 | type Sort string
5 | 
6 | const (
7 | 	// Asc constant value for asc
8 | 	Asc Sort = "asc"
9 | 	// Desc constant value for desc
10 | 	Desc Sort = "desc"
11 | )
```

cmd/internal/ddl/table/ddl.go
```
1 | package table
2 | 
3 | import (
4 | 	"context"
5 | 	"fmt"
6 | 	"go/ast"
7 | 	"go/parser"
8 | 	"go/token"
9 | 	"os"
10 | 	"path/filepath"
11 | 	"reflect"
12 | 	"strings"
13 | 	"time"
14 | 
15 | 	mapset "github.com/deckarep/golang-set"
16 | 	"github.com/iancoleman/strcase"
17 | 	"github.com/jmoiron/sqlx"
18 | 	"github.com/pkg/errors"
19 | 	"github.com/rs/zerolog"
20 | 	"github.com/testcontainers/testcontainers-go"
21 | 	"github.com/testcontainers/testcontainers-go/wait"
22 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/columnenum"
23 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/config"
24 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/ddlast"
25 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/extraenum"
26 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/sortenum"
27 | 	"github.com/unionj-cloud/toolkit/astutils"
28 | 	"github.com/unionj-cloud/toolkit/caller"
29 | 	"github.com/unionj-cloud/toolkit/envconfig"
30 | 	"github.com/unionj-cloud/toolkit/pathutils"
31 | 	"github.com/unionj-cloud/toolkit/sliceutils"
32 | 	"github.com/unionj-cloud/toolkit/sqlext/wrapper"
33 | 	"github.com/unionj-cloud/toolkit/stringutils"
34 | 	"github.com/unionj-cloud/toolkit/zlogger"
35 | )
36 | 
37 | // CreateTable create table from Table
38 | func CreateTable(ctx context.Context, db wrapper.Querier, t Table) error {
39 | 	var (
40 | 		statement string
41 | 		err       error
42 | 	)
43 | 	if statement, err = t.CreateSql(); err != nil {
44 | 		return err
45 | 	}
46 | 	fmt.Println(statement)
47 | 	if _, err = db.ExecContext(ctx, statement); err != nil {
48 | 		return err
49 | 	}
50 | 	return err
51 | }
52 | 
53 | // ChangeColumn change a column definition by Column
54 | func ChangeColumn(ctx context.Context, db wrapper.Querier, col Column) error {
55 | 	var (
56 | 		statement string
57 | 		err       error
58 | 	)
59 | 	if statement, err = col.ChangeColumnSql(); err != nil {
60 | 		return err
61 | 	}
62 | 	fmt.Println(statement)
63 | 	if _, err = db.ExecContext(ctx, statement); err != nil {
64 | 		return err
65 | 	}
66 | 	return err
67 | }
68 | 
69 | // AddColumn add a column by Column
70 | func AddColumn(ctx context.Context, db wrapper.Querier, col Column) error {
71 | 	var (
72 | 		statement string
73 | 		err       error
74 | 	)
75 | 	if statement, err = col.AddColumnSql(); err != nil {
76 | 		return err
77 | 	}
78 | 	fmt.Println(statement)
79 | 	if _, err = db.ExecContext(ctx, statement); err != nil {
80 | 		return err
81 | 	}
82 | 	return err
83 | }
84 | 
85 | // dropAddIndex drop and then add an existing index with the same key_name
86 | func dropAddIndex(ctx context.Context, db wrapper.Querier, idx Index) error {
87 | 	var err error
88 | 	if err = dropIndex(ctx, db, idx); err != nil {
89 | 		return errors.Wrap(err, caller.NewCaller().String())
90 | 	}
91 | 	if err = addIndex(ctx, db, idx); err != nil {
92 | 		return errors.Wrap(err, caller.NewCaller().String())
93 | 	}
94 | 	return nil
95 | }
96 | 
97 | // addIndex add a new index
98 | func addIndex(ctx context.Context, db wrapper.Querier, idx Index) error {
99 | 	var (
100 | 		statement string
101 | 		err       error
102 | 	)
103 | 	if statement, err = idx.AddIndexSql(); err != nil {
104 | 		return errors.Wrap(err, caller.NewCaller().String())
105 | 	}
106 | 	fmt.Println(statement)
107 | 	if _, err = db.ExecContext(ctx, statement); err != nil {
108 | 		return errors.Wrap(err, caller.NewCaller().String())
109 | 	}
110 | 	return nil
111 | }
112 | 
113 | // dropIndex drop an existing index
114 | func dropIndex(ctx context.Context, db wrapper.Querier, idx Index) error {
115 | 	var (
116 | 		statement string
117 | 		err       error
118 | 	)
119 | 	if statement, err = idx.DropIndexSql(); err != nil {
120 | 		return errors.Wrap(err, caller.NewCaller().String())
121 | 	}
122 | 	fmt.Println(statement)
123 | 	if _, err = db.ExecContext(ctx, statement); err != nil {
124 | 		return errors.Wrap(err, caller.NewCaller().String())
125 | 	}
126 | 	return nil
127 | }
128 | 
129 | // dropAddFk drop and then add an existing foreign key with the same constraint
130 | func dropAddFk(ctx context.Context, db wrapper.Querier, fk ForeignKey) error {
131 | 	var err error
132 | 	if err = dropFk(ctx, db, fk); err != nil {
133 | 		return errors.Wrap(err, caller.NewCaller().String())
134 | 	}
135 | 	if err = addFk(ctx, db, fk); err != nil {
136 | 		return errors.Wrap(err, caller.NewCaller().String())
137 | 	}
138 | 	return nil
139 | }
140 | 
141 | // addFk add a new foreign key
142 | func addFk(ctx context.Context, db wrapper.Querier, fk ForeignKey) error {
143 | 	var (
144 | 		statement string
145 | 		err       error
146 | 	)
147 | 	if statement, err = fk.AddFkSql(); err != nil {
148 | 		return errors.Wrap(err, caller.NewCaller().String())
149 | 	}
150 | 	fmt.Println(statement)
151 | 	if _, err = db.ExecContext(ctx, statement); err != nil {
152 | 		return errors.Wrap(err, caller.NewCaller().String())
153 | 	}
154 | 	return nil
155 | }
156 | 
157 | // dropFk drop an existing foreign key
158 | func dropFk(ctx context.Context, db wrapper.Querier, fk ForeignKey) error {
159 | 	var (
160 | 		statement string
161 | 		err       error
162 | 	)
163 | 	if statement, err = fk.DropFkSql(); err != nil {
164 | 		return errors.Wrap(err, caller.NewCaller().String())
165 | 	}
166 | 	fmt.Println(statement)
167 | 	if _, err = db.ExecContext(ctx, statement); err != nil {
168 | 		return errors.Wrap(err, caller.NewCaller().String())
169 | 	}
170 | 	return nil
171 | }
172 | 
173 | func Table2struct(ctx context.Context, pre, schema string, existTables []string, db *sqlx.DB) (tables []Table) {
174 | 	var err error
175 | 	for _, t := range existTables {
176 | 		if stringutils.IsNotEmpty(pre) && !strings.HasPrefix(t, pre) {
177 | 			continue
178 | 		}
179 | 		var dbIndice []DbIndex
180 | 		if err = db.SelectContext(ctx, &dbIndice, fmt.Sprintf("SHOW INDEXES FROM %s", t)); err != nil {
181 | 			panic(errors.Wrap(err, caller.NewCaller().String()))
182 | 		}
183 | 
184 | 		idxMap := make(map[string][]DbIndex)
185 | 
186 | 		for _, idx := range dbIndice {
187 | 			if val, exists := idxMap[idx.KeyName]; exists {
188 | 				val = append(val, idx)
189 | 				idxMap[idx.KeyName] = val
190 | 			} else {
191 | 				idxMap[idx.KeyName] = []DbIndex{
192 | 					idx,
193 | 				}
194 | 			}
195 | 		}
196 | 
197 | 		indexes, colIdxMap := idxListAndMap(idxMap)
198 | 
199 | 		var columns []DbColumn
200 | 		if err = db.SelectContext(ctx, &columns, fmt.Sprintf("SHOW FULL COLUMNS FROM %s", t)); err != nil {
201 | 			panic(errors.Wrap(err, caller.NewCaller().String()))
202 | 		}
203 | 
204 | 		fks := foreignKeys(ctx, db, schema, t)
205 | 		fkMap := make(map[string]ForeignKey)
206 | 		for _, item := range fks {
207 | 			fkMap[item.Fk] = item
208 | 		}
209 | 
210 | 		var cols []Column
211 | 		var fields []astutils.FieldMeta
212 | 		for _, item := range columns {
213 | 			col := dbColumn2Column(item, colIdxMap, t, fkMap[item.Field])
214 | 			fields = append(fields, col.Meta)
215 | 			cols = append(cols, col)
216 | 		}
217 | 
218 | 		entity := astutils.StructMeta{
219 | 			Name:   strcase.ToCamel(strings.TrimPrefix(t, pre)),
220 | 			Fields: fields,
221 | 		}
222 | 
223 | 		var pkColumn Column
224 | 		for _, column := range cols {
225 | 			if column.Pk {
226 | 				pkColumn = column
227 | 				break
228 | 			}
229 | 		}
230 | 
231 | 		tables = append(tables, Table{
232 | 			Name:    t,
233 | 			Columns: cols,
234 | 			Pk:      pkColumn.Name,
235 | 			Indexes: indexes,
236 | 			Meta:    entity,
237 | 			Fks:     fks,
238 | 		})
239 | 	}
240 | 	return
241 | }
242 | 
243 | func foreignKeys(ctx context.Context, db wrapper.Querier, schema, t string) (fks []ForeignKey) {
244 | 	var (
245 | 		dbForeignKeys []DbForeignKey
246 | 		err           error
247 | 	)
248 | 	rawSql := `
249 | 		SELECT TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME, REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME
250 | 		FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
251 | 		WHERE TABLE_SCHEMA = ? AND REFERENCED_TABLE_SCHEMA = ? AND TABLE_NAME = ?
252 | 	`
253 | 	if err = db.SelectContext(ctx, &dbForeignKeys, db.Rebind(rawSql), schema, schema, t); err != nil {
254 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
255 | 	}
256 | 	for _, item := range dbForeignKeys {
257 | 		var (
258 | 			dbActions []DbAction
259 | 			dbAction  DbAction
260 | 		)
261 | 		rawSql = `
262 | 			select CONSTRAINT_NAME, UPDATE_RULE, DELETE_RULE, TABLE_NAME, REFERENCED_TABLE_NAME 
263 | 			from information_schema.REFERENTIAL_CONSTRAINTS 
264 | 			where CONSTRAINT_SCHEMA=? and TABLE_NAME=? and CONSTRAINT_NAME=?
265 | 		`
266 | 		if err = db.SelectContext(ctx, &dbActions, db.Rebind(rawSql), schema, t, item.ConstraintName); err != nil {
267 | 			panic(errors.Wrap(err, caller.NewCaller().String()))
268 | 		}
269 | 		if len(dbActions) > 0 {
270 | 			dbAction = dbActions[0]
271 | 		}
272 | 		var rules []string
273 | 		if stringutils.IsNotEmpty(dbAction.DeleteRule) {
274 | 			rules = append(rules, fmt.Sprintf("ON DELETE %s", dbAction.DeleteRule))
275 | 		}
276 | 		if stringutils.IsNotEmpty(dbAction.UpdateRule) {
277 | 			rules = append(rules, fmt.Sprintf("ON UPDATE %s", dbAction.UpdateRule))
278 | 		}
279 | 		var fullRule string
280 | 		if len(rules) > 0 {
281 | 			fullRule = strings.Join(rules, " ")
282 | 		}
283 | 		fks = append(fks, ForeignKey{
284 | 			Table:           t,
285 | 			Constraint:      item.ConstraintName,
286 | 			Fk:              item.ColumnName,
287 | 			ReferencedTable: item.ReferencedTableName,
288 | 			ReferencedCol:   item.ReferencedColumnName,
289 | 			UpdateRule:      dbAction.UpdateRule,
290 | 			DeleteRule:      dbAction.DeleteRule,
291 | 			FullRule:        fullRule,
292 | 		})
293 | 	}
294 | 	return
295 | }
296 | 
297 | func idxListAndMap(idxMap map[string][]DbIndex) ([]Index, map[string][]IndexItem) {
298 | 	var indexes []Index
299 | 	colIdxMap := make(map[string][]IndexItem)
300 | 	for k, v := range idxMap {
301 | 		if len(v) == 0 {
302 | 			continue
303 | 		}
304 | 		items := make([]IndexItem, len(v))
305 | 		for i, idx := range v {
306 | 			var sor sortenum.Sort
307 | 			if idx.Collation == "B" {
308 | 				sor = sortenum.Desc
309 | 			} else {
310 | 				sor = sortenum.Asc
311 | 			}
312 | 			items[i] = IndexItem{
313 | 				Unique: !v[0].NonUnique,
314 | 				Name:   k,
315 | 				Column: idx.ColumnName,
316 | 				Order:  idx.SeqInIndex,
317 | 				Sort:   sor,
318 | 			}
319 | 			if val, exists := colIdxMap[idx.ColumnName]; exists {
320 | 				val = append(val, items[i])
321 | 				colIdxMap[idx.ColumnName] = val
322 | 			} else {
323 | 				colIdxMap[idx.ColumnName] = []IndexItem{
324 | 					items[i],
325 | 				}
326 | 			}
327 | 		}
328 | 		indexes = append(indexes, Index{
329 | 			Unique: !v[0].NonUnique,
330 | 			Name:   k,
331 | 			Items:  items,
332 | 		})
333 | 	}
334 | 	return indexes, colIdxMap
335 | }
336 | 
337 | func dbColumn2Column(item DbColumn, colIdxMap map[string][]IndexItem, t string, fk ForeignKey) Column {
338 | 	extra := item.Extra
339 | 	if strings.Contains(extra, "auto_increment") {
340 | 		extra = ""
341 | 	}
342 | 	extra = strings.TrimSpace(strings.TrimPrefix(extra, "DEFAULT_GENERATED"))
343 | 	if stringutils.IsNotEmpty(item.Comment) {
344 | 		extra += fmt.Sprintf(" comment '%s'", item.Comment)
345 | 	}
346 | 	extra = strings.TrimSpace(extra)
347 | 	var defaultVal string
348 | 	if item.Default != nil {
349 | 		defaultVal = *item.Default
350 | 	}
351 | 	col := Column{
352 | 		Table:         t,
353 | 		Name:          item.Field,
354 | 		Type:          columnenum.ColumnType(item.Type),
355 | 		Default:       defaultVal,
356 | 		Pk:            CheckPk(item.Key),
357 | 		Nullable:      CheckNull(item.Null),
358 | 		Unsigned:      CheckUnsigned(item.Type),
359 | 		Autoincrement: CheckAutoincrement(item.Extra),
360 | 		Extra:         extraenum.Extra(extra),
361 | 		AutoSet:       CheckAutoSet(defaultVal),
362 | 		Indexes:       colIdxMap[item.Field],
363 | 		Fk:            fk,
364 | 	}
365 | 	col.Meta = NewFieldFromColumn(col)
366 | 	return col
367 | }
368 | 
369 | func Struct2Table(ctx context.Context, dir, pre string, existTables []string, db *sqlx.DB, schema string) (tables []Table) {
370 | 	var (
371 | 		files []string
372 | 		err   error
373 | 		tx    *sqlx.Tx
374 | 		root  *ast.File
375 | 	)
376 | 	if err = filepath.Walk(dir, astutils.Visit(&files)); err != nil {
377 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
378 | 	}
379 | 	sc := astutils.NewStructCollector(astutils.ExprString)
380 | 	for _, file := range files {
381 | 		fset := token.NewFileSet()
382 | 		if root, err = parser.ParseFile(fset, file, nil, parser.ParseComments); err != nil {
383 | 			panic(errors.Wrap(err, caller.NewCaller().String()))
384 | 		}
385 | 		ast.Walk(sc, root)
386 | 	}
387 | 
388 | 	flattened := ddlast.FlatEmbed(sc.Structs)
389 | 	for _, sm := range flattened {
390 | 		tables = append(tables, NewTableFromStruct(sm, pre))
391 | 	}
392 | 
393 | 	if tx, err = db.BeginTxx(ctx, nil); err != nil {
394 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
395 | 	}
396 | 	defer func() {
397 | 		if r := recover(); r != nil {
398 | 			if _err := tx.Rollback(); _err != nil {
399 | 				err = errors.Wrap(_err, "")
400 | 			}
401 | 			panic(errors.Wrap(err, caller.NewCaller().String()))
402 | 		}
403 | 	}()
404 | 
405 | 	if _, err = tx.ExecContext(ctx, `SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;`); err != nil {
406 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
407 | 	}
408 | 
409 | 	for _, t := range tables {
410 | 		if sliceutils.StringContains(existTables, t.Name) {
411 | 			var columns []DbColumn
412 | 			if err = tx.SelectContext(ctx, &columns, fmt.Sprintf("desc %s", t.Name)); err != nil {
413 | 				panic(errors.Wrap(err, caller.NewCaller().String()))
414 | 			}
415 | 			var existColumnNames []interface{}
416 | 			for _, dbCol := range columns {
417 | 				existColumnNames = append(existColumnNames, dbCol.Field)
418 | 			}
419 | 			existColSet := mapset.NewSetFromSlice(existColumnNames)
420 | 
421 | 			for _, col := range t.Columns {
422 | 				if existColSet.Contains(col.Name) {
423 | 					if err = ChangeColumn(ctx, tx, col); err != nil {
424 | 						panic(errors.Wrap(err, caller.NewCaller().String()))
425 | 					}
426 | 				} else {
427 | 					if err = AddColumn(ctx, tx, col); err != nil {
428 | 						panic(errors.Wrap(err, caller.NewCaller().String()))
429 | 					}
430 | 				}
431 | 			}
432 | 			fks := foreignKeys(ctx, tx, schema, t.Name)
433 | 			updateIndexFromStruct(ctx, tx, t, fks)
434 | 			updateFkFromStruct(ctx, tx, t, fks)
435 | 		} else {
436 | 			if err = CreateTable(ctx, tx, t); err != nil {
437 | 				panic(errors.Wrap(err, caller.NewCaller().String()))
438 | 			}
439 | 		}
440 | 	}
441 | 
442 | 	if _, err = tx.ExecContext(ctx, `SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;`); err != nil {
443 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
444 | 	}
445 | 	_ = tx.Commit()
446 | 	return
447 | }
448 | 
449 | func updateFkFromStruct(ctx context.Context, tx *sqlx.Tx, t Table, fks []ForeignKey) {
450 | 	fkMap := make(map[string]ForeignKey)
451 | 	for _, fk := range fks {
452 | 		fkMap[fk.Constraint] = fk
453 | 	}
454 | 	for _, fk := range t.Fks {
455 | 		if current, exists := fkMap[fk.Constraint]; exists {
456 | 			current.DeleteRule = ""
457 | 			current.UpdateRule = ""
458 | 			fk.DeleteRule = ""
459 | 			fk.UpdateRule = ""
460 | 			if reflect.DeepEqual(fk, current) {
461 | 				continue
462 | 			}
463 | 			if err := dropAddFk(ctx, tx, fk); err != nil {
464 | 				panic(errors.Wrap(err, caller.NewCaller().String()))
465 | 			}
466 | 		} else {
467 | 			if err := addFk(ctx, tx, fk); err != nil {
468 | 				panic(errors.Wrap(err, caller.NewCaller().String()))
469 | 			}
470 | 		}
471 | 	}
472 | 
473 | 	var constraints []string
474 | 	for _, fk := range t.Fks {
475 | 		constraints = append(constraints, fk.Constraint)
476 | 	}
477 | 	for k, v := range fkMap {
478 | 		if !sliceutils.StringContains(constraints, k) {
479 | 			if err := dropFk(ctx, tx, v); err != nil {
480 | 				panic(errors.Wrap(err, caller.NewCaller().String()))
481 | 			}
482 | 		}
483 | 	}
484 | }
485 | 
486 | func updateIndexFromStruct(ctx context.Context, tx *sqlx.Tx, t Table, fks []ForeignKey) {
487 | 	var dbIndexes []DbIndex
488 | 	if err := tx.SelectContext(ctx, &dbIndexes, fmt.Sprintf("SHOW INDEXES FROM %s", t.Name)); err != nil {
489 | 		panic(errors.Wrap(err, caller.NewCaller().String()))
490 | 	}
491 | 
492 | 	keyIndexMap := make(map[string][]DbIndex)
493 | 	for _, index := range dbIndexes {
494 | 		if index.KeyName == "PRIMARY" {
495 | 			continue
496 | 		}
497 | 		if val, exists := keyIndexMap[index.KeyName]; exists {
[TRUNCATED]
```

cmd/internal/ddl/table/ddl_test.go
```
1 | package table
2 | 
3 | import (
4 | 	"context"
5 | 	"encoding/json"
6 | 	"fmt"
7 | 	"reflect"
8 | 	"testing"
9 | 
10 | 	_ "github.com/go-sql-driver/mysql"
11 | 	"github.com/jmoiron/sqlx"
12 | 	"github.com/stretchr/testify/assert"
13 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/columnenum"
14 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/sortenum"
15 | 	"github.com/unionj-cloud/toolkit/sqlext/wrapper"
16 | )
17 | 
18 | func ExampleCreateTable() {
19 | 	terminator, db, err := Setup()
20 | 	if err != nil {
21 | 		panic(err)
22 | 	}
23 | 	defer terminator()
24 | 	defer db.Close()
25 | 
26 | 	expectjson := `{"Name":"user_createtable","Columns":[{"Table":"user","Name":"id","Type":"INT","Default":null,"Pk":true,"Nullable":false,"Unsigned":false,"Autoincrement":true,"Extra":"","Meta":{"Name":"ID","Type":"int","Tag":"dd:\"pk;auto\"","Comments":null},"AutoSet":false,"Indexes":null},{"Table":"user","Name":"name","Type":"VARCHAR(255)","Default":"'jack'","Pk":false,"Nullable":false,"Unsigned":false,"Autoincrement":false,"Extra":"","Meta":{"Name":"Name","Type":"string","Tag":"dd:\"index:name_phone_idx,2;default:'jack'\"","Comments":null},"AutoSet":false,"Indexes":null},{"Table":"user","Name":"phone","Type":"VARCHAR(255)","Default":"'13552053960'","Pk":false,"Nullable":false,"Unsigned":false,"Autoincrement":false,"Extra":"comment '手机号'","Meta":{"Name":"Phone","Type":"string","Tag":"dd:\"index:name_phone_idx,1;default:'13552053960';extra:comment '手机号'\"","Comments":null},"AutoSet":false,"Indexes":null},{"Table":"user","Name":"age","Type":"INT","Default":null,"Pk":false,"Nullable":false,"Unsigned":false,"Autoincrement":false,"Extra":"","Meta":{"Name":"Age","Type":"int","Tag":"dd:\"index\"","Comments":null},"AutoSet":false,"Indexes":null},{"Table":"user","Name":"no","Type":"INT","Default":null,"Pk":false,"Nullable":false,"Unsigned":false,"Autoincrement":false,"Extra":"","Meta":{"Name":"No","Type":"int","Tag":"dd:\"unique\"","Comments":null},"AutoSet":false,"Indexes":null},{"Table":"user","Name":"school","Type":"VARCHAR(255)","Default":"'harvard'","Pk":false,"Nullable":true,"Unsigned":false,"Autoincrement":false,"Extra":"comment '学校'","Meta":{"Name":"School","Type":"string","Tag":"dd:\"null;default:'harvard';extra:comment '学校'\"","Comments":null},"AutoSet":false,"Indexes":null},{"Table":"user","Name":"is_student","Type":"TINYINT","Default":null,"Pk":false,"Nullable":false,"Unsigned":false,"Autoincrement":false,"Extra":"","Meta":{"Name":"IsStudent","Type":"bool","Tag":"","Comments":null},"AutoSet":false,"Indexes":null},{"Table":"user","Name":"delete_at","Type":"DATETIME","Default":null,"Pk":false,"Nullable":true,"Unsigned":false,"Autoincrement":false,"Extra":"","Meta":{"Name":"DeleteAt","Type":"*time.Time","Tag":"","Comments":null},"AutoSet":false,"Indexes":null},{"Table":"user","Name":"create_at","Type":"DATETIME","Default":"CURRENT_TIMESTAMP","Pk":false,"Nullable":true,"Unsigned":false,"Autoincrement":false,"Extra":"","Meta":{"Name":"CreateAt","Type":"*time.Time","Tag":"dd:\"default:CURRENT_TIMESTAMP\"","Comments":null},"AutoSet":true,"Indexes":null},{"Table":"user","Name":"update_at","Type":"DATETIME","Default":"CURRENT_TIMESTAMP","Pk":false,"Nullable":true,"Unsigned":false,"Autoincrement":false,"Extra":"ON UPDATE CURRENT_TIMESTAMP","Meta":{"Name":"UpdateAt","Type":"*time.Time","Tag":"dd:\"default:CURRENT_TIMESTAMP;extra:ON UPDATE CURRENT_TIMESTAMP\"","Comments":null},"AutoSet":true,"Indexes":null}],"Pk":"id","Indexes":[{"Unique":false,"Name":"name_phone_idx","Items":[{"Unique":false,"Name":"","Column":"phone","Order":1,"Sort":"asc"},{"Unique":false,"Name":"","Column":"name","Order":2,"Sort":"asc"}]},{"Unique":false,"Name":"age_idx","Items":[{"Unique":false,"Name":"","Column":"age","Order":1,"Sort":"asc"}]},{"Unique":true,"Name":"no_idx","Items":[{"Unique":false,"Name":"","Column":"no","Order":1,"Sort":"asc"}]}],"Meta":{"Name":"User","Fields":[{"Name":"ID","Type":"int","Tag":"dd:\"pk;auto\"","Comments":null},{"Name":"Name","Type":"string","Tag":"dd:\"index:name_phone_idx,2;default:'jack'\"","Comments":null},{"Name":"Phone","Type":"string","Tag":"dd:\"index:name_phone_idx,1;default:'13552053960';extra:comment '手机号'\"","Comments":null},{"Name":"Age","Type":"int","Tag":"dd:\"index\"","Comments":null},{"Name":"No","Type":"int","Tag":"dd:\"unique\"","Comments":null},{"Name":"School","Type":"string","Tag":"dd:\"null;default:'harvard';extra:comment '学校'\"","Comments":null},{"Name":"IsStudent","Type":"bool","Tag":"","Comments":null},{"Name":"DeleteAt","Type":"*time.Time","Tag":"","Comments":null},{"Name":"CreateAt","Type":"*time.Time","Tag":"dd:\"default:CURRENT_TIMESTAMP\"","Comments":null},{"Name":"UpdateAt","Type":"*time.Time","Tag":"dd:\"default:CURRENT_TIMESTAMP;extra:ON UPDATE CURRENT_TIMESTAMP\"","Comments":null}],"Comments":["dd:table"],"Methods":null}}`
27 | 	var table Table
28 | 	if err = json.Unmarshal([]byte(expectjson), &table); err != nil {
29 | 		panic(err)
30 | 	}
31 | 	if err := CreateTable(context.Background(), db, table); (err != nil) != false {
32 | 		panic(fmt.Sprintf("CreateTable() error = %v, wantErr %v", err, false))
33 | 	}
34 | 
35 | 	// Output:
36 | 	//CREATE TABLE `user_createtable` (
37 | 	//`id` INT NOT NULL AUTO_INCREMENT,
38 | 	//`name` VARCHAR(255) NOT NULL DEFAULT 'jack',
39 | 	//`phone` VARCHAR(255) NOT NULL DEFAULT '13552053960' comment '手机号',
40 | 	//`age` INT NOT NULL,
41 | 	//`no` INT NOT NULL,
42 | 	//`school` VARCHAR(255) NULL DEFAULT 'harvard' comment '学校',
43 | 	//`is_student` TINYINT NOT NULL,
44 | 	//`delete_at` DATETIME NULL,
45 | 	//`create_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
46 | 	//`update_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
47 | 	//PRIMARY KEY (`id`),
48 | 	//INDEX `name_phone_idx` (`phone` asc,`name` asc),
49 | 	//INDEX `age_idx` (`age` asc),
50 | 	//UNIQUE INDEX `no_idx` (`no` asc))
51 | }
52 | 
53 | func TestChangeColumn(t *testing.T) {
54 | 	terminator, db, err := Setup()
55 | 	if err != nil {
56 | 		panic(err)
57 | 	}
58 | 	defer terminator()
59 | 	defer db.Close()
60 | 
61 | 	type args struct {
62 | 		db  *sqlx.DB
63 | 		col Column
64 | 	}
65 | 	tests := []struct {
66 | 		name    string
67 | 		args    args
68 | 		wantErr bool
69 | 		errmsg  string
70 | 	}{
71 | 		{
72 | 			name: "1",
73 | 			args: args{
74 | 				db: db,
75 | 				col: Column{
76 | 					Table:   "ddl_user",
77 | 					Name:    "school",
78 | 					Type:    "varchar(45)",
79 | 					Default: "'Beijing Univ.'",
80 | 				},
81 | 			},
82 | 			wantErr: false,
83 | 		},
84 | 		{
85 | 			name: "2",
86 | 			args: args{
87 | 				db: db,
88 | 				col: Column{
89 | 					Table:   "ddl_user",
90 | 					Name:    "school",
91 | 					Type:    columnenum.TextType,
92 | 					Default: "'Beijing Univ.'",
93 | 				},
94 | 			},
95 | 			wantErr: true,
96 | 			errmsg:  `Error 1101: BLOB, TEXT, GEOMETRY or JSON column 'school' can't have a default value`,
97 | 		},
98 | 		{
99 | 			name: "3",
100 | 			args: args{
101 | 				db: db,
102 | 				col: Column{
103 | 					Table:   "ddl_user",
104 | 					Name:    "school",
105 | 					Type:    "varchar(45)",
106 | 					Default: "Beijing Univ.",
107 | 				},
108 | 			},
109 | 			wantErr: true,
110 | 			errmsg:  `Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'Beijing Univ.' at line 2`,
111 | 		},
112 | 	}
113 | 	for _, tt := range tests {
114 | 		t.Run(tt.name, func(t *testing.T) {
115 | 			var err error
116 | 			if err = ChangeColumn(context.Background(), tt.args.db, tt.args.col); (err != nil) != tt.wantErr {
117 | 				t.Errorf("ChangeColumn() error = %v, wantErr %v", err, tt.wantErr)
118 | 			}
119 | 			if err != nil {
120 | 				if err.Error() != tt.errmsg {
121 | 					t.Errorf("want %s, got %s", tt.errmsg, err.Error())
122 | 				}
123 | 			}
124 | 		})
125 | 	}
126 | }
127 | 
128 | func TestAddColumn(t *testing.T) {
129 | 	terminator, db, err := Setup()
130 | 	if err != nil {
131 | 		panic(err)
132 | 	}
133 | 	defer terminator()
134 | 	defer db.Close()
135 | 
136 | 	type args struct {
137 | 		db  *sqlx.DB
138 | 		col Column
139 | 	}
140 | 	tests := []struct {
141 | 		name    string
142 | 		args    args
143 | 		wantErr bool
144 | 		errmsg  string
145 | 	}{
146 | 		{
147 | 			name: "1",
148 | 			args: args{
149 | 				db: db,
150 | 				col: Column{
151 | 					Table:   "ddl_user",
152 | 					Name:    "favourite",
153 | 					Type:    "varchar(45)",
154 | 					Default: "'football'",
155 | 				},
156 | 			},
157 | 			wantErr: false,
158 | 		},
159 | 	}
160 | 	for _, tt := range tests {
161 | 		t.Run(tt.name, func(t *testing.T) {
162 | 			var err error
163 | 			if err = AddColumn(context.Background(), tt.args.db, tt.args.col); (err != nil) != tt.wantErr {
164 | 				t.Errorf("ChangeColumn() error = %v, wantErr %v", err, tt.wantErr)
165 | 			}
166 | 		})
167 | 	}
168 | }
169 | 
170 | func TestDropIndex(t *testing.T) {
171 | 	terminator, db, err := Setup()
172 | 	if err != nil {
173 | 		panic(err)
174 | 	}
175 | 	defer terminator()
176 | 	defer db.Close()
177 | 
178 | 	type args struct {
179 | 		ctx context.Context
180 | 		db  wrapper.Querier
181 | 		idx Index
182 | 	}
183 | 	tests := []struct {
184 | 		name    string
185 | 		args    args
186 | 		wantErr bool
187 | 	}{
188 | 		{
189 | 			name: "",
190 | 			args: args{
191 | 				ctx: context.Background(),
192 | 				db:  db,
193 | 				idx: Index{
194 | 					Table:  "ddl_user",
195 | 					Unique: true,
196 | 					Name:   "age_idx",
197 | 					Items: []IndexItem{
198 | 						{
199 | 							Column: "age",
200 | 							Order:  1,
201 | 							Sort:   sortenum.Asc,
202 | 						},
203 | 					},
204 | 				},
205 | 			},
206 | 			wantErr: false,
207 | 		},
208 | 	}
209 | 	for _, tt := range tests {
210 | 		t.Run(tt.name, func(t *testing.T) {
211 | 			if err := dropIndex(tt.args.ctx, tt.args.db, tt.args.idx); (err != nil) != tt.wantErr {
212 | 				t.Errorf("dropIndex() error = %v, wantErr %v", err, tt.wantErr)
213 | 			}
214 | 		})
215 | 	}
216 | }
217 | 
218 | func TestAddIndex(t *testing.T) {
219 | 	terminator, db, err := Setup()
220 | 	if err != nil {
221 | 		panic(err)
222 | 	}
223 | 	defer terminator()
224 | 	defer db.Close()
225 | 
226 | 	type args struct {
227 | 		ctx context.Context
228 | 		db  wrapper.Querier
229 | 		idx Index
230 | 	}
231 | 	tests := []struct {
232 | 		name    string
233 | 		args    args
234 | 		wantErr bool
235 | 	}{
236 | 		{
237 | 			name: "",
238 | 			args: args{
239 | 				ctx: context.Background(),
240 | 				db:  db,
241 | 				idx: Index{
242 | 					Table:  "ddl_user",
243 | 					Unique: true,
244 | 					Name:   "school_idx",
245 | 					Items: []IndexItem{
246 | 						{
247 | 							Column: "school",
248 | 							Order:  1,
249 | 							Sort:   sortenum.Asc,
250 | 						},
251 | 					},
252 | 				},
253 | 			},
254 | 			wantErr: false,
255 | 		},
256 | 	}
257 | 	for _, tt := range tests {
258 | 		t.Run(tt.name, func(t *testing.T) {
259 | 			if err := addIndex(tt.args.ctx, tt.args.db, tt.args.idx); (err != nil) != tt.wantErr {
260 | 				t.Errorf("addIndex() error = %v, wantErr %v", err, tt.wantErr)
261 | 			}
262 | 		})
263 | 	}
264 | }
265 | 
266 | func TestDropAddIndex(t *testing.T) {
267 | 	terminator, db, err := Setup()
268 | 	if err != nil {
269 | 		panic(err)
270 | 	}
271 | 	defer terminator()
272 | 	defer db.Close()
273 | 
274 | 	type args struct {
275 | 		ctx context.Context
276 | 		db  wrapper.Querier
277 | 		idx Index
278 | 	}
279 | 	tests := []struct {
280 | 		name    string
281 | 		args    args
282 | 		wantErr bool
283 | 	}{
284 | 		{
285 | 			name: "",
286 | 			args: args{
287 | 				ctx: context.Background(),
288 | 				db:  db,
289 | 				idx: Index{
290 | 					Table:  "ddl_user",
291 | 					Unique: true,
292 | 					Name:   "age_idx",
293 | 					Items: []IndexItem{
294 | 						{
295 | 							Column: "age",
296 | 							Order:  1,
297 | 							Sort:   sortenum.Asc,
298 | 						},
299 | 						{
300 | 							Column: "school",
301 | 							Order:  2,
302 | 							Sort:   sortenum.Asc,
303 | 						},
304 | 					},
305 | 				},
306 | 			},
307 | 			wantErr: false,
308 | 		},
309 | 	}
310 | 	for _, tt := range tests {
311 | 		t.Run(tt.name, func(t *testing.T) {
312 | 			if err := dropAddIndex(tt.args.ctx, tt.args.db, tt.args.idx); (err != nil) != tt.wantErr {
313 | 				t.Errorf("dropAddIndex() error = %v, wantErr %v", err, tt.wantErr)
314 | 			}
315 | 		})
316 | 	}
317 | }
318 | 
319 | func Test_foreignKeys(t *testing.T) {
320 | 	terminator, db, err := Setup()
321 | 	if err != nil {
322 | 		panic(err)
323 | 	}
324 | 	defer terminator()
325 | 	defer db.Close()
326 | 
327 | 	type args struct {
328 | 		ctx    context.Context
329 | 		db     *sqlx.DB
330 | 		schema string
331 | 		t      string
332 | 	}
333 | 	tests := []struct {
334 | 		name    string
335 | 		args    args
336 | 		wantFks []ForeignKey
337 | 	}{
338 | 		{
339 | 			name: "",
340 | 			args: args{
341 | 				ctx:    context.Background(),
342 | 				db:     db,
343 | 				schema: "test",
344 | 				t:      "ddl_book",
345 | 			},
346 | 			wantFks: []ForeignKey{
347 | 				{
348 | 					Table:           "ddl_book",
349 | 					Constraint:      "fk_user",
350 | 					Fk:              "user_id",
351 | 					ReferencedTable: "ddl_user",
352 | 					ReferencedCol:   "id",
353 | 					UpdateRule:      "NO ACTION",
354 | 					DeleteRule:      "CASCADE",
355 | 					FullRule:        "ON DELETE CASCADE ON UPDATE NO ACTION",
356 | 				},
357 | 			},
358 | 		},
359 | 	}
360 | 	for _, tt := range tests {
361 | 		t.Run(tt.name, func(t *testing.T) {
362 | 			if gotFks := foreignKeys(tt.args.ctx, tt.args.db, tt.args.schema, tt.args.t); !reflect.DeepEqual(gotFks, tt.wantFks) {
363 | 				t.Errorf("foreignKeys() = %v, want %v", gotFks, tt.wantFks)
364 | 			}
365 | 		})
366 | 	}
367 | }
368 | 
369 | func TestTable2struct(t *testing.T) {
370 | 	terminator, db, err := Setup()
371 | 	if err != nil {
372 | 		panic(err)
373 | 	}
374 | 	defer terminator()
375 | 	defer db.Close()
376 | 
377 | 	type args struct {
378 | 		ctx         context.Context
379 | 		dir         string
380 | 		pre         string
381 | 		schema      string
382 | 		existTables []string
383 | 		db          *sqlx.DB
384 | 	}
385 | 	tests := []struct {
386 | 		name       string
387 | 		args       args
388 | 		wantTables []Table
389 | 	}{
390 | 		{
391 | 			name: "",
392 | 			args: args{
393 | 				ctx:         context.Background(),
394 | 				pre:         "ddl_",
395 | 				schema:      "test",
396 | 				existTables: []string{"ddl_book", "ddl_user"},
397 | 				db:          db,
398 | 			},
399 | 		},
400 | 	}
401 | 	for _, tt := range tests {
402 | 		assert.NotPanics(t, func() {
403 | 			Table2struct(tt.args.ctx, tt.args.pre, tt.args.schema, tt.args.existTables, tt.args.db)
404 | 		})
405 | 	}
406 | }
407 | 
408 | func ExampleStruct2Table() {
409 | 	terminator, db, err := Setup()
410 | 	if err != nil {
411 | 		panic(err)
412 | 	}
413 | 	defer terminator()
414 | 	defer db.Close()
415 | 
416 | 	_ = Struct2Table(context.Background(), "../testdata/entity", "ddl_", []string{"ddl_user", "ddl_book"}, db, "test")
417 | 	// Output:
418 | 	//CREATE TABLE `ddl_order` (
419 | 	//`id` INT NOT NULL AUTO_INCREMENT,
420 | 	//`amount` BIGINT NOT NULL,
421 | 	//`user_id` int NOT NULL,
422 | 	//`create_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
423 | 	//`delete_at` DATETIME NULL,
424 | 	//`update_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
425 | 	//PRIMARY KEY (`id`),
426 | 	//CONSTRAINT `fk_ddl_user` FOREIGN KEY (`user_id`)
427 | 	//REFERENCES `ddl_user`(`id`)
428 | 	//ON DELETE CASCADE ON UPDATE NO ACTION)
429 | 	//ALTER TABLE `ddl_user`
430 | 	//CHANGE COLUMN `id` `id` INT NOT NULL AUTO_INCREMENT;
431 | 	//ALTER TABLE `ddl_user`
432 | 	//CHANGE COLUMN `name` `name` VARCHAR(255) NOT NULL DEFAULT 'jack';
433 | 	//ALTER TABLE `ddl_user`
434 | 	//CHANGE COLUMN `phone` `phone` VARCHAR(255) NOT NULL DEFAULT '13552053960' comment '手机号';
435 | 	//ALTER TABLE `ddl_user`
436 | 	//CHANGE COLUMN `age` `age` INT NOT NULL;
437 | 	//ALTER TABLE `ddl_user`
438 | 	//CHANGE COLUMN `no` `no` int NOT NULL;
439 | 	//ALTER TABLE `ddl_user`
440 | 	//ADD COLUMN `unique_col` int NOT NULL;
441 | 	//ALTER TABLE `ddl_user`
442 | 	//ADD COLUMN `unique_col_2` int NOT NULL;
443 | 	//ALTER TABLE `ddl_user`
444 | 	//CHANGE COLUMN `school` `school` VARCHAR(255) NULL DEFAULT 'harvard' comment '学校';
445 | 	//ALTER TABLE `ddl_user`
446 | 	//CHANGE COLUMN `is_student` `is_student` TINYINT NOT NULL;
447 | 	//ALTER TABLE `ddl_user`
448 | 	//ADD COLUMN `rule` varchar(255) NOT NULL comment '链接匹配规则，匹配的链接采用该css规则来爬';
449 | 	//ALTER TABLE `ddl_user`
450 | 	//ADD COLUMN `rule_type` varchar(45) NOT NULL comment '链接匹配规则类型，支持prefix前缀匹配和regex正则匹配';
451 | 	//ALTER TABLE `ddl_user`
452 | 	//ADD COLUMN `arrive_at` datetime NULL comment '到货时间';
453 | 	//ALTER TABLE `ddl_user`
454 | 	//ADD COLUMN `status` tinyint(4) NOT NULL comment '0进行中
455 | 	//1完结
456 | 	//2取消';
457 | 	//ALTER TABLE `ddl_user`
458 | 	//CHANGE COLUMN `create_at` `create_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP;
459 | 	//ALTER TABLE `ddl_user`
460 | 	//CHANGE COLUMN `delete_at` `delete_at` DATETIME NULL;
461 | 	//ALTER TABLE `ddl_user`
462 | 	//CHANGE COLUMN `update_at` `update_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;
463 | 	//ALTER TABLE `ddl_user` ADD UNIQUE INDEX `rule_idx` (`rule` asc);
[TRUNCATED]
```

cmd/internal/ddl/table/table.go
```
1 | package table
2 | 
3 | import (
4 | 	"fmt"
5 | 	"regexp"
6 | 	"sort"
7 | 	"strconv"
8 | 	"strings"
9 | 
10 | 	"github.com/iancoleman/strcase"
11 | 	"github.com/pkg/errors"
12 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/columnenum"
13 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/extraenum"
14 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/keyenum"
15 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/nullenum"
16 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/sortenum"
17 | 	"github.com/unionj-cloud/toolkit/astutils"
18 | 	"github.com/unionj-cloud/toolkit/stringutils"
19 | 	"github.com/unionj-cloud/toolkit/templateutils"
20 | )
21 | 
22 | const (
23 | 	now = "CURRENT_TIMESTAMP"
24 | )
25 | 
26 | // IndexItems slice type alias for IndexItem
27 | type IndexItems []IndexItem
28 | 
29 | // IndexItem define an index item
30 | type IndexItem struct {
31 | 	Unique bool
32 | 	Name   string
33 | 	Column string
34 | 	Order  int
35 | 	Sort   sortenum.Sort
36 | }
37 | 
38 | // Len return length of IndexItems
39 | func (it IndexItems) Len() int {
40 | 	return len(it)
41 | }
42 | 
43 | // Less define asc or desc order
44 | func (it IndexItems) Less(i, j int) bool {
45 | 	return it[i].Order < it[j].Order
46 | }
47 | 
48 | // Swap change position of elements at i and j
49 | func (it IndexItems) Swap(i, j int) {
50 | 	it[i], it[j] = it[j], it[i]
51 | }
52 | 
53 | // Index define an index
54 | type Index struct {
55 | 	Table  string
56 | 	Unique bool
57 | 	Name   string
58 | 	Items  []IndexItem
59 | }
60 | 
61 | const indexsqltmpl = `{{define "drop"}}
62 | ALTER TABLE ` + "`" + `{{.Table}}` + "`" + ` DROP INDEX ` + "`" + `{{.Name}}` + "`" + `;
63 | {{end}}
64 | 
65 | {{define "add"}}
66 | ALTER TABLE ` + "`" + `{{.Table}}` + "`" + ` ADD {{if .Unique}}UNIQUE{{end}} INDEX ` + "`" + `{{.Name}}` + "`" + ` ({{range $j, $it := .Items}}{{if $j}},{{end}}` + "`" + `{{$it.Column}}` + "`" + ` {{$it.Sort}}{{end}});
67 | {{end}}`
68 | 
69 | func (idx *Index) DropIndexSql() (string, error) {
70 | 	return templateutils.StringBlock("index.tmpl", indexsqltmpl, "drop", idx)
71 | }
72 | 
73 | func (idx *Index) AddIndexSql() (string, error) {
74 | 	return templateutils.StringBlock("index.tmpl", indexsqltmpl, "add", idx)
75 | }
76 | 
77 | func NewIndexFromDbIndexes(dbIndexes []DbIndex) Index {
78 | 	unique := !dbIndexes[0].NonUnique
79 | 	idxName := dbIndexes[0].KeyName
80 | 	items := make([]IndexItem, len(dbIndexes))
81 | 	for i, idx := range dbIndexes {
82 | 		var sor sortenum.Sort
83 | 		if idx.Collation == "B" {
84 | 			sor = sortenum.Desc
85 | 		} else {
86 | 			sor = sortenum.Asc
87 | 		}
88 | 		items[i] = IndexItem{
89 | 			Column: idx.ColumnName,
90 | 			Order:  idx.SeqInIndex,
91 | 			Sort:   sor,
92 | 		}
93 | 	}
94 | 	it := IndexItems(items)
95 | 	sort.Stable(it)
96 | 	return Index{
97 | 		Unique: unique,
98 | 		Name:   idxName,
99 | 		Items:  it,
100 | 	}
101 | }
102 | 
103 | func toColumnType(goType string) columnenum.ColumnType {
104 | 	switch goType {
105 | 	case "int", "int16", "int32":
106 | 		return columnenum.IntType
107 | 	case "int64":
108 | 		return columnenum.BigintType
109 | 	case "float32":
110 | 		return columnenum.FloatType
111 | 	case "float64":
112 | 		return columnenum.DoubleType
113 | 	case "string":
114 | 		return columnenum.VarcharType
115 | 	case "bool", "int8":
116 | 		return columnenum.TinyintType
117 | 	case "time.Time":
118 | 		return columnenum.DatetimeType
119 | 	case "decimal.Decimal":
120 | 		return "decimal(6,2)"
121 | 	case "types.JSONText":
122 | 		return columnenum.JSONType
123 | 	}
124 | 	panic(fmt.Sprintf("no available type %s", goType))
125 | }
126 | 
127 | func toGoType(colType columnenum.ColumnType, nullable bool) string {
128 | 	var goType string
129 | 	if nullable {
130 | 		goType += "*"
131 | 	}
132 | 	if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.IntType))) {
133 | 		goType += "int"
134 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.BigintType))) {
135 | 		goType += "int64"
136 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.FloatType))) {
137 | 		goType += "float32"
138 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.DoubleType))) {
139 | 		goType += "float64"
140 | 	} else if stringutils.HasPrefixI(string(colType), "varchar") {
141 | 		goType += "string"
142 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.TextType))) {
143 | 		goType += "string"
144 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.TinyintType))) {
145 | 		goType += "int8"
146 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.DatetimeType))) {
147 | 		goType += "time.Time"
148 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.MediumtextType))) {
149 | 		goType += "string"
150 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.DecimalType))) {
151 | 		goType += "decimal.Decimal"
152 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.LongtextType))) {
153 | 		goType += "string"
154 | 	} else if stringutils.HasPrefixI(string(colType), strings.ToLower(string(columnenum.JSONType))) {
155 | 		goType += "types.JSONText"
156 | 	} else {
157 | 		panic(fmt.Sprintf("no available type %s", colType))
158 | 	}
159 | 	return goType
160 | }
161 | 
162 | // CheckPk check key is primary key or not
163 | func CheckPk(key keyenum.Key) bool {
164 | 	return key == keyenum.Pri
165 | }
166 | 
167 | // CheckNull check a column is nullable or not
168 | func CheckNull(null nullenum.Null) bool {
169 | 	return null == nullenum.Yes
170 | }
171 | 
172 | // CheckUnsigned check a column is unsigned or not
173 | func CheckUnsigned(dbColType string) bool {
174 | 	splits := strings.Split(dbColType, " ")
175 | 	if len(splits) == 1 {
176 | 		return false
177 | 	}
178 | 	return splits[1] == "unsigned"
179 | }
180 | 
181 | // CheckAutoincrement check a column is auto increment or not
182 | func CheckAutoincrement(extra string) bool {
183 | 	return strings.Contains(extra, "auto_increment")
184 | }
185 | 
186 | // CheckAutoSet check a column is auto generated by database or not
187 | func CheckAutoSet(defaultVal string) bool {
188 | 	return strings.ToLower(defaultVal) == strings.ToLower(now)
189 | }
190 | 
191 | // Column define a column
192 | type Column struct {
193 | 	Table         string
194 | 	Name          string
195 | 	Type          columnenum.ColumnType
196 | 	Default       string
197 | 	Pk            bool
198 | 	Nullable      bool
199 | 	Unsigned      bool
200 | 	Autoincrement bool
201 | 	Extra         extraenum.Extra
202 | 	Meta          astutils.FieldMeta
203 | 	AutoSet       bool
204 | 	Indexes       []IndexItem
205 | 	Fk            ForeignKey
206 | }
207 | 
208 | var altersqltmpl = `{{define "change"}}
209 | ALTER TABLE ` + "`" + `{{.Table}}` + "`" + `
210 | CHANGE COLUMN ` + "`" + `{{.Name}}` + "`" + ` ` + "`" + `{{.Name}}` + "`" + ` {{.Type}} {{if .Nullable}}NULL{{else}}NOT NULL{{end}}{{if .Autoincrement}} AUTO_INCREMENT{{end}}{{if .Default}} DEFAULT {{.Default}}{{end}}{{if .Extra}} {{.Extra}}{{end}};
211 | {{end}}
212 | 
213 | {{define "add"}}
214 | ALTER TABLE ` + "`" + `{{.Table}}` + "`" + `
215 | ADD COLUMN ` + "`" + `{{.Name}}` + "`" + ` {{.Type}} {{if .Nullable}}NULL{{else}}NOT NULL{{end}}{{if .Autoincrement}} AUTO_INCREMENT{{end}}{{if .Default}} DEFAULT {{.Default}}{{end}}{{if .Extra}} {{.Extra}}{{end}};
216 | {{end}}
217 | `
218 | 
219 | // ChangeColumnSql return change column sql
220 | func (c *Column) ChangeColumnSql() (string, error) {
221 | 	return templateutils.StringBlock("alter.tmpl", altersqltmpl, "change", c)
222 | }
223 | 
224 | // AddColumnSql return add column sql
225 | func (c *Column) AddColumnSql() (string, error) {
226 | 	return templateutils.StringBlock("alter.tmpl", altersqltmpl, "add", c)
227 | }
228 | 
229 | // DbColumn defines a column
230 | type DbColumn struct {
231 | 	Field   string        `db:"Field"`
232 | 	Type    string        `db:"Type"`
233 | 	Null    nullenum.Null `db:"Null"`
234 | 	Key     keyenum.Key   `db:"Key"`
235 | 	Default *string       `db:"Default"`
236 | 	Extra   string        `db:"Extra"`
237 | 	Comment string        `db:"Comment"`
238 | }
239 | 
240 | // DbIndex defines an index refer to https://www.mysqltutorial.org/mysql-index/mysql-show-indexes/
241 | type DbIndex struct {
242 | 	Table      string `db:"Table"`        // The name of the table
243 | 	NonUnique  bool   `db:"Non_unique"`   // 1 if the index can contain duplicates, 0 if it cannot.
244 | 	KeyName    string `db:"Key_name"`     // The name of the index. The primary key index always has the name of PRIMARY.
245 | 	SeqInIndex int    `db:"Seq_in_index"` // The column sequence number in the index. The first column sequence number starts from 1.
246 | 	ColumnName string `db:"Column_name"`  // The column name
247 | 	Collation  string `db:"Collation"`    // Collation represents how the column is sorted in the index. A means ascending, B means descending, or NULL means not sorted.
248 | }
249 | 
250 | // DbForeignKey from INFORMATION_SCHEMA.KEY_COLUMN_USAGE
251 | type DbForeignKey struct {
252 | 	TableName            string `db:"TABLE_NAME"`
253 | 	ColumnName           string `db:"COLUMN_NAME"`
254 | 	ConstraintName       string `db:"CONSTRAINT_NAME"`
255 | 	ReferencedTableName  string `db:"REFERENCED_TABLE_NAME"`
256 | 	ReferencedColumnName string `db:"REFERENCED_COLUMN_NAME"`
257 | }
258 | 
259 | // DbAction from information_schema.REFERENTIAL_CONSTRAINTS
260 | type DbAction struct {
261 | 	TableName           string `db:"TABLE_NAME"`
262 | 	ConstraintName      string `db:"CONSTRAINT_NAME"`
263 | 	ReferencedTableName string `db:"REFERENCED_TABLE_NAME"`
264 | 	UpdateRule          string `db:"UPDATE_RULE"`
265 | 	DeleteRule          string `db:"DELETE_RULE"`
266 | }
267 | 
268 | type ForeignKey struct {
269 | 	// Table the child table
270 | 	Table string
271 | 	// Constraint name of foreign key constraint
272 | 	Constraint string
273 | 	// Fk foreign key
274 | 	Fk string
275 | 	// ReferencedTable the referenced table
276 | 	ReferencedTable string
277 | 	// ReferencedCol the referenced column of ReferencedTable
278 | 	ReferencedCol string
279 | 	UpdateRule    string
280 | 	DeleteRule    string
281 | 	FullRule      string
282 | }
283 | 
284 | const fksqltmpl = `{{define "drop"}}
285 | ALTER TABLE ` + "`" + `{{.Table}}` + "`" + ` DROP FOREIGN KEY {{.Constraint}};
286 | {{end}}
287 | 
288 | {{define "add"}}
289 | ALTER TABLE ` + "`" + `{{.Table}}` + "`" + ` ADD CONSTRAINT {{.Constraint}} FOREIGN KEY ({{.Fk}}) REFERENCES {{.ReferencedTable}}({{.ReferencedCol}}) {{.FullRule}};
290 | {{end}}`
291 | 
292 | func (fk *ForeignKey) DropFkSql() (string, error) {
293 | 	return templateutils.StringBlock("fk.tmpl", fksqltmpl, "drop", fk)
294 | }
295 | 
296 | func (fk *ForeignKey) AddFkSql() (string, error) {
297 | 	return templateutils.StringBlock("fk.tmpl", fksqltmpl, "add", fk)
298 | }
299 | 
300 | // Table defines a table
301 | type Table struct {
302 | 	Name    string
303 | 	Columns []Column
304 | 	Pk      string
305 | 	Indexes []Index
306 | 	Meta    astutils.StructMeta
307 | 	Fks     []ForeignKey
308 | }
309 | 
310 | // NewTableFromStruct creates a Table instance from structMeta
311 | func NewTableFromStruct(structMeta astutils.StructMeta, prefix ...string) Table {
312 | 	var (
313 | 		columns       []Column
314 | 		uniqueindexes []Index
315 | 		indexes       []Index
316 | 		fks           []ForeignKey
317 | 		pkColumn      Column
318 | 		table         string
319 | 	)
320 | 	table = strcase.ToSnake(structMeta.Name)
321 | 	if len(prefix) > 0 {
322 | 		table = prefix[0] + table
323 | 	}
324 | 	for _, field := range structMeta.Fields {
325 | 		var (
326 | 			columnName     string
327 | 			_uniqueindexes []Index
328 | 			_indexes       []Index
329 | 			_fks           []ForeignKey
330 | 			column         Column
331 | 		)
332 | 		column.Table = table
333 | 		column.Meta = field
334 | 		columnName = strcase.ToSnake(field.Name)
335 | 		column.Name = columnName
336 | 		if stringutils.IsNotEmpty(field.Tag) {
337 | 			tags := strings.Split(field.Tag, `" `)
338 | 			var ddTag string
339 | 			for _, tag := range tags {
340 | 				if strings.HasPrefix(tag, "dd:") {
341 | 					ddTag = strings.Trim(strings.TrimPrefix(tag, "dd:"), `"`)
342 | 					break
343 | 				}
344 | 			}
345 | 			if stringutils.IsNotEmpty(ddTag) {
346 | 				_indexes, _uniqueindexes, _fks = parseDdTag(ddTag, field, &column)
347 | 			}
348 | 		}
349 | 
350 | 		if strings.HasPrefix(field.Type, "*") {
351 | 			column.Nullable = true
352 | 		}
353 | 
354 | 		if stringutils.IsEmpty(string(column.Type)) {
355 | 			column.Type = toColumnType(strings.TrimPrefix(field.Type, "*"))
356 | 		}
357 | 
358 | 		for _, idx := range _indexes {
359 | 			if stringutils.IsNotEmpty(idx.Name) {
360 | 				idx.Items[0].Column = columnName
361 | 				indexes = append(indexes, idx)
362 | 			}
363 | 		}
364 | 
365 | 		for _, uidx := range _uniqueindexes {
366 | 			if stringutils.IsNotEmpty(uidx.Name) {
367 | 				uidx.Items[0].Column = columnName
368 | 				uniqueindexes = append(uniqueindexes, uidx)
369 | 			}
370 | 		}
371 | 
372 | 		for _, fk := range _fks {
373 | 			if stringutils.IsNotEmpty(fk.Fk) {
374 | 				fks = append(fks, fk)
375 | 			}
376 | 		}
377 | 
378 | 		columns = append(columns, column)
379 | 	}
380 | 
381 | 	for _, column := range columns {
382 | 		if column.Pk {
383 | 			pkColumn = column
384 | 			break
385 | 		}
386 | 	}
387 | 
388 | 	indexesResult := mergeIndexes(indexes, uniqueindexes)
389 | 
390 | 	return Table{
391 | 		Name:    table,
392 | 		Columns: columns,
393 | 		Pk:      pkColumn.Name,
394 | 		Indexes: indexesResult,
395 | 		Meta:    structMeta,
396 | 		Fks:     fks,
397 | 	}
398 | }
399 | 
400 | type sortableIndexes []Index
401 | 
402 | // Len return length of sortableIndexes
403 | func (it sortableIndexes) Len() int {
404 | 	return len(it)
405 | }
406 | 
407 | // Less define asc or desc order
408 | func (it sortableIndexes) Less(i, j int) bool {
409 | 	return it[i].Name < it[j].Name
410 | }
411 | 
412 | // Swap change position of elements at i and j
413 | func (it sortableIndexes) Swap(i, j int) {
414 | 	it[i], it[j] = it[j], it[i]
415 | }
416 | 
417 | func mergeIndexes(indexes, uniqueindexes []Index) []Index {
418 | 	uniqueMap := make(map[string][]IndexItem)
419 | 	indexMap := make(map[string][]IndexItem)
420 | 
421 | 	for _, unique := range uniqueindexes {
422 | 		if items, exists := uniqueMap[unique.Name]; exists {
423 | 			items = append(items, unique.Items...)
424 | 			uniqueMap[unique.Name] = items
425 | 		} else {
426 | 			uniqueMap[unique.Name] = unique.Items
427 | 		}
428 | 	}
429 | 
430 | 	for _, index := range indexes {
431 | 		if items, exists := indexMap[index.Name]; exists {
432 | 			items = append(items, index.Items...)
433 | 			indexMap[index.Name] = items
434 | 		} else {
435 | 			indexMap[index.Name] = index.Items
436 | 		}
437 | 	}
438 | 
439 | 	var uniquesResult, indexesResult []Index
440 | 
441 | 	for k, v := range uniqueMap {
442 | 		it := IndexItems(v)
443 | 		sort.Stable(it)
444 | 		uniquesResult = append(uniquesResult, Index{
445 | 			Unique: true,
446 | 			Name:   k,
447 | 			Items:  it,
448 | 		})
449 | 	}
450 | 
451 | 	for k, v := range indexMap {
452 | 		it := IndexItems(v)
453 | 		sort.Stable(it)
454 | 		indexesResult = append(indexesResult, Index{
455 | 			Name:  k,
456 | 			Items: it,
457 | 		})
458 | 	}
459 | 
460 | 	sort.Stable(sortableIndexes(indexesResult))
461 | 	sort.Stable(sortableIndexes(uniquesResult))
462 | 
463 | 	indexesResult = append(indexesResult, uniquesResult...)
464 | 	return indexesResult
465 | }
466 | 
467 | func parseDdTag(ddTag string, field astutils.FieldMeta, column *Column) (indexes []Index, uniqueIndexes []Index, fks []ForeignKey) {
468 | 	kvs := strings.Split(ddTag, ";")
469 | 	for _, kv := range kvs {
470 | 		pair := strings.Split(kv, ":")
471 | 		if len(pair) > 1 {
472 | 			parsePair(pair, column, &indexes, &uniqueIndexes, &fks)
473 | 		} else {
474 | 			parseSingle(pair, column, field, &indexes, &uniqueIndexes)
475 | 		}
476 | 	}
477 | 	return
478 | }
479 | 
480 | func parseSingle(pair []string, column *Column, field astutils.FieldMeta, indexes *[]Index, uniqueIndexes *[]Index) {
481 | 	key := pair[0]
482 | 	switch key {
483 | 	case "pk":
484 | 		column.Pk = true
485 | 		break
486 | 	case "null":
487 | 		column.Nullable = true
488 | 		break
489 | 	case "unsigned":
490 | 		column.Unsigned = true
491 | 		break
492 | 	case "auto":
493 | 		column.Autoincrement = true
494 | 		break
495 | 	case "index":
496 | 		*indexes = append(*indexes, Index{
497 | 			Name: strcase.ToSnake(field.Name) + "_idx",
498 | 			Items: []IndexItem{
499 | 				{
500 | 					Order: 1,
[TRUNCATED]
```

cmd/internal/ddl/table/table_test.go
```
1 | package table
2 | 
3 | import (
4 | 	"fmt"
5 | 	"go/ast"
6 | 	"go/parser"
7 | 	"go/token"
8 | 	"path/filepath"
9 | 	"reflect"
10 | 	"testing"
11 | 
12 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/columnenum"
13 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/ddlast"
14 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/extraenum"
15 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/keyenum"
16 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/nullenum"
17 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/ddl/sortenum"
18 | 	"github.com/unionj-cloud/toolkit/astutils"
19 | 	"github.com/unionj-cloud/toolkit/pathutils"
20 | )
21 | 
22 | func ExampleNewTableFromStruct() {
23 | 	testDir := pathutils.Abs("../testdata/entity")
24 | 	var files []string
25 | 	var err error
26 | 	err = filepath.Walk(testDir, astutils.Visit(&files))
27 | 	if err != nil {
28 | 		panic(err)
29 | 	}
30 | 	sc := astutils.NewStructCollector(astutils.ExprString)
31 | 	for _, file := range files {
32 | 		fset := token.NewFileSet()
33 | 		root, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
34 | 		if err != nil {
35 | 			panic(err)
36 | 		}
37 | 		ast.Walk(sc, root)
38 | 	}
39 | 	flattened := ddlast.FlatEmbed(sc.Structs)
40 | 
41 | 	for _, sm := range flattened {
42 | 		tab := NewTableFromStruct(sm)
43 | 		fmt.Println(len(tab.Indexes))
44 | 		var statement string
45 | 		if statement, err = tab.CreateSql(); err != nil {
46 | 			panic(err)
47 | 		}
48 | 		fmt.Println(statement)
49 | 	}
50 | 
51 | 	// Output:
52 | 	//0
53 | 	//CREATE TABLE `order` (
54 | 	//`id` INT NOT NULL AUTO_INCREMENT,
55 | 	//`amount` BIGINT NOT NULL,
56 | 	//`user_id` int NOT NULL,
57 | 	//`create_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
58 | 	//`delete_at` DATETIME NULL,
59 | 	//`update_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
60 | 	//PRIMARY KEY (`id`),
61 | 	//CONSTRAINT `fk_ddl_user` FOREIGN KEY (`user_id`)
62 | 	//REFERENCES `ddl_user`(`id`)
63 | 	//ON DELETE CASCADE ON UPDATE NO ACTION)
64 | 	//5
65 | 	//CREATE TABLE `user` (
66 | 	//`id` INT NOT NULL AUTO_INCREMENT,
67 | 	//`name` VARCHAR(255) NOT NULL DEFAULT 'jack',
68 | 	//`phone` VARCHAR(255) NOT NULL DEFAULT '13552053960' comment '手机号',
69 | 	//`age` INT NOT NULL,
70 | 	//`no` int NOT NULL,
71 | 	//`unique_col` int NOT NULL,
72 | 	//`unique_col_2` int NOT NULL,
73 | 	//`school` VARCHAR(255) NULL DEFAULT 'harvard' comment '学校',
74 | 	//`is_student` TINYINT NOT NULL,
75 | 	//`rule` varchar(255) NOT NULL comment '链接匹配规则，匹配的链接采用该css规则来爬',
76 | 	//`rule_type` varchar(45) NOT NULL comment '链接匹配规则类型，支持prefix前缀匹配和regex正则匹配',
77 | 	//`arrive_at` datetime NULL comment '到货时间',
78 | 	//`status` tinyint(4) NOT NULL comment '0进行中
79 | 	//1完结
80 | 	//2取消',
81 | 	//`create_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
82 | 	//`delete_at` DATETIME NULL,
83 | 	//`update_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
84 | 	//PRIMARY KEY (`id`),
85 | 	//INDEX `age_idx` (`age` asc),
86 | 	//INDEX `name_phone_idx` (`phone` asc,`name` asc),
87 | 	//UNIQUE INDEX `no_idx` (`no` asc),
88 | 	//UNIQUE INDEX `rule_idx` (`rule` asc),
89 | 	//UNIQUE INDEX `unique_col_idx` (`unique_col` asc,`unique_col_2` asc))
90 | }
91 | 
92 | func TestTable_CreateSql(t1 *testing.T) {
93 | 	type fields struct {
94 | 		Name          string
95 | 		Columns       []Column
96 | 		Pk            string
97 | 		UniqueIndexes []Index
98 | 		Indexes       []Index
99 | 	}
100 | 	tests := []struct {
101 | 		name    string
102 | 		fields  fields
103 | 		want    string
104 | 		wantErr bool
105 | 	}{
106 | 		{
107 | 			name: "users",
108 | 			fields: fields{
109 | 				Name: "users",
110 | 				Columns: []Column{
111 | 					{
112 | 						Name:          "id",
113 | 						Type:          columnenum.IntType,
114 | 						Default:       "",
115 | 						Pk:            true,
116 | 						Nullable:      false,
117 | 						Unsigned:      false,
118 | 						Autoincrement: true,
119 | 						Extra:         "",
120 | 					},
121 | 					{
122 | 						Name:          "name",
123 | 						Type:          columnenum.VarcharType,
124 | 						Default:       "'wubin'",
125 | 						Pk:            false,
126 | 						Nullable:      true,
127 | 						Unsigned:      false,
128 | 						Autoincrement: false,
129 | 						Extra:         "",
130 | 					},
131 | 					{
132 | 						Name:          "phone",
133 | 						Type:          columnenum.VarcharType,
134 | 						Default:       "'13552053960'",
135 | 						Pk:            false,
136 | 						Nullable:      true,
137 | 						Unsigned:      false,
138 | 						Autoincrement: false,
139 | 						Extra:         "comment '手机号'",
140 | 					},
141 | 					{
142 | 						Name:          "age",
143 | 						Type:          columnenum.IntType,
144 | 						Default:       "",
145 | 						Pk:            false,
146 | 						Nullable:      true,
147 | 						Unsigned:      false,
148 | 						Autoincrement: false,
149 | 						Extra:         "",
150 | 					},
151 | 					{
152 | 						Name:          "no",
153 | 						Type:          columnenum.IntType,
154 | 						Default:       "",
155 | 						Pk:            false,
156 | 						Nullable:      false,
157 | 						Unsigned:      false,
158 | 						Autoincrement: false,
159 | 						Extra:         "",
160 | 					},
161 | 				},
162 | 				Pk: "id",
163 | 				Indexes: []Index{
164 | 					{
165 | 						Name: "name_phone_idx",
166 | 						Items: []IndexItem{
167 | 							{
168 | 								Column: "name",
169 | 								Order:  2,
170 | 								Sort:   "asc",
171 | 							},
172 | 							{
173 | 								Column: "phone",
174 | 								Order:  1,
175 | 								Sort:   "desc",
176 | 							},
177 | 						},
178 | 					},
179 | 					{
180 | 						Unique: true,
181 | 						Name:   "uni_no",
182 | 						Items: []IndexItem{
183 | 							{
184 | 								Column: "no",
185 | 								Order:  0,
186 | 								Sort:   "asc",
187 | 							},
188 | 						},
189 | 					},
190 | 				},
191 | 			},
192 | 			want:    "CREATE TABLE `users` (\n`id` INT NOT NULL AUTO_INCREMENT,\n`name` VARCHAR(255) NULL DEFAULT 'wubin',\n`phone` VARCHAR(255) NULL DEFAULT '13552053960' comment '手机号',\n`age` INT NULL,\n`no` INT NOT NULL,\nPRIMARY KEY (`id`),\nINDEX `name_phone_idx` (`name` asc,`phone` desc),\nUNIQUE INDEX `uni_no` (`no` asc))",
193 | 			wantErr: false,
194 | 		},
195 | 	}
196 | 	for _, tt := range tests {
197 | 		t1.Run(tt.name, func(t1 *testing.T) {
198 | 			t := &Table{
199 | 				Name:    tt.fields.Name,
200 | 				Columns: tt.fields.Columns,
201 | 				Pk:      tt.fields.Pk,
202 | 				Indexes: tt.fields.Indexes,
203 | 			}
204 | 			got, err := t.CreateSql()
205 | 			fmt.Println(got)
206 | 			if (err != nil) != tt.wantErr {
207 | 				t1.Errorf("CreateSql() error = %v, wantErr %v", err, tt.wantErr)
208 | 				return
209 | 			}
210 | 			if got != tt.want {
211 | 				t1.Errorf("CreateSql() got = %v, want %v", got, tt.want)
212 | 			}
213 | 		})
214 | 	}
215 | }
216 | 
217 | func TestColumn_AlterColumnSql(t *testing.T) {
218 | 	type fields struct {
219 | 		Table         string
220 | 		Name          string
221 | 		Type          columnenum.ColumnType
222 | 		Default       string
223 | 		Pk            bool
224 | 		Nullable      bool
225 | 		Unsigned      bool
226 | 		Autoincrement bool
227 | 		Extra         extraenum.Extra
228 | 	}
229 | 	tests := []struct {
230 | 		name    string
231 | 		fields  fields
232 | 		want    string
233 | 		wantErr bool
234 | 	}{
235 | 		{
236 | 			name: "column",
237 | 			fields: fields{
238 | 				Table:         "users",
239 | 				Name:          "phone",
240 | 				Type:          columnenum.VarcharType,
241 | 				Default:       "'13552053960'",
242 | 				Pk:            false,
243 | 				Nullable:      false,
244 | 				Unsigned:      false,
245 | 				Autoincrement: false,
246 | 				Extra:         "comment '手机号'",
247 | 			},
248 | 			want:    "ALTER TABLE `users`\nCHANGE COLUMN `phone` `phone` VARCHAR(255) NOT NULL DEFAULT '13552053960' comment '手机号';",
249 | 			wantErr: false,
250 | 		},
251 | 	}
252 | 	for _, tt := range tests {
253 | 		t.Run(tt.name, func(t *testing.T) {
254 | 			c := &Column{
255 | 				Table:         tt.fields.Table,
256 | 				Name:          tt.fields.Name,
257 | 				Type:          tt.fields.Type,
258 | 				Default:       tt.fields.Default,
259 | 				Pk:            tt.fields.Pk,
260 | 				Nullable:      tt.fields.Nullable,
261 | 				Unsigned:      tt.fields.Unsigned,
262 | 				Autoincrement: tt.fields.Autoincrement,
263 | 				Extra:         tt.fields.Extra,
264 | 			}
265 | 			got, err := c.ChangeColumnSql()
266 | 			fmt.Println(got)
267 | 			if (err != nil) != tt.wantErr {
268 | 				t.Errorf("ChangeColumnSql() error = %v, wantErr %v", err, tt.wantErr)
269 | 				return
270 | 			}
271 | 			if got != tt.want {
272 | 				t.Errorf("ChangeColumnSql() got = %v, want %v", got, tt.want)
273 | 			}
274 | 		})
275 | 	}
276 | }
277 | 
278 | func TestColumn_AddColumnSql(t *testing.T) {
279 | 	type fields struct {
280 | 		Table         string
281 | 		Name          string
282 | 		Type          columnenum.ColumnType
283 | 		Default       string
284 | 		Pk            bool
285 | 		Nullable      bool
286 | 		Unsigned      bool
287 | 		Autoincrement bool
288 | 		Extra         extraenum.Extra
289 | 	}
290 | 	tests := []struct {
291 | 		name    string
292 | 		fields  fields
293 | 		want    string
294 | 		wantErr bool
295 | 	}{
296 | 		{
297 | 			name: "column",
298 | 			fields: fields{
299 | 				Table:         "users",
300 | 				Name:          "school",
301 | 				Type:          columnenum.VarcharType,
302 | 				Default:       "'harvard'",
303 | 				Pk:            false,
304 | 				Nullable:      false,
305 | 				Unsigned:      false,
306 | 				Autoincrement: false,
307 | 				Extra:         "comment '学校'",
308 | 			},
309 | 			want:    "ALTER TABLE `users`\nADD COLUMN `school` VARCHAR(255) NOT NULL DEFAULT 'harvard' comment '学校';",
310 | 			wantErr: false,
311 | 		},
312 | 	}
313 | 	for _, tt := range tests {
314 | 		t.Run(tt.name, func(t *testing.T) {
315 | 			c := &Column{
316 | 				Table:         tt.fields.Table,
317 | 				Name:          tt.fields.Name,
318 | 				Type:          tt.fields.Type,
319 | 				Default:       tt.fields.Default,
320 | 				Pk:            tt.fields.Pk,
321 | 				Nullable:      tt.fields.Nullable,
322 | 				Unsigned:      tt.fields.Unsigned,
323 | 				Autoincrement: tt.fields.Autoincrement,
324 | 				Extra:         tt.fields.Extra,
325 | 			}
326 | 			got, err := c.AddColumnSql()
327 | 			fmt.Println(got)
328 | 			if (err != nil) != tt.wantErr {
329 | 				t.Errorf("AddColumnSql() error = %v, wantErr %v", err, tt.wantErr)
330 | 				return
331 | 			}
332 | 			if got != tt.want {
333 | 				t.Errorf("AddColumnSql() got = %v, want %v", got, tt.want)
334 | 			}
335 | 		})
336 | 	}
337 | }
338 | 
339 | func Test_toColumnType(t *testing.T) {
340 | 	type args struct {
341 | 		goType string
342 | 	}
343 | 	tests := []struct {
344 | 		name string
345 | 		args args
346 | 		want columnenum.ColumnType
347 | 	}{
348 | 		{
349 | 			name: "1",
350 | 			args: args{
351 | 				goType: "float32",
352 | 			},
353 | 			want: columnenum.FloatType,
354 | 		}, {
355 | 			name: "2",
356 | 			args: args{
357 | 				goType: "int",
358 | 			},
359 | 			want: columnenum.IntType,
360 | 		}, {
361 | 			name: "3",
362 | 			args: args{
363 | 				goType: "bool",
364 | 			},
365 | 			want: columnenum.TinyintType,
366 | 		}, {
367 | 			name: "4",
368 | 			args: args{
369 | 				goType: "time.Time",
370 | 			},
371 | 			want: columnenum.DatetimeType,
372 | 		}, {
373 | 			name: "5",
374 | 			args: args{
375 | 				goType: "int64",
376 | 			},
377 | 			want: columnenum.BigintType,
378 | 		}, {
379 | 			name: "6",
380 | 			args: args{
381 | 				goType: "float64",
382 | 			},
383 | 			want: columnenum.DoubleType,
384 | 		}, {
385 | 			name: "7",
386 | 			args: args{
387 | 				goType: "string",
388 | 			},
389 | 			want: columnenum.VarcharType,
390 | 		}, {
391 | 			name: "8",
392 | 			args: args{
393 | 				goType: "decimal.Decimal",
394 | 			},
395 | 			want: "decimal(6,2)",
396 | 		},
397 | 	}
398 | 	for _, tt := range tests {
399 | 		t.Run(tt.name, func(t *testing.T) {
400 | 			if got := toColumnType(tt.args.goType); got != tt.want {
401 | 				t.Errorf("toColumnType() = %v, want %v", got, tt.want)
402 | 			}
403 | 		})
404 | 	}
405 | }
406 | 
407 | func Test_toGoType(t *testing.T) {
408 | 	type args struct {
409 | 		colType  columnenum.ColumnType
410 | 		nullable bool
411 | 	}
412 | 	tests := []struct {
413 | 		name string
414 | 		args args
415 | 		want string
416 | 	}{
417 | 		{
418 | 			name: "1",
419 | 			args: args{
420 | 				colType:  "int",
421 | 				nullable: false,
422 | 			},
423 | 			want: "int",
424 | 		},
425 | 		{
426 | 			name: "2",
427 | 			args: args{
428 | 				colType:  "bigint",
429 | 				nullable: false,
430 | 			},
431 | 			want: "int64",
432 | 		},
433 | 		{
434 | 			name: "3",
435 | 			args: args{
436 | 				colType:  "float",
437 | 				nullable: false,
438 | 			},
439 | 			want: "float32",
440 | 		},
441 | 		{
442 | 			name: "4",
443 | 			args: args{
444 | 				colType:  "double",
445 | 				nullable: false,
446 | 			},
447 | 			want: "float64",
448 | 		},
449 | 		{
450 | 			name: "5",
451 | 			args: args{
452 | 				colType:  "varchar",
453 | 				nullable: false,
454 | 			},
455 | 			want: "string",
456 | 		},
457 | 		{
458 | 			name: "6",
459 | 			args: args{
460 | 				colType:  "tinyint",
461 | 				nullable: false,
462 | 			},
463 | 			want: "int8",
464 | 		},
465 | 		{
466 | 			name: "7",
467 | 			args: args{
468 | 				colType:  "text",
469 | 				nullable: false,
470 | 			},
471 | 			want: "string",
472 | 		},
473 | 		{
474 | 			name: "8",
475 | 			args: args{
476 | 				colType:  "datetime",
477 | 				nullable: false,
478 | 			},
479 | 			want: "time.Time",
480 | 		},
481 | 	}
482 | 	for _, tt := range tests {
483 | 		t.Run(tt.name, func(t *testing.T) {
484 | 			if got := toGoType(tt.args.colType, tt.args.nullable); got != tt.want {
485 | 				t.Errorf("toGoType() = %v, want %v", got, tt.want)
486 | 			}
487 | 		})
488 | 	}
489 | }
490 | 
491 | func TestNewFieldFromColumn(t *testing.T) {
492 | 	type args struct {
493 | 		col Column
494 | 	}
495 | 	tests := []struct {
496 | 		name string
497 | 		args args
498 | 		want astutils.FieldMeta
499 | 	}{
500 | 		{
501 | 			name: "1",
502 | 			args: args{
503 | 				col: Column{
504 | 					Table:         "users",
505 | 					Name:          "school",
506 | 					Type:          columnenum.VarcharType,
507 | 					Default:       "harvard",
508 | 					Pk:            false,
509 | 					Nullable:      false,
510 | 					Unsigned:      false,
511 | 					Autoincrement: false,
512 | 					Extra:         "comment '学校'",
513 | 				},
514 | 			},
515 | 			want: astutils.FieldMeta{
516 | 				Name:     "School",
517 | 				Type:     "string",
518 | 				Tag:      `dd:"type:VARCHAR(255);default:'harvard';extra:comment '学校'"`,
519 | 				Comments: nil,
520 | 			},
521 | 		}, {
522 | 			name: "2",
523 | 			args: args{
524 | 				col: Column{
525 | 					Table:         "users",
526 | 					Name:          "favourite",
527 | 					Type:          columnenum.VarcharType,
528 | 					Default:       "current_timestamp",
529 | 					Pk:            false,
530 | 					Nullable:      true,
531 | 					Unsigned:      false,
532 | 					Autoincrement: true,
533 | 					Extra:         "comment '学校'",
534 | 					Indexes: IndexItems{
535 | 						{
536 | 							Unique: false,
537 | 							Name:   "my_index",
538 | 							Column: "favourite",
539 | 							Order:  1,
540 | 							Sort:   sortenum.Asc,
541 | 						},
542 | 					},
543 | 				},
544 | 			},
545 | 			want: astutils.FieldMeta{
546 | 				Name:     "Favourite",
547 | 				Type:     "*string",
548 | 				Tag:      `dd:"auto;type:VARCHAR(255);default:current_timestamp;extra:comment '学校';index:my_index,1,asc"`,
549 | 				Comments: nil,
550 | 			},
551 | 		},
552 | 	}
553 | 	for _, tt := range tests {
554 | 		t.Run(tt.name, func(t *testing.T) {
555 | 			if got := NewFieldFromColumn(tt.args.col); !reflect.DeepEqual(got, tt.want) {
556 | 				t.Errorf("NewFieldFromColumn() = %v, want %v", got, tt.want)
557 | 			}
558 | 		})
559 | 	}
560 | }
561 | 
562 | func TestCheckPk(t *testing.T) {
563 | 	type args struct {
564 | 		key keyenum.Key
565 | 	}
566 | 	tests := []struct {
567 | 		name string
568 | 		args args
569 | 		want bool
570 | 	}{
571 | 		{
572 | 			name: "",
573 | 			args: args{
574 | 				key: keyenum.Pri,
575 | 			},
576 | 			want: true,
577 | 		},
578 | 	}
579 | 	for _, tt := range tests {
580 | 		t.Run(tt.name, func(t *testing.T) {
581 | 			if got := CheckPk(tt.args.key); got != tt.want {
582 | 				t.Errorf("CheckPk() = %v, want %v", got, tt.want)
583 | 			}
584 | 		})
585 | 	}
586 | }
587 | 
588 | func TestCheckNull(t *testing.T) {
589 | 	type args struct {
590 | 		null nullenum.Null
591 | 	}
592 | 	tests := []struct {
593 | 		name string
594 | 		args args
595 | 		want bool
596 | 	}{
597 | 		{
598 | 			name: "",
599 | 			args: args{
600 | 				null: nullenum.Yes,
601 | 			},
602 | 			want: true,
603 | 		},
604 | 	}
605 | 	for _, tt := range tests {
606 | 		t.Run(tt.name, func(t *testing.T) {
607 | 			if got := CheckNull(tt.args.null); got != tt.want {
608 | 				t.Errorf("CheckNull() = %v, want %v", got, tt.want)
609 | 			}
610 | 		})
611 | 	}
612 | }
613 | 
614 | func TestCheckUnsigned(t *testing.T) {
615 | 	type args struct {
616 | 		dbColType string
617 | 	}
618 | 	tests := []struct {
619 | 		name string
620 | 		args args
621 | 		want bool
622 | 	}{
623 | 		{
624 | 			name: "",
625 | 			args: args{
626 | 				dbColType: "int unsigned",
627 | 			},
628 | 			want: true,
629 | 		},
630 | 	}
631 | 	for _, tt := range tests {
632 | 		t.Run(tt.name, func(t *testing.T) {
[TRUNCATED]
```

cmd/internal/enum/testdata/dto.go
```
1 | package testdata
2 | 
3 | type KeyboardLayout int
4 | 
5 | const (
6 | 	UNKNOWN KeyboardLayout = iota
7 | 	QWERTZ
8 | 	AZERTY
9 | 	QWERTY
10 | )
```

cmd/internal/enum/testdata/enums_gen.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * Don't edit!
4 |  */
5 | package testdata
6 | 
7 | import "encoding/json"
8 | 
9 | func (k *KeyboardLayout) StringSetter(value string) {
10 | 	switch value {
11 | 	case "UNKNOWN":
12 | 		*k = UNKNOWN
13 | 	case "QWERTZ":
14 | 		*k = QWERTZ
15 | 	case "AZERTY":
16 | 		*k = AZERTY
17 | 	case "QWERTY":
18 | 		*k = QWERTY
19 | 	default:
20 | 		*k = UNKNOWN
21 | 	}
22 | }
23 | 
24 | func (k *KeyboardLayout) StringGetter() string {
25 | 	switch *k {
26 | 	case UNKNOWN:
27 | 		return "UNKNOWN"
28 | 	case QWERTZ:
29 | 		return "QWERTZ"
30 | 	case AZERTY:
31 | 		return "AZERTY"
32 | 	case QWERTY:
33 | 		return "QWERTY"
34 | 	default:
35 | 		return "UNKNOWN"
36 | 	}
37 | }
38 | 
39 | func (k *KeyboardLayout) UnmarshalJSON(bytes []byte) error {
40 | 	var _k string
41 | 	err := json.Unmarshal(bytes, &_k)
42 | 	if err != nil {
43 | 		return err
44 | 	}
45 | 	k.StringSetter(_k)
46 | 	return nil
47 | }
48 | 
49 | func (k KeyboardLayout) MarshalJSON() ([]byte, error) {
50 | 	return json.Marshal(k.StringGetter())
51 | }
```

cmd/internal/ddl/testdata/go.mod
```
1 | module testdata
2 | 
3 | go 1.15
```

cmd/internal/name/testdata/vo.go
```
1 | package testdata
2 | 
3 | // 筛选条件
4 | type PageFilter struct {
5 | 	// 真实姓名，前缀匹配
6 | 	Name string
7 | 	// 所属部门ID
8 | 	Dept int
9 | }
10 | 
11 | // 排序条件
12 | type Order struct {
13 | 	Col  string `json:"-"`
14 | 	sort string
15 | }
16 | 
17 | type PageRet struct {
18 | 	Items    interface{}
19 | 	PageNo   int
20 | 	PageSize int
21 | 	Total    int
22 | 	HasNext  bool
23 | }
24 | 
25 | type Field struct {
26 | 	Name   string
27 | 	Type   string
28 | 	Format string
29 | }
30 | 
31 | type Base struct {
32 | 	Index string
33 | 	Type  string
34 | }
35 | 
36 | type MappingPayload struct {
37 | 	Base
38 | 	Fields []Field
39 | 	Index  string
40 | }
```

cmd/internal/name/testdata/vo1.go
```
1 | package testdata
2 | 
3 | import "time"
4 | 
5 | // comment for alia age
6 | type age int
7 | 
8 | type Event struct {
9 | 	Name      string
10 | 	EventType int
11 | }
12 | 
13 | type TestAlias struct {
14 | 	Age    age
15 | 	School []struct {
16 | 		Name string
17 | 		Addr struct {
18 | 			Zip   string
19 | 			Block string
20 | 			Full  string
21 | 		}
22 | 	}
23 | 	EventChan chan Event
24 | 	SigChan   chan int
25 | 	Callback  func(string) bool
26 | 	CallbackN func(param string) bool
27 | }
28 | 
29 | type ta TestAlias
30 | 
31 | type tt time.Time
32 | 
33 | type mm map[string]interface{}
34 | 
35 | type MyInter interface {
36 | 	Speak() error
37 | }
38 | 
39 | type starM *time.Time
```

cmd/internal/name/testdata/vo2
```
1 | import "time"
2 | 
3 | // comment for alia age
4 | type age int
5 | 
6 | type Event struct {
7 | 	Name      string
8 | 	EventType int
9 | }
10 | 
11 | type TestAlias struct {
12 | 	Age    age
13 | 	School []struct {
14 | 		Name string
15 | 		Addr struct {
16 | 			Zip   string
17 | 			Block string
18 | 			Full  string
19 | 		}
20 | 	}
21 | 	EventChan chan Event
22 | 	SigChan   chan int
23 | 	Callback  func(string) bool
24 | 	CallbackN func(param string) bool
25 | }
26 | 
27 | type ta TestAlias
28 | 
29 | type tt time.Time
30 | 
31 | type mm map[string]interface{}
32 | 
33 | type MyInter interface {
34 | 	Speak() error
35 | }
36 | 
37 | type starM *time.Time
```

cmd/internal/svc/parser/parser.go
```
1 | package parser
2 | 
3 | import (
4 | 	"bytes"
5 | 	"encoding/json"
6 | 	"fmt"
7 | 	"go/ast"
8 | 	"go/parser"
9 | 	"go/token"
10 | 	"io/ioutil"
11 | 	"net/http"
12 | 	"os"
13 | 	"path/filepath"
14 | 	"reflect"
15 | 	"strings"
16 | 	"text/template"
17 | 	"time"
18 | 
19 | 	"github.com/iancoleman/strcase"
20 | 	"github.com/samber/lo"
21 | 	"github.com/sirupsen/logrus"
22 | 	"github.com/unionj-cloud/toolkit/astutils"
23 | 	"github.com/unionj-cloud/toolkit/constants"
24 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
25 | 	protov3 "github.com/unionj-cloud/toolkit/protobuf/v3"
26 | 	"github.com/unionj-cloud/toolkit/stringutils"
27 | )
28 | 
29 | var DEFAULT_DTO_PKGS = []string{"vo", "dto", "model"}
30 | 
31 | func getStructs(vofile string) []astutils.StructMeta {
32 | 	fset := token.NewFileSet()
33 | 	root, err := parser.ParseFile(fset, vofile, nil, parser.ParseComments)
34 | 	if err != nil {
35 | 		panic(err)
36 | 	}
37 | 	sc := astutils.NewStructCollector(ExprStringP)
38 | 	ast.Walk(sc, root)
39 | 	return sc.Structs
40 | }
41 | 
42 | func getSchemaNames(vofile string) []string {
43 | 	fset := token.NewFileSet()
44 | 	root, err := parser.ParseFile(fset, vofile, nil, parser.ParseComments)
45 | 	if err != nil {
46 | 		panic(err)
47 | 	}
48 | 	sc := astutils.NewStructCollector(ExprStringP)
49 | 	ast.Walk(sc, root)
50 | 	structs := sc.DocFlatEmbed()
51 | 	var ret []string
52 | 	for _, item := range structs {
53 | 		if item.IsExport {
54 | 			ret = append(ret, item.Name)
55 | 		}
56 | 	}
57 | 	return ret
58 | }
59 | 
60 | func schemasOf(vofile string, globalStructs []astutils.StructMeta) []v3.Schema {
61 | 	fset := token.NewFileSet()
62 | 	root, err := parser.ParseFile(fset, vofile, nil, parser.ParseComments)
63 | 	if err != nil {
64 | 		panic(err)
65 | 	}
66 | 	sc := astutils.NewStructCollector(ExprStringP)
67 | 	ast.Walk(sc, root)
68 | 	sc.GlobalStructs = globalStructs
69 | 	structs := sc.DocFlatEmbed()
70 | 	var ret []v3.Schema
71 | 	for _, item := range structs {
72 | 		ret = append(ret, v3.NewSchema(item))
73 | 	}
74 | 	return ret
75 | }
76 | 
77 | func operationOf(method astutils.MethodMeta, httpMethod string, config GenDocConfig) v3.Operation {
78 | 	var ret v3.Operation
79 | 	var params []v3.Parameter
80 | 
81 | 	ret.Description = strings.Join(method.Comments, "\n")
82 | 
83 | 	// If http method is "POST" and each parameters' type is one of v3.Int, v3.Int64, v3.Bool, v3.String, v3.Float32, v3.Float64,
84 | 	// then we use application/x-www-form-urlencoded as Content-type, and we make one ref schema from them as request body.
85 | 	var simpleCnt int
86 | 	for _, item := range method.Params {
87 | 		if v3.IsBuiltin(item) || item.Type == "context.Context" {
88 | 			simpleCnt++
89 | 		}
90 | 	}
91 | 	if (httpMethod == http.MethodPost || httpMethod == http.MethodPut) && simpleCnt == len(method.Params) {
92 | 		if ret.RequestBody == nil {
93 | 			ret.RequestBody = &v3.RequestBody{}
94 | 		}
95 | 		postFormUrl(ret.RequestBody, &params, method)
96 | 	} else if httpMethod == http.MethodGet && !config.AllowGetWithReqBody {
97 | 		for _, item := range method.Params {
98 | 			if item.Type == "context.Context" {
99 | 				continue
100 | 			}
101 | 			pschema := v3.CopySchema(item)
102 | 			v3.RefAddDoc(&pschema, strings.Join(item.Comments, "\n"))
103 | 			required := !v3.IsOptional(item.Type)
104 | 			param := v3.Parameter{
105 | 				Name:        strcase.ToLowerCamel(item.Name),
106 | 				In:          v3.InQuery,
107 | 				Schema:      &pschema,
108 | 				Description: pschema.Description,
109 | 				Required:    required,
110 | 			}
111 | 			if item.IsPathVariable {
112 | 				param.Name = strings.ToLower(param.Name)
113 | 				param.In = v3.InPath
114 | 			}
115 | 			params = append(params, param)
116 | 		}
117 | 	} else {
118 | 		// Simple parameters such as v3.Int, v3.Int64, v3.Bool, v3.String, v3.Float32, v3.Float64 and corresponding Array type
119 | 		// will be put into query parameter as url search params no matter what http method is.
120 | 		// Complex parameters such as structs in vo and dto package, map and corresponding slice/array type
121 | 		// will be put into request body as json content type.
122 | 		// File and file array parameter will be put into request body as multipart/form-data content type.
123 | 		upload := false
124 | 		for _, item := range method.Params {
125 | 			if item.Type == "context.Context" {
126 | 				continue
127 | 			}
128 | 			pschemaType := v3.SchemaOf(item)
129 | 			if reflect.DeepEqual(pschemaType, v3.FileArray) || pschemaType == v3.File {
130 | 				upload = true
131 | 				break
132 | 			}
133 | 		}
134 | 
135 | 		if upload {
136 | 			ret.RequestBody = uploadFile(method)
137 | 			for _, item := range method.Params {
138 | 				if item.Type == "context.Context" {
139 | 					continue
140 | 				}
141 | 				if v3.IsBuiltin(item) && item.IsPathVariable {
142 | 					pschema := v3.CopySchema(item)
143 | 					v3.RefAddDoc(&pschema, strings.Join(item.Comments, "\n"))
144 | 					required := !v3.IsOptional(item.Type)
145 | 					param := v3.Parameter{
146 | 						Name:        strings.ToLower(strcase.ToLowerCamel(item.Name)),
147 | 						In:          v3.InPath,
148 | 						Schema:      &pschema,
149 | 						Description: pschema.Description,
150 | 						Required:    required,
151 | 					}
152 | 					params = append(params, param)
153 | 				}
154 | 			}
155 | 		} else {
156 | 			for _, item := range method.Params {
157 | 				if item.Type == "context.Context" {
158 | 					continue
159 | 				}
160 | 				pschema := v3.CopySchema(item)
161 | 				v3.RefAddDoc(&pschema, strings.Join(item.Comments, "\n"))
162 | 				required := !v3.IsOptional(item.Type)
163 | 				if v3.IsBuiltin(item) {
164 | 					param := v3.Parameter{
165 | 						Name:        strcase.ToLowerCamel(item.Name),
166 | 						In:          v3.InQuery,
167 | 						Schema:      &pschema,
168 | 						Description: pschema.Description,
169 | 						Required:    required,
170 | 					}
171 | 					if item.IsPathVariable {
172 | 						param.Name = strings.ToLower(param.Name)
173 | 						param.In = v3.InPath
174 | 					}
175 | 					params = append(params, param)
176 | 				} else {
177 | 					var content v3.Content
178 | 					mt := &v3.MediaType{
179 | 						Schema: &pschema,
180 | 					}
181 | 					reflect.ValueOf(&content).Elem().FieldByName("JSON").Set(reflect.ValueOf(mt))
182 | 					ret.RequestBody = &v3.RequestBody{
183 | 						Content:  &content,
184 | 						Required: required,
185 | 					}
186 | 				}
187 | 			}
188 | 		}
189 | 	}
190 | 
191 | 	ret.Parameters = params
192 | 	ret.Responses = response(method)
193 | 	return ret
194 | }
195 | 
196 | func response(method astutils.MethodMeta) *v3.Responses {
197 | 	var respContent v3.Content
198 | 	var hasFile bool
199 | 	var fileDoc string
200 | 	for _, item := range method.Results {
201 | 		if item.Type == "*os.File" {
202 | 			hasFile = true
203 | 			fileDoc = strings.Join(item.Comments, "\n")
204 | 			break
205 | 		}
206 | 	}
207 | 	if hasFile {
208 | 		respContent.Stream = &v3.MediaType{
209 | 			Schema: &v3.Schema{
210 | 				Type:        v3.StringT,
211 | 				Format:      v3.BinaryF,
212 | 				Description: fileDoc,
213 | 			},
214 | 		}
215 | 	} else {
216 | 		title := method.Name + "Resp"
217 | 		respSchema := v3.Schema{
218 | 			Type:       v3.ObjectT,
219 | 			Title:      title,
220 | 			Properties: make(map[string]*v3.Schema),
221 | 		}
222 | 		for _, item := range method.Results {
223 | 			if item.Type == "error" {
224 | 				continue
225 | 			}
226 | 			key := item.Name
227 | 			if stringutils.IsEmpty(key) {
228 | 				key = item.Type[strings.LastIndex(item.Type, ".")+1:]
229 | 			}
230 | 			rschema := v3.CopySchema(item)
231 | 			v3.RefAddDoc(&rschema, strings.Join(item.Comments, "\n"))
232 | 			prop := strcase.ToLowerCamel(key)
233 | 			respSchema.Properties[prop] = &rschema
234 | 			if !v3.IsOptional(item.Type) {
235 | 				respSchema.Required = append(respSchema.Required, prop)
236 | 			}
237 | 		}
238 | 		v3.Schemas[title] = respSchema
239 | 		respContent.JSON = &v3.MediaType{
240 | 			Schema: &v3.Schema{
241 | 				Ref: "#/components/schemas/" + title,
242 | 			},
243 | 		}
244 | 	}
245 | 	return &v3.Responses{
246 | 		Resp200: &v3.Response{
247 | 			Content: &respContent,
248 | 		},
249 | 	}
250 | }
251 | 
252 | func uploadFile(method astutils.MethodMeta) *v3.RequestBody {
253 | 	title := method.Name + "Req"
254 | 	reqSchema := v3.Schema{
255 | 		Type:       v3.ObjectT,
256 | 		Title:      title,
257 | 		Properties: make(map[string]*v3.Schema),
258 | 	}
259 | 	for _, item := range method.Params {
260 | 		if item.Type == "context.Context" {
261 | 			continue
262 | 		}
263 | 		if item.IsPathVariable {
264 | 			continue
265 | 		}
266 | 		pschemaType := v3.SchemaOf(item)
267 | 		if reflect.DeepEqual(pschemaType, v3.FileArray) || pschemaType == v3.File || v3.IsBuiltin(item) {
268 | 			pschema := v3.CopySchema(item)
269 | 			pschema.Description = strings.Join(item.Comments, "\n")
270 | 			prop := strcase.ToLowerCamel(item.Name)
271 | 			reqSchema.Properties[prop] = &pschema
272 | 			if !v3.IsOptional(item.Type) {
273 | 				reqSchema.Required = append(reqSchema.Required, prop)
274 | 			}
275 | 		}
276 | 	}
277 | 	v3.Schemas[title] = reqSchema
278 | 	mt := &v3.MediaType{
279 | 		Schema: &v3.Schema{
280 | 			Ref: "#/components/schemas/" + title,
281 | 		},
282 | 	}
283 | 	var content v3.Content
284 | 	reflect.ValueOf(&content).Elem().FieldByName("FormData").Set(reflect.ValueOf(mt))
285 | 	return &v3.RequestBody{
286 | 		Content:  &content,
287 | 		Required: len(reqSchema.Required) > 0,
288 | 	}
289 | }
290 | 
291 | func postFormUrl(reqBody *v3.RequestBody, params *[]v3.Parameter, method astutils.MethodMeta) {
292 | 	if reqBody == nil {
293 | 		panic("reqBody should not be nil")
294 | 	}
295 | 	if params == nil {
296 | 		panic("params should not be nil")
297 | 	}
298 | 	title := method.Name + "Req"
299 | 	reqSchema := v3.Schema{
300 | 		Type:       v3.ObjectT,
301 | 		Title:      title,
302 | 		Properties: make(map[string]*v3.Schema),
303 | 	}
304 | 	for _, item := range method.Params {
305 | 		if item.Type == "context.Context" {
306 | 			continue
307 | 		}
308 | 		pschema := v3.CopySchema(item)
309 | 		v3.RefAddDoc(&pschema, strings.Join(item.Comments, "\n"))
310 | 		required := !v3.IsOptional(item.Type)
311 | 		if item.IsPathVariable {
312 | 			param := v3.Parameter{
313 | 				Name:        strings.ToLower(strcase.ToLowerCamel(item.Name)),
314 | 				In:          v3.InPath,
315 | 				Schema:      &pschema,
316 | 				Description: pschema.Description,
317 | 				Required:    required,
318 | 			}
319 | 			*params = append(*params, param)
320 | 			continue
321 | 		}
322 | 		prop := strcase.ToLowerCamel(item.Name)
323 | 		reqSchema.Properties[prop] = &pschema
324 | 		if required {
325 | 			reqSchema.Required = append(reqSchema.Required, prop)
326 | 		}
327 | 	}
328 | 	v3.Schemas[title] = reqSchema
329 | 	mt := &v3.MediaType{
330 | 		Schema: &v3.Schema{
331 | 			Ref: "#/components/schemas/" + title,
332 | 		},
333 | 	}
334 | 	var content v3.Content
335 | 	reflect.ValueOf(&content).Elem().FieldByName("FormURL").Set(reflect.ValueOf(mt))
336 | 	reqBody.Content = &content
337 | 	reqBody.Required = len(reqSchema.Required) > 0
338 | }
339 | 
340 | // ApiPattern
341 | // GetShelves_ShelfBooks_Book
342 | // shelves/:shelf/books/:book
343 | func ApiPattern(method string) string {
344 | 	_, endpoint := astutils.Pattern(method)
345 | 	splits := strings.Split(endpoint, "/")
346 | 	var partials []string
347 | 	for _, v := range splits {
348 | 		if strings.HasPrefix(v, ":") {
349 | 			partials = append(partials, "{"+strings.TrimPrefix(v, ":")+"}")
350 | 		} else {
351 | 			partials = append(partials, v)
352 | 		}
353 | 	}
354 | 	return strings.Join(partials, "/")
355 | }
356 | 
357 | func pathsOf(ic astutils.InterfaceCollector, config GenDocConfig) map[string]v3.Path {
358 | 	if len(ic.Interfaces) == 0 {
359 | 		return nil
360 | 	}
361 | 	pathmap := make(map[string]v3.Path)
362 | 	inter := ic.Interfaces[0]
363 | 	for _, method := range inter.Methods {
364 | 		endpoint := fmt.Sprintf("/%s", ApiPattern(method.Name))
365 | 		if config.RoutePatternStrategy == 1 {
366 | 			endpoint = fmt.Sprintf("/%s/%s", strings.ToLower(inter.Name), NoSplitPattern(method.Name))
367 | 		}
368 | 		hm, _ := astutils.Pattern(method.Name)
369 | 		op := operationOf(method, hm, config)
370 | 		if val, ok := pathmap[endpoint]; ok {
371 | 			reflect.ValueOf(&val).Elem().FieldByName(strings.Title(strings.ToLower(hm))).Set(reflect.ValueOf(&op))
372 | 			pathmap[endpoint] = val
373 | 		} else {
374 | 			var v3path v3.Path
375 | 			reflect.ValueOf(&v3path).Elem().FieldByName(strings.Title(strings.ToLower(hm))).Set(reflect.ValueOf(&op))
376 | 			pathmap[endpoint] = v3path
377 | 		}
378 | 	}
379 | 	return pathmap
380 | }
381 | 
382 | var gofileTmpl = `package {{.SvcPackage}}
383 | 
384 | var Oas = ` + "`" + `{{.Doc}}` + "`" + `
385 | `
386 | 
387 | type GenDocConfig struct {
388 | 	RoutePatternStrategy int
389 | 	AllowGetWithReqBody  bool
390 | }
391 | 
392 | // GenDoc generates OpenAPI 3.0 description json file.
393 | // Not support alias type in vo or dto file.
394 | func GenDoc(dir string, ic astutils.InterfaceCollector, config GenDocConfig) {
395 | 	var (
396 | 		err     error
397 | 		svcname string
398 | 		docfile string
399 | 		gofile  string
400 | 		fi      os.FileInfo
401 | 		api     v3.API
402 | 		data    []byte
403 | 		paths   map[string]v3.Path
404 | 		tpl     *template.Template
405 | 		sqlBuf  bytes.Buffer
406 | 		source  string
407 | 	)
408 | 	svcname = ic.Interfaces[0].Name
409 | 	docfile = filepath.Join(dir, strings.ToLower(svcname)+"_openapi3.json")
410 | 	fi, err = os.Stat(docfile)
411 | 	if err != nil && !os.IsNotExist(err) {
412 | 		panic(err)
413 | 	}
414 | 	if fi != nil {
415 | 		logrus.Warningln("file " + docfile + " will be overwritten")
416 | 	}
417 | 	gofile = filepath.Join(dir, strings.ToLower(svcname)+"_openapi3.go")
418 | 	fi, err = os.Stat(gofile)
419 | 	if err != nil && !os.IsNotExist(err) {
420 | 		panic(err)
421 | 	}
422 | 	if fi != nil {
423 | 		logrus.Warningln("file " + gofile + " will be overwritten")
424 | 	}
425 | 	paths = pathsOf(ic, config)
426 | 	api = v3.API{
427 | 		Openapi: "3.0.2",
428 | 		Info: &v3.Info{
429 | 			Title:       svcname,
430 | 			Description: strings.Join(ic.Interfaces[0].Comments, "\n"),
431 | 			Version:     fmt.Sprintf("v%s", time.Now().Local().Format(constants.FORMAT10)),
432 | 		},
433 | 		Servers: []v3.Server{
434 | 			{
435 | 				URL: fmt.Sprintf("http://localhost:%d", 6060),
436 | 			},
437 | 		},
438 | 		Paths: paths,
439 | 		Components: &v3.Components{
440 | 			Schemas: v3.Schemas,
441 | 		},
442 | 	}
443 | 	data, err = json.Marshal(api)
444 | 	err = ioutil.WriteFile(docfile, data, os.ModePerm)
445 | 	if err != nil {
446 | 		panic(err)
447 | 	}
448 | 	if tpl, err = template.New(gofileTmpl).Parse(gofileTmpl); err != nil {
449 | 		panic(err)
450 | 	}
451 | 	if err = tpl.Execute(&sqlBuf, struct {
452 | 		SvcPackage string
453 | 		Doc        string
454 | 	}{
455 | 		SvcPackage: ic.Package.Name,
456 | 		Doc:        string(data),
457 | 	}); err != nil {
458 | 		panic(err)
459 | 	}
460 | 	source = strings.TrimSpace(sqlBuf.String())
461 | 	astutils.FixImport([]byte(source), gofile)
462 | }
463 | 
464 | func ParseDto(dir string, dtoDir ...string) {
465 | 	var (
466 | 		err        error
467 | 		vos        []v3.Schema
468 | 		allMethods map[string][]astutils.MethodMeta
469 | 		allConsts  map[string][]string
470 | 		files      []string
471 | 	)
472 | 	for i := 0; i < len(dtoDir); i++ {
473 | 		vodir := filepath.Join(dir, dtoDir[i])
474 | 		if _, err = os.Stat(vodir); err != nil {
475 | 			continue
476 | 		}
477 | 		if err = filepath.Walk(vodir, astutils.Visit(&files)); err != nil {
478 | 			panic(err)
479 | 		}
480 | 	}
481 | 	globalStructs := make([]astutils.StructMeta, 0)
482 | 	for _, file := range files {
483 | 		v3.SchemaNames = append(v3.SchemaNames, getSchemaNames(file)...)
484 | 		globalStructs = append(globalStructs, getStructs(file)...)
485 | 	}
486 | 	allMethods = make(map[string][]astutils.MethodMeta)
487 | 	allConsts = make(map[string][]string)
488 | 	for _, file := range files {
489 | 		sc := astutils.EnumsOf(file, ExprStringP)
490 | 		for k, v := range sc.Methods {
491 | 			allMethods[k] = append(allMethods[k], v...)
492 | 		}
493 | 		for k, v := range sc.Consts {
494 | 			allConsts[k] = append(allConsts[k], v...)
495 | 		}
496 | 	}
497 | 	for k, v := range allMethods {
498 | 		if v3.IsEnumType(v) {
499 | 			v3.Enums[k] = astutils.EnumMeta{
500 | 				Name:   k,
501 | 				Values: allConsts[k],
502 | 			}
503 | 		}
504 | 	}
505 | 	for _, file := range files {
506 | 		vos = append(vos, schemasOf(file, globalStructs)...)
507 | 	}
508 | 	for _, item := range vos {
509 | 		v3.Schemas[item.Title] = item
510 | 	}
511 | }
512 | 
[TRUNCATED]
```

cmd/internal/svc/codegen/config.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"strings"
7 | 	"text/template"
8 | 
9 | 	"github.com/sirupsen/logrus"
10 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
11 | 	"github.com/unionj-cloud/toolkit/astutils"
12 | 	"github.com/unionj-cloud/go-doudou/v2/version"
13 | )
14 | 
15 | var configTmpl = templates.EditableHeaderTmpl + `package config
16 | 
17 | import (
18 | 	"github.com/unionj-cloud/toolkit/envconfig"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/config"
20 | 	"github.com/unionj-cloud/toolkit/zlogger"
21 | )
22 | 
23 | var G_Config *Config
24 | 
25 | type Config struct {
26 | 	Biz struct {
27 | 		ApiSecret string ` + "`" + `split_words:"true"` + "`" + `
28 | 	}
29 | 	config.Config
30 | }
31 | 
32 | func init() {
33 | 	var conf Config
34 | 	err := envconfig.Process("{{.ServiceName}}", &conf)
35 | 	if err != nil {
36 | 		zlogger.Panic().Msgf("Error processing environment variables: %v", err)
37 | 	}
38 | 	G_Config = &conf
39 | }
40 | 
41 | func LoadFromEnv() *Config {
42 | 	return G_Config
43 | }
44 | `
45 | 
46 | // GenConfig generates config file
47 | func GenConfig(dir string, ic astutils.InterfaceCollector) {
48 | 	var (
49 | 		err         error
50 | 		configfile  string
51 | 		f           *os.File
52 | 		tpl         *template.Template
53 | 		configDir   string
54 | 		serviceName string
55 | 	)
56 | 	configDir = filepath.Join(dir, "config")
57 | 	if err = os.MkdirAll(configDir, os.ModePerm); err != nil {
58 | 		panic(err)
59 | 	}
60 | 	serviceName = strings.ToLower(ic.Interfaces[0].Name)
61 | 	configfile = filepath.Join(configDir, "config.go")
62 | 	if _, err = os.Stat(configfile); os.IsNotExist(err) {
63 | 		if f, err = os.Create(configfile); err != nil {
64 | 			panic(err)
65 | 		}
66 | 		defer f.Close()
67 | 		tpl, _ = template.New("config.go.tmpl").Parse(configTmpl)
68 | 		_ = tpl.Execute(f, struct {
69 | 			Version     string
70 | 			ServiceName string
71 | 		}{
72 | 			Version:     version.Release,
73 | 			ServiceName: serviceName,
74 | 		})
75 | 	} else {
76 | 		logrus.Warnf("file %s already exists", configfile)
77 | 	}
78 | }
```

cmd/internal/svc/codegen/config_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/unionj-cloud/toolkit/astutils"
9 | )
10 | 
11 | const testDir = "testdata"
12 | 
13 | func TestGenConfig(t *testing.T) {
14 | 	dir := testDir + "config"
15 | 	InitSvc(dir)
16 | 	defer os.RemoveAll(dir)
17 | 	var ic astutils.InterfaceCollector
18 | 	GenConfig(dir, ic)
19 | }
20 | 
21 | func TestGenConfig1(t *testing.T) {
22 | 	var ic astutils.InterfaceCollector
23 | 	GenConfig(filepath.Join(testDir), ic)
24 | }
```

cmd/internal/svc/codegen/db.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"text/template"
7 | 
8 | 	"github.com/sirupsen/logrus"
9 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
10 | 	"github.com/unionj-cloud/toolkit/astutils"
11 | 	"github.com/unionj-cloud/go-doudou/v2/version"
12 | )
13 | 
14 | var dbTmpl = templates.EditableHeaderTmpl + `package db
15 | 
16 | import (
17 | 	"{{.ConfigPackage}}"
18 | 	"fmt"
19 | 	_ "github.com/go-sql-driver/mysql"
20 | 	"github.com/iancoleman/strcase"
21 | 	"github.com/jmoiron/sqlx"
22 | 	"github.com/pkg/errors"
23 | )
24 | 
25 | func NewDb(conf config.DbConfig) (*sqlx.DB, error) {
26 | 	conn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=%s",
27 | 		conf.User,
28 | 		conf.Passwd,
29 | 		conf.Host,
30 | 		conf.Port,
31 | 		conf.Schema,
32 | 		conf.Charset)
33 | 	conn += "&loc=Asia%2FShanghai&parseTime=True"
34 | 
35 | 	db, err := sqlx.Connect(conf.Driver, conn)
36 | 	if err != nil {
37 | 		return nil, errors.Wrap(err, "database connection failed")
38 | 	}
39 | 	db.MapperFunc(strcase.ToSnake)
40 | 	return db, nil
41 | }
42 | `
43 | 
44 | var MkdirAll = os.MkdirAll
45 | var Open = os.Open
46 | var Create = os.Create
47 | var Stat = os.Stat
48 | 
49 | // GenDb generates db connection code
50 | func GenDb(dir string) {
51 | 	var (
52 | 		err    error
53 | 		dbfile string
54 | 		f      *os.File
55 | 		tpl    *template.Template
56 | 		dbDir  string
57 | 	)
58 | 	dbDir = filepath.Join(dir, "db")
59 | 	if err = MkdirAll(dbDir, os.ModePerm); err != nil {
60 | 		panic(err)
61 | 	}
62 | 
63 | 	dbfile = filepath.Join(dbDir, "db.go")
64 | 	if _, err = Stat(dbfile); os.IsNotExist(err) {
65 | 		cfgPkg := astutils.GetPkgPath(filepath.Join(dir, "config"))
66 | 		if f, err = Create(dbfile); err != nil {
67 | 			panic(err)
68 | 		}
69 | 		defer f.Close()
70 | 
71 | 		if tpl, err = template.New("db.go.tmpl").Parse(dbTmpl); err != nil {
72 | 			panic(err)
73 | 		}
74 | 		_ = tpl.Execute(f, struct {
75 | 			ConfigPackage string
76 | 			Version       string
77 | 		}{
78 | 			ConfigPackage: cfgPkg,
79 | 			Version:       version.Release,
80 | 		})
81 | 	} else {
82 | 		logrus.Warnf("file %s already exists", dbfile)
83 | 	}
84 | }
```

cmd/internal/svc/codegen/db_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"testing"
6 | 
7 | 	"github.com/pkg/errors"
8 | 	. "github.com/smartystreets/goconvey/convey"
9 | )
10 | 
11 | func TestGenDbPanic(t *testing.T) {
12 | 	Convey("GenDb should panic from MkdirAll", t, func() {
13 | 		MkdirAll = os.MkdirAll
14 | 		Open = os.Open
15 | 		Create = os.Create
16 | 		Stat = os.Stat
17 | 		MkdirAll = func(path string, perm os.FileMode) error {
18 | 			return errors.New("mock MkdirAll error")
19 | 		}
20 | 		dir := testDir + "db"
21 | 		InitSvc(dir)
22 | 		defer os.RemoveAll(dir)
23 | 		So(func() {
24 | 			GenDb(dir)
25 | 		}, ShouldPanic)
26 | 	})
27 | }
28 | 
29 | func TestGenDbPanic2(t *testing.T) {
30 | 	Convey("GenDb should panic from Open", t, func() {
31 | 		MkdirAll = os.MkdirAll
32 | 		Open = os.Open
33 | 		Create = os.Create
34 | 		Stat = os.Stat
35 | 		Open = func(name string) (*os.File, error) {
36 | 			return nil, errors.New("mock Open error")
37 | 		}
38 | 		dir := testDir + "db"
39 | 		InitSvc(dir)
40 | 		defer os.RemoveAll(dir)
41 | 		So(func() {
42 | 			GenDb(dir)
43 | 		}, ShouldPanic)
44 | 	})
45 | }
46 | 
47 | func TestGenDbPanic3(t *testing.T) {
48 | 	Convey("GenDb should panic from Create", t, func() {
49 | 		MkdirAll = os.MkdirAll
50 | 		Open = os.Open
51 | 		Create = os.Create
52 | 		Stat = os.Stat
53 | 		Create = func(name string) (*os.File, error) {
54 | 			return nil, errors.New("mock Create error")
55 | 		}
56 | 		dir := testDir + "db"
57 | 		InitSvc(dir)
58 | 		defer os.RemoveAll(dir)
59 | 		So(func() {
60 | 			GenDb(dir)
61 | 		}, ShouldPanic)
62 | 	})
63 | }
64 | 
65 | func TestGenDbWarn(t *testing.T) {
66 | 	Convey("GenDb should warn", t, func() {
67 | 		MkdirAll = os.MkdirAll
68 | 		Open = os.Open
69 | 		Create = os.Create
70 | 		Stat = os.Stat
71 | 		Stat = func(name string) (os.FileInfo, error) {
72 | 			return nil, errors.New("mock Stat error")
73 | 		}
74 | 		dir := testDir + "db"
75 | 		InitSvc(dir)
76 | 		defer os.RemoveAll(dir)
77 | 		So(func() {
78 | 			GenDb(dir)
79 | 		}, ShouldNotPanic)
80 | 	})
81 | }
82 | 
83 | func TestGenDbPanic4(t *testing.T) {
84 | 	Convey("GenDb should panic from dbTmpl", t, func() {
85 | 		MkdirAll = os.MkdirAll
86 | 		Open = os.Open
87 | 		Create = os.Create
88 | 		Stat = os.Stat
89 | 		dbTmpl = `{{test tmpl}`
90 | 		dir := testDir + "db"
91 | 		InitSvc(dir)
92 | 		defer os.RemoveAll(dir)
93 | 		So(func() {
94 | 			GenDb(dir)
95 | 		}, ShouldPanic)
96 | 	})
97 | }
```

cmd/internal/svc/codegen/grpcannotation.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/unionj-cloud/go-doudou/v2/version"
11 | 
12 | 	"github.com/sirupsen/logrus"
13 | 	"github.com/unionj-cloud/toolkit/astutils"
14 | )
15 | 
16 | var annotationTmpl = `/**
17 | * Generated by go-doudou {{.Version}}.
18 | * Don't edit!
19 | */
20 | package grpc
21 | 
22 | import (
23 | 	"github.com/unionj-cloud/go-doudou/v2/framework"
24 | )
25 | 
26 | var MethodAnnotationStore = framework.AnnotationStore{
27 | 	{{- range $m := .Meta.Methods }}
28 | 	{{- if $m.Annotations }}
29 | 	"{{$m.Name}}Rpc": {
30 | 		{{- range $a := $m.Annotations }}
31 | 		{
32 | 			Name:   "{{ $a.Name }}",
33 | 			{{- if $a.Params }}
34 | 			Params: []string{
35 | 				{{- range $p := $a.Params }}
36 | 				"{{ $p }}",
37 | 				{{- end }}
38 | 			},
39 | 			{{- end }}
40 | 		},
41 | 		{{- end }}
42 | 	},
43 | 	{{- end }}
44 | 	{{- end }}
45 | }
46 | `
47 | 
48 | func GenMethodAnnotationStore(dir string, ic astutils.InterfaceCollector) {
49 | 	var (
50 | 		err            error
51 | 		annotationFile string
52 | 		f              *os.File
53 | 		tpl            *template.Template
54 | 		grpcDir        string
55 | 		source         string
56 | 		sqlBuf         bytes.Buffer
57 | 		fi             os.FileInfo
58 | 	)
59 | 	grpcDir = filepath.Join(dir, "transport", "grpc")
60 | 	if err = os.MkdirAll(grpcDir, os.ModePerm); err != nil {
61 | 		panic(err)
62 | 	}
63 | 	annotationFile = filepath.Join(grpcDir, "annotation.go")
64 | 	fi, err = os.Stat(annotationFile)
65 | 	if err != nil && !os.IsNotExist(err) {
66 | 		panic(err)
67 | 	}
68 | 	if fi != nil {
69 | 		logrus.Warningln("file annotation.go will be overwritten")
70 | 	}
71 | 	if f, err = os.Create(annotationFile); err != nil {
72 | 		panic(err)
73 | 	}
74 | 	defer f.Close()
75 | 
76 | 	if tpl, err = template.New(annotationTmpl).Parse(annotationTmpl); err != nil {
77 | 		panic(err)
78 | 	}
79 | 	if err = tpl.Execute(&sqlBuf, struct {
80 | 		Meta    astutils.InterfaceMeta
81 | 		Version string
82 | 	}{
83 | 		Meta:    ic.Interfaces[0],
84 | 		Version: version.Release,
85 | 	}); err != nil {
86 | 		panic(err)
87 | 	}
88 | 	source = strings.TrimSpace(sqlBuf.String())
89 | 	astutils.FixImport([]byte(source), annotationFile)
90 | }
```

cmd/internal/svc/codegen/grpchttpmain.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
11 | 	"github.com/unionj-cloud/toolkit/astutils"
12 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
13 | 	"github.com/unionj-cloud/go-doudou/v2/version"
14 | )
15 | 
16 | var mainTmplGrpcHttp = templates.EditableHeaderTmpl + `package main
17 | 
18 | import (
19 | 	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
20 | 	grpczerolog "github.com/grpc-ecosystem/go-grpc-middleware/providers/zerolog/v2"
21 | 	grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
22 | 	grpc_ctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
23 | 	grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
24 | 	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
25 | 	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/tags"
26 | 	grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
27 | 	"github.com/unionj-cloud/toolkit/zlogger"
28 | 	"google.golang.org/grpc"
29 |     "github.com/unionj-cloud/go-doudou/v2/framework/grpcx"
30 | 	{{.ServiceAlias}} "{{.ServicePackage}}"
31 |     "{{.ConfigPackage}}"
32 | 	pb "{{.PbPackage}}"
33 | 	"{{.HttpPackage}}"
34 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
35 | )
36 | 
37 | func main() {
38 | 	conf := config.LoadFromEnv()
39 | 	svc := {{.ServiceAlias}}.New{{.SvcName}}(conf)
40 | 
41 | 	go func() {
42 | 		grpcServer := grpcx.NewGrpcServer(
43 | 			grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
44 | 				grpc_ctxtags.StreamServerInterceptor(),
45 | 				grpc_opentracing.StreamServerInterceptor(),
46 | 				grpc_prometheus.StreamServerInterceptor,
47 | 				tags.StreamServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
48 | 				logging.StreamServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
49 | 				grpc_recovery.StreamServerInterceptor(),
50 | 			)),
51 | 			grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
52 | 				grpc_ctxtags.UnaryServerInterceptor(),
53 | 				grpc_opentracing.UnaryServerInterceptor(),
54 | 				grpc_prometheus.UnaryServerInterceptor,
55 | 				tags.UnaryServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
56 | 				logging.UnaryServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
57 | 				grpc_recovery.UnaryServerInterceptor(),
58 | 			)),
59 | 		)
60 | 		pb.Register{{.GrpcSvcName}}Server(grpcServer, svc)
61 | 		grpcServer.Run()
62 | 	}()
63 | 
64 | 	handler := httpsrv.New{{.SvcName}}Http2Grpc(svc)
65 | 	srv := rest.NewRestServer()
66 | 	srv.AddRoutes(httpsrv.Routes(handler))
67 | 	srv.AddRoutes(rest.DocRoutes(service.Oas))
68 | 	srv.Run()
69 | }
70 | `
71 | 
72 | // GenMainGrpcHttp generates main function for grpc service
73 | func GenMainGrpcHttp(dir string, ic astutils.InterfaceCollector, grpcSvc v3.Service) {
74 | 	var (
75 | 		err      error
76 | 		mainfile string
77 | 		f        *os.File
78 | 		tpl      *template.Template
79 | 		cmdDir   string
80 | 		svcName  string
81 | 		alias    string
82 | 		source   string
83 | 	)
84 | 	cmdDir = filepath.Join(dir, "cmd")
85 | 	if err = MkdirAll(cmdDir, os.ModePerm); err != nil {
86 | 		panic(err)
87 | 	}
88 | 	svcName = ic.Interfaces[0].Name
89 | 	alias = ic.Package.Name
90 | 	mainfile = filepath.Join(cmdDir, "main.go")
91 | 	servicePkg := astutils.GetPkgPath(dir)
92 | 	cfgPkg := astutils.GetPkgPath(filepath.Join(dir, "config"))
93 | 	pbPkg := astutils.GetPkgPath(filepath.Join(dir, "transport", "grpc"))
94 | 	httpsrvPkg := astutils.GetPkgPath(filepath.Join(dir, "transport", "httpsrv"))
95 | 	if _, err = Stat(mainfile); os.IsNotExist(err) {
96 | 		if f, err = Create(mainfile); err != nil {
97 | 			panic(err)
98 | 		}
99 | 		defer f.Close()
100 | 		if tpl, err = template.New(mainTmplGrpcHttp).Parse(mainTmplGrpcHttp); err != nil {
101 | 			panic(err)
102 | 		}
103 | 		var buf bytes.Buffer
104 | 		if err = tpl.Execute(&buf, struct {
105 | 			ServicePackage string
106 | 			ConfigPackage  string
107 | 			PbPackage      string
108 | 			SvcName        string
109 | 			ServiceAlias   string
110 | 			Version        string
111 | 			GrpcSvcName    string
112 | 			HttpPackage    string
113 | 		}{
114 | 			ServicePackage: servicePkg,
115 | 			ConfigPackage:  cfgPkg,
116 | 			PbPackage:      pbPkg,
117 | 			SvcName:        svcName,
118 | 			ServiceAlias:   alias,
119 | 			Version:        version.Release,
120 | 			GrpcSvcName:    grpcSvc.Name,
121 | 			HttpPackage:    httpsrvPkg,
122 | 		}); err != nil {
123 | 			panic(err)
124 | 		}
125 | 		source = strings.TrimSpace(buf.String())
126 | 		astutils.FixImport([]byte(source), mainfile)
127 | 	}
128 | }
```

cmd/internal/svc/codegen/grpcmain.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"fmt"
6 | 	"io/ioutil"
7 | 	"os"
8 | 	"path/filepath"
9 | 	"regexp"
10 | 	"strings"
11 | 	"text/template"
12 | 
13 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
14 | 	"github.com/unionj-cloud/toolkit/astutils"
15 | 	"github.com/unionj-cloud/toolkit/constants"
16 | 	"github.com/unionj-cloud/toolkit/fileutils"
17 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
18 | 	"github.com/unionj-cloud/go-doudou/v2/version"
19 | )
20 | 
21 | var mainTmplGrpc = templates.EditableHeaderTmpl + `package main
22 | 
23 | import (
24 | 	` + gRPCImportBlock + `
25 | )
26 | 
27 | func main() {
28 | 	conf := config.LoadFromEnv()
29 | 	svc := {{.ServiceAlias}}.New{{.SvcName}}(conf)
30 | 	grpcServer := grpcx.NewGrpcServer(
31 | 		grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
32 | 			grpc_ctxtags.StreamServerInterceptor(),
33 | 			grpc_opentracing.StreamServerInterceptor(),
34 | 			grpc_prometheus.StreamServerInterceptor,
35 | 			tags.StreamServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
36 | 			logging.StreamServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
37 | 			grpc_recovery.StreamServerInterceptor(),
38 | 		)),
39 | 		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
40 | 			grpc_ctxtags.UnaryServerInterceptor(),
41 | 			grpc_opentracing.UnaryServerInterceptor(),
42 | 			grpc_prometheus.UnaryServerInterceptor,
43 | 			tags.UnaryServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
44 | 			logging.UnaryServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
45 | 			grpc_recovery.UnaryServerInterceptor(),
46 | 		)),
47 | 	)
48 | 	pb.Register{{.GrpcSvcName}}Server(grpcServer, svc)
49 | 	grpcServer.Run()
50 | }
51 | `
52 | 
53 | var appendMainTmplGrpc = `
54 | go func() {
55 | 	grpcServer := grpcx.NewGrpcServer(
56 | 		grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
57 | 			grpc_ctxtags.StreamServerInterceptor(),
58 | 			grpc_opentracing.StreamServerInterceptor(),
59 | 			grpc_prometheus.StreamServerInterceptor,
60 | 			tags.StreamServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
61 | 			logging.StreamServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
62 | 			grpc_recovery.StreamServerInterceptor(),
63 | 		)),
64 | 		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
65 | 			grpc_ctxtags.UnaryServerInterceptor(),
66 | 			grpc_opentracing.UnaryServerInterceptor(),
67 | 			grpc_prometheus.UnaryServerInterceptor,
68 | 			tags.UnaryServerInterceptor(tags.WithFieldExtractor(tags.CodeGenRequestFieldExtractor)),
69 | 			logging.UnaryServerInterceptor(grpczerolog.InterceptorLogger(zlogger.Logger)),
70 | 			grpc_recovery.UnaryServerInterceptor(),
71 | 		)),
72 | 	)
73 | 	pb.Register{{.GrpcSvcName}}Server(grpcServer, svc)
74 | 	grpcServer.Run()
75 | }()
76 | `
77 | 
78 | var gRPCImportBlock = `
79 | 	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
80 | 	grpczerolog "github.com/grpc-ecosystem/go-grpc-middleware/providers/zerolog/v2"
81 | 	grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
82 | 	grpc_ctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
83 | 	grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
84 | 	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
85 | 	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/tags"
86 | 	grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
87 | 	"github.com/unionj-cloud/toolkit/zlogger"
88 | 	"google.golang.org/grpc"
89 |     "github.com/unionj-cloud/go-doudou/v2/framework/grpcx"
90 | 	{{.ServiceAlias}} "{{.ServicePackage}}"
91 |     "{{.ConfigPackage}}"
92 | 	pb "{{.PbPackage}}"
93 | `
94 | 
95 | // GenMainGrpc generates main function for grpc service
96 | func GenMainGrpc(dir string, ic astutils.InterfaceCollector, grpcSvc v3.Service) {
97 | 	var (
98 | 		err      error
99 | 		mainfile string
100 | 		f        *os.File
101 | 		tpl      *template.Template
102 | 		cmdDir   string
103 | 		svcName  string
104 | 		alias    string
105 | 		source   string
106 | 	)
107 | 	cmdDir = filepath.Join(dir, "cmd")
108 | 	if err = MkdirAll(cmdDir, os.ModePerm); err != nil {
109 | 		panic(err)
110 | 	}
111 | 	svcName = ic.Interfaces[0].Name
112 | 	alias = ic.Package.Name
113 | 	mainfile = filepath.Join(cmdDir, "main.go")
114 | 	servicePkg := astutils.GetPkgPath(dir)
115 | 	cfgPkg := astutils.GetPkgPath(filepath.Join(dir, "config"))
116 | 	pbPkg := astutils.GetPkgPath(filepath.Join(dir, "transport", "grpc"))
117 | 	if _, err = Stat(mainfile); os.IsNotExist(err) {
118 | 		if f, err = Create(mainfile); err != nil {
119 | 			panic(err)
120 | 		}
121 | 		defer f.Close()
122 | 		if tpl, err = template.New("main.go.tmpl").Parse(mainTmplGrpc); err != nil {
123 | 			panic(err)
124 | 		}
125 | 		var buf bytes.Buffer
126 | 		if err = tpl.Execute(&buf, struct {
127 | 			ServicePackage string
128 | 			ConfigPackage  string
129 | 			PbPackage      string
130 | 			SvcName        string
131 | 			ServiceAlias   string
132 | 			Version        string
133 | 			GrpcSvcName    string
134 | 		}{
135 | 			ServicePackage: servicePkg,
136 | 			ConfigPackage:  cfgPkg,
137 | 			PbPackage:      pbPkg,
138 | 			SvcName:        svcName,
139 | 			ServiceAlias:   alias,
140 | 			Version:        version.Release,
141 | 			GrpcSvcName:    grpcSvc.Name,
142 | 		}); err != nil {
143 | 			panic(err)
144 | 		}
145 | 		source = strings.TrimSpace(buf.String())
146 | 		astutils.FixImport([]byte(source), mainfile)
147 | 	} else {
148 | 		if f, err = os.OpenFile(mainfile, os.O_APPEND, os.ModePerm); err != nil {
149 | 			panic(err)
150 | 		}
151 | 		defer f.Close()
152 | 		var original []byte
153 | 		if original, err = ioutil.ReadAll(f); err != nil {
154 | 			panic(err)
155 | 		}
156 | 		registerCall := fmt.Sprintf("pb.Register%sServer", grpcSvc.Name)
157 | 		if !strings.Contains(string(original), registerCall) {
158 | 			if tpl, err = template.New(appendMainTmplGrpc).Parse(appendMainTmplGrpc); err != nil {
159 | 				panic(err)
160 | 			}
161 | 			var buf bytes.Buffer
162 | 			if err = tpl.Execute(&buf, struct {
163 | 				GrpcSvcName string
164 | 			}{
165 | 				GrpcSvcName: grpcSvc.Name,
166 | 			}); err != nil {
167 | 				panic(err)
168 | 			}
169 | 			lines, err := fileutils.LinesFromReader(bytes.NewReader(original))
170 | 			if err != nil {
171 | 				panic(err)
172 | 			}
173 | 			fileContent := ""
174 | 			reg := regexp.MustCompile(fmt.Sprintf(`\.New%s\(`, svcName))
175 | 			for _, line := range lines {
176 | 				fileContent += line
177 | 				fileContent += constants.LineBreak
178 | 				if reg.MatchString(line) {
179 | 					fileContent += buf.String()
180 | 					fileContent += constants.LineBreak
181 | 				}
182 | 			}
183 | 			// fix import block
184 | 			var importBuf bytes.Buffer
185 | 			if tpl, err = template.New(gRPCImportBlock).Parse(gRPCImportBlock); err != nil {
186 | 				panic(err)
187 | 			}
188 | 			if err = tpl.Execute(&importBuf, struct {
189 | 				ServicePackage string
190 | 				ConfigPackage  string
191 | 				PbPackage      string
192 | 				SvcName        string
193 | 				ServiceAlias   string
194 | 				Version        string
195 | 				GrpcSvcName    string
196 | 			}{
197 | 				ServicePackage: servicePkg,
198 | 				ConfigPackage:  cfgPkg,
199 | 				PbPackage:      pbPkg,
200 | 				SvcName:        svcName,
201 | 				ServiceAlias:   alias,
202 | 				Version:        version.Release,
203 | 				GrpcSvcName:    grpcSvc.Name,
204 | 			}); err != nil {
205 | 				panic(err)
206 | 			}
207 | 			original = astutils.AppendImportStatements([]byte(fileContent), importBuf.Bytes())
208 | 			astutils.FixImport(original, mainfile)
209 | 		}
210 | 	}
211 | }
```

cmd/internal/svc/codegen/grpcmod.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"io/ioutil"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"regexp"
8 | 
9 | 	"github.com/unionj-cloud/toolkit/constants"
10 | 	"github.com/unionj-cloud/toolkit/fileutils"
11 | )
12 | 
13 | var goModFixGrpc = `
14 | 	github.com/grpc-ecosystem/go-grpc-middleware v1.0.1-0.20190118093823-f849b5445de4
15 | 	github.com/grpc-ecosystem/go-grpc-middleware/providers/zerolog/v2 v2.0.0-rc.2
16 | 	github.com/grpc-ecosystem/go-grpc-middleware/v2 v2.0.0-rc.2
17 | 	github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0
18 | `
19 | 
20 | // FixModGrpc ...
21 | func FixModGrpc(dir string) {
22 | 	var (
23 | 		err     error
24 | 		modfile string
25 | 	)
26 | 	modfile = filepath.Join(dir, "go.mod")
27 | 	lines, err := fileutils.File2lines(modfile)
28 | 	if err != nil {
29 | 		panic(err)
30 | 	}
31 | 	fileContent := ""
32 | 	reg := regexp.MustCompile(`require \(`)
33 | 	var found bool
34 | 	for _, line := range lines {
35 | 		fileContent += line
36 | 		fileContent += constants.LineBreak
37 | 		if reg.MatchString(line) && !found {
38 | 			found = true
39 | 			fileContent += goModFixGrpc
40 | 			fileContent += constants.LineBreak
41 | 		}
42 | 	}
43 | 	ioutil.WriteFile(modfile, []byte(fileContent), os.ModePerm)
44 | }
```

cmd/internal/svc/codegen/grpcproto.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"fmt"
5 | 	"github.com/unionj-cloud/go-doudou/v2/version"
6 | 	"os"
7 | 	"path/filepath"
8 | 	"sort"
9 | 	"strings"
10 | 	"text/template"
11 | 
12 | 	"github.com/sirupsen/logrus"
13 | 	"github.com/unionj-cloud/toolkit/astutils"
14 | 	protov3 "github.com/unionj-cloud/toolkit/protobuf/v3"
15 | 	"github.com/unionj-cloud/toolkit/templateutils"
16 | )
17 | 
18 | var protoTmpl = `/**
19 | * Generated by go-doudou {{.Version}}.
20 | * Don't edit!
21 | *
22 | * Version No.: {{.ProtoVer}}
23 | */
24 | syntax = "proto3";
25 | 
26 | package {{.Package}};
27 | option go_package = "{{.GoPackage}}";
28 | {{ range $i := .Imports }}
29 | import "{{$i}}";
30 | {{- end }}
31 | {{ range $e := .Enums }}
32 | enum {{$e.Name}} {
33 |   {{- range $f := $e.Fields }}
34 |   {{$f.Name}} = {{$f.Number}};
35 |   {{- end }}
36 | }
37 | {{- end }}
38 | 
39 | {{- range $m := .Messages }}
40 | {{ Eval "Message" $m }}
41 | {{- end }}
42 | 
43 | {{- define "Message"}}
44 | {{- if .Comments }}
45 | {{ toComment .Comments }}
46 | {{- end }}
47 | message {{.Name}} {
48 |   {{- range $f := .Fields }}
49 |   {{- if $f.Type.Inner}}
50 |   {{ Eval "Message" $f.Type }}
51 |   {{- end }}
52 |   {{- if $f.Comments }}
53 |   {{ toComment $f.Comments }}
54 |   {{- end }}
55 |   {{$f.Type.GetName | label}} {{$f.Name}} = {{$f.Number}}{{if $f.JsonName}} [json_name="{{$f.JsonName}}"]{{end}};
56 |   {{- end }}
57 | }
58 | {{- end}}
59 | 
60 | service {{.Name}} {
61 |   {{- range $r := .Rpcs }}
62 |   {{- if $r.Comments }}
63 |   {{ toComment $r.Comments }}
64 |   {{- end }}
65 |   rpc {{$r.Name}}({{$r.Request.Name}}) returns ({{$r.Response.Name}});
66 |   {{- end}}
67 | }
68 | `
69 | 
70 | func toComment(comments []string) string {
71 | 	if len(comments) == 0 {
72 | 		return ""
73 | 	}
74 | 	var b strings.Builder
75 | 	for i := range comments {
76 | 		b.WriteString(fmt.Sprintf("// %s\n", comments[i]))
77 | 	}
78 | 	return strings.TrimSuffix(b.String(), "\n")
79 | }
80 | 
81 | func GenGrpcProto(dir string, ic astutils.InterfaceCollector, p protov3.ProtoGenerator) (service protov3.Service, protoFile string) {
82 | 	var (
83 | 		err     error
84 | 		svcname string
85 | 		fi      os.FileInfo
86 | 		tpl     *template.Template
87 | 		f       *os.File
88 | 		grpcDir string
89 | 	)
90 | 	grpcDir = filepath.Join(dir, "transport", "grpc")
91 | 	if err = os.MkdirAll(grpcDir, os.ModePerm); err != nil {
92 | 		panic(err)
93 | 	}
94 | 	svcname = ic.Interfaces[0].Name
95 | 	protoFile = filepath.Join(grpcDir, strings.ToLower(svcname)+".proto")
96 | 	if fi, err = os.Stat(protoFile); err != nil && !os.IsNotExist(err) {
97 | 		panic(err)
98 | 	}
99 | 	if fi != nil {
100 | 		logrus.Warningln("file " + protoFile + " will be overwritten")
101 | 	}
102 | 	if f, err = os.Create(protoFile); err != nil {
103 | 		panic(err)
104 | 	}
105 | 	defer f.Close()
106 | 	servicePkg := astutils.GetPkgPath(dir)
107 | 	service = p.NewService(svcname, servicePkg+"/transport/grpc", version.Release)
108 | 	service.Comments = ic.Interfaces[0].Comments
109 | 	for _, method := range ic.Interfaces[0].Methods {
110 | 		rpc := p.NewRpc(method)
111 | 		if rpc == nil {
112 | 			continue
113 | 		}
114 | 		service.Rpcs = append(service.Rpcs, *rpc)
115 | 	}
116 | 	for k := range protov3.ImportStore {
117 | 		service.Imports = append(service.Imports, k)
118 | 	}
119 | 	sort.Strings(service.Imports)
120 | 	for _, v := range protov3.MessageStore {
121 | 		service.Messages = append(service.Messages, v)
122 | 	}
123 | 	sort.SliceStable(service.Messages, func(i, j int) bool {
124 | 		return service.Messages[i].Name < service.Messages[j].Name
125 | 	})
126 | 	for _, v := range protov3.EnumStore {
127 | 		service.Enums = append(service.Enums, v)
128 | 	}
129 | 	sort.SliceStable(service.Enums, func(i, j int) bool {
130 | 		return service.Enums[i].Name < service.Enums[j].Name
131 | 	})
132 | 	tpl = template.New("proto.tmpl")
133 | 	funcMap := make(map[string]interface{})
134 | 	funcMap["toComment"] = toComment
135 | 	funcMap["Eval"] = templateutils.Eval(tpl)
136 | 	funcMap["label"] = func(input string) string {
137 | 		if !strings.Contains(input, "repeated ") && !strings.Contains(input, "map<") &&
138 | 			!strings.Contains(input, "required ") && !strings.Contains(input, "optional ") {
139 | 			return "optional " + input
140 | 		}
141 | 		return input
142 | 	}
143 | 	if tpl, err = tpl.Funcs(funcMap).Parse(protoTmpl); err != nil {
144 | 		panic(err)
145 | 	}
146 | 	if err = tpl.Execute(f, service); err != nil {
147 | 		panic(err)
148 | 	}
149 | 	return
150 | }
```

cmd/internal/svc/codegen/http.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/parser"
5 | 	"github.com/unionj-cloud/toolkit/astutils"
6 | )
7 | 
8 | func genHttp(dir string, ic astutils.InterfaceCollector, caseConvertor func(string) string) {
9 | 	GenConfig(dir, ic)
10 | 	GenHttpMiddleware(dir)
11 | 	GenHttpHandler(dir, ic, 0)
12 | 	GenHttpHandlerImpl(dir, ic, GenHttpHandlerImplConfig{
13 | 		CaseConvertor: caseConvertor,
14 | 	})
15 | 	GenSvcImpl(dir, ic)
16 | 	parser.GenDoc(dir, ic, parser.GenDocConfig{})
17 | }
```

cmd/internal/svc/codegen/http2grpc.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"io/ioutil"
6 | 	"os"
7 | 	"path/filepath"
8 | 	"strings"
9 | 	"text/template"
10 | 
11 | 	"github.com/iancoleman/strcase"
12 | 	"github.com/sirupsen/logrus"
13 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
14 | 	"github.com/unionj-cloud/go-doudou/v2/version"
15 | 	"github.com/unionj-cloud/toolkit/astutils"
16 | 	"github.com/unionj-cloud/toolkit/copier"
17 | )
18 | 
19 | var appendHttp2GrpcTmpl = `
20 | {{- range $m := .Meta.Methods }}
21 | 	func (receiver *{{$.Meta.Name}}Http2Grpc) {{$m.Name}}(_writer http.ResponseWriter, _req *http.Request) {
22 |     	var (
23 | 			{{- range $p := $m.Params }}
24 | 			{{- if eq $p.Type "context.Context"}}
25 | 			{{ $p.Name }} {{ $p.Type }}
26 | 			{{- else }}
27 | 			{{$p.Name}} = new({{ trimLeft $p.Type "*" | replacePkg }})
28 | 			{{- end }}
29 | 			{{- end }}
30 | 			{{- range $r := $m.Results }}
31 | 			{{- if eq $r.Type "error"}}
32 | 			{{ $r.Name }} {{ $r.Type }}
33 | 			{{- else }}
34 | 			{{ $r.Name }} = new({{ trimLeft $r.Type "*" | replacePkg }})
35 | 			{{- end }}
36 | 			{{- end }}
37 | 		)
38 | 		{{- range $p := $m.Params }}
39 | 		{{- if eq $p.Type "context.Context" }}
40 | 		{{$p.Name}} = _req.Context()
41 | 		{{- else if and (eq $m.HttpMethod "GET") (not $.Config.AllowGetWithReqBody)}}
42 | 		if _err := _req.ParseForm(); _err != nil {
43 | 			rest.PanicBadRequestErr(_err)
44 | 		}
45 | 		if _err := rest.DecodeForm({{ $p.Name }}, _req.Form); _err != nil {
46 | 			rest.PanicBadRequestErr(_err)
47 | 		}
48 | 		if _err := rest.ValidateStruct({{ $p.Name }}); _err != nil {
49 | 			rest.PanicBadRequestErr(_err)
50 | 		}
51 | 		{{- else }}
52 | 		if _err := json.NewDecoder(_req.Body).Decode({{$p.Name}}); _err != nil {
53 | 			rest.PanicBadRequestErr(_err)	
54 | 		}
55 | 		if _err := rest.ValidateStruct({{$p.Name}}); _err != nil {
56 | 			rest.PanicBadRequestErr(_err)
57 | 		}
58 | 		{{- end }}
59 | 		{{- end }}
60 | 		{{- if eq (len $m.Results) 1 }}
61 | 		_, {{ range $i, $r := $m.Results }}{{- $r.Name }}{{- end }} = receiver.{{$.Meta.Name | toLowerCamel}}.{{$m.Name}}Rpc(
62 | 		{{- else }}
63 | 		{{ range $i, $r := $m.Results }}{{- if $i}},{{- end}}{{- $r.Name }}{{- end }} = receiver.{{$.Meta.Name | toLowerCamel}}.{{$m.Name}}Rpc(
64 | 		{{- end }}
65 | 			{{- if eq (len $m.Params) 1 }}
66 | 			{{- range $p := $m.Params }}
67 | 			{{ $p.Name }},
68 | 			{{- end }}
69 | 			new(emptypb.Empty),
70 | 			{{- else }}
71 | 			{{- range $p := $m.Params }}
72 | 			{{- if eq $p.Type "context.Context"}}
73 | 			{{ $p.Name }},
74 | 			{{- else }}
75 | 			{{$p.Name}},
76 | 			{{- end }}
77 | 			{{- end }}
78 | 			{{- end }}
79 | 		)
80 | 		{{- range $r := $m.Results }}
81 | 			{{- if eq $r.Type "error" }}
82 | 				if {{ $r.Name }} != nil {
83 | 					panic({{ $r.Name }})
84 | 				}
85 | 			{{- end }}
86 | 		{{- end }}
87 | 		_writer.Header().Set("Content-Type", "application/json; charset=UTF-8")
88 | 		{{- if eq (len $m.Results) 1 }}
89 | 			if _err := json.NewEncoder(_writer).Encode(struct {}{}); _err != nil {
90 | 				rest.HandleInternalServerError(_err)
91 | 			}
92 | 		{{- else }}
93 | 			if _err := json.NewEncoder(_writer).Encode(struct {
94 | 				{{- range $r := $m.Results }}
95 | 				{{- if ne $r.Type "error" }}
96 | 				{{ $r.Name | toCamel }} *{{ trimLeft $r.Type "*" | replacePkg }} ` + "`" + `json:"{{ $r.Name | convertCase }}{{if $.Config.Omitempty}},omitempty{{end}}"` + "`" + `
97 | 				{{- end }}
98 | 				{{- end }}
99 | 			}{
100 | 				{{- range $r := $m.Results }}
101 | 				{{- if ne $r.Type "error" }}
102 | 				{{ $r.Name | toCamel }}: {{ $r.Name }},
103 | 				{{- end }}
104 | 				{{- end }}
105 | 			}); _err != nil {
106 | 				rest.HandleInternalServerError(_err)
107 | 			}
108 | 		{{- end }}
109 |     }
110 | {{- end }}
111 | `
112 | 
113 | var initHttp2GrpcTmpl = templates.EditableHeaderTmpl + `package httpsrv
114 | 
115 | import ()
116 | 
117 | type {{.Meta.Name}}Http2Grpc struct{
118 | 	{{.Meta.Name | toLowerCamel}} pb.{{.Meta.Name}}ServiceServer
119 | }
120 | 
121 | ` + appendHttp2GrpcTmpl + `
122 | 
123 | func New{{.Meta.Name}}Http2Grpc({{.Meta.Name | toLowerCamel}} pb.{{.Meta.Name}}ServiceServer) {{.Meta.Name}}Handler {
124 | 	return &{{.Meta.Name}}Http2Grpc{
125 | 		{{.Meta.Name | toLowerCamel}},
126 | 	}
127 | }
128 | `
129 | 
130 | var importHttp2GrpcTmpl = `
131 | 	"context"
132 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
133 | 	"net/http"
134 | 	pb "{{.TransportGrpcPackage}}"
135 | `
136 | 
137 | type GenHttp2GrpcConfig struct {
138 | 	Omitempty           bool
139 | 	AllowGetWithReqBody bool
140 | 	CaseConvertor       func(string) string
141 | }
142 | 
143 | // GenHttp2Grpc generates http handler implementation
144 | // Parsed value from query string parameters or application/x-www-form-urlencoded form will be string type.
145 | // You may need to convert the type by yourself.
146 | func GenHttp2Grpc(dir string, ic astutils.InterfaceCollector, config GenHttp2GrpcConfig) {
147 | 	var (
148 | 		err             error
149 | 		handlerimplfile string
150 | 		f               *os.File
151 | 		tpl             *template.Template
152 | 		buf             bytes.Buffer
153 | 		httpDir         string
154 | 		fi              os.FileInfo
155 | 		tmpl            string
156 | 		meta            astutils.InterfaceMeta
157 | 		importBuf       bytes.Buffer
158 | 	)
159 | 	httpDir = filepath.Join(dir, "transport", "httpsrv")
160 | 	if err = os.MkdirAll(httpDir, os.ModePerm); err != nil {
161 | 		panic(err)
162 | 	}
163 | 	handlerimplfile = filepath.Join(httpDir, "http2grpc.go")
164 | 	fi, err = os.Stat(handlerimplfile)
165 | 	if err != nil && !os.IsNotExist(err) {
166 | 		panic(err)
167 | 	}
168 | 	err = copier.DeepCopy(ic.Interfaces[0], &meta)
169 | 	if err != nil {
170 | 		panic(err)
171 | 	}
172 | 	unimplementedMethods(&meta, httpDir, meta.Name+"Http2Grpc")
173 | 	if fi != nil {
174 | 		logrus.Warningln("New content will be append to http2grpc.go file")
175 | 		if f, err = os.OpenFile(handlerimplfile, os.O_APPEND, os.ModePerm); err != nil {
176 | 			panic(err)
177 | 		}
178 | 		defer f.Close()
179 | 		tmpl = appendHttp2GrpcTmpl
180 | 	} else {
181 | 		if f, err = os.Create(handlerimplfile); err != nil {
182 | 			panic(err)
183 | 		}
184 | 		defer f.Close()
185 | 		tmpl = initHttp2GrpcTmpl
186 | 	}
187 | 
188 | 	funcMap := make(map[string]interface{})
189 | 	funcMap["toLowerCamel"] = strcase.ToLowerCamel
190 | 	funcMap["replacePkg"] = func(input string) string {
191 | 		return "pb" + input[strings.LastIndex(input, "."):]
192 | 	}
193 | 	funcMap["trimLeft"] = strings.TrimLeft
194 | 	funcMap["toCamel"] = strcase.ToCamel
195 | 	funcMap["convertCase"] = config.CaseConvertor
196 | 	if tpl, err = template.New(tmpl).Funcs(funcMap).Parse(tmpl); err != nil {
197 | 		panic(err)
198 | 	}
199 | 	if err = tpl.Execute(&buf, struct {
200 | 		Meta    astutils.InterfaceMeta
201 | 		Config  GenHttp2GrpcConfig
202 | 		Version string
203 | 	}{
204 | 		Meta:    meta,
205 | 		Config:  config,
206 | 		Version: version.Release,
207 | 	}); err != nil {
208 | 		panic(err)
209 | 	}
210 | 	original, err := ioutil.ReadAll(f)
211 | 	if err != nil {
212 | 		panic(err)
213 | 	}
214 | 	original = append(original, buf.Bytes()...)
215 | 	if tpl, err = template.New(importHttp2GrpcTmpl).Parse(importHttp2GrpcTmpl); err != nil {
216 | 		panic(err)
217 | 	}
218 | 	transGrpcPkg := astutils.GetPkgPath(filepath.Join(dir, "transport", "grpc"))
219 | 	if err = tpl.Execute(&importBuf, struct {
220 | 		TransportGrpcPackage string
221 | 	}{
222 | 		TransportGrpcPackage: transGrpcPkg,
223 | 	}); err != nil {
224 | 		panic(err)
225 | 	}
226 | 	original = astutils.AppendImportStatements(original, importBuf.Bytes())
227 | 	astutils.FixImport(original, handlerimplfile)
228 | }
```

cmd/internal/svc/codegen/httpclient.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/iancoleman/strcase"
11 | 	"github.com/sirupsen/logrus"
12 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/parser"
13 | 	"github.com/unionj-cloud/toolkit/astutils"
14 | 	"github.com/unionj-cloud/toolkit/copier"
15 | 	v3helper "github.com/unionj-cloud/toolkit/openapi/v3"
16 | 	"github.com/unionj-cloud/go-doudou/v2/version"
17 | )
18 | 
19 | var clientTmpl = `/**
20 | * Generated by go-doudou {{.Version}}.
21 | * Don't edit!
22 | */
23 | package client
24 | 
25 | import (
26 | 	"context"
27 | 	"github.com/bytedance/sonic"
28 | 	"github.com/go-resty/resty/v2"
29 | 	"github.com/pkg/errors"
30 | 	"github.com/klauspost/compress/gzip"
31 | 	"github.com/unionj-cloud/toolkit/fileutils"
32 | 	"github.com/unionj-cloud/toolkit/stringutils"
33 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
34 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
35 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
36 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
37 | 	"github.com/opentracing/opentracing-go"
38 | 	"io"
39 | 	"net/http"
40 | 	"mime/multipart"
41 | 	"net/url"
42 | 	"os"
43 | 	"path/filepath"
44 | 	"strings"
45 | )
46 | 
47 | var json = sonic.ConfigDefault
48 | 
49 | type {{.Meta.Name}}Client struct {
50 | 	provider registry.IServiceProvider
51 | 	client   *resty.Client
52 | 	rootPath string
53 | }
54 | 
55 | func (receiver *{{.Meta.Name}}Client) SetRootPath(rootPath string) {
56 | 	receiver.rootPath = rootPath
57 | }
58 | 
59 | func (receiver *{{.Meta.Name}}Client) SetProvider(provider registry.IServiceProvider) {
60 | 	receiver.provider = provider
61 | }
62 | 
63 | func (receiver *{{.Meta.Name}}Client) SetClient(client *resty.Client) {
64 | 	receiver.client = client
65 | }
66 | 
67 | {{- range $m := .Meta.Methods }}
68 | 	func (receiver *{{$.Meta.Name}}Client) {{$m.Name}}(ctx context.Context, _headers map[string]string, {{- range $i, $p := $m.Params}}
69 | 	{{- if ne $p.Type "context.Context" }}
70 | 	{{- $p.Name}} {{$p.Type}},
71 | 	{{- end }}
72 |     {{- end }} options Options) (_resp *resty.Response, {{- range $i, $r := $m.Results}}
73 |                      {{- if $i}},{{end}}
74 |                      {{- $r.Name}} {{$r.Type}}
75 |                      {{- end }}) {
76 | 		var _err error
77 | 		_urlValues := url.Values{}
78 | 		_req := receiver.client.R()
79 | 		if len(_headers) > 0 {
80 | 			_req.SetHeaders(_headers)
81 | 		}
82 | 		_req.SetContext(ctx)
83 | 		{{- range $p := $m.Params }}
84 | 		{{- if $p.IsPathVariable }}
85 | 		{{- if IsEnum $p }}
86 | 		_req.SetPathParam("{{$p.Name}}", {{$p.Name}}.StringGetter())
87 | 		{{- else }}
88 | 		_req.SetPathParam("{{$p.Name}}", fmt.Sprintf("%v", {{$p.Name}}))
89 | 		{{- end }}
90 | 		{{- else if or (eq $p.Type "*multipart.FileHeader") (eq $p.Type "[]*multipart.FileHeader") }}
91 | 		{{- if contains $p.Type "["}}
92 | 		for _, _fh := range {{$p.Name}} {
93 | 			_f, _err := _fh.Open()
94 | 			if _err != nil {
95 | 				{{- range $r := $m.Results }}
96 | 					{{- if eq $r.Type "error" }}
97 | 				{{ $r.Name }} = errors.Wrap(_err, "error")
98 | 					{{- end }}
99 | 				{{- end }}
100 | 				return
101 | 			}
102 | 			_req.SetFileReader("{{$p.Name}}", _fh.Filename, _f)
103 | 		}
104 | 		{{- else}}
105 | 		if _f, _err := {{$p.Name}}.Open(); _err != nil {
106 | 			{{- range $r := $m.Results }}
107 | 				{{- if eq $r.Type "error" }}
108 | 			{{ $r.Name }} = errors.Wrap(_err, "error")
109 | 				{{- end }}
110 | 			{{- end }}
111 | 			return
112 | 		} else {
113 | 			_req.SetFileReader("{{$p.Name}}", {{$p.Name}}.Filename, _f)
114 | 		}
115 | 		{{- end}}
116 | 		{{- else if or (eq $p.Type "v3.FileModel") (eq $p.Type "*v3.FileModel") (eq $p.Type "[]v3.FileModel") (eq $p.Type "*[]v3.FileModel") (eq $p.Type "...v3.FileModel") }}
117 | 		{{- if isSlice $p.Type }}
118 | 		{{- if isOptional $p.Type }}
119 | 		if {{$p.Name}} != nil {
120 | 			{{- if isVarargs $p.Type }}
121 | 			for _, _f := range {{$p.Name}} {
122 | 			{{- else }}
123 | 			for _, _f := range *{{$p.Name}} {
124 | 			{{- end }}
125 | 				_req.SetFileReader("{{$p.Name}}", _f.Filename, _f.Reader)
126 | 			}
127 | 		}
128 | 		{{- else }}
129 | 		if len({{$p.Name}}) == 0 {
130 | 			{{- range $r := $m.Results }}
131 | 				{{- if eq $r.Type "error" }}
132 | 			{{ $r.Name }} = errors.New("at least one file should be uploaded for parameter {{$p.Name}}")
133 | 				{{- end }}
134 | 			{{- end }}
135 | 			return
136 | 		}
137 | 		for _, _f := range {{$p.Name}} {
138 | 			_req.SetFileReader("{{$p.Name}}", _f.Filename, _f.Reader)
139 | 		}
140 | 		{{- end }}
141 | 		{{- else }}
142 | 		{{- if isOptional $p.Type }}
143 | 		if {{$p.Name}} != nil { 
144 | 			_req.SetFileReader("{{$p.Name}}", {{$p.Name}}.Filename, {{$p.Name}}.Reader)
145 | 		}
146 | 		{{- else }}
147 | 		_req.SetFileReader("{{$p.Name}}", {{$p.Name}}.Filename, {{$p.Name}}.Reader)
148 | 		{{- end }}
149 | 		{{- end }}
150 | 		{{- else if eq $p.Type "context.Context" }}
151 | 		{{- else if not (isBuiltin $p)}}
152 | 		{{- if and (eq $m.HttpMethod "GET") (not $.Config.AllowGetWithReqBody) }}
153 | 		{{$p.Name}}UrlValues, _err := rest.EncodeForm(&{{$p.Name}})
154 | 		if _err != nil {
155 | 			{{- range $r := $m.Results }}
156 | 				{{- if eq $r.Type "error" }}
157 | 			{{ $r.Name }} = errors.Wrap(_err, "error")
158 | 				{{- end }}
159 | 			{{- end }}
160 | 			return
161 | 		}
162 | 		_req.SetQueryParamsFromValues({{$p.Name}}UrlValues)
163 | 		{{- else }}
164 | 		if options.GzipReqBody {
165 | 			pr, pw := io.Pipe()
166 | 			go func() {
167 | 				gw := gzip.NewWriter(pw)
168 | 				_err = json.NewEncoder(gw).Encode({{$p.Name}})
169 | 				if _err != nil {
170 | 					{{- range $r := $m.Results }}
171 | 						{{- if eq $r.Type "error" }}
172 | 					{{ $r.Name }} = errors.Wrap(_err, "error")
173 | 						{{- end }}
174 | 					{{- end }}
175 | 					return
176 | 				}
177 | 				_err = gw.Close()
178 | 				if _err != nil {
179 | 					{{- range $r := $m.Results }}
180 | 						{{- if eq $r.Type "error" }}
181 | 					{{ $r.Name }} = errors.Wrap(_err, "error")
182 | 						{{- end }}
183 | 					{{- end }}
184 | 					return
185 | 				}
186 | 				{{- range $r := $m.Results }}
187 | 					{{- if eq $r.Type "error" }}
188 | 				defer pw.CloseWithError({{ $r.Name }})
189 | 					{{- end }}
190 | 				{{- end }}
191 | 			}()
192 | 			_req.SetHeader("Content-Type", "application/json")
193 | 			_req.SetHeader("Content-Encoding", "gzip")
194 | 			_req.SetBody(pr)
195 | 		} else {
196 | 			_req.SetBody({{$p.Name}})
197 | 		}
198 | 		{{- end }}
199 | 		{{- else if isSlice $p.Type }}
200 | 		{{- if isOptional $p.Type }}
201 | 		if {{$p.Name}} != nil { 
202 | 			{{- if isVarargs $p.Type }}
203 | 			for _, _item := range {{$p.Name}} {
204 | 			{{- else }}
205 | 			for _, _item := range *{{$p.Name}} {
206 | 			{{- end }}
207 | 				{{- if IsEnum $p }}
208 | 				_urlValues.Add("{{$p.Name}}", _item.StringGetter())
209 | 				{{- else }}
210 | 				_urlValues.Add("{{$p.Name}}", fmt.Sprintf("%v", _item))
211 | 				{{- end }}
212 | 			}
213 | 		}
214 | 		{{- else }}
215 | 		if len({{$p.Name}}) == 0 {
216 | 			{{- range $r := $m.Results }}
217 | 				{{- if eq $r.Type "error" }}
218 | 			{{ $r.Name }} = errors.New("size of parameter {{$p.Name}} should be greater than zero")
219 | 				{{- end }}
220 | 			{{- end }}
221 | 			return
222 | 		}
223 | 		for _, _item := range {{$p.Name}} {
224 | 			{{- if IsEnum $p }}
225 | 			_urlValues.Add("{{$p.Name}}", _item.StringGetter())
226 | 			{{- else }}
227 | 			_urlValues.Add("{{$p.Name}}", fmt.Sprintf("%v", _item))
228 | 			{{- end }}
229 | 		}
230 | 		{{- end}}
231 | 		{{- else }}
232 | 		{{- if isOptional $p.Type }}
233 | 		if {{$p.Name}} != nil { 
234 |             {{- if IsEnum $p }}
235 | 			_urlValues.Set("{{$p.Name}}", {{$p.Name}}.StringGetter())
236 | 			{{- else }}
237 | 			_urlValues.Set("{{$p.Name}}", fmt.Sprintf("%v", *{{$p.Name}}))
238 | 			{{- end }}
239 | 		}
240 | 		{{- else }}
241 | 		{{- if IsEnum $p }}
242 | 		_urlValues.Set("{{$p.Name}}", {{$p.Name}}.StringGetter())
243 | 		{{- else }}
244 | 		_urlValues.Set("{{$p.Name}}", fmt.Sprintf("%v", {{$p.Name}}))
245 | 		{{- end }}
246 | 		{{- end }}
247 | 		{{- end }}
248 | 		{{- end }}
249 | 
250 | 		{{- range $r := $m.Results }}
251 | 			{{- if eq $r.Type "*os.File" }}
252 | 				_req.SetDoNotParseResponse(true)
253 | 			{{- end }}
254 | 		{{- end }}
255 | 
256 | 		{{- if eq $.Config.RoutePatternStrategy 1}}
257 | 		_path := "/{{$.Meta.Name | lower}}/{{$m.Name | noSplitPattern}}"
258 | 		{{- else }}
259 | 		_path := "/{{$m.Name | pattern}}"
260 | 		{{- end }}
261 | 
262 | 		{{- if eq $m.HttpMethod "GET" }}
263 | 		_req.SetQueryParamsFromValues(_urlValues)
264 | 		{{- else }}
265 | 		if _req.Body != nil {
266 | 			_req.SetQueryParamsFromValues(_urlValues)
267 | 		} else {
268 | 			_req.SetFormDataFromValues(_urlValues)
269 | 		}
270 | 		{{- end }}
271 | 		_resp, _err = _req.{{$m.Name | restyMethod}}(_path)
272 | 		if _err != nil {
273 | 			{{- range $r := $m.Results }}
274 | 				{{- if eq $r.Type "error" }}
275 | 			{{ $r.Name }} = errors.Wrap(_err, "error")
276 | 				{{- end }}
277 | 			{{- end }}
278 | 			return
279 | 		}
280 | 		if _resp.IsError() {
281 | 			{{- range $r := $m.Results }}
282 | 				{{- if eq $r.Type "error" }}
283 | 			{{ $r.Name }} = errors.New(_resp.String())
284 | 				{{- end }}
285 | 			{{- end }}
286 | 			return
287 | 		}
288 | 		{{- $done := false }}
289 | 		{{- range $r := $m.Results }}
290 | 			{{- if eq $r.Type "*os.File" }}
291 | 				_disp := _resp.Header().Get("Content-Disposition")
292 | 				_file := strings.TrimPrefix(_disp, "attachment; filename=")
293 | 				_output := os.TempDir()
294 | 				if stringutils.IsNotEmpty(_output) {
295 | 					_file = _output + string(filepath.Separator) + _file
296 | 				}
297 | 				_file = filepath.Clean(_file)
298 | 				if _err = fileutils.CreateDirectory(filepath.Dir(_file)); _err != nil {
299 | 					{{- range $r := $m.Results }}
300 | 						{{- if eq $r.Type "error" }}
301 | 					{{ $r.Name }} = errors.Wrap(_err, "error")
302 | 						{{- end }}
303 | 					{{- end }}
304 | 					return
305 | 				}
306 | 				_outFile, _err := os.Create(_file)
307 | 				if _err != nil {
308 | 					{{- range $r := $m.Results }}
309 | 						{{- if eq $r.Type "error" }}
310 | 					{{ $r.Name }} = errors.Wrap(_err, "error")
311 | 						{{- end }}
312 | 					{{- end }}
313 | 					return
314 | 				}
315 | 				defer _outFile.Close()
316 | 				defer _resp.RawBody().Close()
317 | 				_, _err = io.Copy(_outFile, _resp.RawBody())
318 | 				if _err != nil {
319 | 					{{- range $r := $m.Results }}
320 | 						{{- if eq $r.Type "error" }}
321 | 					{{ $r.Name }} = errors.Wrap(_err, "error")
322 | 						{{- end }}
323 | 					{{- end }}
324 | 					return
325 | 				}
326 | 				{{ $r.Name }} = _outFile
327 | 				return
328 | 				{{- $done = true }}	
329 | 			{{- end }}
330 | 		{{- end }}
331 | 		{{- if not $done }}
332 | 			var _result struct {
333 | 				{{- range $r := $m.Results }}
334 | 				{{- if ne $r.Type "error" }}
335 | 				{{ $r.Name | toCamel }} {{ $r.Type }} ` + "`" + `json:"{{ $r.Name | convertCase }}"` + "`" + `
336 | 				{{- end }}
337 | 				{{- end }}
338 | 			}
339 | 			if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
340 | 				{{- range $r := $m.Results }}
341 | 					{{- if eq $r.Type "error" }}
342 | 				{{ $r.Name }} = errors.Wrap(_err, "error")
343 | 					{{- end }}
344 | 				{{- end }}
345 | 				return
346 | 			}
347 | 			return _resp, {{range $i, $r := $m.Results }}{{- if $i}},{{end}}{{ if eq $r.Type "error" }}nil{{else}}_result.{{ $r.Name | toCamel }}{{end}}{{- end }}
348 | 		{{- end }}    
349 | 	}
350 | {{- end }}
351 | 
352 | func New{{.Meta.Name}}Client(opts ...restclient.RestClientOption) *{{.Meta.Name}}Client {
353 | 	{{- if .Config.Env }}
354 | 	defaultProvider := restclient.NewServiceProvider("{{.Config.Env}}")
355 | 	{{- else }}
356 | 	defaultProvider := restclient.NewServiceProvider("{{.Meta.Name | toUpper}}")
357 | 	{{- end }}
358 | 	defaultClient := restclient.NewClient()
359 | 
360 | 	svcClient := &{{.Meta.Name}}Client{
361 | 		provider: defaultProvider,
362 | 		client:   defaultClient,
363 | 	}
364 | 
365 | 	for _, opt := range opts {
366 | 		opt(svcClient)
367 | 	}
368 | 
369 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
370 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
371 | 		return nil
372 | 	})
373 | 
374 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
375 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
376 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
377 | 		*request = *traceReq
378 | 		return nil
379 | 	})
380 | 
381 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
382 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
383 | 		return nil
384 | 	})
385 | 
386 | 	return svcClient
387 | }
388 | `
389 | 
390 | func restyMethod(method string) string {
391 | 	hm, _ := astutils.Pattern(method)
392 | 	return strings.Title(strings.ToLower(hm))
393 | }
394 | 
395 | type GenGoClientConfig struct {
396 | 	Env                  string
397 | 	RoutePatternStrategy int
398 | 	AllowGetWithReqBody  bool
399 | 	CaseConvertor        func(string) string
400 | }
401 | 
402 | // GenGoClient generates golang http client code from result of parsing svc.go file in project root path
403 | func GenGoClient(dir string, ic astutils.InterfaceCollector, config GenGoClientConfig) {
404 | 	var (
405 | 		err        error
406 | 		clientfile string
407 | 		f          *os.File
408 | 		tpl        *template.Template
409 | 		sqlBuf     bytes.Buffer
410 | 		clientDir  string
411 | 		fi         os.FileInfo
412 | 		source     string
413 | 		meta       astutils.InterfaceMeta
414 | 	)
415 | 	clientDir = filepath.Join(dir, "client")
416 | 	if err = MkdirAll(clientDir, os.ModePerm); err != nil {
417 | 		panic(err)
418 | 	}
419 | 
420 | 	clientfile = filepath.Join(clientDir, "client.go")
421 | 	fi, err = Stat(clientfile)
422 | 	if err != nil && !os.IsNotExist(err) {
423 | 		panic(err)
424 | 	}
425 | 	if fi != nil {
426 | 		logrus.Warningln("file client.go will be overwritten")
427 | 	}
428 | 	if f, err = Create(clientfile); err != nil {
429 | 		panic(err)
430 | 	}
431 | 	defer f.Close()
432 | 
433 | 	_ = copier.DeepCopy(ic.Interfaces[0], &meta)
434 | 
435 | 	funcMap := make(map[string]interface{})
436 | 	funcMap["toLowerCamel"] = strcase.ToLowerCamel
437 | 	funcMap["toCamel"] = strcase.ToCamel
438 | 	funcMap["pattern"] = parser.ApiPattern
439 | 	funcMap["lower"] = strings.ToLower
440 | 	funcMap["contains"] = strings.Contains
441 | 	funcMap["isBuiltin"] = v3helper.IsBuiltin
442 | 	funcMap["restyMethod"] = restyMethod
443 | 	funcMap["toUpper"] = strings.ToUpper
444 | 	funcMap["noSplitPattern"] = parser.NoSplitPattern
445 | 	funcMap["isOptional"] = v3helper.IsOptional
446 | 	funcMap["convertCase"] = config.CaseConvertor
447 | 	funcMap["isSlice"] = v3helper.IsSlice
448 | 	funcMap["isVarargs"] = v3helper.IsVarargs
449 | 	funcMap["IsEnum"] = v3helper.IsEnum
450 | 	if tpl, err = template.New("client.go.tmpl").Funcs(funcMap).Parse(clientTmpl); err != nil {
451 | 		panic(err)
452 | 	}
453 | 	if err = tpl.Execute(&sqlBuf, struct {
454 | 		Meta    astutils.InterfaceMeta
455 | 		Config  GenGoClientConfig
456 | 		Version string
457 | 	}{
458 | 		Meta:    meta,
459 | 		Config:  config,
460 | 		Version: version.Release,
461 | 	}); err != nil {
462 | 		panic(err)
463 | 	}
464 | 	source = strings.TrimSpace(sqlBuf.String())
465 | 	astutils.FixImport([]byte(source), clientfile)
466 | }
```

cmd/internal/svc/codegen/httpclient_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/iancoleman/strcase"
9 | 	"github.com/pkg/errors"
10 | 	. "github.com/smartystreets/goconvey/convey"
11 | 	"github.com/unionj-cloud/toolkit/astutils"
12 | )
13 | 
14 | func TestGenGoClient(t *testing.T) {
15 | 	dir := testDir + "client1"
16 | 	InitSvc(dir)
17 | 	defer os.RemoveAll(dir)
18 | 	svcfile := filepath.Join(dir, "svc.go")
19 | 	ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
20 | 
21 | 	type args struct {
22 | 		dir string
23 | 		ic  astutils.InterfaceCollector
24 | 	}
25 | 	tests := []struct {
26 | 		name string
27 | 		args args
28 | 	}{
29 | 		{
30 | 			name: "",
31 | 			args: args{
32 | 				dir: dir,
33 | 				ic:  ic,
34 | 			},
35 | 		},
36 | 	}
37 | 	for _, tt := range tests {
38 | 		t.Run(tt.name, func(t *testing.T) {
39 | 			GenGoClient(tt.args.dir, tt.args.ic, GenGoClientConfig{
40 | 				Env:                  "",
41 | 				RoutePatternStrategy: 1,
42 | 				AllowGetWithReqBody:  false,
43 | 				CaseConvertor:        strcase.ToLowerCamel,
44 | 			})
45 | 		})
46 | 	}
47 | }
48 | 
49 | func TestGenGoClientPanic_Stat(t *testing.T) {
50 | 	Convey("Test GenGoClient panic from Stat", t, func() {
51 | 		MkdirAll = os.MkdirAll
52 | 		Open = os.Open
53 | 		Create = os.Create
54 | 		Stat = os.Stat
55 | 		Stat = func(name string) (os.FileInfo, error) {
56 | 			return nil, errors.New("mock Stat error")
57 | 		}
58 | 
59 | 		svcfile := filepath.Join(testDir, "svc.go")
60 | 		ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
61 | 
62 | 		So(func() {
63 | 			GenGoClient(testDir, ic, GenGoClientConfig{
64 | 				Env:                  "",
65 | 				RoutePatternStrategy: 1,
66 | 				AllowGetWithReqBody:  false,
67 | 				CaseConvertor:        strcase.ToLowerCamel,
68 | 			})
69 | 		}, ShouldPanic)
70 | 	})
71 | }
72 | 
73 | func TestGenGoClientPanic_Create(t *testing.T) {
74 | 	Convey("Test GenGoClient panic from Create", t, func() {
75 | 		MkdirAll = os.MkdirAll
76 | 		Open = os.Open
77 | 		Create = os.Create
78 | 		Stat = os.Stat
79 | 		Create = func(name string) (*os.File, error) {
80 | 			return nil, errors.New("mock Create error")
81 | 		}
82 | 		svcfile := filepath.Join(testDir, "svc.go")
83 | 		ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
84 | 
85 | 		So(func() {
86 | 			GenGoClient(testDir, ic, GenGoClientConfig{
87 | 				Env:                  "",
88 | 				RoutePatternStrategy: 1,
89 | 				AllowGetWithReqBody:  false,
90 | 				CaseConvertor:        strcase.ToLowerCamel,
91 | 			})
92 | 		}, ShouldPanic)
93 | 	})
94 | }
95 | 
96 | func TestGenGoClientPanic_Open(t *testing.T) {
97 | 	Convey("Test GenGoClient panic from Open", t, func() {
98 | 		MkdirAll = os.MkdirAll
99 | 		Open = os.Open
100 | 		Create = os.Create
101 | 		Stat = os.Stat
102 | 		Open = func(name string) (*os.File, error) {
103 | 			return nil, errors.New("mock Open error")
104 | 		}
105 | 		svcfile := filepath.Join(testDir, "svc.go")
106 | 		ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
107 | 
108 | 		So(func() {
109 | 			GenGoClient(testDir, ic, GenGoClientConfig{
110 | 				Env:                  "",
111 | 				RoutePatternStrategy: 1,
112 | 				AllowGetWithReqBody:  false,
113 | 				CaseConvertor:        strcase.ToLowerCamel,
114 | 			})
115 | 		}, ShouldPanic)
116 | 	})
117 | }
118 | 
119 | func TestGenGoClientPanic_MkdirAll(t *testing.T) {
120 | 	Convey("Test GenGoClient panic from MkdirAll", t, func() {
121 | 		MkdirAll = os.MkdirAll
122 | 		Open = os.Open
123 | 		Create = os.Create
124 | 		Stat = os.Stat
125 | 		MkdirAll = func(path string, perm os.FileMode) error {
126 | 			return errors.New("mock MkdirAll error")
127 | 		}
128 | 		svcfile := filepath.Join(testDir, "svc.go")
129 | 		ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
130 | 
131 | 		So(func() {
132 | 			GenGoClient(testDir, ic, GenGoClientConfig{
133 | 				Env:                  "",
134 | 				RoutePatternStrategy: 1,
135 | 				AllowGetWithReqBody:  false,
136 | 				CaseConvertor:        strcase.ToLowerCamel,
137 | 			})
138 | 		}, ShouldPanic)
139 | 	})
140 | }
```

cmd/internal/svc/codegen/httpclientproxy.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"go/ast"
6 | 	"go/parser"
7 | 	"go/token"
8 | 	"io/ioutil"
9 | 	"os"
10 | 	"path/filepath"
11 | 	"text/template"
12 | 
13 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
14 | 	"github.com/unionj-cloud/toolkit/astutils"
15 | 	"github.com/unionj-cloud/toolkit/copier"
16 | 	v3helper "github.com/unionj-cloud/toolkit/openapi/v3"
17 | 	"github.com/unionj-cloud/toolkit/zlogger"
18 | 	"github.com/unionj-cloud/go-doudou/v2/version"
19 | )
20 | 
21 | var cpimportTmpl = `
22 | 	"context"
23 | 	"github.com/pkg/errors"
24 | 	"github.com/prometheus/client_golang/prometheus"
25 | 	"github.com/rs/zerolog"
26 | 	"github.com/unionj-cloud/toolkit/zlogger"
27 | 	"github.com/slok/goresilience"
28 | 	"github.com/go-resty/resty/v2"
29 | 	"github.com/slok/goresilience/circuitbreaker"
30 | 	rerrors "github.com/slok/goresilience/errors"
31 | 	"github.com/slok/goresilience/metrics"
32 | 	"github.com/slok/goresilience/retry"
33 | 	"github.com/slok/goresilience/timeout"
34 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
35 | 	"os"
36 | 	"time"
37 | `
38 | 
39 | var appendTmpl = `
40 | {{- range $m := .Meta.Methods }}
41 | 	func (receiver *{{$.SvcName}}ClientProxy) {{$m.Name}}(ctx context.Context, _headers map[string]string, {{- range $i, $p := $m.Params}}
42 | 	{{- if ne $p.Type "context.Context" }}
43 | 	{{- $p.Name}} {{$p.Type}},
44 | 	{{- end }}
45 |     {{- end }} options Options) (_resp *resty.Response, {{- range $i, $r := $m.Results}}
46 |                      {{- if $i}},{{end}}
47 |                      {{- $r.Name}} {{$r.Type}}
48 |                      {{- end }}) {
49 | 		if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
50 | 			_resp, {{ range $i, $r := $m.Results }}{{- if $i}},{{- end}}{{- $r.Name }}{{- end }} = receiver.client.{{$m.Name}}(
51 | 				ctx,
52 | 				_headers,
53 | 				{{- range $p := $m.Params }}
54 | 				{{- if ne $p.Type "context.Context" }}
55 | 				{{- if isVarargs $p.Type }}
56 | 				{{ $p.Name }}...,
57 | 				{{- else }}
58 | 				{{ $p.Name }},
59 | 				{{- end }}
60 | 				{{- end }}
61 | 				{{- end }}
62 | 				options,
63 | 			)
64 | 			{{- range $r := $m.Results }}
65 | 				{{- if eq $r.Type "error" }}
66 | 					if {{ $r.Name }} != nil {
67 | 						return errors.Wrap({{ $r.Name }}, "call {{$m.Name}} fail")
68 | 					}
69 | 				{{- end }}
70 | 			{{- end }}
71 | 			return nil
72 | 		}); _err != nil {
73 | 			// you can implement your fallback logic here
74 | 			if errors.Is(_err, rerrors.ErrCircuitOpen) {
75 | 				receiver.logger.Error().Err(_err).Msg("")
76 | 			}
77 | 			{{- range $r := $m.Results }}
78 | 				{{- if eq $r.Type "error" }}
79 | 					{{ $r.Name }} = errors.Wrap(_err, "call {{$m.Name}} fail")
80 | 				{{- end }}
81 | 			{{- end }}
82 | 		}
83 | 		return
84 | 	}
85 | {{- end }}
86 | `
87 | 
88 | var baseTmpl = templates.EditableHeaderTmpl + `package client
89 | 
90 | import ()
91 | 
92 | type {{.SvcName}}ClientProxy struct {
93 | 	client *{{.SvcName}}Client
94 | 	logger zerolog.Logger
95 | 	runner goresilience.Runner
96 | }
97 | 
98 | ` + appendTmpl + `
99 | 
100 | type ProxyOption func(*{{.SvcName}}ClientProxy)
101 | 
102 | func WithRunner(runner goresilience.Runner) ProxyOption {
103 | 	return func(proxy *{{.SvcName}}ClientProxy) {
104 | 		proxy.runner = runner
105 | 	}
106 | }
107 | 
108 | func WithLogger(logger zerolog.Logger) ProxyOption {
109 | 	return func(proxy *{{.SvcName}}ClientProxy) {
110 | 		proxy.logger = logger
111 | 	}
112 | }
113 | 
114 | func New{{.SvcName}}ClientProxy(client *{{.SvcName}}Client, opts ...ProxyOption) *{{.SvcName}}ClientProxy {
115 | 	cp := &{{.SvcName}}ClientProxy{
116 | 		client: client,
117 | 		logger: zlogger.Logger,
118 | 	}
119 | 
120 | 	for _, opt := range opts {
121 | 		opt(cp)
122 | 	}
123 | 
124 | 	if cp.runner == nil {
125 | 		var mid []goresilience.Middleware
126 | 		mid = append(mid, metrics.NewMiddleware("{{.ServicePackage}}_client", metrics.NewPrometheusRecorder(prometheus.DefaultRegisterer)))
127 | 		mid = append(mid, circuitbreaker.NewMiddleware(circuitbreaker.Config{
128 | 			ErrorPercentThresholdToOpen:        50,
129 | 			MinimumRequestToOpen:               6,
130 | 			SuccessfulRequiredOnHalfOpen:       1,
131 | 			WaitDurationInOpenState:            5 * time.Second,
132 | 			MetricsSlidingWindowBucketQuantity: 10,
133 | 			MetricsBucketDuration:              1 * time.Second,
134 | 		}),
135 | 			timeout.NewMiddleware(timeout.Config{
136 | 				Timeout: 3 * time.Minute,
137 | 			}),
138 | 			retry.NewMiddleware(retry.Config{
139 | 				Times: 3,
140 | 			}))
141 | 
142 | 		cp.runner = goresilience.RunnerChain(mid...)
143 | 	}
144 | 
145 | 	return cp
146 | }
147 | `
148 | 
149 | func unimplementedSvcMethods(meta *astutils.InterfaceMeta, clientfile string) {
150 | 	fset := token.NewFileSet()
151 | 	root, err := parser.ParseFile(fset, clientfile, nil, parser.ParseComments)
152 | 	if err != nil {
153 | 		panic(err)
154 | 	}
155 | 	sc := astutils.NewStructCollector(astutils.ExprString)
156 | 	ast.Walk(sc, root)
157 | 	if handlers, exists := sc.Methods[meta.Name+"ClientProxy"]; exists {
158 | 		var notimplemented []astutils.MethodMeta
159 | 		for _, item := range meta.Methods {
160 | 			for _, handler := range handlers {
161 | 				if item.Name == handler.Name {
162 | 					goto L
163 | 				}
164 | 			}
165 | 			notimplemented = append(notimplemented, item)
166 | 
167 | 		L:
168 | 		}
169 | 
170 | 		meta.Methods = notimplemented
171 | 	}
172 | }
173 | 
174 | // GenGoClientProxy wraps client with resiliency features
175 | func GenGoClientProxy(dir string, ic astutils.InterfaceCollector) {
176 | 	var (
177 | 		err             error
178 | 		clientfile      string
179 | 		f               *os.File
180 | 		tpl             *template.Template
181 | 		buf             bytes.Buffer
182 | 		clientDir       string
183 | 		fi              os.FileInfo
184 | 		meta            astutils.InterfaceMeta
185 | 		clientProxyTmpl string
186 | 		importBuf       bytes.Buffer
187 | 	)
188 | 	clientDir = filepath.Join(dir, "client")
189 | 	if err = os.MkdirAll(clientDir, os.ModePerm); err != nil {
190 | 		panic(err)
191 | 	}
192 | 
193 | 	clientfile = filepath.Join(clientDir, "clientproxy.go")
194 | 	fi, err = os.Stat(clientfile)
195 | 	if err != nil && !os.IsNotExist(err) {
196 | 		panic(err)
197 | 	}
198 | 	err = copier.DeepCopy(ic.Interfaces[0], &meta)
199 | 	if err != nil {
200 | 		panic(err)
201 | 	}
202 | 	if fi != nil {
203 | 		zlogger.Warn().Msg("New content will be append to clientproxy.go file")
204 | 		if f, err = os.OpenFile(clientfile, os.O_APPEND, os.ModePerm); err != nil {
205 | 			panic(err)
206 | 		}
207 | 		defer f.Close()
208 | 		clientProxyTmpl = appendTmpl
209 | 
210 | 		unimplementedSvcMethods(&meta, clientfile)
211 | 	} else {
212 | 		if f, err = os.Create(clientfile); err != nil {
213 | 			panic(err)
214 | 		}
215 | 		defer f.Close()
216 | 		clientProxyTmpl = baseTmpl
217 | 	}
218 | 
219 | 	servicePkg := astutils.GetPkgPath(dir)
220 | 	cfgPkg := astutils.GetPkgPath(filepath.Join(dir, "config"))
221 | 
222 | 	funcMap := make(map[string]interface{})
223 | 	funcMap["isVarargs"] = v3helper.IsVarargs
224 | 	if tpl, err = template.New("clientproxy.go.tmpl").Funcs(funcMap).Parse(clientProxyTmpl); err != nil {
225 | 		panic(err)
226 | 	}
227 | 	if err = tpl.Execute(&buf, struct {
228 | 		Meta           astutils.InterfaceMeta
229 | 		ServicePackage string
230 | 		ServiceAlias   string
231 | 		SvcName        string
232 | 		Version        string
233 | 	}{
234 | 		Meta:           meta,
235 | 		ServicePackage: servicePkg,
236 | 		ServiceAlias:   ic.Package.Name,
237 | 		SvcName:        ic.Interfaces[0].Name,
238 | 		Version:        version.Release,
239 | 	}); err != nil {
240 | 		panic(err)
241 | 	}
242 | 
243 | 	original, err := ioutil.ReadAll(f)
244 | 	if err != nil {
245 | 		panic(err)
246 | 	}
247 | 
248 | 	original = append(original, buf.Bytes()...)
249 | 	if tpl, err = template.New("cpimportimpl.go.tmpl").Parse(cpimportTmpl); err != nil {
250 | 		panic(err)
251 | 	}
252 | 	if err = tpl.Execute(&importBuf, struct {
253 | 		ConfigPackage string
254 | 	}{
255 | 		ConfigPackage: cfgPkg,
256 | 	}); err != nil {
257 | 		panic(err)
258 | 	}
259 | 	original = astutils.AppendImportStatements(original, importBuf.Bytes())
260 | 	astutils.FixImport(original, clientfile)
261 | }
```

cmd/internal/svc/codegen/httpclientproxy_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/unionj-cloud/toolkit/astutils"
9 | )
10 | 
11 | func TestGenGoClientProxy1(t *testing.T) {
12 | 	dir := testDir + "clientproxy"
13 | 	InitSvc(dir)
14 | 	defer os.RemoveAll(dir)
15 | 	svcfile := filepath.Join(testDir, "svc.go")
16 | 	ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
17 | 
18 | 	type args struct {
19 | 		dir string
20 | 		ic  astutils.InterfaceCollector
21 | 	}
22 | 	tests := []struct {
23 | 		name string
24 | 		args args
25 | 	}{
26 | 		{
27 | 			name: "",
28 | 			args: args{
29 | 				dir: dir,
30 | 				ic:  ic,
31 | 			},
32 | 		},
33 | 	}
34 | 	for _, tt := range tests {
35 | 		t.Run(tt.name, func(t *testing.T) {
36 | 			GenGoClientProxy(tt.args.dir, tt.args.ic)
37 | 		})
38 | 	}
39 | }
```

cmd/internal/svc/codegen/httphandler.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/parser"
11 | 	"github.com/unionj-cloud/go-doudou/v2/version"
12 | 
13 | 	"github.com/sirupsen/logrus"
14 | 	"github.com/unionj-cloud/toolkit/astutils"
15 | )
16 | 
17 | var httpHandlerTmpl = `/**
18 | * Generated by go-doudou {{.Version}}.
19 | * Don't edit!
20 | */
21 | package httpsrv
22 | 
23 | import (
24 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
25 | 	"github.com/unionj-cloud/go-doudou/v2/framework"
26 | 	"net/http"
27 | )
28 | 
29 | type {{.Meta.Name}}Handler interface {
30 | {{- range $m := .Meta.Methods }}
31 | 	{{$m.Name}}(w http.ResponseWriter, r *http.Request)
32 | {{- end }}
33 | }
34 | 
35 | func Routes(handler {{.Meta.Name}}Handler) []rest.Route {
36 | 	return []rest.Route{
37 | 		{{- range $m := .Meta.Methods }}
38 | 		{
39 | 			Name: "{{$m.Name}}",
40 | 			Method: "{{$m.HttpMethod}}",
41 | 			Pattern: {{- if eq $.RoutePatternStrategy 1}}"/{{$.Meta.Name | lower}}/{{$m.Name | noSplitPattern}}",{{- else }}"/{{$m.Name | pattern}}",{{- end }}
42 | 			HandlerFunc: handler.{{$m.Name}},
43 | 		},
44 | 		{{- end }}
45 | 	}
46 | }
47 | 
48 | 
49 | var RouteAnnotationStore = framework.AnnotationStore{
50 | 	{{- range $m := .Meta.Methods }}
51 | 	{{- if $m.Annotations }}
52 | 	"{{$m.Name}}": {
53 | 		{{- range $a := $m.Annotations }}
54 | 		{
55 | 			Name:   "{{ $a.Name }}",
56 | 			{{- if $a.Params }}
57 | 			Params: []string{
58 | 				{{- range $p := $a.Params }}
59 | 				"{{ $p }}",
60 | 				{{- end }}
61 | 			},
62 | 			{{- end }}
63 | 		},
64 | 		{{- end }}
65 | 	},
66 | 	{{- end }}
67 | 	{{- end }}
68 | }
69 | `
70 | 
71 | // GenHttpHandler generates http handler interface and routes
72 | func GenHttpHandler(dir string, ic astutils.InterfaceCollector, routePatternStrategy int) {
73 | 	var (
74 | 		err         error
75 | 		handlerfile string
76 | 		f           *os.File
77 | 		tpl         *template.Template
78 | 		httpDir     string
79 | 		source      string
80 | 		buf         bytes.Buffer
81 | 		fi          os.FileInfo
82 | 	)
83 | 	httpDir = filepath.Join(dir, "transport/httpsrv")
84 | 	if err = os.MkdirAll(httpDir, os.ModePerm); err != nil {
85 | 		panic(err)
86 | 	}
87 | 
88 | 	handlerfile = filepath.Join(httpDir, "handler.go")
89 | 	fi, err = os.Stat(handlerfile)
90 | 	if err != nil && !os.IsNotExist(err) {
91 | 		panic(err)
92 | 	}
93 | 	if fi != nil {
94 | 		logrus.Warningln("file handler.go will be overwritten")
95 | 	}
96 | 	if f, err = os.Create(handlerfile); err != nil {
97 | 		panic(err)
98 | 	}
99 | 	defer f.Close()
100 | 
101 | 	funcMap := make(map[string]interface{})
102 | 	funcMap["pattern"] = func(input string) string {
103 | 		_, endpoint := astutils.Pattern(input)
104 | 		return endpoint
105 | 	}
106 | 	funcMap["noSplitPattern"] = parser.NoSplitPattern
107 | 	funcMap["lower"] = strings.ToLower
108 | 	if tpl, err = template.New(httpHandlerTmpl).Funcs(funcMap).Parse(httpHandlerTmpl); err != nil {
109 | 		panic(err)
110 | 	}
111 | 	if err = tpl.Execute(&buf, struct {
112 | 		RoutePatternStrategy int
113 | 		Meta                 astutils.InterfaceMeta
114 | 		Version              string
115 | 	}{
116 | 		RoutePatternStrategy: routePatternStrategy,
117 | 		Meta:                 ic.Interfaces[0],
118 | 		Version:              version.Release,
119 | 	}); err != nil {
120 | 		panic(err)
121 | 	}
122 | 	source = strings.TrimSpace(buf.String())
123 | 	astutils.FixImport([]byte(source), handlerfile)
124 | }
```

cmd/internal/svc/codegen/httphandler_test.go
```
1 | package codegen
```

cmd/internal/svc/codegen/httphandlerimpl.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"io/ioutil"
6 | 	"os"
7 | 	"path/filepath"
8 | 	"strings"
9 | 	"text/template"
10 | 
11 | 	"github.com/iancoleman/strcase"
12 | 	"github.com/sirupsen/logrus"
13 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
14 | 	"github.com/unionj-cloud/toolkit/astutils"
15 | 	"github.com/unionj-cloud/toolkit/copier"
16 | 	v3helper "github.com/unionj-cloud/toolkit/openapi/v3"
17 | 	"github.com/unionj-cloud/go-doudou/v2/version"
18 | )
19 | 
20 | var appendHttpHandlerImplTmpl = `
21 | {{- range $m := .Meta.Methods }}
22 | 	func (receiver *{{$.Meta.Name}}HandlerImpl) {{$m.Name}}(_writer http.ResponseWriter, _req *http.Request) {
23 |     	var (
24 | 			{{- range $p := $m.Params }}
25 | 			{{- if isVarargs $p.Type }}
26 | 			{{ $p.Name }} = new({{ $p.Type | toSlice }})
27 | 			{{- else if eq $p.Type "context.Context"}}
28 | 			{{ $p.Name }} {{ $p.Type }}
29 | 			{{- else if and (and (eq $m.HttpMethod "GET") (not (isBuiltin $p))) (gt (len $m.QueryVars) 1) }}
30 | 			{{ $p.Name }}Wrapper struct {
31 | 				{{ $p.Name | title }} {{ $p.Type }} ` + "`" + `json:"{{ $p.Name }}"` + "`" + `
32 | 			}
33 | 			{{- else }}
34 | 			{{ $p.Name }} {{ $p.Type }}
35 | 			{{- end }}
36 | 			{{- end }}
37 | 			{{- range $r := $m.Results }}
38 | 			{{ $r.Name }} {{ $r.Type }}
39 | 			{{- end }}
40 | 		)
41 | 		{{- if $m.HasPathVariable }}
42 | 		paramsFromCtx := httprouter.ParamsFromContext(_req.Context())
43 | 		{{- end }}
44 | 		{{- $multipartFormParsed := false }}
45 | 		{{- $formParsed := false }}
46 | 		{{- range $p := $m.Params }}
47 | 		{{- if $p.IsPathVariable }}
48 | 		{{- if IsEnum $p }}
49 | 		{{ $p.Name }}.StringSetter(paramsFromCtx.ByName("{{$p.Name}}"))
50 | 		{{- else if $p.Type | isSupport }}
51 | 		if casted, _err := cast.{{$p.Type | castFunc}}E(paramsFromCtx.ByName("{{$p.Name}}")); _err != nil {
52 | 			rest.HandleBadRequestErr(_err)
53 | 		} else {
54 | 			{{$p.Name}} = casted
55 | 		}
56 | 		{{- else }}
57 | 		{{$p.Name}} = paramsFromCtx.ByName("{{$p.Name}}")
58 | 		{{- end }}
59 | 		if _err := rest.ValidateVar({{$p.Name}}, "{{$p.ValidateTag}}", "{{$p.Name}}"); _err != nil {
60 | 			rest.HandleBadRequestErr(_err)
61 | 		}
62 | 		{{- else if or (eq $p.Type "*multipart.FileHeader") (eq $p.Type "[]*multipart.FileHeader") }}
63 | 		{{- if not $multipartFormParsed }}
64 | 		if _err := _req.ParseMultipartForm(32 << 20); _err != nil {
65 | 			rest.HandleBadRequestErr(_err)
66 | 		}
67 | 		{{- $multipartFormParsed = true }}
68 | 		{{- end }}
69 | 		{{- if contains $p.Type "["}}
70 | 		{{$p.Name}} = _req.MultipartForm.File["{{$p.Name}}"]
71 | 		{{- else}}
72 | 		{{$p.Name}}Files := _req.MultipartForm.File["{{$p.Name}}"]
73 | 		if len({{$p.Name}}Files) > 0 {
74 | 			{{$p.Name}} = {{$p.Name}}Files[0]
75 | 		}
76 | 		{{- end}}
77 | 		{{- else if or (eq $p.Type "v3.FileModel") (eq $p.Type "*v3.FileModel") (eq $p.Type "[]v3.FileModel") (eq $p.Type "*[]v3.FileModel") (eq $p.Type "...v3.FileModel") }}
78 | 		{{- if not $multipartFormParsed }}
79 | 		if _err := _req.ParseMultipartForm(32 << 20); _err != nil {
80 | 			rest.HandleBadRequestErr(_err)
81 | 		}
82 | 		{{- $multipartFormParsed = true }}
83 | 		{{- end }}
84 | 		{{$p.Name}}FileHeaders, exists := _req.MultipartForm.File["{{$p.Name}}"]
85 | 		if exists {
86 | 			{{- if not (isOptional $p.Type) }}
87 | 			if len({{$p.Name}}FileHeaders) == 0 {
88 | 				rest.HandleBadRequestErr(errors.New("no file uploaded for parameter {{$p.Name}}"))
89 | 			}
90 | 			{{- end }}
91 | 			{{- if isSlice $p.Type }}
92 | 			{{- if isOptional $p.Type }}
93 | 			if {{$p.Name}} == nil && len({{$p.Name}}FileHeaders) > 0 {
94 | 				{{$p.Name}} = new([]v3.FileModel)
95 | 			}
96 | 			{{- end }}
97 | 			for _, _fh :=range {{$p.Name}}FileHeaders {
98 | 				_f, _err := _fh.Open()
99 | 				if _err != nil {
100 | 					rest.HandleBadRequestErr(_err)
101 | 				}
102 | 				{{- if isOptional $p.Type }}
103 | 				*{{$p.Name}} = append(*{{$p.Name}}, v3.FileModel{
104 | 					Filename: _fh.Filename,
105 | 					Reader: _f,
106 | 				})
107 | 				{{- else }}
108 | 				{{$p.Name}} = append({{$p.Name}}, v3.FileModel{
109 | 					Filename: _fh.Filename,
110 | 					Reader: _f,
111 | 				})
112 | 				{{- end }}
113 | 			}
114 | 			{{- else}}
115 | 			if len({{$p.Name}}FileHeaders) > 0 {
116 | 				_fh := {{$p.Name}}FileHeaders[0]
117 | 				_f, _err := _fh.Open()
118 | 				if _err != nil {
119 | 					rest.HandleBadRequestErr(_err)
120 | 				}
121 | 				{{- if isOptional $p.Type }}
122 | 				{{$p.Name}} = &v3.FileModel{
123 | 					Filename: _fh.Filename,
124 | 					Reader: _f,
125 | 				}
126 | 				{{- else }}
127 | 				{{$p.Name}} = v3.FileModel{
128 | 					Filename: _fh.Filename,
129 | 					Reader: _f,
130 | 				}
131 | 				{{- end }}
132 | 			}
133 | 			{{- end}}
134 | 		}{{- if not (isOptional $p.Type) }} else {
135 | 			rest.HandleBadRequestErr(errors.New("missing parameter {{$p.Name}}"))
136 | 		}{{- end }}
137 | 		{{- else if eq $p.Type "context.Context" }}
138 | 		{{$p.Name}} = _req.Context()
139 | 		{{- else if not (isBuiltin $p)}}
140 | 		{{- if and (eq $m.HttpMethod "GET") (not $.Config.AllowGetWithReqBody) }}
141 | 		{{- if not $formParsed }}
142 | 		if _err := _req.ParseForm(); _err != nil {
143 | 			rest.HandleBadRequestErr(_err)
144 | 		}
145 | 		{{- $formParsed = true }}
146 | 		{{- end }}
147 | 		{{- if gt (len $m.QueryVars) 1 }}
148 | 		if _err := rest.DecodeForm(&{{ $p.Name }}Wrapper, _req.Form); _err != nil {
149 | 			rest.HandleBadRequestErr(_err)
150 | 		} else {
151 | 			{{- if isStruct $p }}
152 | 			if _err := rest.ValidateStruct({{ $p.Name }}Wrapper.{{ $p.Name | title }}); _err != nil {
153 | 				rest.HandleBadRequestErr(_err)
154 | 			}
155 | 			{{- else }}
156 | 			if _err := rest.ValidateVar({{ $p.Name }}Wrapper.{{ $p.Name | title }}, "{{$p.ValidateTag}}", ""); _err != nil {
157 | 				rest.HandleBadRequestErr(_err)
158 | 			}
159 | 			{{- end }}
160 | 		}
161 | 		{{- else }}
162 | 		if _err := rest.DecodeForm(&{{ $p.Name }}, _req.Form); _err != nil {
163 | 			rest.HandleBadRequestErr(_err)
164 | 		} else {
165 | 			{{- if isStruct $p }}
166 | 			if _err := rest.ValidateStruct({{ $p.Name }}); _err != nil {
167 | 				rest.HandleBadRequestErr(_err)
168 | 			}
169 | 			{{- else }}
170 | 			if _err := rest.ValidateVar({{ $p.Name }}, "{{$p.ValidateTag}}", ""); _err != nil {
171 | 				rest.HandleBadRequestErr(_err)
172 | 			}
173 | 			{{- end }}
174 | 		}
175 | 		{{- end }}
176 | 		{{- else }}
177 | 		{{- if isOptional $p.Type }}
178 | 		if _err := json.NewDecoder(_req.Body).Decode(&{{$p.Name}}); _err != nil {
179 | 			if _err != io.EOF {
180 | 				rest.HandleBadRequestErr(_err)				
181 | 			}
182 | 		} else {
183 | 			{{- if isStruct $p }}
184 | 			if _err := rest.ValidateStruct({{$p.Name}}); _err != nil {
185 | 				rest.HandleBadRequestErr(_err)
186 | 			}
187 | 			{{- else }}
188 | 			if _err := rest.ValidateVar({{$p.Name}}, "{{$p.ValidateTag}}", ""); _err != nil {
189 | 				rest.HandleBadRequestErr(_err)
190 | 			}
191 | 			{{- end }}
192 | 		}
193 | 		{{- else }}
194 | 		if _err := json.NewDecoder(_req.Body).Decode(&{{$p.Name}}); _err != nil {
195 | 			rest.HandleBadRequestErr(_err)	
196 | 		} else {
197 | 			{{- if isStruct $p }}
198 | 			if _err := rest.ValidateStruct({{$p.Name}}); _err != nil {
199 | 				rest.HandleBadRequestErr(_err)
200 | 			}
201 | 			{{- else }}
202 | 			if _err := rest.ValidateVar({{$p.Name}}, "{{$p.ValidateTag}}", ""); _err != nil {
203 | 				rest.HandleBadRequestErr(_err)
204 | 			}
205 | 			{{- end }}
206 | 		}
207 | 		{{- end }}
208 | 		{{- end }}
209 | 		{{- else if isSlice $p.Type }}
210 | 		{{- if not $formParsed }}
211 | 		if _err := _req.ParseForm(); _err != nil {
212 | 			rest.HandleBadRequestErr(_err)
213 | 		}
214 | 		{{- $formParsed = true }}
215 | 		{{- end }}
216 | 		if _, exists := _req.Form["{{$p.Name}}"]; exists {
217 | 			{{- if IsEnum $p }}
218 | 			{{- if isOptional $p.Type }}
219 | 			{{- if not (isVarargs $p.Type) }}
220 | 			{{$p.Name}} = new({{ TrimPrefix $p.Type "*"}})
221 | 			{{- end }}
222 | 			{{- end }}
223 | 			for _, item := range _req.Form["{{$p.Name}}"] {
224 | 				var _{{ $p.Name }} {{ ElementType $p.Type }}
225 | 				_{{ $p.Name }}.StringSetter(item)
226 | 				{{- if isOptional $p.Type }}
227 | 				*{{ $p.Name }} = append(*{{ $p.Name }}, _{{ $p.Name }})
228 | 				{{- else }}
229 | 				{{ $p.Name }} = append({{ $p.Name }}, _{{ $p.Name }})
230 | 				{{- end }}
231 | 			}
232 | 			{{- else if $p.Type | isSupport }}
233 | 			if casted, _err := cast.{{$p.Type | castFunc}}E(_req.Form["{{$p.Name}}"]); _err != nil {
234 | 				rest.HandleBadRequestErr(_err)
235 | 			} else {
236 | 				{{- if isOptional $p.Type }}
237 | 				{{$p.Name}} = &casted
238 | 				{{- else }}
239 | 				{{$p.Name}} = casted
240 | 				{{- end }}
241 | 			}
242 | 			{{- else }}
243 | 			{{- if isOptional $p.Type }}
244 | 			_{{$p.Name}} := _req.Form["{{$p.Name}}"]
245 | 			{{$p.Name}} = &_{{$p.Name}}
246 | 			{{- else }}
247 | 			{{$p.Name}} = _req.Form["{{$p.Name}}"]
248 | 			{{- end }}
249 | 			{{- end }}
250 | 			if _err := rest.ValidateVar({{$p.Name}}, "{{$p.ValidateTag}}", "{{$p.Name}}"); _err != nil {
251 | 				rest.HandleBadRequestErr(_err)
252 | 			}
253 | 		} else {
254 | 			if _, exists := _req.Form["{{$p.Name}}[]"]; exists {
255 | 				{{- if IsEnum $p }}
256 | 				{{- if isOptional $p.Type }}
257 | 				{{- if not (isVarargs $p.Type) }}
258 | 				{{$p.Name}} = new({{ TrimPrefix $p.Type "*"}})
259 | 				{{- end }}
260 | 				{{- end }}
261 | 				for _, item := range _req.Form["{{$p.Name}}[]"] {
262 | 					var _{{ $p.Name }} {{ ElementType $p.Type }}
263 | 					_{{ $p.Name }}.StringSetter(item)
264 | 					{{- if isOptional $p.Type }}
265 | 					*{{ $p.Name }} = append(*{{ $p.Name }}, _{{ $p.Name }})
266 | 					{{- else }}
267 | 					{{ $p.Name }} = append({{ $p.Name }}, _{{ $p.Name }})
268 | 					{{- end }}
269 | 				}
270 | 				{{- else if $p.Type | isSupport }}
271 | 				if casted, _err := cast.{{$p.Type | castFunc}}E(_req.Form["{{$p.Name}}[]"]); _err != nil {
272 | 					rest.HandleBadRequestErr(_err)
273 | 				} else {
274 | 					{{- if isOptional $p.Type }}
275 | 					{{$p.Name}} = &casted
276 | 					{{- else }}
277 | 					{{$p.Name}} = casted
278 | 					{{- end }}
279 | 				}
280 | 				{{- else }}
281 | 				{{- if isOptional $p.Type }}
282 | 				_{{$p.Name}} := _req.Form["{{$p.Name}}[]"]
283 | 				{{$p.Name}} = &_{{$p.Name}}
284 | 				{{- else }}
285 | 				{{$p.Name}} = _req.Form["{{$p.Name}}[]"]
286 | 				{{- end }}
287 | 				{{- end }}
288 | 				if _err := rest.ValidateVar({{$p.Name}}, "{{$p.ValidateTag}}", "{{$p.Name}}"); _err != nil {
289 | 					rest.HandleBadRequestErr(_err)
290 | 				}
291 | 			}{{- if not (isOptional $p.Type) }} else {
292 | 				rest.HandleBadRequestErr(errors.New("missing parameter {{$p.Name}}"))
293 | 			}{{- end }}
294 | 		}
295 | 		{{- else }}
296 | 		{{- if not $formParsed }}
297 | 		if _err := _req.ParseForm(); _err != nil {
298 | 			rest.HandleBadRequestErr(_err)
299 | 		}
300 | 		{{- $formParsed = true }}
301 | 		{{- end }}
302 | 		if _, exists := _req.Form["{{$p.Name}}"]; exists {
303 | 			{{- if IsEnum $p }}
304 | 			{{- if isOptional $p.Type }}
305 | 			{{$p.Name}} = new({{ TrimPrefix $p.Type "*"}})
306 | 			{{- end }}
307 | 			{{ $p.Name }}.StringSetter(_req.FormValue("{{$p.Name}}"))
308 | 			{{- else if $p.Type | isSupport }}
309 | 			if casted, _err := cast.{{$p.Type | castFunc}}E(_req.FormValue("{{$p.Name}}")); _err != nil {
310 | 				rest.HandleBadRequestErr(_err)
311 | 			} else {
312 | 				{{- if isOptional $p.Type }}
313 | 				{{$p.Name}} = &casted
314 | 				{{- else }}
315 | 				{{$p.Name}} = casted
316 | 				{{- end }}
317 | 			}
318 | 			{{- else }}
319 | 			{{- if isOptional $p.Type }}
320 | 			_{{$p.Name}} := _req.FormValue("{{$p.Name}}")
321 | 			{{$p.Name}} = &_{{$p.Name}}
322 | 			{{- else }}
323 | 			{{$p.Name}} = _req.FormValue("{{$p.Name}}")
324 | 			{{- end }}
325 | 			{{- end }}
326 | 			if _err := rest.ValidateVar({{$p.Name}}, "{{$p.ValidateTag}}", "{{$p.Name}}"); _err != nil {
327 | 				rest.HandleBadRequestErr(_err)
328 | 			}
329 | 		}{{- if not (isOptional $p.Type) }} else {
330 | 			rest.HandleBadRequestErr(errors.New("missing parameter {{$p.Name}}"))
331 | 		}{{- end }}
332 | 		{{- end }}
333 | 		{{- end }}
334 | 		{{ range $i, $r := $m.Results }}{{- if $i}},{{- end}}{{- $r.Name }}{{- end }} = receiver.{{$.Meta.Name | toLowerCamel}}.{{$m.Name}}(
335 | 			{{- range $p := $m.Params }}
336 | 			{{- if isVarargs $p.Type }}
337 | 			*{{ $p.Name }}...,
338 | 			{{- else if eq $p.Type "context.Context"}}
339 | 			{{ $p.Name }},
340 | 			{{- else if and (and (eq $m.HttpMethod "GET") (not (isBuiltin $p))) (gt (len $m.QueryVars) 1) }}
341 | 			{{ $p.Name }}Wrapper.{{ $p.Name | title }},
342 | 			{{- else }}
343 | 			{{ $p.Name }},
344 | 			{{- end }}
345 | 			{{- end }}
346 | 		)
347 | 		{{- range $r := $m.Results }}
348 | 			{{- if eq $r.Type "error" }}
349 | 				if {{ $r.Name }} != nil {
350 | 					panic({{ $r.Name }})
351 | 				}
352 | 			{{- end }}
353 | 		{{- end }}
354 | 		{{- $done := false }}
355 | 		{{- range $r := $m.Results }}
356 | 			{{- if eq $r.Type "*os.File" }}
357 | 				if {{$r.Name}} == nil {
358 | 					rest.HandleInternalServerError(errors.New("No file returned"))
359 | 				}
360 | 				defer {{$r.Name}}.Close()
361 | 				var _fi os.FileInfo
362 | 				_fi, _err := {{$r.Name}}.Stat()
363 | 				if _err != nil {
364 | 					rest.HandleInternalServerError(_err)
365 | 				}
366 | 				_writer.Header().Set("Content-Disposition", "attachment; filename="+_fi.Name())
367 | 				_writer.Header().Set("Content-Type", "application/octet-stream")
368 | 				_writer.Header().Set("Content-Length", fmt.Sprintf("%d", _fi.Size()))
369 | 				io.Copy(_writer, {{$r.Name}})
370 | 				{{- $done = true }}	
371 | 			{{- end }}
372 | 		{{- end }}
373 | 		{{- if not $done }}
374 | 			_writer.Header().Set("Content-Type", "application/json; charset=UTF-8")
375 | 			if _err := json.NewEncoder(_writer).Encode(struct {
376 | 				{{- range $r := $m.Results }}
377 | 				{{- if ne $r.Type "error" }}
378 | 				{{ $r.Name | toCamel }} {{ $r.Type }} ` + "`" + `json:"{{ $r.Name | convertCase }}{{if $.Config.Omitempty}},omitempty{{end}}"` + "`" + `
379 | 				{{- end }}
380 | 				{{- end }}
381 | 			}{
382 | 				{{- range $r := $m.Results }}
383 | 				{{- if ne $r.Type "error" }}
384 | 				{{ $r.Name | toCamel }}: {{ $r.Name }},
385 | 				{{- end }}
386 | 				{{- end }}
387 | 			}); _err != nil {
388 | 				rest.HandleInternalServerError(_err)
389 | 			}
390 | 		{{- end }}
391 |     }
392 | {{- end }}
393 | `
394 | 
395 | var importTmpl = `
396 | 	"context"
397 | 	"github.com/bytedance/sonic"
398 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
399 | 	{{.ServiceAlias}} "{{.ServicePackage}}"
400 | 	"{{.DtoPackage}}"
401 | 	"net/http"
402 | `
403 | 
404 | var initHttpHandlerImplTmpl = templates.EditableHeaderTmpl + `package httpsrv
405 | 
406 | import ()
407 | 
408 | var json = sonic.ConfigDefault
409 | 
410 | type {{.Meta.Name}}HandlerImpl struct{
411 | 	{{.Meta.Name | toLowerCamel}} {{.ServiceAlias}}.{{.Meta.Name}}
412 | }
413 | 
414 | ` + appendHttpHandlerImplTmpl + `
415 | 
416 | func New{{.Meta.Name}}Handler({{.Meta.Name | toLowerCamel}} {{.ServiceAlias}}.{{.Meta.Name}}) {{.Meta.Name}}Handler {
417 | 	return &{{.Meta.Name}}HandlerImpl{
418 | 		{{.Meta.Name | toLowerCamel}},
419 | 	}
420 | }
421 | `
422 | 
423 | type GenHttpHandlerImplConfig struct {
424 | 	Omitempty           bool
425 | 	AllowGetWithReqBody bool
426 | 	CaseConvertor       func(string) string
427 | }
428 | 
429 | // GenHttpHandlerImpl generates http handler implementation
430 | // Parsed value from query string parameters or application/x-www-form-urlencoded form will be string type.
431 | // You may need to convert the type by yourself.
432 | func GenHttpHandlerImpl(dir string, ic astutils.InterfaceCollector, config GenHttpHandlerImplConfig) {
433 | 	var (
434 | 		err             error
435 | 		handlerimplfile string
436 | 		f               *os.File
437 | 		tpl             *template.Template
438 | 		buf             bytes.Buffer
439 | 		httpDir         string
440 | 		fi              os.FileInfo
441 | 		tmpl            string
442 | 		meta            astutils.InterfaceMeta
443 | 		importBuf       bytes.Buffer
444 | 	)
445 | 	httpDir = filepath.Join(dir, "transport/httpsrv")
446 | 	if err = os.MkdirAll(httpDir, os.ModePerm); err != nil {
447 | 		panic(err)
448 | 	}
449 | 
450 | 	handlerimplfile = filepath.Join(httpDir, "handlerimpl.go")
451 | 	fi, err = os.Stat(handlerimplfile)
452 | 	if err != nil && !os.IsNotExist(err) {
453 | 		panic(err)
454 | 	}
455 | 
456 | 	err = copier.DeepCopy(ic.Interfaces[0], &meta)
457 | 	if err != nil {
458 | 		panic(err)
459 | 	}
460 | 	unimplementedMethods(&meta, httpDir, meta.Name+"HandlerImpl")
461 | 	if fi != nil {
462 | 		logrus.Warningln("New content will be append to handlerimpl.go file")
463 | 		if f, err = os.OpenFile(handlerimplfile, os.O_APPEND, os.ModePerm); err != nil {
464 | 			panic(err)
465 | 		}
466 | 		defer f.Close()
467 | 		tmpl = appendHttpHandlerImplTmpl
468 | 	} else {
469 | 		if f, err = os.Create(handlerimplfile); err != nil {
470 | 			panic(err)
471 | 		}
472 | 		defer f.Close()
473 | 		tmpl = initHttpHandlerImplTmpl
474 | 	}
475 | 
476 | 	servicePkg := astutils.GetPkgPath(dir)
477 | 
478 | 	funcMap := make(map[string]interface{})
479 | 	funcMap["toLowerCamel"] = strcase.ToLowerCamel
480 | 	funcMap["toCamel"] = strcase.ToCamel
481 | 	funcMap["contains"] = strings.Contains
482 | 	funcMap["isBuiltin"] = v3helper.IsBuiltin
483 | 	funcMap["isStruct"] = v3helper.IsStruct
484 | 	funcMap["isSupport"] = v3helper.IsSupport
485 | 	funcMap["isOptional"] = v3helper.IsOptional
486 | 	funcMap["castFunc"] = v3helper.CastFunc
487 | 	funcMap["convertCase"] = config.CaseConvertor
488 | 	funcMap["isVarargs"] = v3helper.IsVarargs
489 | 	funcMap["toSlice"] = v3helper.ToSlice
[TRUNCATED]
```

cmd/internal/svc/codegen/httphandlerimpl_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"fmt"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/unionj-cloud/toolkit/astutils"
9 | 	"github.com/unionj-cloud/toolkit/copier"
10 | )
11 | 
12 | func Test_unimplementedMethods(t *testing.T) {
13 | 	ic := astutils.BuildInterfaceCollector(filepath.Join(testDir, "svc.go"), astutils.ExprString)
14 | 	var meta astutils.InterfaceMeta
15 | 	_ = copier.DeepCopy(ic.Interfaces[0], &meta)
16 | 	unimplementedMethods(&meta, filepath.Join(testDir, "transport/httpsrv"), meta.Name+"HandlerImpl")
17 | 	fmt.Println(len(meta.Methods))
18 | }
```

cmd/internal/svc/codegen/httpiclient.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/sirupsen/logrus"
11 | 	"github.com/unionj-cloud/toolkit/astutils"
12 | 	"github.com/unionj-cloud/toolkit/copier"
13 | 	"github.com/unionj-cloud/go-doudou/v2/version"
14 | )
15 | 
16 | var iclientTmpl = `/**
17 | * Generated by go-doudou {{.Version}}.
18 | * Don't edit!
19 | */
20 | package client
21 | 
22 | import (
23 | 	"context"
24 | 	"github.com/go-resty/resty/v2"
25 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
26 | 	"os"
27 | )
28 | 
29 | type Options struct {
30 | 	GzipReqBody bool
31 | }
32 | 
33 | type I{{.Meta.Name}}Client interface {
34 | {{- range $m := .Meta.Methods }}
35 | 	{{$m.Name}}(ctx context.Context, _headers map[string]string, {{- range $i, $p := $m.Params}}
36 | 	{{- if ne $p.Type "context.Context" }}
37 | 	{{- $p.Name}} {{$p.Type}},
38 | 	{{- end }}
39 |     {{- end }} options Options) (_resp *resty.Response, {{- range $i, $r := $m.Results}}
40 |                      {{- if $i}},{{end}}
41 |                      {{- $r.Name}} {{$r.Type}}
42 |                      {{- end }})
43 | {{- end }}
44 | }
45 | `
46 | 
47 | // GenGoIClient generates golang http client interface code from result of parsing svc.go file in project root path
48 | func GenGoIClient(dir string, ic astutils.InterfaceCollector) {
49 | 	var (
50 | 		err        error
51 | 		clientfile string
52 | 		f          *os.File
53 | 		tpl        *template.Template
54 | 		sqlBuf     bytes.Buffer
55 | 		clientDir  string
56 | 		fi         os.FileInfo
57 | 		source     string
58 | 		meta       astutils.InterfaceMeta
59 | 	)
60 | 	clientDir = filepath.Join(dir, "client")
61 | 	if err = os.MkdirAll(clientDir, os.ModePerm); err != nil {
62 | 		panic(err)
63 | 	}
64 | 
65 | 	clientfile = filepath.Join(clientDir, "iclient.go")
66 | 	fi, err = os.Stat(clientfile)
67 | 	if err != nil && !os.IsNotExist(err) {
68 | 		panic(err)
69 | 	}
70 | 	if fi != nil {
71 | 		logrus.Warningln("file iclient.go will be overwritten")
72 | 	}
73 | 	if f, err = os.Create(clientfile); err != nil {
74 | 		panic(err)
75 | 	}
76 | 	defer f.Close()
77 | 	err = copier.DeepCopy(ic.Interfaces[0], &meta)
78 | 	if err != nil {
79 | 		panic(err)
80 | 	}
81 | 	if tpl, err = template.New("iclient.go.tmpl").Parse(iclientTmpl); err != nil {
82 | 		panic(err)
83 | 	}
84 | 	if err = tpl.Execute(&sqlBuf, struct {
85 | 		Meta    astutils.InterfaceMeta
86 | 		Version string
87 | 	}{
88 | 		Meta:    meta,
89 | 		Version: version.Release,
90 | 	}); err != nil {
91 | 		panic(err)
92 | 	}
93 | 
94 | 	source = strings.TrimSpace(sqlBuf.String())
95 | 	astutils.FixImport([]byte(source), clientfile)
96 | }
```

cmd/internal/svc/codegen/httpiclient_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"path/filepath"
5 | 	"testing"
6 | 
7 | 	"github.com/unionj-cloud/toolkit/astutils"
8 | )
9 | 
10 | func TestGenGoIClient(t *testing.T) {
11 | 	svcfile := filepath.Join(testDir, "svc.go")
12 | 	ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
13 | 
14 | 	type args struct {
15 | 		dir string
16 | 		ic  astutils.InterfaceCollector
17 | 	}
18 | 	tests := []struct {
19 | 		name string
20 | 		args args
21 | 	}{
22 | 		{
23 | 			name: "",
24 | 			args: args{
25 | 				dir: testDir,
26 | 				ic:  ic,
27 | 			},
28 | 		},
29 | 	}
30 | 	for _, tt := range tests {
31 | 		t.Run(tt.name, func(t *testing.T) {
32 | 			GenGoIClient(tt.args.dir, tt.args.ic)
33 | 		})
34 | 	}
35 | }
```

cmd/internal/svc/codegen/httpintegrationtesting.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"fmt"
6 | 	"go/ast"
7 | 	"go/parser"
8 | 	"go/token"
9 | 	"io/ioutil"
10 | 	"os"
11 | 	"path/filepath"
12 | 	"strings"
13 | 	"text/template"
14 | 
15 | 	"github.com/rbretecher/go-postman-collection"
16 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
17 | 	"github.com/unionj-cloud/toolkit/astutils"
18 | 	"github.com/unionj-cloud/toolkit/zlogger"
19 | 	"github.com/unionj-cloud/go-doudou/v2/version"
20 | )
21 | 
22 | var appendIntegrationTestingTmpl = `
23 | {{- range $response := .Responses }}
24 | 
25 | func Test_{{$response.Name | cleanName}}(t *testing.T) {
26 | 	apitest.New("{{$response.Name}}").
27 | 		Handler(router).
28 | 		{{$response.OriginalRequest.Method | toString | capital}}("{{ $response.OriginalRequest.URL.Path | toEndpoint }}").
29 | {{- range $header := $response.OriginalRequest.Header }}
30 | {{- if not $header.Disabled }}
31 | 		Header("{{$header.Key}}", "{{$header.Value}}").
32 | {{- end }}
33 | {{- end }}
34 | {{- if $response.OriginalRequest.URL.Query }}
35 | {{- range $query := $response.OriginalRequest.URL.Query }}
36 | {{- if not (index $query "disabled") }}
37 | 		Query("{{index $query "key"}}", "{{index $query "value"}}").
38 | {{- end }}
39 | {{- end }}
40 | {{- end }}
41 | {{- if $response.OriginalRequest.Body }}
42 | {{- if eq $response.OriginalRequest.Body.Mode "raw" }}
43 | 		JSON(` + "`" + `{{$response.OriginalRequest.Body.Raw}}` + "`" + `).
44 | {{- else if eq $response.OriginalRequest.Body.Mode "urlencoded" }}
45 | {{- range $query := $response.OriginalRequest.Body.URLEncoded }}
46 | {{- if not (index $query "disabled") }}
47 | 		FormData("{{index $query "key"}}", "{{index $query "value"}}").
48 | {{- end }}
49 | {{- end }}
50 | {{- else if eq $response.OriginalRequest.Body.Mode "formdata" }}
51 | {{- range $query := $response.OriginalRequest.Body.FormData }}
52 | {{- if not (index $query "disabled") }}
53 | {{- if eq (index $query "type") "file" }}
54 | 		MultipartFile("{{index $query "key"}}", "{{index $query "src"}}").
55 | {{- else }}
56 | 		MultipartFormData("{{index $query "key"}}", "{{index $query "value"}}").
57 | {{- end }}
58 | {{- end }}
59 | {{- end }}
60 | {{- end }}
61 | {{- end }}
62 | 		Expect(t).
63 | {{- if $response.Body }}
64 | 		Body(` + "`" + `{{$response.Body}}` + "`" + `).
65 | {{- end }}
66 | 		Status({{$response.Code}}).
67 | 		End()
68 | }
69 | {{- end }}
70 | `
71 | 
72 | var integrationTestingImportTmpl = `
73 | 	"github.com/gorilla/mux"
74 | 	"github.com/joho/godotenv"
75 | 	"github.com/rs/zerolog"
76 | 	"github.com/unionj-cloud/toolkit/zlogger"
77 | 	"github.com/steinfletcher/apitest"
78 | 	jsonpath "github.com/steinfletcher/apitest-jsonpath"
79 | 	"net/http"
80 | 	{{.ServiceAlias}} "{{.ServicePackage}}"
81 | 	"{{.ServicePackage}}/config"
82 | 	"{{.ServicePackage}}/db"
83 | 	"{{.ServicePackage}}/transport/httpsrv"
84 | 	"testing"
85 | `
86 | 
87 | var initIntegrationTestingTmpl = templates.EditableHeaderTmpl + `package integrationtest_test
88 | 
89 | import ()
90 | 
91 | var (
92 | 	router *mux.Router
93 | )
94 | 
95 | func TestMain(m *testing.M) {
96 | 	_ = godotenv.Load("{{.DotenvPath}}")
97 | 	conf := config.LoadFromEnv()
98 | 	conn, err := db.NewDb(conf.DbConf)
99 | 	if err != nil {
100 | 		panic(err)
101 | 	}
102 | 	defer func() {
103 | 		if conn == nil {
104 | 			return
105 | 		}
106 | 		if err := conn.Close(); err == nil {
107 | 			zlogger.Info().Msg("Database connection is closed")
108 | 		} else {
109 | 			zlogger.Warn().Msg("Failed to close database connection")
110 | 		}
111 | 	}()
112 | 	svc := {{.ServiceAlias}}.New{{.SvcName}}(conf, conn)
113 | 	handler := httpsrv.New{{.SvcName}}Handler(svc)
114 | 	router = mux.NewRouter()
115 | 	for _, item := range httpsrv.Routes(handler) {
116 | 		router.
117 | 			Methods(item.Method).
118 | 			Path(item.Pattern).
119 | 			Name(item.Name).
120 | 			Handler(item.HandlerFunc)
121 | 	}
122 | 	m.Run()
123 | }
124 | ` + appendIntegrationTestingTmpl
125 | 
126 | func toEndpoint(input []string) string {
127 | 	return "/" + strings.Join(input, "/")
128 | }
129 | 
130 | func toString(input postman.Method) string {
131 | 	return string(input)
132 | }
133 | 
134 | func capital(input string) string {
135 | 	return strings.Title(strings.ToLower(input))
136 | }
137 | 
138 | func GenHttpIntegrationTesting(dir string, ic astutils.InterfaceCollector, postmanCollectionPath, dotenvPath string) {
139 | 	var (
140 | 		err                error
141 | 		testFile           string
142 | 		f                  *os.File
143 | 		tpl                *template.Template
144 | 		buf                bytes.Buffer
145 | 		fi                 os.FileInfo
146 | 		tmpl               string
147 | 		importBuf          bytes.Buffer
148 | 		integrationTestDir string
149 | 		responses          []*postman.Response
150 | 	)
151 | 	integrationTestDir = filepath.Join(dir, "integrationtest")
152 | 	if err = os.MkdirAll(integrationTestDir, os.ModePerm); err != nil {
153 | 		panic(err)
154 | 	}
155 | 	testFile = filepath.Join(integrationTestDir, "integration_test.go")
156 | 	responses = notGenerated(integrationTestDir, postmanCollectionPath)
157 | 	fi, _ = os.Stat(testFile)
158 | 	if fi != nil {
159 | 		zlogger.Warn().Msg("New content will be append to integration_test.go file")
160 | 		if f, err = os.OpenFile(testFile, os.O_APPEND, os.ModePerm); err != nil {
161 | 			panic(err)
162 | 		}
163 | 		defer f.Close()
164 | 		tmpl = appendIntegrationTestingTmpl
165 | 	} else {
166 | 		if f, err = os.Create(testFile); err != nil {
167 | 			panic(err)
168 | 		}
169 | 		defer f.Close()
170 | 		tmpl = initIntegrationTestingTmpl
171 | 	}
172 | 
173 | 	servicePkg := astutils.GetPkgPath(dir)
174 | 
175 | 	funcMap := make(map[string]interface{})
176 | 	funcMap["toEndpoint"] = toEndpoint
177 | 	funcMap["toString"] = toString
178 | 	funcMap["capital"] = capital
179 | 	funcMap["cleanName"] = cleanName
180 | 	if tpl, err = template.New("integration_test.go.tmpl").Funcs(funcMap).Parse(tmpl); err != nil {
181 | 		panic(err)
182 | 	}
183 | 	absDotenv, _ := filepath.Abs(dotenvPath)
184 | 	absDir, _ := filepath.Abs(integrationTestDir)
185 | 	relDotenv, _ := filepath.Rel(absDir, absDotenv)
186 | 	if err = tpl.Execute(&buf, struct {
187 | 		ServicePackage string
188 | 		ServiceAlias   string
189 | 		Version        string
190 | 		DotenvPath     string
191 | 		SvcName        string
192 | 		Responses      []*postman.Response
193 | 	}{
194 | 		ServicePackage: servicePkg,
195 | 		ServiceAlias:   ic.Package.Name,
196 | 		Version:        version.Release,
197 | 		DotenvPath:     relDotenv,
198 | 		SvcName:        ic.Interfaces[0].Name,
199 | 		Responses:      responses,
200 | 	}); err != nil {
201 | 		panic(err)
202 | 	}
203 | 	original, err := ioutil.ReadAll(f)
204 | 	if err != nil {
205 | 		panic(err)
206 | 	}
207 | 	original = append(original, buf.Bytes()...)
208 | 	if tpl, err = template.New("testimportimpl.go.tmpl").Parse(integrationTestingImportTmpl); err != nil {
209 | 		panic(err)
210 | 	}
211 | 	if err = tpl.Execute(&importBuf, struct {
212 | 		ServicePackage string
213 | 		ServiceAlias   string
214 | 	}{
215 | 		ServicePackage: servicePkg,
216 | 		ServiceAlias:   ic.Package.Name,
217 | 	}); err != nil {
218 | 		panic(err)
219 | 	}
220 | 	original = astutils.AppendImportStatements(original, importBuf.Bytes())
221 | 	astutils.FixImport(original, testFile)
222 | }
223 | 
224 | func notGenerated(dir, postmanCollectionPath string) []*postman.Response {
225 | 	file, err := os.Open(postmanCollectionPath)
226 | 	if err != nil {
227 | 		panic(err)
228 | 	}
229 | 	defer file.Close()
230 | 	c, err := postman.ParseCollection(file)
231 | 	if err != nil {
232 | 		panic(err)
233 | 	}
234 | 	responses := flattenResponses(c.Items)
235 | 	var files []string
236 | 	err = filepath.Walk(dir, astutils.Visit(&files))
237 | 	if err != nil {
238 | 		panic(err)
239 | 	}
240 | 	sc := astutils.NewStaticMethodCollector(astutils.ExprString)
241 | 	for _, file := range files {
242 | 		root, err := parser.ParseFile(token.NewFileSet(), file, nil, parser.ParseComments)
243 | 		if err != nil {
244 | 			panic(err)
245 | 		}
246 | 		ast.Walk(sc, root)
247 | 	}
248 | 	methodStore := make(map[string]struct{})
249 | 	for _, item := range sc.Methods {
250 | 		methodStore[item.Name] = struct{}{}
251 | 	}
252 | 	var result []*postman.Response
253 | 	for _, item := range responses {
254 | 		methodName := fmt.Sprintf("Test_%s", cleanName(item.Name))
255 | 		if _, exists := methodStore[methodName]; !exists {
256 | 			result = append(result, item)
257 | 		}
258 | 	}
259 | 	return result
260 | }
261 | 
262 | func flattenResponses(items []*postman.Items) []*postman.Response {
263 | 	var result []*postman.Response
264 | 	for _, item := range items {
265 | 		if len(item.Items) > 0 {
266 | 			result = append(result, flattenResponses(item.Items)...)
267 | 		} else {
268 | 			for _, resp := range item.Responses {
269 | 				if resp.Name != "Untitled Example" && resp.Name != "response" {
270 | 					result = append(result, resp)
271 | 				}
272 | 			}
273 | 		}
274 | 	}
275 | 	return result
276 | }
277 | 
278 | func cleanName(name string) string {
279 | 	name = strings.ReplaceAll(strings.ReplaceAll(name, "{", ""), "}", "")
280 | 	name = strings.ReplaceAll(strings.Trim(name, "/"), "/", "_")
281 | 	return name
282 | }
```

cmd/internal/svc/codegen/httpintegrationtesting_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"fmt"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/unionj-cloud/toolkit/fileutils"
9 | )
10 | 
11 | func Test_notGenerated(t *testing.T) {
12 | 	_ = fileutils.CreateDirectory(filepath.Join(testDir, "integrationtest"))
13 | 	result := notGenerated(filepath.Join(testDir, "integrationtest"), filepath.Join(testDir, "testcode.postman_collection.json"))
14 | 	fmt.Println(result)
15 | }
```

cmd/internal/svc/codegen/httpmiddleware.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"text/template"
7 | 
8 | 	"github.com/sirupsen/logrus"
9 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
10 | 	"github.com/unionj-cloud/go-doudou/v2/version"
11 | )
12 | 
13 | var httpMwTmpl = templates.EditableHeaderTmpl + `package httpsrv`
14 | 
15 | // GenHttpMiddleware generates http middleware file
16 | func GenHttpMiddleware(dir string) {
17 | 	var (
18 | 		err     error
19 | 		mwfile  string
20 | 		f       *os.File
21 | 		tpl     *template.Template
22 | 		httpDir string
23 | 	)
24 | 	httpDir = filepath.Join(dir, "transport/httpsrv")
25 | 	if err = os.MkdirAll(httpDir, os.ModePerm); err != nil {
26 | 		panic(err)
27 | 	}
28 | 
29 | 	mwfile = filepath.Join(httpDir, "middleware.go")
30 | 	if _, err = os.Stat(mwfile); os.IsNotExist(err) {
31 | 		if f, err = os.Create(mwfile); err != nil {
32 | 			panic(err)
33 | 		}
34 | 		defer f.Close()
35 | 		tpl, _ = template.New("middleware.go.tmpl").Parse(httpMwTmpl)
36 | 		_ = tpl.Execute(f, struct {
37 | 			Version string
38 | 		}{
39 | 			Version: version.Release,
40 | 		})
41 | 	} else {
42 | 		logrus.Warnf("file %s already exists", mwfile)
43 | 	}
44 | }
```

cmd/internal/svc/codegen/httpmiddleware_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"testing"
6 | )
7 | 
8 | func TestGenRouterMiddleware(t *testing.T) {
9 | 	dir := testDir + "middleware1"
10 | 	InitSvc(dir)
11 | 	defer os.RemoveAll(dir)
12 | 	type args struct {
13 | 		dir string
14 | 	}
15 | 	tests := []struct {
16 | 		name string
17 | 		args args
18 | 	}{
19 | 		{
20 | 			name: "1",
21 | 			args: args{
22 | 				dir: dir,
23 | 			},
24 | 		},
25 | 	}
26 | 	for _, tt := range tests {
27 | 		t.Run(tt.name, func(t *testing.T) {
28 | 			GenHttpMiddleware(tt.args.dir)
29 | 		})
30 | 	}
31 | }
```

cmd/internal/svc/codegen/init.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"fmt"
5 | 	"io/ioutil"
6 | 	"os"
7 | 	"path/filepath"
8 | 	"strings"
9 | 	"text/template"
10 | 
11 | 	"github.com/iancoleman/strcase"
12 | 	"github.com/sirupsen/logrus"
13 | 	"github.com/unionj-cloud/toolkit/astutils"
14 | 	"github.com/unionj-cloud/toolkit/common"
15 | 	"github.com/unionj-cloud/toolkit/executils"
16 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
17 | 	"github.com/unionj-cloud/toolkit/stringutils"
18 | 
19 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/openapi/v3/codegen/server"
20 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/parser"
21 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
22 | 	"github.com/unionj-cloud/go-doudou/v2/version"
23 | )
24 | 
25 | const svcTmpl = templates.EditableHeaderTmpl + `package service
26 | 
27 | import (
28 | 	"context"
29 | 	"{{.DtoPackage}}"
30 | )
31 | 
32 | {{- if eq .ProjectType "rest" }}
33 | //go:generate go-doudou svc http --case {{ .JsonCase }}
34 | {{- else }}
35 | //go:generate go-doudou svc grpc --http2grpc --case {{ .JsonCase }}
36 | {{- end }}
37 | 
38 | type {{.SvcName}} interface {
39 | 	// You can define your service methods as your need. Below is an example.
40 | 	// You can also add annotations here like @role(admin) to add meta data to routes for 
41 | 	// implementing your own middlewares
42 | 	PostUser(ctx context.Context, user dto.GddUser) (data dto.GddUser, err error)
43 | 	PutUser(ctx context.Context, user dto.GddUser) error
44 | 	DeleteUser(ctx context.Context, user dto.GddUser) error
45 | 	GetUsers(ctx context.Context, parameter dto.Parameter) (data dto.Page, err error)
46 | }
47 | `
48 | 
49 | const dtoTmpl = templates.EditableHeaderTmpl + `package dto
50 | 
51 | //go:generate go-doudou name --file $GOFILE --form --case {{ .JsonCase }}
52 | 
53 | type GddUser struct {
54 | 	Id    int64
55 | 	Name  string
56 | 	Phone string
57 | 	Dept  string
58 | }
59 | 
60 | // Page result wrapper
61 | type Page struct {
62 | 	Items      []interface{}
63 | 	Page       int64
64 | 	Size       int64
65 | 	MaxPage    int64
66 | 	TotalPages int64
67 | 	Total      int64
68 | 	Last       bool
69 | 	First      bool
70 | 	Visible    int64
71 | }
72 | 
73 | // Parameter struct
74 | type Parameter struct {
75 | 	Page    int64
76 | 	Size    int64
77 | 	Sort    string
78 | 	Order   string
79 | 	Fields  string
80 | 	Filters string
81 | }
82 | 
83 | func (receiver Parameter) GetPage() int64 {
84 | 	return receiver.Page
85 | }
86 | 
87 | func (receiver Parameter) GetSize() int64 {
88 | 	return receiver.Size
89 | }
90 | 
91 | func (receiver Parameter) GetSort() string {
92 | 	return receiver.Sort
93 | }
94 | 
95 | func (receiver Parameter) GetOrder() string {
96 | 	return receiver.Order
97 | }
98 | 
99 | func (receiver Parameter) GetFields() string {
100 | 	return receiver.Fields
101 | }
102 | 
103 | func (receiver Parameter) GetFilters() interface{} {
104 | 	return receiver.Filters
105 | }
106 | 
107 | func (receiver Parameter) IParameterInstance() {
108 | 
109 | }
110 | `
111 | 
112 | const modTmpl = `module {{.ModName}}
113 | 
114 | go {{.GoVersion}}
115 | 
116 | require (
117 | 	github.com/ascarter/requestid v0.0.0-20170313220838-5b76ab3d4aee
118 | 	github.com/brianvoe/gofakeit/v6 v6.10.0
119 | 	github.com/go-resty/resty/v2 v2.6.0
120 | 	github.com/go-sql-driver/mysql v1.6.0
121 | 	github.com/gorilla/handlers v1.5.1
122 | 	github.com/iancoleman/strcase v0.1.3
123 | 	github.com/opentracing-contrib/go-stdlib v1.0.0
124 | 	github.com/opentracing/opentracing-go v1.2.0
125 | 	github.com/pkg/errors v0.9.1
126 | 	github.com/rs/zerolog v1.28.0
127 | 	github.com/grpc-ecosystem/go-grpc-middleware v1.0.1-0.20190118093823-f849b5445de4
128 | 	github.com/grpc-ecosystem/go-grpc-middleware/providers/zerolog/v2 v2.0.0-rc.2
129 | 	github.com/grpc-ecosystem/go-grpc-middleware/v2 v2.0.0-rc.2
130 | 	github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0
131 | 	github.com/prometheus/client_golang v1.11.0
132 | 	google.golang.org/grpc v1.38.0
133 | 	google.golang.org/protobuf v1.26.0
134 | 	github.com/bytedance/sonic v1.12.1
135 | 	github.com/unionj-cloud/toolkit v0.0.1
136 | 	github.com/wubin1989/gen v0.0.5
137 | 	github.com/unionj-cloud/go-doudou/v2 ` + version.Release + `
138 | )`
139 | 
140 | const envTmpl = ``
141 | 
142 | const dockerignorefileTmpl = `**/*.local
143 | `
144 | 
145 | const dockerfileTmpl = `FROM devopsworks/golang-upx:1.18 AS builder
146 | 
147 | ENV GO111MODULE=on
148 | ENV GOPROXY=https://goproxy.cn,direct
149 | ARG user
150 | ENV HOST_USER=$user
151 | 
152 | WORKDIR /repo
153 | 
154 | # all the steps are cached
155 | ADD go.mod .
156 | ADD go.sum .
157 | # if go.mod/go.sum not changed, this step is also cached
158 | RUN go mod download
159 | 
160 | ADD . ./
161 | RUN go mod vendor
162 | 
163 | RUN export GDD_VER=$(go list -mod=vendor -m -f '{{` + "`" + `{{` + "`" + `}} .Version {{` + "`" + `}}` + "`" + `}}' github.com/unionj-cloud/go-doudou/v2) && \
164 | CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -v -ldflags="-s -w -X 'github.com/unionj-cloud/go-doudou/v2/framework/buildinfo.BuildUser=$HOST_USER' -X 'github.com/unionj-cloud/go-doudou/v2/framework/buildinfo.BuildTime=$(date)' -X 'github.com/unionj-cloud/go-doudou/v2/framework/buildinfo.GddVer=$GDD_VER'" -mod vendor -o api cmd/main.go && \
165 | strip api && /usr/local/bin/upx api
166 | 
167 | FROM alpine:3.14
168 | 
169 | COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /usr/share/zoneinfo/Asia/Shanghai
170 | ENV TZ="Asia/Shanghai"
171 | 
172 | WORKDIR /repo
173 | 
174 | COPY --from=builder /repo/api ./
175 | 
176 | COPY .env* ./
177 | 
178 | ENTRYPOINT ["/repo/api"]
179 | `
180 | 
181 | type InitProjConfig struct {
182 | 	Dir            string
183 | 	ModName        string
184 | 	Runner         executils.Runner
185 | 	Module         bool
186 | 	ProtoGenerator v3.ProtoGenerator
187 | 	JsonCase       string
188 | 	DocPath        string
189 | 	ProjectType    string
190 | }
191 | 
192 | // InitProj inits a service project
193 | // dir is root path
194 | // modName is module name
195 | func InitProj(conf InitProjConfig) {
196 | 	var (
197 | 		err         error
198 | 		svcName     string
199 | 		svcfile     string
200 | 		dtodir      string
201 | 		dtofile     string
202 | 		goVersion   string
203 | 		f           *os.File
204 | 		tpl         *template.Template
205 | 		envfile     string
206 | 		docPath     string
207 | 		projectType string
208 | 	)
209 | 	dir, modName, runner, module, jsonCase, docPath, projectType := conf.Dir, conf.ModName, conf.Runner, conf.Module, conf.JsonCase, conf.DocPath, conf.ProjectType
210 | 	if stringutils.IsEmpty(dir) {
211 | 		dir, _ = os.Getwd()
212 | 	}
213 | 	_ = os.MkdirAll(dir, os.ModePerm)
214 | 
215 | 	goVersion, err = common.GetGoVersionNum(runner)
216 | 	if err != nil {
217 | 		panic(err)
218 | 	}
219 | 	if stringutils.IsEmpty(modName) {
220 | 		modName = filepath.Base(dir)
221 | 	}
222 | 	modfile := filepath.Join(dir, "go.mod")
223 | 	if _, err = os.Stat(modfile); os.IsNotExist(err) {
224 | 		if f, err = os.Create(modfile); err != nil {
225 | 			panic(err)
226 | 		}
227 | 		defer f.Close()
228 | 
229 | 		tpl, _ = template.New("go.mod.tmpl").Parse(modTmpl)
230 | 		_ = tpl.Execute(f, struct {
231 | 			ModName   string
232 | 			GoVersion string
233 | 		}{
234 | 			ModName:   modName,
235 | 			GoVersion: goVersion,
236 | 		})
237 | 	} else {
238 | 		logrus.Warn("Project has already been initialized, it is not safe to be reinitialized")
239 | 		return
240 | 	}
241 | 	if module {
242 | 		if err = runner.Run("go", "work", "use", filepath.Base(dir)); err != nil {
243 | 			panic(err)
244 | 		}
245 | 	}
246 | 
247 | 	envfile = filepath.Join(dir, ".env")
248 | 	if f, err = os.Create(envfile); err != nil {
249 | 		panic(err)
250 | 	}
251 | 	defer f.Close()
252 | 
253 | 	tpl, _ = template.New(".env.tmpl").Parse(envTmpl)
254 | 	_ = tpl.Execute(f, struct {
255 | 		SvcName string
256 | 	}{
257 | 		SvcName: modName,
258 | 	})
259 | 
260 | 	if stringutils.IsNotEmpty(docPath) {
261 | 		server.GenSvcGo(dir, docPath)
262 | 	} else {
263 | 		dtodir = filepath.Join(dir, "dto")
264 | 		if err = os.MkdirAll(dtodir, os.ModePerm); err != nil {
265 | 			panic(err)
266 | 		}
267 | 		dtofile = filepath.Join(dtodir, "dto.go")
268 | 		if f, err = os.Create(dtofile); err != nil {
269 | 			panic(err)
270 | 		}
271 | 		defer f.Close()
272 | 
273 | 		tpl, _ = template.New(dtoTmpl).Parse(dtoTmpl)
274 | 		_ = tpl.Execute(f, struct {
275 | 			Version  string
276 | 			JsonCase string
277 | 		}{
278 | 			Version:  version.Release,
279 | 			JsonCase: jsonCase,
280 | 		})
281 | 
282 | 		svcName = strcase.ToCamel(filepath.Base(dir))
283 | 		svcfile = filepath.Join(dir, "svc.go")
284 | 		if f, err = os.Create(svcfile); err != nil {
285 | 			panic(err)
286 | 		}
287 | 		defer f.Close()
288 | 
289 | 		tpl, _ = template.New(svcTmpl).Parse(svcTmpl)
290 | 		_ = tpl.Execute(f, struct {
291 | 			DtoPackage  string
292 | 			SvcName     string
293 | 			Version     string
294 | 			JsonCase    string
295 | 			ProjectType string
296 | 		}{
297 | 			DtoPackage:  strings.ReplaceAll(filepath.Join(modName, "dto"), string(os.PathSeparator), "/"),
298 | 			SvcName:     svcName,
299 | 			Version:     version.Release,
300 | 			JsonCase:    jsonCase,
301 | 			ProjectType: projectType,
302 | 		})
303 | 	}
304 | 
305 | 	oldWd, _ := os.Getwd()
306 | 	os.Chdir(dir)
307 | 	if err = runner.Run("go", "generate", "./..."); err != nil {
308 | 		panic(err)
309 | 	}
310 | 	os.Chdir(oldWd)
311 | 
312 | 	dockerfile := filepath.Join(dir, "Dockerfile")
313 | 	if f, err = os.Create(dockerfile); err != nil {
314 | 		panic(err)
315 | 	}
316 | 	defer f.Close()
317 | 
318 | 	tpl, _ = template.New("dockerfile.tmpl").Parse(dockerfileTmpl)
319 | 	_ = tpl.Execute(f, nil)
320 | 
321 | 	dockerignorefile := filepath.Join(dir, ".dockerignore")
322 | 	if f, err = os.Create(dockerignorefile); err != nil {
323 | 		panic(err)
324 | 	}
325 | 	defer f.Close()
326 | 
327 | 	tpl, _ = template.New("dockerignorefile.tmpl").Parse(dockerignorefileTmpl)
328 | 	_ = tpl.Execute(f, nil)
329 | 
330 | 	if module {
331 | 		parser.ParseDto(dir, parser.DEFAULT_DTO_PKGS...)
332 | 		ic := astutils.BuildInterfaceCollector(filepath.Join(dir, "svc.go"), astutils.ExprString)
333 | 		genPlugin(dir, ic, CodeGenConfig{
334 | 			ProjectType: projectType,
335 | 		})
336 | 		genMain(dir, CodeGenConfig{
337 | 			ProjectType: projectType,
338 | 		})
339 | 		mainMainFile := filepath.Join(filepath.Dir(dir), "main", "cmd", "main.go")
340 | 		fileContent, err := ioutil.ReadFile(mainMainFile)
341 | 		if err != nil {
342 | 			panic(err)
343 | 		}
344 | 		pluginPkg := astutils.GetPkgPath(filepath.Join(dir, "plugin"))
345 | 		original := astutils.AppendImportStatements(fileContent, []byte(fmt.Sprintf(`_ "%s"`, pluginPkg)))
346 | 		astutils.FixImport(original, mainMainFile)
347 | 		// Comment below code due to performance issue
348 | 		//if err = runner.Run("go", "work", "sync"); err != nil {
349 | 		//	panic(err)
350 | 		//}
351 | 	}
352 | }
353 | 
354 | // InitSvc inits a service project, test purpose only
355 | func InitSvc(dir string) {
356 | }
```

cmd/internal/svc/codegen/init_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/stretchr/testify/assert"
9 | 	"github.com/unionj-cloud/toolkit/executils"
10 | )
11 | 
12 | func TestInitProj(t *testing.T) {
13 | 	dir := filepath.Join("testdata", "init")
14 | 	os.MkdirAll(dir, os.ModePerm)
15 | 	defer os.RemoveAll(dir)
16 | 	conf := InitProjConfig{
17 | 		Dir:      dir,
18 | 		ModName:  "testinit",
19 | 		Runner:   executils.CmdRunner{},
20 | 	}
21 | 	assert.NotPanics(t, func() {
22 | 		InitProj(conf)
23 | 	})
24 | }
```

cmd/internal/svc/codegen/k8sdeployment.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"io/ioutil"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/Jeffail/gabs/v2"
11 | 	"github.com/goccy/go-yaml"
12 | 	"github.com/sirupsen/logrus"
13 | )
14 | 
15 | var deploymentTmpl = `apiVersion: apps/v1
16 | kind: Deployment
17 | metadata:
18 |   name: {{.SvcName}}-deployment
19 | spec:
20 |   replicas: 1
21 |   selector:
22 |     matchLabels:
23 |       app: {{.SvcName}}
24 |   template:
25 |     metadata:
26 |       labels:
27 |         app: {{.SvcName}}
28 |     spec:
29 |       containers:
30 |         - name: {{.SvcName}}
31 |           image: {{.Image}}
32 |           imagePullPolicy: Always
33 |           ports:
34 |             - name: http-port
35 |               containerPort: 6060
36 |               protocol: TCP
37 |           resources:
38 |             requests:
39 |               cpu: 100m
40 |               memory: 128Mi
41 |       restartPolicy: Always
42 | ---
43 | apiVersion: v1
44 | kind: Service
45 | metadata:
46 |   name: {{.SvcName}}-service
47 | spec:
48 |   type: LoadBalancer
49 |   externalTrafficPolicy: Cluster
50 |   selector:
51 |     app: {{.SvcName}}
52 |   ports:
53 |     - protocol: TCP
54 |       port: 6060
55 |       targetPort: 6060`
56 | 
57 | // GenK8sDeployment generates deployment kind yaml file for kubernetes deploy.
58 | func GenK8sDeployment(dir string, svcname, image string) {
59 | 	var (
60 | 		f   *os.File
61 | 		tpl *template.Template
62 | 	)
63 | 	file := filepath.Join(dir, svcname+"_deployment.yaml")
64 | 	if _, err := os.Stat(file); os.IsNotExist(err) {
65 | 		if f, err = os.Create(file); err != nil {
66 | 			panic(err)
67 | 		}
68 | 		defer f.Close()
69 | 
70 | 		if tpl, err = template.New("deployment.tmpl").Parse(deploymentTmpl); err != nil {
71 | 			panic(err)
72 | 		}
73 | 		if err = tpl.Execute(f, struct {
74 | 			SvcName string
75 | 			Image   string
76 | 		}{
77 | 			SvcName: svcname,
78 | 			Image:   image,
79 | 		}); err != nil {
80 | 			panic(err)
81 | 		}
82 | 	} else {
83 | 		logrus.Warnf("image version will be modified in file %s", file)
84 | 		err = ioutil.WriteFile(file, modifyVersion(file, image), os.ModePerm)
85 | 		if err != nil {
86 | 			panic(err)
87 | 		}
88 | 	}
89 | }
90 | 
91 | func modifyVersion(yfile string, image string) []byte {
92 | 	var (
93 | 		f                             *os.File
94 | 		err                           error
95 | 		raw, jdeployment, ddeployment []byte
96 | 		deployment                    string
97 | 	)
98 | 	if f, err = os.Open(yfile); err != nil {
99 | 		panic(err)
100 | 	}
101 | 	defer f.Close()
102 | 	raw, err = ioutil.ReadAll(f)
103 | 	if err != nil {
104 | 		panic(err)
105 | 	}
106 | 	blocks := strings.Split(string(raw), "---")
107 | 	deployment = blocks[0]
108 | 
109 | 	jdeployment, err = yaml.YAMLToJSON([]byte(deployment))
110 | 	if err != nil {
111 | 		panic(err)
112 | 	}
113 | 	c, err := gabs.ParseJSON(jdeployment)
114 | 	if err != nil {
115 | 		panic(err)
116 | 	}
117 | 	c.Set(image, gabs.DotPathToSlice("spec.template.spec.containers.0.image")...)
118 | 	if err != nil {
119 | 		panic(err)
120 | 	}
121 | 	ddeployment, _ = yaml.JSONToYAML(c.Bytes())
122 | 	blocks[0] = string(ddeployment)
123 | 	return []byte(strings.Join(blocks, "---"))
124 | }
```

cmd/internal/svc/codegen/k8sdeployment_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"fmt"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"testing"
8 | 
9 | 	"github.com/unionj-cloud/toolkit/pathutils"
10 | )
11 | 
12 | func TestModifyVersion(t *testing.T) {
13 | 	type args struct {
14 | 		yfile string
15 | 	}
16 | 	tests := []struct {
17 | 		name string
18 | 		args args
19 | 	}{
20 | 		{
21 | 			name: "",
22 | 			args: args{
23 | 				yfile: pathutils.Abs("./testdata/k8s.yaml"),
24 | 			},
25 | 		},
26 | 	}
27 | 	for _, tt := range tests {
28 | 		t.Run(tt.name, func(t *testing.T) {
29 | 			result := modifyVersion(tt.args.yfile, "v1.0.0")
30 | 			fmt.Println(string(result))
31 | 		})
32 | 	}
33 | }
34 | 
35 | func TestModifyVersion2(t *testing.T) {
36 | 	type args struct {
37 | 		yfile string
38 | 	}
39 | 	tests := []struct {
40 | 		name string
41 | 		args args
42 | 	}{
43 | 		{
44 | 			name: "",
45 | 			args: args{
46 | 				yfile: pathutils.Abs("./testdata/corpus_statefulset.yaml"),
47 | 			},
48 | 		},
49 | 	}
50 | 	for _, tt := range tests {
51 | 		t.Run(tt.name, func(t *testing.T) {
52 | 			result := modifyVersion(tt.args.yfile, "v1.0.0")
53 | 			fmt.Println(string(result))
54 | 		})
55 | 	}
56 | }
57 | 
58 | func TestGenK8sDeployment(t *testing.T) {
59 | 	type args struct {
60 | 		dir     string
61 | 		svcname string
62 | 		image   string
63 | 	}
64 | 	tests := []struct {
65 | 		name string
66 | 		args args
67 | 	}{
68 | 		{
69 | 			name: "",
70 | 			args: args{
71 | 				dir:     pathutils.Abs("./testdata"),
72 | 				svcname: "corpus",
73 | 				image:   "google.com/corpus:v2.0.0",
74 | 			},
75 | 		},
76 | 	}
77 | 	for _, tt := range tests {
78 | 		t.Run(tt.name, func(t *testing.T) {
79 | 			GenK8sDeployment(tt.args.dir, tt.args.svcname, tt.args.image)
80 | 		})
81 | 	}
82 | }
83 | 
84 | func TestGenK8sDeployment2(t *testing.T) {
85 | 	os.MkdirAll(filepath.Join("testdata", "nodeployment"), os.ModePerm)
86 | 	defer os.RemoveAll(filepath.Join("testdata", "nodeployment"))
87 | 	type args struct {
88 | 		dir     string
89 | 		svcname string
90 | 		image   string
91 | 	}
92 | 	tests := []struct {
93 | 		name string
94 | 		args args
95 | 	}{
96 | 		{
97 | 			name: "",
98 | 			args: args{
99 | 				dir:     filepath.Join("testdata", "nodeployment"),
100 | 				svcname: "corpus",
101 | 				image:   "google.com/corpus:v2.0.0",
102 | 			},
103 | 		},
104 | 	}
105 | 	for _, tt := range tests {
106 | 		t.Run(tt.name, func(t *testing.T) {
107 | 			GenK8sDeployment(tt.args.dir, tt.args.svcname, tt.args.image)
108 | 		})
109 | 	}
110 | }
```

cmd/internal/svc/codegen/k8sstatefulset.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"io/ioutil"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"text/template"
8 | 
9 | 	"github.com/sirupsen/logrus"
10 | )
11 | 
12 | var statefulsetTmpl = `apiVersion: apps/v1
13 | kind: StatefulSet
14 | metadata:
15 |   name: {{.SvcName}}-statefulset
16 | spec:
17 |   selector:
18 |     matchLabels:
19 |       app: {{.SvcName}}
20 |   serviceName: {{.SvcName}}-svc-headless
21 |   replicas: 1
22 |   template:
23 |     metadata:
24 |       labels:
25 |         app: {{.SvcName}}
26 |     spec:
27 |       terminationGracePeriodSeconds: 10
28 |       containers:
29 |         - name: {{.SvcName}}
30 |           image: {{.Image}}
31 |           imagePullPolicy: Always
32 |           ports:
33 |             - name: http-port
34 |               containerPort: 6060
35 |               protocol: TCP
36 |           resources:
37 |             requests:
38 |               cpu: 100m
39 |               memory: 128Mi
40 |       restartPolicy: Always
41 | ---
42 | apiVersion: v1
43 | kind: Service
44 | metadata:
45 |   name: {{.SvcName}}-svc-headless
46 | spec:
47 |   selector:
48 |     app: {{.SvcName}}
49 |   ports:
50 |     - protocol: TCP
51 |       port: 6060
52 |       targetPort: 6060
53 |   clusterIP: None`
54 | 
55 | // GenK8sStatefulset generates statefulset kind yaml file for kubernetes deploy
56 | func GenK8sStatefulset(dir string, svcname, image string) {
57 | 	var (
58 | 		f   *os.File
59 | 		tpl *template.Template
60 | 	)
61 | 	file := filepath.Join(dir, svcname+"_statefulset.yaml")
62 | 	if _, err := os.Stat(file); os.IsNotExist(err) {
63 | 		if f, err = os.Create(file); err != nil {
64 | 			panic(err)
65 | 		}
66 | 		defer f.Close()
67 | 
68 | 		if tpl, err = template.New("statefulset.tmpl").Parse(statefulsetTmpl); err != nil {
69 | 			panic(err)
70 | 		}
71 | 		if err = tpl.Execute(f, struct {
72 | 			SvcName string
73 | 			Image   string
74 | 		}{
75 | 			SvcName: svcname,
76 | 			Image:   image,
77 | 		}); err != nil {
78 | 			panic(err)
79 | 		}
80 | 	} else {
81 | 		logrus.Warnf("image version will be modified in file %s", file)
82 | 		err = ioutil.WriteFile(file, modifyVersion(file, image), os.ModePerm)
83 | 		if err != nil {
84 | 			panic(err)
85 | 		}
86 | 	}
87 | }
```

cmd/internal/svc/codegen/k8sstatefulset_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/unionj-cloud/toolkit/pathutils"
9 | )
10 | 
11 | func TestGenK8sStatefulset(t *testing.T) {
12 | 	type args struct {
13 | 		dir     string
14 | 		svcname string
15 | 		image   string
16 | 	}
17 | 	tests := []struct {
18 | 		name string
19 | 		args args
20 | 	}{
21 | 		{
22 | 			name: "",
23 | 			args: args{
24 | 				dir:     pathutils.Abs("./testdata"),
25 | 				svcname: "corpus",
26 | 				image:   "google.com/corpus:v2.0.0",
27 | 			},
28 | 		},
29 | 	}
30 | 	for _, tt := range tests {
31 | 		t.Run(tt.name, func(t *testing.T) {
32 | 			GenK8sStatefulset(tt.args.dir, tt.args.svcname, tt.args.image)
33 | 		})
34 | 	}
35 | }
36 | 
37 | func TestGenK8sStatefulset2(t *testing.T) {
38 | 	os.MkdirAll(filepath.Join("testdata", "nostatefulset"), os.ModePerm)
39 | 	defer os.RemoveAll(filepath.Join("testdata", "nostatefulset"))
40 | 	type args struct {
41 | 		dir     string
42 | 		svcname string
43 | 		image   string
44 | 	}
45 | 	tests := []struct {
46 | 		name string
47 | 		args args
48 | 	}{
49 | 		{
50 | 			name: "",
51 | 			args: args{
52 | 				dir:     filepath.Join("testdata", "nostatefulset"),
53 | 				svcname: "corpus",
54 | 				image:   "google.com/corpus:v2.0.0",
55 | 			},
56 | 		},
57 | 	}
58 | 	for _, tt := range tests {
59 | 		t.Run(tt.name, func(t *testing.T) {
60 | 			GenK8sStatefulset(tt.args.dir, tt.args.svcname, tt.args.image)
61 | 		})
62 | 	}
63 | }
```

cmd/internal/svc/codegen/main.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"text/template"
7 | 
8 | 	"github.com/sirupsen/logrus"
9 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
10 | 	"github.com/unionj-cloud/toolkit/astutils"
11 | 	"github.com/unionj-cloud/go-doudou/v2/version"
12 | )
13 | 
14 | var mainTmpl = templates.EditableHeaderTmpl + `package main
15 | 
16 | import (
17 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
18 | 	{{.ServiceAlias}} "{{.ServicePackage}}"
19 |     {{- if .QueryPackage}}
20 | 	"{{.QueryPackage}}"
21 | 	"github.com/unionj-cloud/go-doudou/v2/framework/database"
22 | 	{{- end}}
23 |     "{{.ConfigPackage}}"
24 | 	"{{.HttpPackage}}"
25 | )
26 | 
27 | func main() {
28 | 	conf := config.LoadFromEnv()
29 | {{- if .QueryPackage}}
30 | 	query.SetDefault(database.NewDb(conf.Config))
31 | {{- end}}
32 |     svc := {{.ServiceAlias}}.New{{.SvcName}}(conf)
33 | 	handler := httpsrv.New{{.SvcName}}Handler(svc)
34 | 	srv := rest.NewRestServer()
35 | 	srv.AddRoutes(httpsrv.Routes(handler))
36 | 	srv.AddRoutes(rest.DocRoutes(service.Oas))
37 | 	srv.Run()
38 | }
39 | `
40 | 
41 | // GenMain generates main function
42 | func GenMain(dir string, ic astutils.InterfaceCollector) {
43 | 	var (
44 | 		err      error
45 | 		mainfile string
46 | 		f        *os.File
47 | 		tpl      *template.Template
48 | 		cmdDir   string
49 | 		svcName  string
50 | 		alias    string
51 | 	)
52 | 	cmdDir = filepath.Join(dir, "cmd")
53 | 	if err = MkdirAll(cmdDir, os.ModePerm); err != nil {
54 | 		panic(err)
55 | 	}
56 | 
57 | 	svcName = ic.Interfaces[0].Name
58 | 	alias = ic.Package.Name
59 | 	mainfile = filepath.Join(cmdDir, "main.go")
60 | 	if _, err = Stat(mainfile); os.IsNotExist(err) {
61 | 		servicePkg := astutils.GetPkgPath(dir)
62 | 		cfgPkg := astutils.GetPkgPath(filepath.Join(dir, "config"))
63 | 		httpsrvPkg := astutils.GetPkgPath(filepath.Join(dir, "transport", "httpsrv"))
64 | 		var queryPkg string
65 | 		if _, err := Stat(filepath.Join(dir, "query")); err == nil {
66 | 			queryPkg = astutils.GetPkgPath(filepath.Join(dir, "query"))
67 | 		}
68 | 
69 | 		if f, err = Create(mainfile); err != nil {
70 | 			panic(err)
71 | 		}
72 | 		defer f.Close()
73 | 
74 | 		if tpl, err = template.New("main.go.tmpl").Parse(mainTmpl); err != nil {
75 | 			panic(err)
76 | 		}
77 | 		if err = tpl.Execute(f, struct {
78 | 			ServicePackage string
79 | 			ConfigPackage  string
80 | 			HttpPackage    string
81 | 			SvcName        string
82 | 			ServiceAlias   string
83 | 			Version        string
84 | 			QueryPackage   string
85 | 		}{
86 | 			ServicePackage: servicePkg,
87 | 			ConfigPackage:  cfgPkg,
88 | 			HttpPackage:    httpsrvPkg,
89 | 			SvcName:        svcName,
90 | 			ServiceAlias:   alias,
91 | 			Version:        version.Release,
92 | 			QueryPackage:   queryPkg,
93 | 		}); err != nil {
94 | 			panic(err)
95 | 		}
96 | 	} else {
97 | 		logrus.Warnf("file %s already exists", mainfile)
98 | 	}
99 | }
```

cmd/internal/svc/codegen/main_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"testing"
7 | 
8 | 	"github.com/pkg/errors"
9 | 	. "github.com/smartystreets/goconvey/convey"
10 | 	"github.com/unionj-cloud/toolkit/astutils"
11 | )
12 | 
13 | func TestGenMainPanic_Stat(t *testing.T) {
14 | 	Convey("Test GenMain panic from Stat", t, func() {
15 | 		dir := testDir + "main"
16 | 		InitSvc(dir)
17 | 		defer os.RemoveAll(dir)
18 | 		MkdirAll = os.MkdirAll
19 | 		Open = os.Open
20 | 		Create = os.Create
21 | 		Stat = os.Stat
22 | 		Stat = func(name string) (os.FileInfo, error) {
23 | 			return nil, errors.New("mock Stat error")
24 | 		}
25 | 
26 | 		svcfile := filepath.Join(dir, "svc.go")
27 | 		ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
28 | 
29 | 		So(func() {
30 | 			GenMain(dir, ic)
31 | 		}, ShouldNotPanic)
32 | 	})
33 | }
34 | 
35 | func TestGenMainPanic_Create(t *testing.T) {
36 | 	Convey("Test GenMain panic from Create", t, func() {
37 | 		dir := testDir + "main"
38 | 		InitSvc(dir)
39 | 		defer os.RemoveAll(dir)
40 | 		MkdirAll = os.MkdirAll
41 | 		Open = os.Open
42 | 		Create = os.Create
43 | 		Stat = os.Stat
44 | 		Create = func(name string) (*os.File, error) {
45 | 			return nil, errors.New("mock Create error")
46 | 		}
47 | 		svcfile := filepath.Join(dir, "svc.go")
48 | 		ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
49 | 
50 | 		So(func() {
51 | 			GenMain(dir, ic)
52 | 		}, ShouldPanic)
53 | 	})
54 | }
55 | 
56 | func TestGenMainPanic_Open(t *testing.T) {
57 | 	Convey("Test GenMain panic from Open", t, func() {
58 | 		dir := testDir + "main"
59 | 		InitSvc(dir)
60 | 		defer os.RemoveAll(dir)
61 | 		MkdirAll = os.MkdirAll
62 | 		Open = os.Open
63 | 		Create = os.Create
64 | 		Stat = os.Stat
65 | 		Open = func(name string) (*os.File, error) {
66 | 			return nil, errors.New("mock Open error")
67 | 		}
68 | 		svcfile := filepath.Join(dir, "svc.go")
69 | 		ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
70 | 
71 | 		So(func() {
72 | 			GenMain(dir, ic)
73 | 		}, ShouldPanic)
74 | 	})
75 | }
76 | 
77 | func TestGenMainPanic_MkdirAll(t *testing.T) {
78 | 	Convey("Test GenMain panic from MkdirAll", t, func() {
79 | 		dir := testDir + "main"
80 | 		InitSvc(dir)
81 | 		defer os.RemoveAll(dir)
82 | 		MkdirAll = os.MkdirAll
83 | 		Open = os.Open
84 | 		Create = os.Create
85 | 		Stat = os.Stat
86 | 		MkdirAll = func(path string, perm os.FileMode) error {
87 | 			return errors.New("mock MkdirAll error")
88 | 		}
89 | 		svcfile := filepath.Join(dir, "svc.go")
90 | 		ic := astutils.BuildInterfaceCollector(svcfile, astutils.ExprString)
91 | 
92 | 		So(func() {
93 | 			GenMain(dir, ic)
94 | 		}, ShouldPanic)
95 | 	})
96 | }
```

cmd/internal/svc/codegen/mainmodule.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
11 | 	"github.com/unionj-cloud/toolkit/astutils"
12 | 	"github.com/unionj-cloud/go-doudou/v2/version"
13 | )
14 | 
15 | func genMain(dir string, conf CodeGenConfig) {
16 | 	var (
17 | 		err      error
18 | 		mainfile string
19 | 		f        *os.File
20 | 		tpl      *template.Template
21 | 		cmdDir   string
22 | 		buf      bytes.Buffer
23 | 	)
24 | 	cmdDir = filepath.Join(dir, "cmd")
25 | 	if err = MkdirAll(cmdDir, os.ModePerm); err != nil {
26 | 		panic(err)
27 | 	}
28 | 	mainfile = filepath.Join(cmdDir, "main.go")
29 | 	if f, err = Create(mainfile); err != nil {
30 | 		panic(err)
31 | 	}
32 | 	defer f.Close()
33 | 
34 | 	if tpl, err = template.New(templates.MainTmpl).Parse(templates.MainTmpl); err != nil {
35 | 		panic(err)
36 | 	}
37 | 	pluginPkg := astutils.GetPkgPath(filepath.Join(dir, "plugin"))
38 | 	if err = tpl.Execute(&buf, struct {
39 | 		CodeGenConfig
40 | 		PluginPackage string
41 | 		Version       string
42 | 	}{
43 | 		PluginPackage: pluginPkg,
44 | 		Version:       version.Release,
45 | 		CodeGenConfig: conf,
46 | 	}); err != nil {
47 | 		panic(err)
48 | 	}
49 | 	astutils.FixImport([]byte(strings.TrimSpace(buf.String())), mainfile)
50 | }
```

cmd/internal/svc/codegen/plugin.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 	"text/template"
9 | 
10 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
11 | 	"github.com/unionj-cloud/toolkit/astutils"
12 | 	"github.com/unionj-cloud/go-doudou/v2/version"
13 | )
14 | 
15 | type CodeGenConfig struct {
16 | 	ProjectType string
17 | }
18 | 
19 | func genPlugin(dir string, ic astutils.InterfaceCollector, conf CodeGenConfig) {
20 | 	var (
21 | 		err        error
22 | 		pluginFile string
23 | 		f          *os.File
24 | 		tpl        *template.Template
25 | 		pluginDir  string
26 | 		buf        bytes.Buffer
27 | 	)
28 | 	pluginDir = filepath.Join(dir, "plugin")
29 | 	if err = MkdirAll(pluginDir, os.ModePerm); err != nil {
30 | 		panic(err)
31 | 	}
32 | 	pluginFile = filepath.Join(pluginDir, "plugin.go")
33 | 	if f, err = Create(pluginFile); err != nil {
34 | 		panic(err)
35 | 	}
36 | 	defer f.Close()
37 | 
38 | 	funcMap := make(map[string]interface{})
39 | 	funcMap["toLower"] = strings.ToLower
40 | 	if tpl, err = template.New(templates.PluginTmpl).Funcs(funcMap).Parse(templates.PluginTmpl); err != nil {
41 | 		panic(err)
42 | 	}
43 | 
44 | 	servicePkg := astutils.GetPkgPath(dir)
45 | 	cfgPkg := astutils.GetPkgPath(filepath.Join(dir, "config"))
46 | 	httpsrvPkg := astutils.GetPkgPath(filepath.Join(dir, "transport", "httpsrv"))
47 | 	transGrpcPkg := astutils.GetPkgPath(filepath.Join(dir, "transport", "grpc"))
48 | 	svcName := ic.Interfaces[0].Name
49 | 	alias := ic.Package.Name
50 | 	if err = tpl.Execute(&buf, struct {
51 | 		CodeGenConfig
52 | 		ServicePackage       string
53 | 		ConfigPackage        string
54 | 		TransportGrpcPackage string
55 | 		TransportHttpPackage string
56 | 		ServiceAlias         string
57 | 		SvcName              string
58 | 		Version              string
59 | 	}{
60 | 		ServicePackage:       servicePkg,
61 | 		ConfigPackage:        cfgPkg,
62 | 		TransportGrpcPackage: transGrpcPkg,
63 | 		TransportHttpPackage: httpsrvPkg,
64 | 		ServiceAlias:         alias,
65 | 		SvcName:              svcName,
66 | 		Version:              version.Release,
67 | 		CodeGenConfig:        conf,
68 | 	}); err != nil {
69 | 		panic(err)
70 | 	}
71 | 	astutils.FixImport([]byte(strings.TrimSpace(buf.String())), pluginFile)
72 | }
```

cmd/internal/svc/codegen/svcimpl.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"io/ioutil"
6 | 	"os"
7 | 	"path/filepath"
8 | 	"text/template"
9 | 
10 | 	"github.com/iancoleman/strcase"
11 | 	"github.com/sirupsen/logrus"
12 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
13 | 	"github.com/unionj-cloud/toolkit/astutils"
14 | 	"github.com/unionj-cloud/toolkit/copier"
15 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
16 | 	"github.com/unionj-cloud/go-doudou/v2/version"
17 | )
18 | 
19 | var svcimportTmpl = `
20 | 	"context"
21 | 	"{{.ConfigPackage}}"
22 | 	"{{.DtoPackage}}"
23 | 	"github.com/brianvoe/gofakeit/v6"
24 | `
25 | 
26 | var appendPart = `{{- range $m := .Meta.Methods }}
27 | 	func (receiver *{{$.Meta.Name}}Impl) {{$m.Name}}({{- range $i, $p := $m.Params}}
28 |     {{- if $i}},{{end}}
29 |     {{- $p.Name}} {{$p.Type}}
30 |     {{- end }}) ({{- range $i, $r := $m.Results}}
31 |                      {{- if $i}},{{end}}
32 |                      {{- $r.Name}} {{$r.Type}}
33 |                      {{- end }}) {
34 |     	var _result struct{
35 | 			{{- range $r := $m.Results }}
36 | 			{{- if ne $r.Type "error" }}
37 | 			{{ $r.Name | toCamel }} {{ $r.Type }}
38 | 			{{- end }}
39 | 			{{- end }}
40 | 		}
41 | 		_ = gofakeit.Struct(&_result)
42 | 		return {{range $i, $r := $m.Results }}{{- if $i}},{{end}}{{ if eq $r.Type "error" }}nil{{else}}_result.{{ $r.Name | toCamel }}{{end}}{{- end }}
43 |     }
44 | {{- end }}`
45 | 
46 | var svcimplTmpl = templates.EditableHeaderTmpl + `package {{.SvcPackage}}
47 | 
48 | import ()
49 | 
50 | var _ {{.Meta.Name}} = (*{{.Meta.Name}}Impl)(nil)
51 | 
52 | type {{.Meta.Name}}Impl struct {
53 | 	conf *config.Config
54 | }
55 | 
56 | ` + appendPart + `
57 | 
58 | func New{{.Meta.Name}}(conf *config.Config) *{{.Meta.Name}}Impl {
59 | 	return &{{.Meta.Name}}Impl{
60 | 		conf: conf,
61 | 	}
62 | }
63 | `
64 | 
65 | var svcimportTmplGrpc = `
66 | 	"context"
67 | 	"{{.ConfigPackage}}"
68 | 	pb "{{.PbPackage}}"
69 | 	"google.golang.org/protobuf/types/known/emptypb"
70 | `
71 | 
72 | var appendPartGrpc = `{{- range $m := .GrpcSvc.Rpcs }}
73 |     {{- if eq $m.StreamType 0 }}
74 | 	func (receiver *{{$.Meta.Name}}Impl) {{$m.Name}}(ctx context.Context, request *{{$m.Request | convert}}) (*{{$m.Response | convert}}, error) {
75 |     	//TODO implement me
76 | 		panic("implement me")
77 |     }
78 |     {{- end }}
79 |     {{- if eq $m.StreamType 1 }}
80 | 	func (receiver *{{$.Meta.Name}}Impl) {{$m.Name}}(server pb.{{$.GrpcSvc.Name}}_{{$m.Name}}Server) error {
81 | 		//TODO implement me
82 | 		panic("implement me")
83 | 	}
84 |     {{- end }}
85 |     {{- if eq $m.StreamType 2 }}
86 | 	func (receiver *{{$.Meta.Name}}Impl) {{$m.Name}}(server pb.{{$.GrpcSvc.Name}}_{{$m.Name}}Server) error {
87 | 		//TODO implement me
88 | 		panic("implement me")
89 | 	}
90 |     {{- end }}
91 |     {{- if eq $m.StreamType 3 }}
92 | 	func (receiver *{{$.Meta.Name}}Impl) {{$m.Name}}(request *{{$m.Request | convert}}, server pb.{{$.GrpcSvc.Name}}_{{$m.Name}}Server) error {
93 | 		//TODO implement me
94 | 		panic("implement me")
95 | 	}
96 |     {{- end }}
97 | {{- end }}`
98 | 
99 | var svcimplTmplGrpc = templates.EditableHeaderTmpl + `package {{.SvcPackage}}
100 | 
101 | import ()
102 | 
103 | var _ pb.{{.GrpcSvc.Name}}Server = (*{{.Meta.Name}}Impl)(nil)
104 | 
105 | type {{.Meta.Name}}Impl struct {
106 |     pb.Unimplemented{{.GrpcSvc.Name}}Server
107 | 	conf *config.Config
108 | }
109 | 
110 | ` + appendPartGrpc + `
111 | 
112 | func New{{.Meta.Name}}(conf *config.Config) *{{.Meta.Name}}Impl {
113 | 	return &{{.Meta.Name}}Impl{
114 | 		conf: conf,
115 | 	}
116 | }
117 | `
118 | 
119 | // GenSvcImpl generates service implementation
120 | func GenSvcImpl(dir string, ic astutils.InterfaceCollector) {
121 | 	var (
122 | 		err         error
123 | 		svcimplfile string
124 | 		f           *os.File
125 | 		tpl         *template.Template
126 | 		buf         bytes.Buffer
127 | 		meta        astutils.InterfaceMeta
128 | 		tmpl        string
129 | 		importBuf   bytes.Buffer
130 | 	)
131 | 	svcimplfile = filepath.Join(dir, "svcimpl.go")
132 | 	err = copier.DeepCopy(ic.Interfaces[0], &meta)
133 | 	if err != nil {
134 | 		panic(err)
135 | 	}
136 | 	cfgPkg := astutils.GetPkgPath(filepath.Join(dir, "config"))
137 | 	if _, err = os.Stat(svcimplfile); os.IsNotExist(err) {
138 | 		if f, err = os.Create(svcimplfile); err != nil {
139 | 			panic(err)
140 | 		}
141 | 		defer f.Close()
142 | 		tmpl = svcimplTmpl
143 | 	} else {
144 | 		logrus.Warningln("New content will be append to file svcimpl.go")
145 | 		if f, err = os.OpenFile(svcimplfile, os.O_APPEND, os.ModePerm); err != nil {
146 | 			panic(err)
147 | 		}
148 | 		defer f.Close()
149 | 		tmpl = appendPart
150 | 
151 | 		sc := astutils.NewStructCollector(astutils.ExprString)
152 | 		astutils.CollectStructsInFolder(dir, sc)
153 | 		if implementations, exists := sc.Methods[meta.Name+"Impl"]; exists {
154 | 			var notimplemented []astutils.MethodMeta
155 | 			for _, item := range meta.Methods {
156 | 				for _, implemented := range implementations {
157 | 					if item.Name == implemented.Name {
158 | 						goto L
159 | 					}
160 | 				}
161 | 				notimplemented = append(notimplemented, item)
162 | 
163 | 			L:
164 | 			}
165 | 
166 | 			meta.Methods = notimplemented
167 | 		}
168 | 	}
169 | 
170 | 	funcMap := make(map[string]interface{})
171 | 	funcMap["toCamel"] = strcase.ToCamel
172 | 	if tpl, err = template.New(tmpl).Funcs(funcMap).Parse(tmpl); err != nil {
173 | 		panic(err)
174 | 	}
175 | 	if err = tpl.Execute(&buf, struct {
176 | 		ConfigPackage string
177 | 		VoPackage     string
178 | 		SvcPackage    string
179 | 		Meta          astutils.InterfaceMeta
180 | 		Version       string
181 | 	}{
182 | 		ConfigPackage: cfgPkg,
183 | 		SvcPackage:    ic.Package.Name,
184 | 		Meta:          meta,
185 | 		Version:       version.Release,
186 | 	}); err != nil {
187 | 		panic(err)
188 | 	}
189 | 
190 | 	original, err := ioutil.ReadAll(f)
191 | 	if err != nil {
192 | 		panic(err)
193 | 	}
194 | 
195 | 	original = append(original, buf.Bytes()...)
196 | 	dtoPkg := astutils.GetPkgPath(filepath.Join(dir, "dto"))
197 | 	if tpl, err = template.New(svcimportTmpl).Parse(svcimportTmpl); err != nil {
198 | 		panic(err)
199 | 	}
200 | 	if err = tpl.Execute(&importBuf, struct {
201 | 		ConfigPackage string
202 | 		DtoPackage    string
203 | 	}{
204 | 		ConfigPackage: cfgPkg,
205 | 		DtoPackage:    dtoPkg,
206 | 	}); err != nil {
207 | 		panic(err)
208 | 	}
209 | 	original = astutils.AppendImportStatements(original, importBuf.Bytes())
210 | 	original = astutils.RestRelatedModify(original, meta.Name)
211 | 	//fmt.Println(string(original))
212 | 	astutils.FixImport(original, svcimplfile)
213 | }
214 | 
215 | func convert(m v3.Message) string {
216 | 	if !m.IsImported {
217 | 		return "pb." + m.String()
218 | 	}
219 | 	return m.String()
220 | }
221 | 
222 | // GenSvcImplGrpc generates service implementation for grpc
223 | func GenSvcImplGrpc(dir string, ic astutils.InterfaceCollector, grpcSvc v3.Service) {
224 | 	var (
225 | 		err         error
226 | 		svcimplfile string
227 | 		f           *os.File
228 | 		tpl         *template.Template
229 | 		buf         bytes.Buffer
230 | 		meta        astutils.InterfaceMeta
231 | 		tmpl        string
232 | 		importBuf   bytes.Buffer
233 | 	)
234 | 	svcimplfile = filepath.Join(dir, "svcimpl.go")
235 | 	err = copier.DeepCopy(ic.Interfaces[0], &meta)
236 | 	if err != nil {
237 | 		panic(err)
238 | 	}
239 | 	if _, err = os.Stat(svcimplfile); os.IsNotExist(err) {
240 | 		if f, err = os.Create(svcimplfile); err != nil {
241 | 			panic(err)
242 | 		}
243 | 		defer f.Close()
244 | 		tmpl = svcimplTmplGrpc
245 | 	} else {
246 | 		logrus.Warningln("New content will be append to file svcimpl.go")
247 | 		if f, err = os.OpenFile(svcimplfile, os.O_APPEND, os.ModePerm); err != nil {
248 | 			panic(err)
249 | 		}
250 | 		defer f.Close()
251 | 		tmpl = appendPartGrpc
252 | 
253 | 		sc := astutils.NewStructCollector(astutils.ExprString)
254 | 		astutils.CollectStructsInFolder(dir, sc)
255 | 		if implementations, exists := sc.Methods[meta.Name+"Impl"]; exists {
256 | 			var notimplemented []v3.Rpc
257 | 			for _, item := range grpcSvc.Rpcs {
258 | 				for _, implemented := range implementations {
259 | 					if item.Name == implemented.Name {
260 | 						goto L
261 | 					}
262 | 				}
263 | 				notimplemented = append(notimplemented, item)
264 | 
265 | 			L:
266 | 			}
267 | 
268 | 			grpcSvc.Rpcs = notimplemented
269 | 		}
270 | 	}
271 | 
272 | 	funcMap := make(map[string]interface{})
273 | 	funcMap["toCamel"] = strcase.ToCamel
274 | 	funcMap["convert"] = convert
275 | 	if tpl, err = template.New("svcimpl.go.tmpl").Funcs(funcMap).Parse(tmpl); err != nil {
276 | 		panic(err)
277 | 	}
278 | 	cfgPkg := astutils.GetPkgPath(filepath.Join(dir, "config"))
279 | 	pbPkg := astutils.GetPkgPath(filepath.Join(dir, "transport", "grpc"))
280 | 	if err = tpl.Execute(&buf, struct {
281 | 		ConfigPackage string
282 | 		PbPackage     string
283 | 		SvcPackage    string
284 | 		Meta          astutils.InterfaceMeta
285 | 		GrpcSvc       v3.Service
286 | 		Version       string
287 | 	}{
288 | 		ConfigPackage: cfgPkg,
289 | 		PbPackage:     pbPkg,
290 | 		SvcPackage:    ic.Package.Name,
291 | 		Meta:          meta,
292 | 		GrpcSvc:       grpcSvc,
293 | 		Version:       version.Release,
294 | 	}); err != nil {
295 | 		panic(err)
296 | 	}
297 | 
298 | 	original, err := ioutil.ReadAll(f)
299 | 	if err != nil {
300 | 		panic(err)
301 | 	}
302 | 
303 | 	original = append(original, buf.Bytes()...)
304 | 	if tpl, err = template.New("simportimpl.go.tmpl").Parse(svcimportTmplGrpc); err != nil {
305 | 		panic(err)
306 | 	}
307 | 	if err = tpl.Execute(&importBuf, struct {
308 | 		ConfigPackage string
309 | 		VoPackage     string
310 | 		PbPackage     string
311 | 	}{
312 | 		ConfigPackage: cfgPkg,
313 | 		PbPackage:     pbPkg,
314 | 	}); err != nil {
315 | 		panic(err)
316 | 	}
317 | 	original = astutils.AppendImportStatements(original, importBuf.Bytes())
318 | 	original = astutils.GrpcRelatedModify(original, meta.Name, grpcSvc.Name)
319 | 	//fmt.Println(string(original))
320 | 	astutils.FixImport(original, svcimplfile)
321 | }
```

cmd/internal/svc/validate/validate.go
```
1 | package validate
2 | 
3 | import (
4 | 	"fmt"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"regexp"
8 | 	"strings"
9 | 
10 | 	"github.com/pkg/errors"
11 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/parser"
12 | 	"github.com/unionj-cloud/toolkit/astutils"
13 | 	v3helper "github.com/unionj-cloud/toolkit/openapi/v3"
14 | 	"github.com/unionj-cloud/toolkit/sliceutils"
15 | )
16 | 
17 | func DataType(dir string, dtoDirs ...string) {
18 | 	astutils.BuildInterfaceCollector(filepath.Join(dir, "svc.go"), parser.ExprStringP)
19 | 	var files []string
20 | 	for i := 0; i < len(dtoDirs); i++ {
21 | 		dtodir := filepath.Join(dir, dtoDirs[i])
22 | 		if _, err := os.Stat(dtodir); err != nil {
23 | 			continue
24 | 		}
25 | 		_ = filepath.Walk(dtodir, astutils.Visit(&files))
26 | 	}
27 | 	for _, file := range files {
28 | 		astutils.BuildStructCollector(file, parser.ExprStringP)
29 | 	}
30 | }
31 | 
32 | // RestApi is checking whether parameter types in each of service interface methods valid or not
33 | // Only support at most one golang non-built-in type as parameter in a service interface method
34 | // because go-doudou cannot put more than one parameter into request body except v3.FileModel.
35 | // If there are v3.FileModel parameters, go-doudou will assume you want a multipart/form-data api
36 | // Support struct, map[string]ANY, built-in type and corresponding slice only
37 | // Not support anonymous struct as parameter
38 | func RestApi(dir string, ic astutils.InterfaceCollector) {
39 | 	if len(ic.Interfaces) == 0 {
40 | 		panic(errors.New("no service interface found"))
41 | 	}
42 | 	if len(v3helper.SchemaNames) == 0 && len(v3helper.Enums) == 0 {
43 | 		parser.ParseDto(dir, parser.DEFAULT_DTO_PKGS...)
44 | 	}
45 | 	svcInter := ic.Interfaces[0]
46 | 	re := regexp.MustCompile(`anonystruct«(.*)»`)
47 | 	for _, method := range svcInter.Methods {
48 | 		nonBasicTypes := getNonBasicTypes(method.Params)
49 | 		if len(nonBasicTypes) > 1 {
50 | 			panic(fmt.Sprintf("Too many golang non-builtin type parameters in method %s, can't decide which one should be put into request body!", method))
51 | 		}
52 | 		for _, param := range method.Results {
53 | 			if re.MatchString(param.Type) {
54 | 				panic("not support anonymous struct as parameter")
55 | 			}
56 | 		}
57 | 	}
58 | }
59 | 
60 | func GrpcApi(dir string, ic astutils.InterfaceCollector, http2grpc bool) {
61 | 	if len(ic.Interfaces) == 0 {
62 | 		panic(errors.New("no service interface found"))
63 | 	}
64 | 	if len(v3helper.SchemaNames) == 0 && len(v3helper.Enums) == 0 {
65 | 		parser.ParseDto(dir, parser.DEFAULT_DTO_PKGS...)
66 | 	}
67 | 	svcInter := ic.Interfaces[0]
68 | 	re := regexp.MustCompile(`anonystruct«(.*)»`)
69 | 	for _, method := range svcInter.Methods {
70 | 		if http2grpc {
71 | 			pass := checkParams(method.Params)
72 | 			if !pass {
73 | 				panic("Only support pass one context.Context and at most one struct from dto package as parameters. A context.Context is required.")
74 | 			}
75 | 			pass = checkResults(method.Results)
76 | 			if !pass {
77 | 				panic("Only support pass one struct from dto package and one error as results. An error is required.")
78 | 			}
79 | 		} else {
80 | 			nonBasicTypes := getNonBasicTypes(method.Params)
81 | 			if len(nonBasicTypes) > 1 {
82 | 				panic(fmt.Sprintf("Too many golang non-builtin type parameters in method %s, can't decide which one should be put into request body!", method))
83 | 			}
84 | 			for _, param := range method.Results {
85 | 				if re.MatchString(param.Type) {
86 | 					panic("not support anonymous struct as parameter")
87 | 				}
88 | 			}
89 | 		}
90 | 	}
91 | }
92 | 
93 | func checkResults(params []astutils.FieldMeta) bool {
94 | 	pass := true
95 | 	var passedParams []string
96 | 	for _, param := range params {
97 | 		if param.Type == "error" ||
98 | 			strings.HasPrefix(strings.TrimLeft(param.Type, "*"), "vo.") ||
99 | 			strings.HasPrefix(strings.TrimLeft(param.Type, "*"), "dto.") ||
100 | 			strings.HasPrefix(strings.TrimLeft(param.Type, "*"), "model.") {
101 | 			passedParams = append(passedParams, param.Type)
102 | 			continue
103 | 		}
104 | 		return false
105 | 	}
106 | 	if len(passedParams) > 2 {
107 | 		return false
108 | 	}
109 | 	if !sliceutils.StringContains(passedParams, "error") {
110 | 		return false
111 | 	}
112 | 	return pass
113 | }
114 | 
115 | func checkParams(params []astutils.FieldMeta) bool {
116 | 	pass := true
117 | 	var passedParams []string
118 | 	for _, param := range params {
119 | 		if param.Type == "context.Context" ||
120 | 			strings.HasPrefix(strings.TrimLeft(param.Type, "*"), "vo.") ||
121 | 			strings.HasPrefix(strings.TrimLeft(param.Type, "*"), "dto.") ||
122 | 			strings.HasPrefix(strings.TrimLeft(param.Type, "*"), "model.") {
123 | 			passedParams = append(passedParams, param.Type)
124 | 			continue
125 | 		}
126 | 		return false
127 | 	}
128 | 	if len(passedParams) > 2 {
129 | 		return false
130 | 	}
131 | 	if !sliceutils.StringContains(passedParams, "context.Context") {
132 | 		return false
133 | 	}
134 | 	return pass
135 | }
136 | 
137 | func getNonBasicTypes(params []astutils.FieldMeta) []string {
138 | 	var nonBasicTypes []string
139 | 	cpmap := make(map[string]int)
140 | 	re := regexp.MustCompile(`anonystruct«(.*)»`)
141 | 	for _, param := range params {
142 | 		if param.Type == "context.Context" {
143 | 			continue
144 | 		}
145 | 		if re.MatchString(param.Type) {
146 | 			panic("not support anonymous struct as parameter")
147 | 		}
148 | 		if !v3helper.IsBuiltin(param) {
149 | 			ptype := param.Type
150 | 			if strings.HasPrefix(ptype, "[") || strings.HasPrefix(ptype, "*[") {
151 | 				elem := ptype[strings.Index(ptype, "]")+1:]
152 | 				if elem == "*v3.FileModel" || elem == "v3.FileModel" || elem == "*multipart.FileHeader" {
153 | 					elem = "file"
154 | 					if _, exists := cpmap[elem]; !exists {
155 | 						cpmap[elem]++
156 | 						nonBasicTypes = append(nonBasicTypes, elem)
157 | 					}
158 | 					continue
159 | 				}
160 | 			}
161 | 			if ptype == "*v3.FileModel" || ptype == "v3.FileModel" || ptype == "*multipart.FileHeader" {
162 | 				ptype = "file"
163 | 				if _, exists := cpmap[ptype]; !exists {
164 | 					cpmap[ptype]++
165 | 					nonBasicTypes = append(nonBasicTypes, ptype)
166 | 				}
167 | 				continue
168 | 			}
169 | 			nonBasicTypes = append(nonBasicTypes, param.Type)
170 | 		}
171 | 	}
172 | 	return nonBasicTypes
173 | }
```

cmd/testdata/testsvc/client/client.go
```
1 | /**
2 | * Generated by go-doudou v1.3.8.
3 | * Don't edit!
4 |  */
5 | package client
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"net/http"
12 | 	"net/url"
13 | 	"testsvc/vo"
14 | 
15 | 	"github.com/go-resty/resty/v2"
16 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
17 | 	"github.com/opentracing/opentracing-go"
18 | 	"github.com/pkg/errors"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
20 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
21 | )
22 | 
23 | type TestsvcClient struct {
24 | 	provider registry.IServiceProvider
25 | 	client   *resty.Client
26 | 	rootPath string
27 | }
28 | 
29 | func (receiver *TestsvcClient) SetRootPath(rootPath string) {
30 | 	receiver.rootPath = rootPath
31 | }
32 | 
33 | func (receiver *TestsvcClient) SetProvider(provider registry.IServiceProvider) {
34 | 	receiver.provider = provider
35 | }
36 | 
37 | func (receiver *TestsvcClient) SetClient(client *resty.Client) {
38 | 	receiver.client = client
39 | }
40 | func (receiver *TestsvcClient) PageUsers(ctx context.Context, _headers map[string]string, query vo.PageQuery) (_resp *resty.Response, code int, data vo.PageRet, err error) {
41 | 	var _err error
42 | 	_urlValues := url.Values{}
43 | 	_req := receiver.client.R()
44 | 	if len(_headers) > 0 {
45 | 		_req.SetHeaders(_headers)
46 | 	}
47 | 	_req.SetContext(ctx)
48 | 	_req.SetBody(query)
49 | 	_path := "/page/users"
50 | 	if _req.Body != nil {
51 | 		_req.SetQueryParamsFromValues(_urlValues)
52 | 	} else {
53 | 		_req.SetFormDataFromValues(_urlValues)
54 | 	}
55 | 	_resp, _err = _req.Post(_path)
56 | 	if _err != nil {
57 | 		err = errors.Wrap(_err, "error")
58 | 		return
59 | 	}
60 | 	if _resp.IsError() {
61 | 		err = errors.New(_resp.String())
62 | 		return
63 | 	}
64 | 	var _result struct {
65 | 		Code int        `json:"code"`
66 | 		Data vo.PageRet `json:"data"`
67 | 	}
68 | 	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
69 | 		err = errors.Wrap(_err, "error")
70 | 		return
71 | 	}
72 | 	return _resp, _result.Code, _result.Data, nil
73 | }
74 | 
75 | func NewTestsvcClient(opts ...restclient.RestClientOption) *TestsvcClient {
76 | 	defaultProvider := restclient.NewServiceProvider("TESTSVC")
77 | 	defaultClient := restclient.NewClient()
78 | 
79 | 	svcClient := &TestsvcClient{
80 | 		provider: defaultProvider,
81 | 		client:   defaultClient,
82 | 	}
83 | 
84 | 	for _, opt := range opts {
85 | 		opt(svcClient)
86 | 	}
87 | 
88 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
89 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
90 | 		return nil
91 | 	})
92 | 
93 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
94 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
95 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
96 | 		*request = *traceReq
97 | 		return nil
98 | 	})
99 | 
100 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
101 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
102 | 		return nil
103 | 	})
104 | 
105 | 	return svcClient
106 | }
```

cmd/testdata/testsvc/client/clientproxy.go
```
1 | package client
2 | 
3 | import (
4 | 	"context"
5 | 	"testsvc/vo"
6 | 	"time"
7 | 
8 | 	"github.com/pkg/errors"
9 | 	"github.com/prometheus/client_golang/prometheus"
10 | 	"github.com/sirupsen/logrus"
11 | 	"github.com/slok/goresilience"
12 | 	"github.com/slok/goresilience/circuitbreaker"
13 | 	rerrors "github.com/slok/goresilience/errors"
14 | 	"github.com/slok/goresilience/metrics"
15 | 	"github.com/slok/goresilience/retry"
16 | 	"github.com/slok/goresilience/timeout"
17 | 	"github.com/unionj-cloud/go-doudou/v2/svc/config"
18 | )
19 | 
20 | type TestsvcClientProxy struct {
21 | 	client *TestsvcClient
22 | 	logger *logrus.Logger
23 | 	runner goresilience.Runner
24 | }
25 | 
26 | func (receiver *TestsvcClientProxy) PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, err error) {
27 | 	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
28 | 		_, code, data, err = receiver.client.PageUsers(
29 | 			ctx,
30 | 			query,
31 | 		)
32 | 		if err != nil {
33 | 			return errors.Wrap(err, "call PageUsers fail")
34 | 		}
35 | 		return nil
36 | 	}); _err != nil {
37 | 		// you can implement your fallback logic here
38 | 		if errors.Is(_err, rerrors.ErrCircuitOpen) {
39 | 			receiver.logger.Error(_err)
40 | 		}
41 | 		err = errors.Wrap(_err, "call PageUsers fail")
42 | 	}
43 | 	return
44 | }
45 | 
46 | type ProxyOption func(*TestsvcClientProxy)
47 | 
48 | func WithRunner(runner goresilience.Runner) ProxyOption {
49 | 	return func(proxy *TestsvcClientProxy) {
50 | 		proxy.runner = runner
51 | 	}
52 | }
53 | 
54 | func WithLogger(logger *logrus.Logger) ProxyOption {
55 | 	return func(proxy *TestsvcClientProxy) {
56 | 		proxy.logger = logger
57 | 	}
58 | }
59 | 
60 | func NewTestsvcClientProxy(client *TestsvcClient, opts ...ProxyOption) *TestsvcClientProxy {
61 | 	cp := &TestsvcClientProxy{
62 | 		client: client,
63 | 		logger: logrus.StandardLogger(),
64 | 	}
65 | 
66 | 	for _, opt := range opts {
67 | 		opt(cp)
68 | 	}
69 | 
70 | 	if cp.runner == nil {
71 | 		var mid []goresilience.Middleware
72 | 
73 | 		if config.GddManage.Load() == "true" {
74 | 			mid = append(mid, metrics.NewMiddleware("testsvc_client", metrics.NewPrometheusRecorder(prometheus.DefaultRegisterer)))
75 | 		}
76 | 
77 | 		mid = append(mid, circuitbreaker.NewMiddleware(circuitbreaker.Config{
78 | 			ErrorPercentThresholdToOpen:        50,
79 | 			MinimumRequestToOpen:               6,
80 | 			SuccessfulRequiredOnHalfOpen:       1,
81 | 			WaitDurationInOpenState:            5 * time.Second,
82 | 			MetricsSlidingWindowBucketQuantity: 10,
83 | 			MetricsBucketDuration:              1 * time.Second,
84 | 		}),
85 | 			timeout.NewMiddleware(timeout.Config{
86 | 				Timeout: 3 * time.Minute,
87 | 			}),
88 | 			retry.NewMiddleware(retry.Config{
89 | 				Times: 3,
90 | 			}))
91 | 
92 | 		cp.runner = goresilience.RunnerChain(mid...)
93 | 	}
94 | 
95 | 	return cp
96 | }
```

cmd/testdata/testsvc/client/iclient.go
```
1 | /**
2 | * Generated by go-doudou v1.3.8.
3 | * Don't edit!
4 |  */
5 | package client
6 | 
7 | import (
8 | 	"context"
9 | 	"testsvc/vo"
10 | 
11 | 	"github.com/go-resty/resty/v2"
12 | )
13 | 
14 | type ITestsvcClient interface {
15 | 	PageUsers(ctx context.Context, _headers map[string]string, query vo.PageQuery) (_resp *resty.Response, code int, data vo.PageRet, err error)
16 | }
```

cmd/testdata/testsvc/cmd/main.go
```
1 | package main
2 | 
3 | import (
4 | 	service "testsvc"
5 | 	"testsvc/config"
6 | 	"testsvc/transport/httpsrv"
7 | 
8 | 	"github.com/ascarter/requestid"
9 | 	"github.com/gorilla/handlers"
10 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
11 | )
12 | 
13 | func main() {
14 | 	conf := config.LoadFromEnv()
15 | 	svc := service.NewTestsvc(conf)
16 | 
17 | 	handler := httpsrv.NewTestsvcHandler(svc)
18 | 	srv := rest.NewRestServer()
19 | 	srv.AddMiddleware(rest.Tracing, rest.Metrics, requestid.RequestIDHandler, handlers.CompressHandler, handlers.ProxyHeaders, rest.Logger, rest.Rest, rest.Recover)
20 | 	srv.AddRoute(httpsrv.Routes(handler)...)
21 | 	srv.Run()
22 | }
```

cmd/testdata/testsvc/config/config.go
```
1 | package config
2 | 
3 | import (
4 | 	"github.com/sirupsen/logrus"
5 | 	"github.com/unionj-cloud/toolkit/envconfig"
6 | )
7 | 
8 | type Config struct {
9 | 	DbConf DbConfig
10 | }
11 | 
12 | type DbConfig struct {
13 | 	Driver  string `default:"mysql"`
14 | 	Host    string `default:"localhost"`
15 | 	Port    string `default:"3306"`
16 | 	User    string
17 | 	Passwd  string
18 | 	Schema  string
19 | 	Charset string `default:"utf8mb4"`
20 | }
21 | 
22 | func LoadFromEnv() *Config {
23 | 	var dbconf DbConfig
24 | 	err := envconfig.Process("db", &dbconf)
25 | 	if err != nil {
26 | 		logrus.Panicln("Error processing env", err)
27 | 	}
28 | 	return &Config{
29 | 		dbconf,
30 | 	}
31 | }
```

cmd/testdata/testsvc/db/db.go
```
1 | package db
2 | 
3 | import (
4 | 	"fmt"
5 | 	"testsvc/config"
6 | 
7 | 	_ "github.com/go-sql-driver/mysql"
8 | 	"github.com/iancoleman/strcase"
9 | 	"github.com/jmoiron/sqlx"
10 | 	"github.com/pkg/errors"
11 | )
12 | 
13 | func NewDb(conf config.DbConfig) (*sqlx.DB, error) {
14 | 	conn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=%s",
15 | 		conf.User,
16 | 		conf.Passwd,
17 | 		conf.Host,
18 | 		conf.Port,
19 | 		conf.Schema,
20 | 		conf.Charset)
21 | 	conn += "&loc=Asia%2FShanghai&parseTime=True"
22 | 
23 | 	db, err := sqlx.Connect(conf.Driver, conn)
24 | 	if err != nil {
25 | 		return nil, errors.Wrap(err, "database connection failed")
26 | 	}
27 | 	db.MapperFunc(strcase.ToSnake)
28 | 	return db, nil
29 | }
```

cmd/testdata/testsvc/vo/enums_gen.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * Don't edit!
4 |  */
5 | package vo
6 | 
7 | import "encoding/json"
8 | 
9 | func (k *KeyboardLayout) StringSetter(value string) {
10 | 	switch value {
11 | 	case "UNKNOWN":
12 | 		*k = UNKNOWN
13 | 	case "QWERTZ":
14 | 		*k = QWERTZ
15 | 	case "AZERTY":
16 | 		*k = AZERTY
17 | 	case "QWERTY":
18 | 		*k = QWERTY
19 | 	default:
20 | 		*k = UNKNOWN
21 | 	}
22 | }
23 | 
24 | func (k *KeyboardLayout) StringGetter() string {
25 | 	switch *k {
26 | 	case UNKNOWN:
27 | 		return "UNKNOWN"
28 | 	case QWERTZ:
29 | 		return "QWERTZ"
30 | 	case AZERTY:
31 | 		return "AZERTY"
32 | 	case QWERTY:
33 | 		return "QWERTY"
34 | 	default:
35 | 		return "UNKNOWN"
36 | 	}
37 | }
38 | 
39 | func (k *KeyboardLayout) UnmarshalJSON(bytes []byte) error {
40 | 	var _k string
41 | 	err := json.Unmarshal(bytes, &_k)
42 | 	if err != nil {
43 | 		return err
44 | 	}
45 | 	k.StringSetter(_k)
46 | 	return nil
47 | }
48 | 
49 | func (k KeyboardLayout) MarshalJSON() ([]byte, error) {
50 | 	return json.Marshal(k.StringGetter())
51 | }
52 | func (k *RoleEnum) StringSetter(value string) {
53 | 	switch value {
54 | 	case "GUEST":
55 | 		*k = GUEST
56 | 	case "USER":
57 | 		*k = USER
58 | 	case "ADMIN":
59 | 		*k = ADMIN
60 | 	default:
61 | 		*k = GUEST
62 | 	}
63 | }
64 | 
65 | func (k *RoleEnum) StringGetter() string {
66 | 	switch *k {
67 | 	case GUEST:
68 | 		return "GUEST"
69 | 	case USER:
70 | 		return "USER"
71 | 	case ADMIN:
72 | 		return "ADMIN"
73 | 	default:
74 | 		return "GUEST"
75 | 	}
76 | }
77 | 
78 | func (k *RoleEnum) UnmarshalJSON(bytes []byte) error {
79 | 	var _k string
80 | 	err := json.Unmarshal(bytes, &_k)
81 | 	if err != nil {
82 | 		return err
83 | 	}
84 | 	k.StringSetter(_k)
85 | 	return nil
86 | }
87 | 
88 | func (k RoleEnum) MarshalJSON() ([]byte, error) {
89 | 	return json.Marshal(k.StringGetter())
90 | }
```

cmd/testdata/testsvc/vo/vo.go
```
1 | package vo
2 | 
3 | //go:generate go-doudou name --file $GOFILE
4 | //go:generate go-doudou enum --file $GOFILE
5 | 
6 | type PageFilter struct {
7 | 	// 真实姓名，前缀匹配
8 | 	Name string
9 | 	// 所属部门ID
10 | 	Dept int
11 | }
12 | 
13 | type Order struct {
14 | 	Col  string
15 | 	Sort string
16 | }
17 | 
18 | type Page struct {
19 | 	// 排序规则
20 | 	Orders []Order
21 | 	// 页码
22 | 	PageNo int
23 | 	// 每页行数
24 | 	Size int
25 | }
26 | 
27 | // 分页筛选条件
28 | type PageQuery struct {
29 | 	Filter PageFilter
30 | 	Page   Page
31 | }
32 | 
33 | type PageRet struct {
34 | 	Items    interface{}
35 | 	PageNo   int
36 | 	PageSize int
37 | 	Total    int
38 | 	HasNext  bool
39 | }
40 | 
41 | type UserVo struct {
42 | 	Id    int
43 | 	Name  string
44 | 	Phone string
45 | 	Dept  string
46 | }
47 | 
48 | type RoleEnum int
49 | 
50 | const (
51 | 	GUEST RoleEnum = iota
52 | 	USER
53 | 	ADMIN
54 | )
55 | 
56 | type KeyboardLayout int
57 | 
58 | const (
59 | 	UNKNOWN KeyboardLayout = iota
60 | 	QWERTZ
61 | 	AZERTY
62 | 	QWERTY
63 | )
```

cmd/internal/svc/testdata/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"mime/multipart"
6 | 	"os"
7 | 
8 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/testdata/vo"
9 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
10 | )
11 | 
12 | // 用户服务接口
13 | // v1版本
14 | type Usersvc interface {
15 | 	// You can define your service methods as your need. Below is an example.
16 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, msg error)
17 | 
18 | 	// comment1
19 | 	// comment2
20 | 	GetUser(ctx context.Context,
21 | 		// 用户ID
22 | 		userId string,
23 | 		// 图片地址
24 | 		photo string,
25 | 	) (code int, data string, msg error)
26 | 
27 | 	// comment3
28 | 	SignUp(ctx context.Context, username string, password int, actived bool, score float64) (code int, data string, msg error)
29 | 
30 | 	// comment4
31 | 	UploadAvatar(context.Context, []*multipart.FileHeader, []*multipart.FileHeader, *multipart.FileHeader, v3.FileModel, string) (int, string, error)
32 | 
33 | 	// comment5
34 | 	DownloadAvatar(ctx context.Context, userId string, layout vo.KeyboardLayout) (*os.File, error)
35 | }
```

cmd/internal/svc/testdata/svcp.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"os"
6 | 
7 | 	"github.com/unionj-cloud/go-doudou/v2/framework/testdata/vo"
8 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
9 | )
10 | 
11 | // 用户服务接口
12 | // v1版本
13 | type UsersvcPanic interface {
14 | 	// You can define your service methods as your need. Below is an example.
15 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, msg error)
16 | 
17 | 	// comment1
18 | 	// comment2
19 | 	GetUser(ctx context.Context,
20 | 		// 用户ID
21 | 		userId string,
22 | 		// 图片地址
23 | 		photo string,
24 | 	) (code int, data string, msg error)
25 | 
26 | 	// comment3
27 | 	SignUp(ctx context.Context, username string, password int, actived bool, score float64) (code int, data string, msg error)
28 | 
29 | 	// comment4
30 | 	UploadAvatar(context.Context, []v3.FileModel, string) (int, string, error)
31 | 
32 | 	// comment5
33 | 	DownloadAvatar(ctx context.Context, userId string) (*os.File, error)
34 | 
35 | 	// Wrong1
36 | 	Wrong1(ctx context.Context, userId string, query vo.PageQuery, files []v3.FileModel) (*os.File, error)
37 | 
38 | 	// Wrong2
39 | 	Wrong2(ctx context.Context, ch chan string) (*os.File, error)
40 | 
41 | 	// Wrong3
42 | 	Wrong3(ctx context.Context, fun func()) (*os.File, error)
43 | }
```

cmd/internal/svc/testdata/testfilesdoc1_openapi3.json
```
1 | {"openapi":"3.0.2","info":{"title":"Testdatadoc1","version":"v20210625"},"paths":{"/testdatadoc1/pageusers":{"post":{"summary":"You can define your service methods as your need. Below is an example.","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageQuery"}}},"required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageUsersResp"}}}}}}}},"components":{"schemas":{"Order":{"title":"Order","type":"object","properties":{"Col":{"type":"string"},"Sort":{"type":"string"}}},"Page":{"title":"Page","type":"object","properties":{"Orders":{"type":"array","items":{"$ref":"#/components/schemas/Order"},"description":"排序规则"},"PageNo":{"type":"integer","format":"int32","description":"页码"},"Size":{"type":"integer","format":"int32","description":"每页行数"}}},"PageFilter":{"title":"PageFilter","type":"object","properties":{"Dept":{"type":"integer","format":"int32","description":"所属部门ID"},"Name":{"type":"string","description":"真实姓名，前缀匹配"}}},"PageQuery":{"title":"PageQuery","type":"object","properties":{"Filter":{"$ref":"#/components/schemas/PageFilter"},"Page":{"$ref":"#/components/schemas/Page"}},"description":"分页筛选条件"},"PageRet":{"title":"PageRet","type":"object","properties":{"HasNext":{"type":"boolean"},"Items":{"type":"object"},"PageNo":{"type":"integer","format":"int32"},"PageSize":{"type":"integer","format":"int32"},"Total":{"type":"integer","format":"int32"}}},"PageUsersResp":{"title":"PageUsersResp","type":"object","properties":{"code":{"type":"integer","format":"int32"},"data":{"$ref":"#/components/schemas/PageRet"},"msg":{"type":"string"}}},"UserVo":{"title":"UserVo","type":"object","properties":{"Dept":{"type":"string"},"Id":{"type":"integer","format":"int32"},"Name":{"type":"string"},"Phone":{"type":"string"}}}}}}
```

cmd/internal/svc/testdata/usersvc_deployment.yaml
```
1 | apiVersion: apps/v1
2 | kind: Deployment
3 | metadata:
4 |   name: usersvc-deployment
5 | spec:
6 |   replicas: 1
7 |   selector:
8 |     matchLabels:
9 |       app: usersvc
10 |   template:
11 |     metadata:
12 |       labels:
13 |         app: usersvc
14 |     spec:
15 |       containers:
16 |       - image: wubin1989/go-doudou-usersvc
17 |         imagePullPolicy: Always
18 |         name: usersvc
19 |         ports:
20 |         - containerPort: 6060
21 |           name: http-port
22 |           protocol: TCP
23 |         resources:
24 |           requests:
25 |             cpu: 100m
26 |             memory: 128Mi
27 |       restartPolicy: Always
28 | ---
29 | apiVersion: v1
30 | kind: Service
31 | metadata:
32 |   name: usersvc-service
33 | spec:
34 |   type: LoadBalancer
35 |   externalTrafficPolicy: Cluster
36 |   selector:
37 |     app: usersvc
38 |   ports:
39 |     - protocol: TCP
40 |       port: 6060
41 |       targetPort: 6060
```

cmd/internal/svc/testdata/usersvc_statefulset.yaml
```
1 | apiVersion: apps/v1
2 | kind: StatefulSet
3 | metadata:
4 |   name: usersvc-statefulset
5 | spec:
6 |   replicas: 1
7 |   selector:
8 |     matchLabels:
9 |       app: usersvc
10 |   serviceName: usersvc-svc-headless
11 |   template:
12 |     metadata:
13 |       labels:
14 |         app: usersvc
15 |     spec:
16 |       containers:
17 |       - image: wubin1989/go-doudou-usersvc
18 |         imagePullPolicy: Always
19 |         name: usersvc
20 |         ports:
21 |         - containerPort: 6060
22 |           name: http-port
23 |           protocol: TCP
24 |         resources:
25 |           requests:
26 |             cpu: 100m
27 |             memory: 128Mi
28 |       restartPolicy: Always
29 |       terminationGracePeriodSeconds: 10
30 | ---
31 | apiVersion: v1
32 | kind: Service
33 | metadata:
34 |   name: usersvc-svc-headless
35 | spec:
36 |   selector:
37 |     app: usersvc
38 |   ports:
39 |     - protocol: TCP
40 |       port: 6060
41 |       targetPort: 6060
42 |   clusterIP: None
```

cmd/internal/ddl/testdata/entity4/base.go
```
1 | package entity
2 | 
3 | import "time"
4 | 
5 | type Base struct {
6 | 	CreateAt *time.Time `dd:"default:CURRENT_TIMESTAMP"`
7 | 	UpdateAt *time.Time `dd:"default:CURRENT_TIMESTAMP;extra:ON UPDATE CURRENT_TIMESTAMP"`
8 | 	DeleteAt *time.Time
9 | }
```

cmd/internal/ddl/testdata/entity4/book.go
```
1 | package entity
2 | 
3 | //dd:table
4 | type Book struct {
5 | 	ID          int `dd:"pk;auto"`
6 | 	UserId      int `dd:"type:int;fk:ddl_user,id,fk_user,ON DELETE CASCADE ON UPDATE NO ACTION"`
7 | 	PublisherId int
8 | 
9 | 	Base
10 | }
```

cmd/internal/ddl/testdata/entity4/publisher.go
```
1 | package entity
2 | 
3 | //dd:table
4 | type Publisher struct {
5 | 	ID   int `dd:"pk;auto"`
6 | 	Name string
7 | 
8 | 	Base
9 | }
```

cmd/internal/ddl/testdata/entity4/user.go
```
1 | package entity
2 | 
3 | import "time"
4 | 
5 | //dd:table
6 | type User struct {
7 | 	ID         int    `dd:"pk;auto"`
8 | 	Name       string `dd:"index:name_phone_idx,2;default:'jack'"`
9 | 	Phone      string `dd:"default:'13552053960';extra:comment '手机号'"`
10 | 	Age        int    `dd:"unsigned"`
11 | 	No         int    `dd:"type:int;unique"`
12 | 	UniqueCol  int    `dd:"type:int;unique:unique_col_idx,1"`
13 | 	UniqueCol2 int    `dd:"type:int;unique:unique_col_idx,2"`
14 | 	School     string `dd:"null;index:name_phone_idx,1;default:'harvard';extra:comment '学校'"`
15 | 	IsStudent  bool
16 | 	Rule       string `dd:"type:varchar(255);unique;extra:comment '链接匹配规则，匹配的链接采用该css规则来爬'"`
17 | 	RuleType   string `dd:"type:varchar(45);extra:comment '链接匹配规则类型，支持prefix前缀匹配和regex正则匹配'"`
18 | 
19 | 	ArriveAt *time.Time `dd:"type:datetime;extra:comment '到货时间'"`
20 | 	Status   int8       `dd:"type:tinyint(4);extra:comment '0进行中
21 | 1完结
22 | 2取消'"`
23 | 
24 | 	Base
25 | }
```

cmd/internal/ddl/testdata/sql/test_ddl_user.sql
```
1 | create table ddl_user
2 | (
3 |     id         int auto_increment
4 |         primary key,
5 |     name       varchar(255) default 'jack'            not null,
6 |     phone      varchar(255) default '13552053960'     not null comment 'mobile phone',
7 |     age        int                                    not null,
8 |     no         int                                    not null,
9 |     school     varchar(255) default 'harvard'         null comment 'school',
10 |     is_student tinyint                                not null,
11 |     create_at  datetime     default CURRENT_TIMESTAMP null,
12 |     update_at  datetime     default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP,
13 |     delete_at  datetime                               null,
14 |     constraint no_idx
15 |         unique (no)
16 | );
17 | 
18 | create index age_idx
19 |     on ddl_user (age);
20 | 
21 | create index name_phone_idx
22 |     on ddl_user (phone, name);
23 | 
24 | create table ddl_book
25 | (
26 |     id           int auto_increment
27 |         primary key,
28 |     name         varchar(45) null,
29 |     user_id      int         null,
30 |     publisher_id int         null,
31 |     constraint fk_user
32 |         foreign key (user_id) references ddl_user (id)
33 |         ON DELETE CASCADE ON UPDATE NO ACTION
34 | );
35 | 
36 | create table ddl_publisher
37 | (
38 |     id   int auto_increment
39 |         primary key,
40 |     name varchar(45) null
41 | );
```

cmd/internal/openapi/v3/codegen/common.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"fmt"
6 | 	"os"
7 | 	"path/filepath"
8 | 	"regexp"
9 | 	"sort"
10 | 	"strings"
11 | 	"text/template"
12 | 
13 | 	"github.com/iancoleman/strcase"
14 | 	"github.com/pkg/errors"
15 | 	"github.com/sirupsen/logrus"
16 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
17 | 	"github.com/unionj-cloud/toolkit/astutils"
18 | 	"github.com/unionj-cloud/toolkit/copier"
19 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
20 | 	"github.com/unionj-cloud/toolkit/sliceutils"
21 | 	"github.com/unionj-cloud/toolkit/stringutils"
22 | 	"github.com/unionj-cloud/go-doudou/v2/version"
23 | )
24 | 
25 | type OpenAPICodeGenerator struct {
26 | 	Schemas          map[string]v3.Schema
27 | 	RequestBodies    map[string]v3.RequestBody
28 | 	Responses        map[string]v3.Response
29 | 	Omitempty        bool
30 | 	SvcName, ModName string
31 | 	Comments         []string
32 | 	DtoPkg           string
33 | 	ApiInfo          *v3.Info
34 | }
35 | 
36 | func toComment(comment string, title ...string) string {
37 | 	if stringutils.IsEmpty(comment) {
38 | 		return ""
39 | 	}
40 | 	b := new(strings.Builder)
41 | 	lines := strings.Split(comment, "\n")
42 | 	for i, line := range lines {
43 | 		if len(title) > 0 && i == 0 {
44 | 			b.WriteString(fmt.Sprintf("// %s %s\n", title[0], line))
45 | 		} else {
46 | 			b.WriteString(fmt.Sprintf("// %s\n", line))
47 | 		}
48 | 	}
49 | 	return strings.TrimSuffix(b.String(), "\n")
50 | }
51 | 
52 | func clean(str string) string {
53 | 	return strings.TrimSpace(strings.ReplaceAll(strings.ReplaceAll(str, "«", ""), "»", ""))
54 | }
55 | 
56 | func toCamel(str string) string {
57 | 	return stringutils.ToCamel(clean(str))
58 | }
59 | 
60 | func (receiver OpenAPICodeGenerator) APIComments() []string {
61 | 	info := receiver.ApiInfo
62 | 	comments := []string{info.Title}
63 | 	comments = append(comments, strings.Split(info.Description, "\n")...)
64 | 	comments = append(comments, info.TermsOfService, info.Version)
65 | 	if info.Contact != nil {
66 | 		comments = append(comments, info.Contact.Email)
67 | 	}
68 | 	if info.License != nil {
69 | 		comments = append(comments, info.License.Name, info.License.URL)
70 | 	}
71 | 	return comments
72 | }
73 | 
74 | func (receiver *OpenAPICodeGenerator) object2Struct(schema *v3.Schema) string {
75 | 	if schema.AdditionalProperties != nil {
76 | 		result := receiver.additionalProperties2Map(schema.AdditionalProperties)
77 | 		if stringutils.IsNotEmpty(result) {
78 | 			return result
79 | 		}
80 | 	}
81 | 	if len(schema.Properties) == 0 {
82 | 		return "interface{}"
83 | 	}
84 | 	b := new(strings.Builder)
85 | 	b.WriteString("struct {\n")
86 | 	for k, v := range schema.Properties {
87 | 		if stringutils.IsNotEmpty(v.Description) {
88 | 			descs := strings.Split(v.Description, "\n")
89 | 			for _, desc := range descs {
90 | 				b.WriteString(fmt.Sprintf("  // %s\n", desc))
91 | 			}
92 | 		}
93 | 		if sliceutils.StringContains(schema.Required, k) {
94 | 			b.WriteString("  // required\n")
95 | 		}
96 | 		jsontag := k
97 | 		if receiver.Omitempty {
98 | 			jsontag += ",omitempty"
99 | 		}
100 | 		if sliceutils.StringContains(schema.Required, k) {
101 | 			b.WriteString(fmt.Sprintf("  %s %s `json:\"%s\" url:\"%s\"`\n", strcase.ToCamel(k), receiver.toGoType(v), jsontag, k))
102 | 		} else {
103 | 			b.WriteString(fmt.Sprintf("  %s %s `json:\"%s\" url:\"%s\"`\n", strcase.ToCamel(k), "*"+receiver.toGoType(v), jsontag, k))
104 | 		}
105 | 	}
106 | 	b.WriteString("}")
107 | 	return b.String()
108 | }
109 | 
110 | func string2Go(schema *v3.Schema) string {
111 | 	switch schema.Format {
112 | 	case v3.DateTimeF:
113 | 		return "time.Time"
114 | 	case v3.BinaryF:
115 | 		return "v3.FileModel"
116 | 	default:
117 | 		return "string"
118 | 	}
119 | }
120 | 
121 | // integer2Go converts integer schema to golang basic type
122 | //
123 | //	Int32F    Format = "int32"
124 | //	Int64F    Format = "int64"
125 | //	FloatF    Format = "float"
126 | //	DoubleF   Format = "double"
127 | //	DateTimeF Format = "date-time"
128 | //	BinaryF   Format = "binary"
129 | func integer2Go(schema *v3.Schema) string {
130 | 	switch schema.Format {
131 | 	case v3.Int32F:
132 | 		return "int"
133 | 	case v3.Int64F:
134 | 		return "int64"
135 | 	default:
136 | 		return "int"
137 | 	}
138 | }
139 | 
140 | func number2Go(schema *v3.Schema) string {
141 | 	switch schema.Format {
142 | 	case v3.FloatF:
143 | 		return "float32"
144 | 	case v3.DoubleF:
145 | 		return "float64"
146 | 	default:
147 | 		return "float64"
148 | 	}
149 | }
150 | 
151 | // toGoType converts schema to golang type
152 | //
153 | //	IntegerT Type = "integer"
154 | //	StringT  Type = "string"
155 | //	BooleanT Type = "boolean"
156 | //	NumberT  Type = "number"
157 | //	ObjectT  Type = "object"
158 | //	ArrayT   Type = "array"
159 | func (receiver *OpenAPICodeGenerator) toGoType(schema *v3.Schema) string {
160 | 	if stringutils.IsNotEmpty(schema.Ref) {
161 | 		refName := strings.TrimPrefix(schema.Ref, "#/components/schemas/")
162 | 		if realSchema, exists := receiver.Schemas[refName]; exists {
163 | 			if realSchema.Type == v3.ObjectT && realSchema.AdditionalProperties != nil {
164 | 				result := receiver.additionalProperties2Map(realSchema.AdditionalProperties)
165 | 				if stringutils.IsNotEmpty(result) {
166 | 					return result
167 | 				}
168 | 			}
169 | 		}
170 | 		dtoName := toCamel(clean(refName))
171 | 		if stringutils.IsNotEmpty(receiver.DtoPkg) {
172 | 			dtoName = receiver.DtoPkg + "." + dtoName
173 | 		}
174 | 		return dtoName
175 | 	}
176 | 	switch schema.Type {
177 | 	case v3.IntegerT:
178 | 		return integer2Go(schema)
179 | 	case v3.StringT:
180 | 		return string2Go(schema)
181 | 	case v3.BooleanT:
182 | 		return "bool"
183 | 	case v3.NumberT:
184 | 		return number2Go(schema)
185 | 	case v3.ObjectT:
186 | 		return receiver.object2Struct(schema)
187 | 	case v3.ArrayT:
188 | 		return "[]" + receiver.toGoType(schema.Items)
189 | 	default:
190 | 		return "interface{}"
191 | 	}
192 | }
193 | 
194 | func (receiver *OpenAPICodeGenerator) toOptionalGoType(schema *v3.Schema) string {
195 | 	if stringutils.IsNotEmpty(schema.Ref) {
196 | 		refName := strings.TrimPrefix(schema.Ref, "#/components/schemas/")
197 | 		if realSchema, exists := receiver.Schemas[refName]; exists {
198 | 			if realSchema.Type == v3.ObjectT && realSchema.AdditionalProperties != nil {
199 | 				result := receiver.additionalProperties2Map(realSchema.AdditionalProperties)
200 | 				if stringutils.IsNotEmpty(result) {
201 | 					return result
202 | 				}
203 | 			}
204 | 		}
205 | 		dtoName := toCamel(clean(refName))
206 | 		if stringutils.IsNotEmpty(receiver.DtoPkg) {
207 | 			dtoName = receiver.DtoPkg + "." + dtoName
208 | 		}
209 | 		return "*" + dtoName
210 | 	}
211 | 	switch schema.Type {
212 | 	case v3.IntegerT:
213 | 		return "*" + integer2Go(schema)
214 | 	case v3.StringT:
215 | 		return "*" + string2Go(schema)
216 | 	case v3.BooleanT:
217 | 		return "*bool"
218 | 	case v3.NumberT:
219 | 		return "*" + number2Go(schema)
220 | 	case v3.ObjectT:
221 | 		result := receiver.object2Struct(schema)
222 | 		if strings.HasPrefix(result, "struct {") {
223 | 			return "*" + result
224 | 		}
225 | 		return result
226 | 	case v3.ArrayT:
227 | 		return "[]" + receiver.toGoType(schema.Items)
228 | 	default:
229 | 		return "interface{}"
230 | 	}
231 | }
232 | 
233 | func (receiver *OpenAPICodeGenerator) additionalProperties2Map(additionalProperties interface{}) string {
234 | 	if additionalProperties == nil {
235 | 		return ""
236 | 	}
237 | 	if value, ok := additionalProperties.(map[string]interface{}); ok {
238 | 		var additionalSchema v3.Schema
239 | 		copier.DeepCopy(value, &additionalSchema)
240 | 		if stringutils.IsNotEmpty(additionalSchema.XMapType) {
241 | 			return additionalSchema.XMapType
242 | 		}
243 | 		return "map[string]" + receiver.toGoType(&additionalSchema)
244 | 	}
245 | 	return ""
246 | }
247 | 
248 | func (receiver *OpenAPICodeGenerator) GenGoDto(schemas map[string]v3.Schema, output, pkg, tmpl string) {
249 | 	if err := os.MkdirAll(filepath.Dir(output), os.ModePerm); err != nil {
250 | 		panic(err)
251 | 	}
252 | 	funcMap := make(map[string]interface{})
253 | 	funcMap["toCamel"] = toCamel
254 | 	funcMap["toGoType"] = receiver.toGoType
255 | 	funcMap["toComment"] = toComment
256 | 	funcMap["toOptionalGoType"] = receiver.toOptionalGoType
257 | 	funcMap["stringContains"] = sliceutils.StringContains
258 | 	filterMap := make(map[string]v3.Schema)
259 | 	for k, v := range schemas {
260 | 		result := receiver.additionalProperties2Map(v.AdditionalProperties)
261 | 		if stringutils.IsEmpty(result) {
262 | 			filterMap[k] = v
263 | 		}
264 | 	}
265 | 	tpl, _ := template.New(tmpl).Funcs(funcMap).Parse(tmpl)
266 | 	var sqlBuf bytes.Buffer
267 | 	_ = tpl.Execute(&sqlBuf, struct {
268 | 		Schemas map[string]v3.Schema
269 | 		Omit    bool
270 | 		Pkg     string
271 | 		Version string
272 | 	}{
273 | 		Schemas: filterMap,
274 | 		Omit:    receiver.Omitempty,
275 | 		Pkg:     pkg,
276 | 		Version: version.Release,
277 | 	})
278 | 	source := strings.TrimSpace(sqlBuf.String())
279 | 	astutils.FixImport([]byte(source), output)
280 | }
281 | 
282 | // TODO example2Schema converts example to *v3.Schema
283 | func (receiver *OpenAPICodeGenerator) example2Schema(example interface{}, exampleType v3.ExampleType) *v3.Schema {
284 | 	return v3.Any
285 | }
286 | 
287 | func (receiver *OpenAPICodeGenerator) schema2Field(schema *v3.Schema, name string, example interface{}, exampleType v3.ExampleType) *astutils.FieldMeta {
288 | 	if schema == nil {
289 | 		schema = receiver.example2Schema(example, exampleType)
290 | 	}
291 | 	var comments []string
292 | 	if stringutils.IsNotEmpty(schema.Description) {
293 | 		comments = append(comments, strings.Split(schema.Description, "\n")...)
294 | 	}
295 | 	return &astutils.FieldMeta{
296 | 		Name:     name,
297 | 		Type:     receiver.toGoType(schema),
298 | 		Comments: comments,
299 | 	}
300 | }
301 | 
302 | func (receiver *OpenAPICodeGenerator) responseBody(endpoint, httpMethod string, operation *v3.Operation) (results []astutils.FieldMeta, err error) {
303 | 	if stringutils.IsNotEmpty(operation.Responses.Resp200.Ref) {
304 | 		key := strings.TrimPrefix(operation.Responses.Resp200.Ref, "#/components/responses/")
305 | 		if response, exists := receiver.Responses[key]; exists {
306 | 			operation.Responses.Resp200 = &response
307 | 		} else {
308 | 			panic(fmt.Errorf("response %s not exists", operation.Responses.Resp200.Ref))
309 | 		}
310 | 	}
311 | 
312 | 	content := operation.Responses.Resp200.Content
313 | 	if content == nil {
314 | 		logrus.Warnf("200 response content definition not found in api %s %s, using text/plain as default", httpMethod, endpoint)
315 | 		content = &v3.Content{
316 | 			TextPlain: &v3.MediaType{
317 | 				Schema: v3.String,
318 | 			},
319 | 		}
320 | 	}
321 | 
322 | 	if content.JSON != nil {
323 | 		results = append(results, *receiver.schema2Field(content.JSON.Schema, "ret", content.JSON.Example, v3.JSON_EXAMPLE))
324 | 	} else if content.Stream != nil {
325 | 		results = append(results, astutils.FieldMeta{
326 | 			Name: "_downloadFile",
327 | 			Type: "*os.File",
328 | 		})
329 | 	} else if content.TextPlain != nil {
330 | 		results = append(results, *receiver.schema2Field(content.TextPlain.Schema, "ret", content.TextPlain.Example, v3.TEXT_EXAMPLE))
331 | 	} else if content.Default != nil {
332 | 		results = append(results, *receiver.schema2Field(content.Default.Schema, "ret", content.Default.Example, v3.TEXT_EXAMPLE))
333 | 	} else {
334 | 		return nil, errors.Errorf("200 response content definition not support yet in api %s %s", httpMethod, endpoint)
335 | 	}
336 | 	return
337 | }
338 | 
339 | func commentLines(operation *v3.Operation) []string {
340 | 	var comments []string
341 | 	if stringutils.IsNotEmpty(operation.Summary) {
342 | 		comments = append(comments, strings.Split(operation.Summary, "\n")...)
343 | 	}
344 | 	if stringutils.IsNotEmpty(operation.Description) {
345 | 		comments = append(comments, strings.Split(operation.Description, "\n")...)
346 | 	}
347 | 	return comments
348 | }
349 | 
350 | func (receiver *OpenAPICodeGenerator) parameter2Field(param v3.Parameter) astutils.FieldMeta {
351 | 	var comments []string
352 | 	if stringutils.IsNotEmpty(param.Description) {
353 | 		comments = append(comments, strings.Split(param.Description, "\n")...)
354 | 	}
355 | 	t := receiver.toGoType(param.Schema)
356 | 	if param.Required {
357 | 		comments = append(comments, "required")
358 | 	} else {
359 | 		t = v3.ToOptional(t)
360 | 	}
361 | 	return astutils.FieldMeta{
362 | 		Name:     param.Name,
363 | 		Type:     t,
364 | 		Comments: comments,
365 | 	}
366 | }
367 | 
368 | func toMethod(endpoint string) string {
369 | 	endpoint = strings.ReplaceAll(strings.ReplaceAll(endpoint, "{", ""), "}", "")
370 | 	endpoint = strings.ReplaceAll(strings.Trim(endpoint, "/"), "/", "_")
371 | 	nosymbolreg := regexp.MustCompile(`[^a-zA-Z0-9_]`)
372 | 	endpoint = nosymbolreg.ReplaceAllLiteralString(endpoint, "")
373 | 	endpoint = strcase.ToCamel(endpoint)
374 | 	numberstartreg := regexp.MustCompile(`^[0-9]+`)
375 | 	if numberstartreg.MatchString(endpoint) {
376 | 		startNumbers := numberstartreg.FindStringSubmatch(endpoint)
377 | 		endpoint = numberstartreg.ReplaceAllLiteralString(endpoint, "")
378 | 		endpoint += startNumbers[0]
379 | 	}
380 | 	return endpoint
381 | }
382 | 
383 | func httpMethod(method string) string {
384 | 	httpMethods := []string{"GET", "POST", "PUT", "DELETE"}
385 | 	snake := strcase.ToSnake(method)
386 | 	splits := strings.Split(snake, "_")
387 | 	head := strings.ToUpper(splits[0])
388 | 	for _, m := range httpMethods {
389 | 		if head == m {
390 | 			return m
391 | 		}
392 | 	}
393 | 	return "POST"
394 | }
395 | 
396 | func RestyMethod(method string) string {
397 | 	return strings.Title(strings.ToLower(httpMethod(method)))
398 | }
399 | 
400 | func IsOptional(t string) bool {
401 | 	return strings.HasPrefix(t, "*")
402 | }
403 | 
404 | func (receiver *OpenAPICodeGenerator) Api2Interface(paths map[string]v3.Path, svcName string, operationConverter IOperationConverter) astutils.InterfaceMeta {
405 | 	var meta astutils.InterfaceMeta
406 | 	meta.Name = strcase.ToCamel(svcName)
407 | 	meta.Comments = receiver.APIComments()
408 | 	for endpoint, path := range paths {
409 | 		if path.Get != nil {
410 | 			if method, err := operationConverter.ConvertOperation(endpoint, "Get", path.Get, path.Parameters); err == nil {
411 | 				meta.Methods = append(meta.Methods, method)
412 | 			} else {
413 | 				logrus.Errorln(err)
414 | 			}
415 | 		}
416 | 		if path.Post != nil {
417 | 			if method, err := operationConverter.ConvertOperation(endpoint, "Post", path.Post, path.Parameters); err == nil {
418 | 				meta.Methods = append(meta.Methods, method)
419 | 			} else {
420 | 				logrus.Errorln(err)
421 | 			}
422 | 		}
423 | 		if path.Put != nil {
424 | 			if method, err := operationConverter.ConvertOperation(endpoint, "Put", path.Put, path.Parameters); err == nil {
425 | 				meta.Methods = append(meta.Methods, method)
426 | 			} else {
427 | 				logrus.Errorln(err)
428 | 			}
429 | 		}
430 | 		if path.Delete != nil {
431 | 			if method, err := operationConverter.ConvertOperation(endpoint, "Delete", path.Delete, path.Parameters); err == nil {
432 | 				meta.Methods = append(meta.Methods, method)
433 | 			} else {
434 | 				logrus.Errorln(err)
435 | 			}
436 | 		}
437 | 	}
438 | 	sort.SliceStable(meta.Methods, func(i, j int) bool {
439 | 		return meta.Methods[i].Name < meta.Methods[j].Name
440 | 	})
441 | 	return meta
442 | }
443 | 
444 | type ClientOperationConverter struct {
445 | 	_         [0]int
446 | 	Generator *OpenAPICodeGenerator
447 | }
448 | 
449 | func (receiver *ClientOperationConverter) form(operation *v3.Operation) (bodyParams *astutils.FieldMeta) {
450 | 	receiver.Generator.resolveSchemaFromRef(operation)
451 | 	content := operation.RequestBody.Content
452 | 	if content.JSON != nil {
453 | 	} else if content.FormURL != nil {
454 | 		bodyParams = receiver.Generator.schema2Field(content.FormURL.Schema, "bodyParams", content.FormURL.Example, v3.TEXT_EXAMPLE)
455 | 		if !operation.RequestBody.Required && bodyParams != nil {
456 | 			bodyParams.Type = v3.ToOptional(bodyParams.Type)
457 | 		}
458 | 	} else if content.FormData != nil {
459 | 		bodyParams, _ = receiver.Generator.parseFormData(content.FormData)
460 | 		if !operation.RequestBody.Required && bodyParams != nil {
461 | 			bodyParams.Type = v3.ToOptional(bodyParams.Type)
462 | 		}
463 | 	}
464 | 	return
465 | }
466 | 
467 | func (receiver *ClientOperationConverter) ConvertOperation(endpoint, httpMethod string, operation *v3.Operation, gparams []v3.Parameter) (astutils.MethodMeta, error) {
468 | 	var files, params []astutils.FieldMeta
469 | 	var bodyJSON, bodyParams, qparams *astutils.FieldMeta
470 | 	comments := commentLines(operation)
471 | 	qSchema, pathvars, headervars := receiver.globalParams(gparams)
472 | 	receiver.operationParams(operation.Parameters, &qSchema, &pathvars, &headervars)
473 | 
474 | 	if len(qSchema.Properties) > 0 {
475 | 		qparams = receiver.Generator.schema2Field(&qSchema, "queryParams", nil, v3.UNKNOWN_EXAMPLE)
476 | 		if qSchema.Type == v3.ObjectT && len(qSchema.Required) == 0 {
477 | 			qparams.Type = v3.ToOptional(qparams.Type)
478 | 		}
479 | 	}
480 | 
481 | 	if httpMethod != "Get" && operation.RequestBody != nil {
482 | 		bodyJSON, files = receiver.Generator.requestBody(operation)
483 | 		bodyParams = receiver.form(operation)
484 | 	}
485 | 
486 | 	if operation.Responses == nil {
487 | 		return astutils.MethodMeta{}, errors.Errorf("response definition not found in api %s %s", httpMethod, endpoint)
488 | 	}
489 | 
490 | 	if operation.Responses.Resp200 == nil {
491 | 		return astutils.MethodMeta{}, errors.Errorf("200 response definition not found in api %s %s", httpMethod, endpoint)
492 | 	}
493 | 
494 | 	results, err := receiver.Generator.responseBody(endpoint, httpMethod, operation)
495 | 	if err != nil {
496 | 		return astutils.MethodMeta{}, err
497 | 	}
498 | 
499 | 	if qparams != nil {
500 | 		params = append(params, *qparams)
501 | 	}
502 | 
503 | 	params = append(params, pathvars...)
504 | 	params = append(params, headervars...)
505 | 
[TRUNCATED]
```

cmd/internal/openapi/v3/codegen/common_test.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"path"
5 | 	"path/filepath"
6 | 	"strings"
7 | 	"testing"
8 | 
9 | 	"github.com/stretchr/testify/assert"
10 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
11 | 	"github.com/unionj-cloud/toolkit/pathutils"
12 | )
13 | 
14 | func TestPattern2Method(t *testing.T) {
15 | 	type args struct {
16 | 		pattern string
17 | 	}
18 | 	tests := []struct {
19 | 		name string
20 | 		args args
21 | 		want string
22 | 	}{
23 | 		{
24 | 			name: "",
25 | 			args: args{
26 | 				pattern: "/shelves/{shelf}/books/{book}",
27 | 			},
28 | 			want: "Shelves_ShelfBooks_Book",
29 | 		},
30 | 		{
31 | 			name: "",
32 | 			args: args{
33 | 				pattern: "/goodFood/{bigApple}/books/{myBird}",
34 | 			},
35 | 			want: "Goodfood_BigappleBooks_Mybird",
36 | 		},
37 | 		{
38 | 			name: "",
39 | 			args: args{
40 | 				pattern: "/api/v1/query_range",
41 | 			},
42 | 			want: "ApiV1Query_range",
43 | 		},
44 | 	}
45 | 	for _, tt := range tests {
46 | 		t.Run(tt.name, func(t *testing.T) {
47 | 			if got := Pattern2Method(tt.args.pattern); got != tt.want {
48 | 				t.Errorf("Pattern2Method() = %v, want %v", got, tt.want)
49 | 			}
50 | 		})
51 | 	}
52 | }
53 | 
54 | func Test_genGoVo(t *testing.T) {
55 | 	testdir := pathutils.Abs("testdata")
56 | 	api := v3.LoadAPI(path.Join(testdir, "petstore3.json"))
57 | 	generator := &OpenAPICodeGenerator{
58 | 		Schemas:       api.Components.Schemas,
59 | 		RequestBodies: api.Components.RequestBodies,
60 | 		Responses:     api.Components.Responses,
61 | 		ApiInfo:       api.Info,
62 | 	}
63 | 	generator.GenGoDto(api.Components.Schemas, filepath.Join(testdir, "test", "vo.go"), "test", "")
64 | }
65 | 
66 | func Test_genGoVo_clean(t *testing.T) {
67 | 	testdir := pathutils.Abs("testdata")
68 | 	api := v3.LoadAPI(path.Join(testdir, "test5.json"))
69 | 	generator := &OpenAPICodeGenerator{
70 | 		Schemas:       api.Components.Schemas,
71 | 		RequestBodies: api.Components.RequestBodies,
72 | 		Responses:     api.Components.Responses,
73 | 		ApiInfo:       api.Info,
74 | 	}
75 | 	generator.GenGoDto(api.Components.Schemas, filepath.Join(testdir, "test", "vo.go"), "test", "")
76 | }
77 | 
78 | func Test_genGoVo_Omit(t *testing.T) {
79 | 	testdir := pathutils.Abs("testdata")
80 | 	api := v3.LoadAPI(path.Join(testdir, "petstore3.json"))
81 | 	generator := &OpenAPICodeGenerator{
82 | 		Schemas:       api.Components.Schemas,
83 | 		RequestBodies: api.Components.RequestBodies,
84 | 		Responses:     api.Components.Responses,
85 | 		ApiInfo:       api.Info,
86 | 		Omitempty:     true,
87 | 	}
88 | 	generator.GenGoDto(api.Components.Schemas, filepath.Join(testdir, "test", "vo.go"), "test", "")
89 | }
90 | 
91 | func Test_genGoHttp(t *testing.T) {
92 | 	testdir := pathutils.Abs("testdata")
93 | 	api := v3.LoadAPI(path.Join(testdir, "petstore3.json"))
94 | 	generator := &OpenAPICodeGenerator{
95 | 		Schemas:       api.Components.Schemas,
96 | 		RequestBodies: api.Components.RequestBodies,
97 | 		Responses:     api.Components.Responses,
98 | 		ApiInfo:       api.Info,
99 | 	}
100 | 	svcmap := make(map[string]map[string]v3.Path)
101 | 	for endpoint, path := range api.Paths {
102 | 		svcname := strings.Split(strings.Trim(endpoint, "/"), "/")[0]
103 | 		if value, exists := svcmap[svcname]; exists {
104 | 			value[endpoint] = path
105 | 		} else {
106 | 			svcmap[svcname] = make(map[string]v3.Path)
107 | 			svcmap[svcname][endpoint] = path
108 | 		}
109 | 	}
110 | 	operationConverter := &ClientOperationConverter{
111 | 		Generator: generator,
112 | 	}
113 | 	for svcname, paths := range svcmap {
114 | 		generator.GenGoHTTP(paths, svcname, filepath.Join(testdir, "test"), "", "test", operationConverter)
115 | 	}
116 | }
117 | 
118 | func Test_genGoHttp1(t *testing.T) {
119 | 	testdir := pathutils.Abs("testdata")
120 | 	api := v3.LoadAPI(path.Join(testdir, "test1.json"))
121 | 	generator := &OpenAPICodeGenerator{
122 | 		Schemas:       api.Components.Schemas,
123 | 		RequestBodies: api.Components.RequestBodies,
124 | 		Responses:     api.Components.Responses,
125 | 		ApiInfo:       api.Info,
126 | 	}
127 | 	svcmap := make(map[string]map[string]v3.Path)
128 | 	for endpoint, path := range api.Paths {
129 | 		svcname := strings.Split(strings.Trim(endpoint, "/"), "/")[0]
130 | 		if value, exists := svcmap[svcname]; exists {
131 | 			value[endpoint] = path
132 | 		} else {
133 | 			svcmap[svcname] = make(map[string]v3.Path)
134 | 			svcmap[svcname][endpoint] = path
135 | 		}
136 | 	}
137 | 	operationConverter := &ClientOperationConverter{
138 | 		Generator: generator,
139 | 	}
140 | 	for svcname, paths := range svcmap {
141 | 		generator.GenGoHTTP(paths, svcname, filepath.Join(testdir, "test"), "", "test", operationConverter)
142 | 	}
143 | }
144 | 
145 | func Test_genGoHttp2(t *testing.T) {
146 | 	testdir := pathutils.Abs("testdata")
147 | 	api := v3.LoadAPI(path.Join(testdir, "test2.json"))
148 | 	generator := &OpenAPICodeGenerator{
149 | 		Schemas:       api.Components.Schemas,
150 | 		RequestBodies: api.Components.RequestBodies,
151 | 		Responses:     api.Components.Responses,
152 | 		ApiInfo:       api.Info,
153 | 	}
154 | 	svcmap := make(map[string]map[string]v3.Path)
155 | 	for endpoint, path := range api.Paths {
156 | 		svcname := strings.Split(strings.Trim(endpoint, "/"), "/")[0]
157 | 		if value, exists := svcmap[svcname]; exists {
158 | 			value[endpoint] = path
159 | 		} else {
160 | 			svcmap[svcname] = make(map[string]v3.Path)
161 | 			svcmap[svcname][endpoint] = path
162 | 		}
163 | 	}
164 | 	operationConverter := &ClientOperationConverter{
165 | 		Generator: generator,
166 | 	}
167 | 	for svcname, paths := range svcmap {
168 | 		generator.GenGoHTTP(paths, svcname, filepath.Join(testdir, "test"), "", "test", operationConverter)
169 | 	}
170 | }
171 | 
172 | func Test_genGoHttp3(t *testing.T) {
173 | 	testdir := pathutils.Abs("testdata")
174 | 	api := v3.LoadAPI(path.Join(testdir, "test3.json"))
175 | 	generator := &OpenAPICodeGenerator{
176 | 		Schemas:       api.Components.Schemas,
177 | 		RequestBodies: api.Components.RequestBodies,
178 | 		Responses:     api.Components.Responses,
179 | 		ApiInfo:       api.Info,
180 | 	}
181 | 	svcmap := make(map[string]map[string]v3.Path)
182 | 	for endpoint, path := range api.Paths {
183 | 		svcname := strings.Split(strings.Trim(endpoint, "/"), "/")[0]
184 | 		if value, exists := svcmap[svcname]; exists {
185 | 			value[endpoint] = path
186 | 		} else {
187 | 			svcmap[svcname] = make(map[string]v3.Path)
188 | 			svcmap[svcname][endpoint] = path
189 | 		}
190 | 	}
191 | 	operationConverter := &ClientOperationConverter{
192 | 		Generator: generator,
193 | 	}
194 | 	for svcname, paths := range svcmap {
195 | 		generator.GenGoHTTP(paths, svcname, filepath.Join(testdir, "test"), "", "test", operationConverter)
196 | 	}
197 | }
198 | 
199 | func Test_genGoHttp4(t *testing.T) {
200 | 	testdir := pathutils.Abs("testdata")
201 | 	api := v3.LoadAPI("https://petstore3.swagger.io/api/v3/openapi.json")
202 | 	generator := &OpenAPICodeGenerator{
203 | 		Schemas:       api.Components.Schemas,
204 | 		RequestBodies: api.Components.RequestBodies,
205 | 		Responses:     api.Components.Responses,
206 | 		ApiInfo:       api.Info,
207 | 	}
208 | 	svcmap := make(map[string]map[string]v3.Path)
209 | 	for endpoint, path := range api.Paths {
210 | 		svcname := strings.Split(strings.Trim(endpoint, "/"), "/")[0]
211 | 		if value, exists := svcmap[svcname]; exists {
212 | 			value[endpoint] = path
213 | 		} else {
214 | 			svcmap[svcname] = make(map[string]v3.Path)
215 | 			svcmap[svcname][endpoint] = path
216 | 		}
217 | 	}
218 | 
219 | 	operationConverter := &ClientOperationConverter{
220 | 		Generator: generator,
221 | 	}
222 | 	for svcname, paths := range svcmap {
223 | 		generator.GenGoHTTP(paths, svcname, filepath.Join(testdir, "test"), "", "test", operationConverter)
224 | 	}
225 | }
226 | 
227 | func Test_genGoHttp5(t *testing.T) {
228 | 	testdir := pathutils.Abs("testdata")
229 | 	api := v3.LoadAPI(path.Join(testdir, "test5.json"))
230 | 	generator := &OpenAPICodeGenerator{
231 | 		Schemas:       api.Components.Schemas,
232 | 		RequestBodies: api.Components.RequestBodies,
233 | 		Responses:     api.Components.Responses,
234 | 		ApiInfo:       api.Info,
235 | 	}
236 | 	svcmap := make(map[string]map[string]v3.Path)
237 | 	for endpoint, path := range api.Paths {
238 | 		svcname := strings.Split(strings.Trim(endpoint, "/"), "/")[0]
239 | 		if value, exists := svcmap[svcname]; exists {
240 | 			value[endpoint] = path
241 | 		} else {
242 | 			svcmap[svcname] = make(map[string]v3.Path)
243 | 			svcmap[svcname][endpoint] = path
244 | 		}
245 | 	}
246 | 
247 | 	operationConverter := &ClientOperationConverter{
248 | 		Generator: generator,
249 | 	}
250 | 	for svcname, paths := range svcmap {
251 | 		generator.GenGoHTTP(paths, svcname, filepath.Join(testdir, "test"), "", "test", operationConverter)
252 | 	}
253 | }
254 | 
255 | func Test_loadApiPanic(t *testing.T) {
256 | 	assert.Panics(t, func() {
257 | 		v3.LoadAPI("notexists.json")
258 | 	})
259 | }
260 | 
261 | func Test_loadApiJsonUnmarshalPanic(t *testing.T) {
262 | 	assert.Panics(t, func() {
263 | 		v3.LoadAPI("testdata/test4.json")
264 | 	})
265 | }
266 | 
267 | func Test_genGoHttp_Omit(t *testing.T) {
268 | 	testdir := pathutils.Abs("testdata")
269 | 	api := v3.LoadAPI(path.Join(testdir, "petstore3.json"))
270 | 	generator := &OpenAPICodeGenerator{
271 | 		Schemas:       api.Components.Schemas,
272 | 		RequestBodies: api.Components.RequestBodies,
273 | 		Responses:     api.Components.Responses,
274 | 		ApiInfo:       api.Info,
275 | 		Omitempty:     true,
276 | 	}
277 | 	svcmap := make(map[string]map[string]v3.Path)
278 | 	for endpoint, path := range api.Paths {
279 | 		svcname := strings.Split(strings.Trim(endpoint, "/"), "/")[0]
280 | 		if value, exists := svcmap[svcname]; exists {
281 | 			value[endpoint] = path
282 | 		} else {
283 | 			svcmap[svcname] = make(map[string]v3.Path)
284 | 			svcmap[svcname][endpoint] = path
285 | 		}
286 | 	}
287 | 
288 | 	operationConverter := &ClientOperationConverter{
289 | 		Generator: generator,
290 | 	}
291 | 	for svcname, paths := range svcmap {
292 | 		generator.GenGoHTTP(paths, svcname, filepath.Join(testdir, "test"), "", "test", operationConverter)
293 | 	}
294 | }
295 | 
296 | func Test_toMethod(t *testing.T) {
297 | 	type args struct {
298 | 		endpoint string
299 | 	}
300 | 	tests := []struct {
301 | 		name string
302 | 		args args
303 | 		want string
304 | 	}{
305 | 		{
306 | 			name: "",
307 | 			args: args{
308 | 				endpoint: "/apps/a32(34/~name/{id}",
309 | 			},
310 | 			want: "AppsA3234NameId",
311 | 		},
312 | 		{
313 | 			name: "",
314 | 			args: args{
315 | 				endpoint: "/678/9apps/a32(34/~name/{id}",
316 | 			},
317 | 			want: "AppsA3234NameId6789",
318 | 		},
319 | 	}
320 | 	for _, tt := range tests {
321 | 		t.Run(tt.name, func(t *testing.T) {
322 | 			if got := toMethod(tt.args.endpoint); got != tt.want {
323 | 				t.Errorf("toMethod() = %v, want %v", got, tt.want)
324 | 			}
325 | 		})
326 | 	}
327 | }
328 | 
329 | func Test_httpMethod(t *testing.T) {
330 | 	type args struct {
331 | 		method string
332 | 	}
333 | 	tests := []struct {
334 | 		name string
335 | 		args args
336 | 		want string
337 | 	}{
338 | 		{
339 | 			name: "",
340 | 			args: args{
341 | 				method: "CreateUser",
342 | 			},
343 | 			want: "POST",
344 | 		},
345 | 		{
346 | 			name: "",
347 | 			args: args{
348 | 				method: "GetUserInfo",
349 | 			},
350 | 			want: "GET",
351 | 		},
352 | 	}
353 | 	for _, tt := range tests {
354 | 		t.Run(tt.name, func(t *testing.T) {
355 | 			if got := httpMethod(tt.args.method); got != tt.want {
356 | 				t.Errorf("httpMethod() = %v, want %v", got, tt.want)
357 | 			}
358 | 		})
359 | 	}
360 | }
361 | 
362 | func Test_operation2Method(t *testing.T) {
363 | 	type args struct {
364 | 		endpoint   string
365 | 		httpMethod string
366 | 		operation  *v3.Operation
367 | 		gparams    []v3.Parameter
368 | 	}
369 | 	tests := []struct {
370 | 		name    string
371 | 		args    args
372 | 		wantErr bool
373 | 	}{
374 | 		{
375 | 			name: "",
376 | 			args: args{
377 | 				endpoint:   "/test/operation2Mthod/{pid}",
378 | 				httpMethod: "GET",
379 | 				operation: &v3.Operation{
380 | 					Tags:        []string{"test"},
381 | 					Summary:     "This is only for test",
382 | 					Description: "Description for test",
383 | 					OperationID: "TestOperation2Mthod",
384 | 					Parameters:  []v3.Parameter{},
385 | 					RequestBody: &v3.RequestBody{
386 | 						Description: "This is a description",
387 | 						Content: &v3.Content{
388 | 							FormURL: &v3.MediaType{
389 | 								Schema: &v3.Schema{
390 | 									Type: "object",
391 | 									Properties: map[string]*v3.Schema{
392 | 										"id":    v3.Int64,
393 | 										"name":  v3.String,
394 | 										"score": v3.Float64,
395 | 										"isBoy": v3.Bool,
396 | 									},
397 | 								},
398 | 							},
399 | 						},
400 | 						Required: true,
401 | 					},
402 | 					Responses: &v3.Responses{
403 | 						Resp200: &v3.Response{
404 | 							Description: "this is a response",
405 | 							Content: &v3.Content{
406 | 								JSON: &v3.MediaType{
407 | 									Schema: &v3.Schema{
408 | 										Type: "object",
409 | 										Properties: map[string]*v3.Schema{
410 | 											"code": v3.Int,
411 | 											"data": v3.String,
412 | 											"err":  v3.String,
413 | 										},
414 | 									},
415 | 								},
416 | 							},
417 | 						},
418 | 					},
419 | 				},
420 | 				gparams: []v3.Parameter{
421 | 					{
422 | 						Name:        "companyId",
423 | 						In:          v3.InQuery,
424 | 						Description: "company ID",
425 | 						Required:    true,
426 | 						Schema:      v3.Int64,
427 | 					},
428 | 					{
429 | 						Name:        "name",
430 | 						In:          v3.InQuery,
431 | 						Description: "user name",
432 | 						Required:    true,
433 | 						Deprecated:  false,
434 | 						Schema:      v3.String,
435 | 					},
436 | 					{
437 | 						Name:        "pid",
438 | 						In:          v3.InPath,
439 | 						Description: "project Id",
440 | 						Required:    false,
441 | 						Deprecated:  false,
442 | 						Schema:      v3.Int64,
443 | 					},
444 | 					{
445 | 						Name:        "token",
446 | 						In:          v3.InHeader,
447 | 						Description: "user token",
448 | 						Required:    true,
449 | 						Deprecated:  false,
450 | 						Schema:      v3.String,
451 | 					},
452 | 				},
453 | 			},
454 | 			wantErr: false,
455 | 		},
456 | 		{
457 | 			name: "",
458 | 			args: args{
459 | 				endpoint:   "/test/operation2Mthod/{pid}",
460 | 				httpMethod: "GET",
461 | 				operation: &v3.Operation{
462 | 					Tags:        []string{"test"},
463 | 					Summary:     "This is only for test",
464 | 					Description: "Description for test",
465 | 					OperationID: "TestOperation2Mthod",
466 | 					Parameters:  []v3.Parameter{},
467 | 					RequestBody: &v3.RequestBody{
468 | 						Description: "This is a description",
469 | 						Content: &v3.Content{
470 | 							FormData: &v3.MediaType{
471 | 								Schema: &v3.Schema{
472 | 									Type: "object",
473 | 									Properties: map[string]*v3.Schema{
474 | 										"id":      v3.Int64,
475 | 										"name":    v3.String,
476 | 										"score":   v3.Float64,
477 | 										"isBoy":   v3.Bool,
478 | 										"photoes": v3.FileArray,
479 | 										"doc":     v3.File,
480 | 									},
481 | 								},
482 | 							},
483 | 						},
484 | 						Required: true,
485 | 					},
486 | 					Responses: &v3.Responses{
487 | 						Resp200: &v3.Response{
488 | 							Description: "this is a response",
489 | 							Content: &v3.Content{
490 | 								JSON: &v3.MediaType{
491 | 									Schema: &v3.Schema{
492 | 										Type: "object",
493 | 										Properties: map[string]*v3.Schema{
494 | 											"code": v3.Int,
495 | 											"data": v3.String,
496 | 											"err":  v3.String,
497 | 										},
498 | 									},
499 | 								},
500 | 							},
501 | 						},
502 | 					},
503 | 				},
504 | 			},
505 | 			wantErr: false,
506 | 		},
507 | 		{
508 | 			name: "",
509 | 			args: args{
510 | 				endpoint:   "/test/operation2Mthod/{pid}",
511 | 				httpMethod: "GET",
512 | 				operation: &v3.Operation{
513 | 					Tags:        []string{"test"},
514 | 					Summary:     "This is only for test",
515 | 					Description: "Description for test",
516 | 					OperationID: "TestOperation2Mthod",
517 | 					Parameters:  []v3.Parameter{},
518 | 					RequestBody: &v3.RequestBody{
519 | 						Description: "This is a description",
520 | 						Content: &v3.Content{
521 | 							FormData: &v3.MediaType{
522 | 								Schema: &v3.Schema{
523 | 									Type: "object",
524 | 									Properties: map[string]*v3.Schema{
525 | 										"id":      v3.Int64,
526 | 										"name":    v3.String,
527 | 										"score":   v3.Float64,
528 | 										"isBoy":   v3.Bool,
529 | 										"photoes": v3.FileArray,
530 | 										"doc":     v3.File,
531 | 									},
532 | 								},
533 | 							},
534 | 						},
535 | 						Required: true,
536 | 					},
537 | 					Responses: &v3.Responses{
538 | 						Resp200: &v3.Response{
539 | 							Description: "this is a response",
540 | 							Content: &v3.Content{
541 | 								Stream: &v3.MediaType{
542 | 									Schema: v3.File,
543 | 								},
544 | 							},
545 | 						},
546 | 					},
547 | 				},
548 | 			},
549 | 			wantErr: false,
550 | 		},
551 | 		{
552 | 			name: "",
553 | 			args: args{
554 | 				endpoint:   "/test/operation2Mthod/{pid}",
555 | 				httpMethod: "GET",
556 | 				operation: &v3.Operation{
557 | 					Tags:        []string{"test"},
558 | 					Summary:     "This is only for test",
559 | 					Description: "Description for test",
560 | 					OperationID: "TestOperation2Mthod",
561 | 					Parameters:  []v3.Parameter{},
562 | 					RequestBody: &v3.RequestBody{
563 | 						Description: "This is a description",
564 | 						Content: &v3.Content{
565 | 							TextPlain: &v3.MediaType{
566 | 								Schema: &v3.Schema{
567 | 									Type: "object",
568 | 									Properties: map[string]*v3.Schema{
569 | 										"id":    v3.Int64,
570 | 										"name":  v3.String,
571 | 										"score": v3.Float64,
572 | 										"isBoy": v3.Bool,
573 | 									},
574 | 								},
575 | 							},
576 | 						},
577 | 						Required: true,
578 | 					},
579 | 					Responses: &v3.Responses{
580 | 						Resp200: &v3.Response{
581 | 							Description: "this is a response",
582 | 							Content: &v3.Content{
583 | 								TextPlain: &v3.MediaType{
584 | 									Schema: &v3.Schema{
585 | 										Type: "object",
586 | 										Properties: map[string]*v3.Schema{
587 | 											"code": v3.Int,
588 | 											"data": v3.String,
589 | 											"err":  v3.String,
590 | 										},
591 | 									},
592 | 								},
593 | 							},
594 | 						},
595 | 					},
596 | 				},
597 | 			},
[TRUNCATED]
```

cmd/internal/openapi/v3/codegen/server.go
```
1 | package codegen
2 | 
3 | import (
4 | 	"bytes"
5 | 	"fmt"
6 | 	"os"
7 | 	"path/filepath"
8 | 	"regexp"
9 | 	"strings"
10 | 	"text/template"
11 | 
12 | 	"github.com/iancoleman/strcase"
13 | 	"github.com/pkg/errors"
14 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
15 | 	"github.com/unionj-cloud/toolkit/astutils"
16 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
17 | 	"github.com/unionj-cloud/toolkit/sliceutils"
18 | 	"github.com/unionj-cloud/toolkit/stringutils"
19 | 	"github.com/unionj-cloud/go-doudou/v2/version"
20 | 	"golang.org/x/text/cases"
21 | 	"golang.org/x/text/language"
22 | )
23 | 
24 | type IOperationConverter interface {
25 | 	ConvertOperation(endpoint, httpMethod string, operation *v3.Operation, gparams []v3.Parameter) (astutils.MethodMeta, error)
26 | }
27 | 
28 | type ServerOperationConverter struct {
29 | 	_         [0]int
30 | 	Generator *OpenAPICodeGenerator
31 | }
32 | 
33 | // /shelves/{shelf}/books/{book}
34 | // [shelves,{shelf},books,{book}]
35 | // shelves_{shelf}_books_{book}
36 | // Shelves_ShelfBooks_Book
37 | func Pattern2Method(pattern string) string {
38 | 	pattern = strings.TrimSuffix(strings.TrimPrefix(pattern, "/"), "/")
39 | 	partials := strings.Split(pattern, "/")
40 | 	var converted []string
41 | 	nosymbolreg := regexp.MustCompile(`[^a-zA-Z0-9_]`)
42 | 	for _, item := range partials {
43 | 		if strings.HasPrefix(item, "{") && strings.HasSuffix(item, "}") {
44 | 			item = strings.TrimSuffix(strings.TrimPrefix(item, "{"), "}")
45 | 			item = nosymbolreg.ReplaceAllLiteralString(item, "")
46 | 			item = cases.Title(language.English).String(strings.ToLower(item))
47 | 			converted = append(converted, "_"+item)
48 | 			continue
49 | 		}
50 | 		item = nosymbolreg.ReplaceAllLiteralString(item, "")
51 | 		item = cases.Title(language.English).String(strings.ToLower(item))
52 | 		converted = append(converted, item)
53 | 	}
54 | 	return strings.Join(converted, "")
55 | }
56 | 
57 | func (receiver *ServerOperationConverter) globalParams(gparams []v3.Parameter) (queryVars, pathVars, headerVars []astutils.FieldMeta) {
58 | 	for _, item := range gparams {
59 | 		switch item.In {
60 | 		case v3.InQuery:
61 | 			queryVars = append(queryVars, receiver.Generator.parameter2Field(item))
62 | 		case v3.InPath:
63 | 			pathVar := receiver.Generator.parameter2Field(item)
64 | 			pathVar.Name = strings.ToLower(pathVar.Name)
65 | 			pathVars = append(pathVars, pathVar)
66 | 		case v3.InHeader:
67 | 			headerVars = append(headerVars, receiver.Generator.parameter2Field(item))
68 | 		default:
69 | 			panic(fmt.Errorf("not support %s parameter yet", item.In))
70 | 		}
71 | 	}
72 | 	return
73 | }
74 | 
75 | func (receiver *ServerOperationConverter) operationParams(parameters []v3.Parameter, queryVars, pathVars, headerVars *[]astutils.FieldMeta) {
76 | 	for _, item := range parameters {
77 | 		switch item.In {
78 | 		case v3.InQuery:
79 | 			*queryVars = append(*queryVars, receiver.Generator.parameter2Field(item))
80 | 		case v3.InPath:
81 | 			pathVar := receiver.Generator.parameter2Field(item)
82 | 			pathVar.Name = strings.ToLower(pathVar.Name)
83 | 			*pathVars = append(*pathVars, pathVar)
84 | 		case v3.InHeader:
85 | 			*headerVars = append(*headerVars, receiver.Generator.parameter2Field(item))
86 | 		default:
87 | 			panic(fmt.Errorf("not support %s parameter yet", item.In))
88 | 		}
89 | 	}
90 | }
91 | 
92 | func (receiver *ServerOperationConverter) parseForm(form *v3.MediaType) (bodyParams []astutils.FieldMeta) {
93 | 	schema := *form.Schema
94 | 	if stringutils.IsNotEmpty(schema.Ref) {
95 | 		schema = receiver.Generator.Schemas[strings.TrimPrefix(form.Schema.Ref, "#/components/schemas/")]
96 | 	}
97 | 	for k, v := range schema.Properties {
98 | 		var gotype string
99 | 		if v.Type == v3.StringT && v.Format == v3.BinaryF {
100 | 			gotype = "v3.FileModel"
101 | 		} else if v.Type == v3.ArrayT && v.Items.Type == v3.StringT && v.Items.Format == v3.BinaryF {
102 | 			gotype = "[]v3.FileModel"
103 | 		}
104 | 		if stringutils.IsNotEmpty(gotype) {
105 | 			continue
106 | 		}
107 | 		field := receiver.Generator.schema2Field(v, k, nil, v3.UNKNOWN_EXAMPLE)
108 | 		if !sliceutils.StringContains(schema.Required, k) {
109 | 			field.Type = v3.ToOptional(field.Type)
110 | 		}
111 | 		bodyParams = append(bodyParams, *field)
112 | 	}
113 | 	return
114 | }
115 | 
116 | func (receiver *ServerOperationConverter) form(operation *v3.Operation) (bodyParams []astutils.FieldMeta) {
117 | 	receiver.Generator.resolveSchemaFromRef(operation)
118 | 	content := operation.RequestBody.Content
119 | 	if content.JSON != nil {
120 | 	} else if content.FormURL != nil {
121 | 		bodyParams = receiver.parseForm(content.FormURL)
122 | 	} else if content.FormData != nil {
123 | 		bodyParams = receiver.parseForm(content.FormData)
124 | 	}
125 | 	return
126 | }
127 | 
128 | func (receiver *ServerOperationConverter) ConvertOperation(endpoint, httpMethod string, operation *v3.Operation, gparams []v3.Parameter) (astutils.MethodMeta, error) {
129 | 	var files, params, bodyParams []astutils.FieldMeta
130 | 	var bodyJSON *astutils.FieldMeta
131 | 	comments := commentLines(operation)
132 | 	queryVars, pathvars, headervars := receiver.globalParams(gparams)
133 | 	receiver.operationParams(operation.Parameters, &queryVars, &pathvars, &headervars)
134 | 
135 | 	if httpMethod != "Get" && operation.RequestBody != nil {
136 | 		bodyJSON, files = receiver.Generator.requestBody(operation)
137 | 		bodyParams = receiver.form(operation)
138 | 	}
139 | 
140 | 	if operation.Responses == nil {
141 | 		return astutils.MethodMeta{}, errors.Errorf("response definition not found in api %s %s", httpMethod, endpoint)
142 | 	}
143 | 
144 | 	if operation.Responses.Resp200 == nil {
145 | 		return astutils.MethodMeta{}, errors.Errorf("200 response definition not found in api %s %s", httpMethod, endpoint)
146 | 	}
147 | 
148 | 	results, err := receiver.Generator.responseBody(endpoint, httpMethod, operation)
149 | 	if err != nil {
150 | 		return astutils.MethodMeta{}, err
151 | 	}
152 | 
153 | 	params = append(params, queryVars...)
154 | 	params = append(params, pathvars...)
155 | 	params = append(params, headervars...)
156 | 	params = append(params, bodyParams...)
157 | 	params = append(params, files...)
158 | 
159 | 	if bodyJSON != nil {
160 | 		params = append(params, *bodyJSON)
161 | 	}
162 | 
163 | 	if httpMethod == "Post" {
164 | 		httpMethod = ""
165 | 	}
166 | 
167 | 	ret := astutils.MethodMeta{
168 | 		Name:       httpMethod + Pattern2Method(endpoint),
169 | 		Params:     params,
170 | 		Results:    results,
171 | 		PathVars:   pathvars,
172 | 		HeaderVars: headervars,
173 | 		BodyJSON:   bodyJSON,
174 | 		Files:      files,
175 | 		Comments:   comments,
176 | 		Path:       endpoint,
177 | 	}
178 | 	return ret, nil
179 | }
180 | 
181 | var svcTmpl = templates.EditableHeaderTmpl + `package service
182 | 
183 | import (
184 | 	"context"
185 | 	"{{.DtoPackage}}"
186 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
187 | )
188 | 
189 | //go:generate go-doudou svc http
190 | 
191 | {{ range $i, $c := .Meta.Comments }}
192 | {{- if eq $i 0}}
193 | // {{$.Meta.Name}} {{$c}}
194 | {{- else}}
195 | // {{$c}}
196 | {{- end}}
197 | {{- end }}
198 | type {{.Meta.Name}} interface {
199 | 	{{ range $m := .Meta.Methods }}
200 | 	{{- range $i, $c := $m.Comments }}
201 | 	{{- if eq $i 0}}
202 | 	// {{$m.Name}} {{$c}}
203 | 	{{- else}}
204 | 	// {{$c}}
205 | 	{{- end}}
206 | 	{{- end }}
207 | 	{{$m.Name}}(ctx context.Context{{if $m.Params}}, {{end}}{{- range $i, $p := $m.Params}}
208 | 	{{- if $i}},{{end}}
209 | 	{{- range $c := $p.Comments }}
210 | 	// {{$c}}
211 | 	{{- end }}
212 | 	{{ $p.Name}} {{$p.Type}}
213 | 	{{- end }}) ({{- range $i, $r := $m.Results}}
214 | 					 {{- if $i}},{{end}}
215 | 					 {{- range $c := $r.Comments }}
216 | 					 // {{$c}}
217 | 					 {{- end }}
218 | 					 {{ $r.Name}} {{$r.Type}}
219 | 					 {{- end }}{{if $m.Results}}, {{end}}err error)
220 | 
221 | 	{{ end }}
222 | }
223 | `
224 | 
225 | func (receiver *OpenAPICodeGenerator) GenGoInterface(output string, paths map[string]v3.Path, operationConverter IOperationConverter) {
226 | 	_ = os.MkdirAll(filepath.Dir(output), os.ModePerm)
227 | 	funcMap := make(map[string]interface{})
228 | 	funcMap["toCamel"] = strcase.ToCamel
229 | 	funcMap["contains"] = strings.Contains
230 | 	funcMap["restyMethod"] = RestyMethod
231 | 	funcMap["toUpper"] = strings.ToUpper
232 | 	funcMap["isOptional"] = IsOptional
233 | 	tpl, _ := template.New(svcTmpl).Funcs(funcMap).Parse(svcTmpl)
234 | 	var sqlBuf bytes.Buffer
235 | 	_ = tpl.Execute(&sqlBuf, struct {
236 | 		Meta       astutils.InterfaceMeta
237 | 		DtoPackage string
238 | 		Version    string
239 | 	}{
240 | 		Meta:       receiver.Api2Interface(paths, receiver.SvcName, operationConverter),
241 | 		DtoPackage: receiver.ModName + "/dto",
242 | 		Version:    version.Release,
243 | 	})
244 | 	source := strings.TrimSpace(sqlBuf.String())
245 | 	astutils.FixImport([]byte(source), output)
246 | }
```

cmd/internal/ddl/testdata/entity2/base.go
```
1 | package entity
2 | 
3 | import "time"
4 | 
5 | type Base struct {
6 | 	CreateAt *time.Time `dd:"default:CURRENT_TIMESTAMP"`
7 | 	UpdateAt *time.Time `dd:"default:CURRENT_TIMESTAMP;extra:ON UPDATE CURRENT_TIMESTAMP"`
8 | 	DeleteAt *time.Time
9 | }
```

cmd/internal/ddl/testdata/entity2/book.go
```
1 | package entity
2 | 
3 | //dd:table
4 | type Book struct {
5 | 	ID          int `dd:"pk;auto"`
6 | 	UserId      int `dd:"type:int;fk:ddl_publisher,id,fk_user,ON DELETE CASCADE ON UPDATE NO ACTION"`
7 | 	PublisherId int
8 | 
9 | 	Base
10 | }
```

cmd/internal/ddl/testdata/entity2/publisher.go
```
1 | package entity
2 | 
3 | //dd:table
4 | type Publisher struct {
5 | 	ID   int `dd:"pk;auto"`
6 | 	Name string
7 | 
8 | 	Base
9 | }
```

cmd/internal/ddl/testdata/entity2/user.go
```
1 | package entity
2 | 
3 | import "time"
4 | 
5 | //dd:table
6 | type User struct {
7 | 	ID         int    `dd:"pk;auto"`
8 | 	Name       string `dd:"index:name_phone_idx,2;default:'jack'"`
9 | 	Phone      string `dd:"index:name_phone_idx,1;default:'13552053960';extra:comment '手机号'"`
10 | 	Age        int    `dd:"index;unsigned"`
11 | 	No         int    `dd:"type:int;unique"`
12 | 	UniqueCol  int    `dd:"type:int;unique:unique_col_idx,1"`
13 | 	UniqueCol2 int    `dd:"type:int;unique:unique_col_idx,2"`
14 | 	School     string `dd:"null;default:'harvard';extra:comment '学校'"`
15 | 	IsStudent  bool
16 | 	Rule       string `dd:"type:varchar(255);unique;extra:comment '链接匹配规则，匹配的链接采用该css规则来爬'"`
17 | 	RuleType   string `dd:"type:varchar(45);extra:comment '链接匹配规则类型，支持prefix前缀匹配和regex正则匹配'"`
18 | 
19 | 	ArriveAt *time.Time `dd:"type:datetime;extra:comment '到货时间'"`
20 | 	Status   int8       `dd:"type:tinyint(4);extra:comment '0进行中
21 | 1完结
22 | 2取消'"`
23 | 
24 | 	Base
25 | }
```

cmd/internal/ddl/testdata/entity3/base.go
```
1 | package entity
2 | 
3 | import "time"
4 | 
5 | type Base struct {
6 | 	CreateAt *time.Time `dd:"default:CURRENT_TIMESTAMP"`
7 | 	UpdateAt *time.Time `dd:"default:CURRENT_TIMESTAMP;extra:ON UPDATE CURRENT_TIMESTAMP"`
8 | 	DeleteAt *time.Time
9 | }
```

cmd/internal/ddl/testdata/entity3/book.go
```
1 | package entity
2 | 
3 | //dd:table
4 | type Book struct {
5 | 	ID          int `dd:"pk;auto"`
6 | 	UserId      int `dd:"type:int"`
7 | 	PublisherId int `dd:"fk:ddl_publisher,id,fk_publisher,ON DELETE CASCADE ON UPDATE NO ACTION"`
8 | 
9 | 	Base
10 | }
```

cmd/internal/ddl/testdata/entity3/publisher.go
```
1 | package entity
2 | 
3 | //dd:table
4 | type Publisher struct {
5 | 	ID   int `dd:"pk;auto"`
6 | 	Name string
7 | 
8 | 	Base
9 | }
```

cmd/internal/ddl/testdata/entity3/user.go
```
1 | package entity
2 | 
3 | import "time"
4 | 
5 | //dd:table
6 | type User struct {
7 | 	ID         int    `dd:"pk;auto"`
8 | 	Name       string `dd:"index:name_phone_idx,2;default:'jack'"`
9 | 	Phone      string `dd:"index:name_phone_idx,1;default:'13552053960';extra:comment '手机号'"`
10 | 	Age        int    `dd:"unsigned"`
11 | 	No         int    `dd:"type:int;unique"`
12 | 	UniqueCol  int    `dd:"type:int;unique:unique_col_idx,1"`
13 | 	UniqueCol2 int    `dd:"type:int;unique:unique_col_idx,2"`
14 | 	School     string `dd:"null;default:'harvard';extra:comment '学校'"`
15 | 	IsStudent  bool
16 | 	Rule       string `dd:"type:varchar(255);unique;extra:comment '链接匹配规则，匹配的链接采用该css规则来爬'"`
17 | 	RuleType   string `dd:"type:varchar(45);extra:comment '链接匹配规则类型，支持prefix前缀匹配和regex正则匹配'"`
18 | 
19 | 	ArriveAt *time.Time `dd:"type:datetime;extra:comment '到货时间'"`
20 | 	Status   int8       `dd:"type:tinyint(4);extra:comment '0进行中
21 | 1完结
22 | 2取消'"`
23 | 
24 | 	Base
25 | }
```

cmd/internal/ddl/testdata/entity/base.go
```
1 | package entity
2 | 
3 | import "time"
4 | 
5 | type Base struct {
6 | 	CreateAt *time.Time `dd:"default:CURRENT_TIMESTAMP"`
7 | 	UpdateAt *time.Time `dd:"default:CURRENT_TIMESTAMP;extra:ON UPDATE CURRENT_TIMESTAMP"`
8 | 	DeleteAt *time.Time
9 | }
```

cmd/internal/ddl/testdata/entity/order.go
```
1 | package entity
2 | 
3 | //dd:table
4 | type Order struct {
5 | 	ID     int `dd:"pk;auto"`
6 | 	Amount int64
7 | 	UserId int `dd:"type:int;fk:ddl_user,id,fk_ddl_user,ON DELETE CASCADE ON UPDATE NO ACTION"`
8 | 
9 | 	Base
10 | }
```

cmd/internal/ddl/testdata/entity/user.go
```
1 | package entity
2 | 
3 | import "time"
4 | 
5 | //dd:table
6 | type User struct {
7 | 	ID         int    `dd:"pk;auto"`
8 | 	Name       string `dd:"index:name_phone_idx,2;default:'jack'"`
9 | 	Phone      string `dd:"index:name_phone_idx,1;default:'13552053960';extra:comment '手机号'"`
10 | 	Age        int    `dd:"index;unsigned"`
11 | 	No         int    `dd:"type:int;unique"`
12 | 	UniqueCol  int    `dd:"type:int;unique:unique_col_idx,1"`
13 | 	UniqueCol2 int    `dd:"type:int;unique:unique_col_idx,2"`
14 | 	School     string `dd:"null;default:'harvard';extra:comment '学校'"`
15 | 	IsStudent  bool
16 | 	Rule       string `dd:"type:varchar(255);unique;extra:comment '链接匹配规则，匹配的链接采用该css规则来爬'"`
17 | 	RuleType   string `dd:"type:varchar(45);extra:comment '链接匹配规则类型，支持prefix前缀匹配和regex正则匹配'"`
18 | 
19 | 	ArriveAt *time.Time `dd:"type:datetime;extra:comment '到货时间'"`
20 | 	Status   int8       `dd:"type:tinyint(4);extra:comment '0进行中
21 | 1完结
22 | 2取消'"`
23 | 
24 | 	Base
25 | }
```

cmd/internal/svc/codegen/database/common.go
```
1 | package database
2 | 
3 | import (
4 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/codegen"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/parser"
6 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/validate"
7 | 	"github.com/unionj-cloud/toolkit/astutils"
8 | 	"github.com/unionj-cloud/toolkit/executils"
9 | 	v3 "github.com/unionj-cloud/toolkit/protobuf/v3"
10 | 	"github.com/wubin1989/gen"
11 | 	"os"
12 | 	"path/filepath"
13 | )
14 | 
15 | var OrmGeneratorRegistry = make(map[OrmKind]IOrmGenerator)
16 | 
17 | type OrmKind string
18 | 
19 | func RegisterOrmGenerator(kind OrmKind, instance IOrmGenerator) {
20 | 	OrmGeneratorRegistry[kind] = instance
21 | }
22 | 
23 | func GetOrmGenerator(kind OrmKind) IOrmGenerator {
24 | 	if gen, ok := OrmGeneratorRegistry[kind]; ok {
25 | 		return gen
26 | 	}
27 | 	return nil
28 | }
29 | 
30 | type OrmGeneratorConfig struct {
31 | 	Driver           string
32 | 	Dsn              string
33 | 	TablePrefix      string
34 | 	TableGlob        string
35 | 	TableExcludeGlob string
36 | 	GenGenGo         bool
37 | 	CaseConverter    func(string) string
38 | 	Dir              string
39 | 	Soft             string
40 | 	ProtoGenerator   v3.ProtoGenerator
41 | 	Omitempty        bool
42 | 	TypeMapping      string
43 | }
44 | 
45 | type IOrmGenerator interface {
46 | 	svcGo()
47 | 	svcImplGrpc()
48 | 	svcImplRest()
49 | 	orm()
50 | 	fix()
51 | 	Initialize(conf OrmGeneratorConfig)
52 | 	GenGrpc()
53 | 	GenRest()
54 | 	GenDao()
55 | }
56 | 
57 | var _ IOrmGenerator = (*AbstractBaseGenerator)(nil)
58 | 
59 | type AbstractBaseGenerator struct {
60 | 	Driver              string
61 | 	Dsn                 string
62 | 	TablePrefix         string
63 | 	TableGlob           string
64 | 	TableExcludeGlob    string
65 | 	GenGenGo            bool
66 | 	Dir                 string
67 | 	g                   *gormgen.Generator
68 | 	CaseConverter       func(string) string
69 | 	ProtoGenerator      v3.ProtoGenerator
70 | 	Omitempty           bool
71 | 	AllowGetWithReqBody bool
72 | 	Client              bool
73 | 	Env                 string
74 | 	impl                IOrmGenerator
75 | 	runner              executils.Runner
76 | 	ConfigPackage       string
77 | }
78 | 
79 | func (b *AbstractBaseGenerator) GenRest() {
80 | 	b.orm()
81 | 	b.svcGo()
82 | 	b.svcImplRest()
83 | 
84 | 	validate.DataType(b.Dir, parser.DEFAULT_DTO_PKGS...)
85 | 	ic := astutils.BuildInterfaceCollector(filepath.Join(b.Dir, "svc.go"), astutils.ExprString)
86 | 	validate.RestApi(b.Dir, ic)
87 | 
88 | 	codegen.GenHttpMiddleware(b.Dir)
89 | 	codegen.GenHttpHandler(b.Dir, ic, 0)
90 | 	codegen.GenHttpHandlerImpl(b.Dir, ic, codegen.GenHttpHandlerImplConfig{
91 | 		Omitempty:           b.Omitempty,
92 | 		AllowGetWithReqBody: b.AllowGetWithReqBody,
93 | 		CaseConvertor:       b.CaseConverter,
94 | 	})
95 | 	if b.Client {
96 | 		codegen.GenGoIClient(b.Dir, ic)
97 | 		codegen.GenGoClient(b.Dir, ic, codegen.GenGoClientConfig{
98 | 			Env:                 b.Env,
99 | 			AllowGetWithReqBody: b.AllowGetWithReqBody,
100 | 			CaseConvertor:       b.CaseConverter,
101 | 		})
102 | 		codegen.GenGoClientProxy(b.Dir, ic)
103 | 	}
104 | 	parser.GenDoc(b.Dir, ic, parser.GenDocConfig{
105 | 		AllowGetWithReqBody: b.AllowGetWithReqBody,
106 | 	})
107 | 
108 | 	b.fix()
109 | 	b.goModTidy()
110 | }
111 | 
112 | func (b *AbstractBaseGenerator) GenDao() {
113 | 	b.orm()
114 | 	b.goModTidy()
115 | }
116 | 
117 | func (b *AbstractBaseGenerator) fix() {
118 | 	b.impl.fix()
119 | }
120 | 
121 | func (b *AbstractBaseGenerator) orm() {
122 | 	b.impl.orm()
123 | }
124 | 
125 | func (b *AbstractBaseGenerator) svcImplRest() {
126 | 	b.impl.svcImplRest()
127 | }
128 | 
129 | func (b *AbstractBaseGenerator) svcGo() {
130 | 	b.impl.svcGo()
131 | }
132 | 
133 | func (b *AbstractBaseGenerator) svcImplGrpc() {
134 | 	b.impl.svcImplGrpc()
135 | }
136 | 
137 | func (b *AbstractBaseGenerator) Initialize(conf OrmGeneratorConfig) {
138 | 	//TODO implement me
139 | 	panic("implement me")
140 | }
141 | 
142 | func (b *AbstractBaseGenerator) GenGrpc() {
143 | 	b.orm()
144 | 	b.svcGo()
145 | 	b.svcImplGrpc()
146 | 
147 | 	validate.DataType(b.Dir, parser.DEFAULT_DTO_PKGS...)
148 | 	ic := astutils.BuildInterfaceCollector(filepath.Join(b.Dir, "svc.go"), astutils.ExprString)
149 | 	validate.GrpcApi(b.Dir, ic, true)
150 | 	parser.ParseDtoGrpc(b.Dir, b.ProtoGenerator, parser.DEFAULT_DTO_PKGS...)
151 | 	_, protoFile := codegen.GenGrpcProto(b.Dir, ic, b.ProtoGenerator)
152 | 	protoFile, _ = filepath.Rel(b.Dir, protoFile)
153 | 	wd, _ := os.Getwd()
154 | 	os.Chdir(filepath.Join(b.Dir))
155 | 	if err := b.ProtoGenerator.Generate(protoFile, b.runner); err != nil {
156 | 		panic(err)
157 | 	}
158 | 	os.Chdir(wd)
159 | 	codegen.GenHttpHandler(b.Dir, ic, 0)
160 | 	codegen.GenHttp2Grpc(b.Dir, ic, codegen.GenHttp2GrpcConfig{
161 | 		AllowGetWithReqBody: b.AllowGetWithReqBody,
162 | 		CaseConvertor:       b.CaseConverter,
163 | 		Omitempty:           b.Omitempty,
164 | 	})
165 | 	parser.GenDoc(b.Dir, ic, parser.GenDocConfig{
166 | 		RoutePatternStrategy: 0,
167 | 		AllowGetWithReqBody:  b.AllowGetWithReqBody,
168 | 	})
169 | 	codegen.GenMethodAnnotationStore(b.Dir, ic)
170 | 
171 | 	b.fix()
172 | 	b.goModTidy()
173 | }
174 | 
175 | func (b *AbstractBaseGenerator) goModTidy() {
176 | 	// here go mod tidy cause performance issue on some computer
177 | 	//wd, _ := os.Getwd()
178 | 	//os.Chdir(filepath.Join(b.Dir))
179 | 	//err := b.runner.Run("go", "mod", "tidy")
180 | 	//if err != nil {
181 | 	//	panic(err)
182 | 	//}
183 | 	//os.Chdir(wd)
184 | }
```

cmd/internal/svc/codegen/database/gorm.go
```
1 | package database
2 | 
3 | import (
4 | 	"github.com/samber/lo"
5 | 	"github.com/unionj-cloud/toolkit/astutils"
6 | 	"path/filepath"
7 | 	"strings"
8 | 
9 | 	"github.com/gobwas/glob"
10 | 	"github.com/unionj-cloud/toolkit/errorx"
11 | 	"github.com/unionj-cloud/toolkit/executils"
12 | 	"github.com/unionj-cloud/toolkit/stringutils"
13 | 	"github.com/wubin1989/gen"
14 | 	"github.com/wubin1989/gen/field"
15 | 	"github.com/wubin1989/gorm"
16 | 	"github.com/wubin1989/mysql"
17 | 	"github.com/wubin1989/postgres"
18 | 	"github.com/wubin1989/sqlite"
19 | 	"github.com/wubin1989/sqlserver"
20 | )
21 | 
22 | const (
23 | 	GormKind = "gorm"
24 | )
25 | 
26 | func init() {
27 | 	gg := &GormGenerator{}
28 | 	ag := &AbstractBaseGenerator{
29 | 		impl:   gg,
30 | 		runner: executils.CmdRunner{},
31 | 	}
32 | 	gg.AbstractBaseGenerator = ag
33 | 	RegisterOrmGenerator(GormKind, gg)
34 | }
35 | 
36 | var _ IOrmGenerator = (*GormGenerator)(nil)
37 | 
38 | type GormGenerator struct {
39 | 	*AbstractBaseGenerator
40 | }
41 | 
42 | func (gg *GormGenerator) svcGo() {
43 | 	gg.g.GenerateSvcGo()
44 | }
45 | 
46 | func (gg *GormGenerator) svcImplGrpc() {
47 | 	gg.g.GenerateSvcImplGrpc()
48 | }
49 | 
50 | func (gg *GormGenerator) svcImplRest() {
51 | 	gg.g.GenerateSvcImplRest()
52 | }
53 | 
54 | func (gg *GormGenerator) orm() {
55 | 	gg.g.Execute()
56 | }
57 | 
58 | func (gg *GormGenerator) fix() {
59 | 	//dir, _ := filepath.Abs(gg.Dir)
60 | 	//var files []string
61 | 	//err := filepath.Walk(dir, astutils.Visit(&files))
62 | 	//if err != nil {
63 | 	//	panic(err)
64 | 	//}
65 | 	//for _, file := range files {
66 | 	//	if filepath.Ext(file) != ".go" {
67 | 	//		continue
68 | 	//	}
69 | 	//	source, err := ioutil.ReadFile(file)
70 | 	//	if err != nil {
71 | 	//		panic(err)
72 | 	//	}
73 | 	//	fileContent := string(source)
74 | 	//	fileContent = strings.ReplaceAll(fileContent, "github.com/wubin1989/gen", "github.com/wubin1989/gen")
75 | 	//	ioutil.WriteFile(file, []byte(fileContent), os.ModePerm)
76 | 	//}
77 | }
78 | 
79 | const (
80 | 	driverMysql     = "mysql"
81 | 	driverPostgres  = "postgres"
82 | 	driverSqlite    = "sqlite"
83 | 	driverSqlserver = "sqlserver"
84 | 	driverTidb      = "tidb"
85 | )
86 | 
87 | func (gg *GormGenerator) Initialize(conf OrmGeneratorConfig) {
88 | 	gg.Dir = conf.Dir
89 | 	gg.Driver = conf.Driver
90 | 	gg.Dsn = conf.Dsn
91 | 	gg.Client = false
92 | 	gg.TablePrefix = strings.TrimSuffix(conf.TablePrefix, ".")
93 | 	gg.TableGlob = conf.TableGlob
94 | 	gg.TableExcludeGlob = conf.TableExcludeGlob
95 | 	gg.GenGenGo = conf.GenGenGo
96 | 	gg.CaseConverter = conf.CaseConverter
97 | 	gg.ProtoGenerator = conf.ProtoGenerator
98 | 	var db *gorm.DB
99 | 	var err error
100 | 	switch gg.Driver {
101 | 	case driverMysql, driverTidb:
102 | 		conf := mysql.Config{
103 | 			DSN: gg.Dsn, // data source name
104 | 		}
105 | 		db, err = gorm.Open(mysql.New(conf))
106 | 	case driverPostgres:
107 | 		conf := postgres.Config{
108 | 			DSN: gg.Dsn,
109 | 		}
110 | 		db, err = gorm.Open(postgres.New(conf))
111 | 		if stringutils.IsNotEmpty(gg.TablePrefix) {
112 | 			db.Exec(`set search_path='` + gg.TablePrefix + `'`)
113 | 		}
114 | 	case driverSqlite:
115 | 		db, err = gorm.Open(sqlite.Open(gg.Dsn))
116 | 	case driverSqlserver:
117 | 		db, err = gorm.Open(sqlserver.Open(gg.Dsn))
118 | 	default:
119 | 		errorx.Panic("Not support driver")
120 | 	}
121 | 	if err != nil {
122 | 		errorx.Panic(err.Error())
123 | 	}
124 | 	g := gormgen.NewGenerator(gormgen.Config{
125 | 		RootDir:       gg.Dir,
126 | 		OutPath:       gg.Dir + "/query",
127 | 		Mode:          gormgen.WithoutContext | gormgen.WithDefaultQuery | gormgen.WithQueryInterface,
128 | 		FieldNullable: true,
129 | 		// if you want to assign field which has a default value in the `Create` API, set FieldCoverable true
130 | 		FieldCoverable: true,
131 | 		// if you want to generate field with unsigned integer type, set FieldSignable true
132 | 		FieldSignable: false,
133 | 		// if you want to generate index tags from database, set FieldWithIndexTag true
134 | 		FieldWithIndexTag: true,
135 | 		// if you want to generate type tags from database, set FieldWithTypeTag true
136 | 		FieldWithTypeTag: true,
137 | 		// if you need unit tests for query code, set WithUnitTest true
138 | 		WithUnitTest: false,
139 | 	})
140 | 	g.WithOpts(gormgen.FieldGORMTag("", func(tag field.GormTag) field.GormTag {
141 | 		if defaultTag, ok := tag["default"]; ok {
142 | 			if len(defaultTag) > 0 {
143 | 				t := defaultTag[0]
144 | 				idx := strings.Index(t, "::")
145 | 				if idx > -1 {
146 | 					tag.Set("default", t[:idx])
147 | 				}
148 | 			}
149 | 		}
150 | 		return tag
151 | 	}))
152 | 	g.WithJSONTagNameStrategy(func(n string, t string) string {
153 | 		tagContent := gg.CaseConverter(n)
154 | 		if conf.Omitempty {
155 | 			tagContent = tagContent + ",omitempty"
156 | 		}
157 | 		return tagContent
158 | 	})
159 | 	if stringutils.IsNotEmpty(conf.TypeMapping) {
160 | 		typeMapping := make(map[string]func(gorm.ColumnType) (dataType string))
161 | 		lo.ForEach(strings.Split(conf.TypeMapping, ","), func(item string, index int) {
162 | 			kv := strings.Split(item, ":")
163 | 			columnType := kv[0]
164 | 			goType := kv[1]
165 | 			typeMapping[columnType] = func(columnType gorm.ColumnType) (dataType string) {
166 | 				if n, ok := columnType.Nullable(); ok && n {
167 | 					return "*" + goType
168 | 				}
169 | 				return goType
170 | 			}
171 | 		})
172 | 		g.WithDataTypeMap(typeMapping)
173 | 	}
174 | 	g.UseDB(db)
175 | 	g.GenGenGo = gg.GenGenGo
176 | 	var models []interface{}
177 | 	if stringutils.IsNotEmpty(gg.TableGlob) {
178 | 		g.FilterTableGlob = glob.MustCompile(gg.TableGlob)
179 | 	}
180 | 	if stringutils.IsNotEmpty(gg.TableExcludeGlob) {
181 | 		g.ExcludeTableGlob = glob.MustCompile(gg.TableExcludeGlob)
182 | 	}
183 | 
184 | 	if stringutils.IsEmpty(gg.TableGlob) && stringutils.IsEmpty(gg.TableExcludeGlob) {
185 | 		models = g.GenerateAllTable(
186 | 			gormgen.FieldType(conf.Soft, "gorm.DeletedAt"),
187 | 			gormgen.FieldGenType(conf.Soft, "Time"),
188 | 		)
189 | 	} else {
190 | 		models = g.GenerateFilteredTables(
191 | 			gormgen.FieldType(conf.Soft, "gorm.DeletedAt"),
192 | 			gormgen.FieldGenType(conf.Soft, "Time"))
193 | 	}
194 | 	g.ApplyBasic(models...)
195 | 	g.ConfigPackage = astutils.GetPkgPath(filepath.Join(gg.Dir, "config"))
196 | 	gg.g = g
197 | }
```

cmd/internal/svc/codegen/database/gorm_test.go
```
1 | package database
2 | 
3 | import (
4 | 	"os"
5 | 	"testing"
6 | )
7 | 
8 | func TestInitialize(t *testing.T) {
9 | 	dir := "testdata/testpg"
10 | 	defer os.RemoveAll(dir)
11 | 	gen := GetOrmGenerator("gorm")
12 | 	gen.Initialize(OrmGeneratorConfig{
13 | 		Driver:      "postgres",
14 | 		Dsn:         "host=localhost user=corteza password=corteza dbname=postgres port=5432 sslmode=disable TimeZone=Asia/Shanghai",
15 | 		TablePrefix: "tutorial",
16 | 		Dir:         dir,
17 | 	})
18 | 	gen.GenGrpc()
19 | }
```

cmd/internal/svc/testdata/change/change.go
```
1 | test
```

cmd/testdata/testsvc/transport/httpsrv/handler.go
```
1 | /**
2 | * Generated by go-doudou v1.3.8.
3 | * Don't edit!
4 |  */
5 | package httpsrv
6 | 
7 | import (
8 | 	"net/http"
9 | 
10 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
11 | )
12 | 
13 | type TestsvcHandler interface {
14 | 	PageUsers(w http.ResponseWriter, r *http.Request)
15 | }
16 | 
17 | func Routes(handler TestsvcHandler) []rest.Route {
18 | 	return []rest.Route{
19 | 		{
20 | 			Name:        "PageUsers",
21 | 			Method:      "POST",
22 | 			Pattern:     "/page/users",
23 | 			HandlerFunc: handler.PageUsers,
24 | 		},
25 | 	}
26 | }
27 | 
28 | var RouteAnnotationStore = rest.AnnotationStore{}
```

cmd/testdata/testsvc/transport/httpsrv/handlerimpl.go
```
1 | package httpsrv
2 | 
3 | import (
4 | 	"context"
5 | 	"net/http"
6 | 	service "testsvc"
7 | 	"testsvc/vo"
8 | 
9 | 	"encoding/json"
10 | 
11 | 	"github.com/pkg/errors"
12 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
13 | )
14 | 
15 | type TestsvcHandlerImpl struct {
16 | 	testsvc service.Testsvc
17 | }
18 | 
19 | func (receiver *TestsvcHandlerImpl) PageUsers(_writer http.ResponseWriter, _req *http.Request) {
20 | 	var (
21 | 		ctx   context.Context
22 | 		query vo.PageQuery
23 | 		code  int
24 | 		data  vo.PageRet
25 | 		err   error
26 | 	)
27 | 	ctx = _req.Context()
28 | 	if _req.Body == nil {
29 | 		http.Error(_writer, "missing request body", http.StatusBadRequest)
30 | 		return
31 | 	} else {
32 | 		if _err := json.NewDecoder(_req.Body).Decode(&query); _err != nil {
33 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
34 | 			return
35 | 		} else {
36 | 			if _err := rest.ValidateStruct(query); _err != nil {
37 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
38 | 				return
39 | 			}
40 | 		}
41 | 	}
42 | 	code, data, err = receiver.testsvc.PageUsers(
43 | 		ctx,
44 | 		query,
45 | 	)
46 | 	if err != nil {
47 | 		if errors.Is(err, context.Canceled) {
48 | 			http.Error(_writer, err.Error(), http.StatusBadRequest)
49 | 		} else if _err, ok := err.(*rest.BizError); ok {
50 | 			http.Error(_writer, _err.Error(), _err.StatusCode)
51 | 		} else {
52 | 			http.Error(_writer, err.Error(), http.StatusInternalServerError)
53 | 		}
54 | 		return
55 | 	}
56 | 	if _err := json.NewEncoder(_writer).Encode(struct {
57 | 		Code int        `json:"code,omitempty"`
58 | 		Data vo.PageRet `json:"data,omitempty"`
59 | 	}{
60 | 		Code: code,
61 | 		Data: data,
62 | 	}); _err != nil {
63 | 		http.Error(_writer, _err.Error(), http.StatusInternalServerError)
64 | 		return
65 | 	}
66 | }
67 | 
68 | func NewTestsvcHandler(testsvc service.Testsvc) TestsvcHandler {
69 | 	return &TestsvcHandlerImpl{
70 | 		testsvc,
71 | 	}
72 | }
```

cmd/testdata/testsvc/transport/httpsrv/middleware.go
```
1 | package httpsrv
```

cmd/internal/svc/testdata/checkIc2/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"mime/multipart"
6 | 
7 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
8 | )
9 | 
10 | // 用户服务接口
11 | // v1版本
12 | type Usersvc interface {
13 | 	// comment4
14 | 	UploadAvatar(context.Context, *multipart.FileHeader, v3.FileModel, string, []*multipart.FileHeader, []*multipart.FileHeader) (int, string, error)
15 | }
```

cmd/internal/svc/codegen/testdata/corpus_deployment.yaml
```
1 | apiVersion: apps/v1
2 | kind: Deployment
3 | metadata:
4 |   name: corpus-deployment
5 | spec:
6 |   replicas: 1
7 |   selector:
8 |     matchLabels:
9 |       app: corpus
10 |   template:
11 |     metadata:
12 |       labels:
13 |         app: corpus
14 |     spec:
15 |       containers:
16 |       - image: google.com/corpus:v2.0.0
17 |         imagePullPolicy: Always
18 |         name: corpus
19 |         ports:
20 |         - containerPort: 6060
21 |           name: http-port
22 |           protocol: TCP
23 |         resources:
24 |           requests:
25 |             cpu: 100m
26 |             memory: 128Mi
27 |       restartPolicy: Always
28 | ---
29 | apiVersion: v1
30 | kind: Service
31 | metadata:
32 |   name: corpus-service
33 | spec:
34 |   type: LoadBalancer
35 |   externalTrafficPolicy: Cluster
36 |   selector:
37 |     app: corpus
38 |   ports:
39 |     - protocol: TCP
40 |       port: 6060
41 |       targetPort: 6060
```

cmd/internal/svc/codegen/testdata/corpus_statefulset.yaml
```
1 | apiVersion: apps/v1
2 | kind: StatefulSet
3 | metadata:
4 |   name: corpus-statefulset
5 | spec:
6 |   replicas: 1
7 |   selector:
8 |     matchLabels:
9 |       app: corpus
10 |   serviceName: corpus-svc-headless
11 |   template:
12 |     metadata:
13 |       labels:
14 |         app: corpus
15 |     spec:
16 |       containers:
17 |       - image: google.com/corpus:v2.0.0
18 |         imagePullPolicy: Always
19 |         name: corpus
20 |         ports:
21 |         - containerPort: 6060
22 |           name: http-port
23 |           protocol: TCP
24 |         resources:
25 |           requests:
26 |             cpu: 100m
27 |             memory: 128Mi
28 |       restartPolicy: Always
29 |       terminationGracePeriodSeconds: 10
30 | ---
31 | apiVersion: v1
32 | kind: Service
33 | metadata:
34 |   name: corpus-svc-headless
35 | spec:
36 |   selector:
37 |     app: corpus
38 |   ports:
39 |     - protocol: TCP
40 |       port: 6060
41 |       targetPort: 6060
42 |   clusterIP: None
```

cmd/internal/svc/codegen/testdata/go.mod
```
1 | module testdata
2 | 
3 | go 1.18
```

cmd/internal/svc/codegen/testdata/k8s.yaml
```
1 | apiVersion: apps/v1
2 | kind: Deployment
3 | metadata:
4 |   name: corpus-deployment
5 | spec:
6 |   replicas: 1
7 |   selector:
8 |     matchLabels:
9 |       app: corpus
10 |   template:
11 |     metadata:
12 |       labels:
13 |         app: corpus
14 |     spec:
15 |       containers:
16 |         - name: corpus
17 |           image: corpus:latest
18 |           imagePullPolicy: Always
19 |           ports:
20 |             - name: http-port
21 |               containerPort: 6060
22 |               protocol: TCP
23 |           resources:
24 |             requests:
25 |               cpu: 100m
26 |               memory: 128Mi
27 |       restartPolicy: Always
28 | ---
29 | apiVersion: v1
30 | kind: Service
31 | metadata:
32 |   name: corpus-service
33 | spec:
34 |   type: LoadBalancer
35 |   externalTrafficPolicy: Cluster
36 |   selector:
37 |     app: corpus
38 |   ports:
39 |     - protocol: TCP
40 |       port: 6060
41 |       targetPort: 6060
```

cmd/internal/svc/codegen/testdata/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"mime/multipart"
6 | 	"os"
7 | 	"testdata/vo"
8 | 
9 | 	"github.com/shopspring/decimal"
10 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
11 | )
12 | 
13 | // 用户服务接口
14 | // v1版本
15 | type Usersvc interface {
16 | 	// You can define your service methods as your need. Below is an example.@role(user)
17 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, msg error)
18 | 
19 | 	// comment1
20 | 	// comment2
21 | 	// @role(admin)
22 | 	GetUser(ctx context.Context,
23 | 		// 用户ID
24 | 		userId,
25 | 		// 图片地址
26 | 		photo string,
27 | 	) (code int, data string, msg error)
28 | 
29 | 	// comment3
30 | 	// @permission(create,update)@role(admin)
31 | 	SignUp(ctx context.Context, username string, password int, actived bool, score []int) (code int, data string, msg error)
32 | 
33 | 	// comment4
34 | 	// @role(user)
35 | 	UploadAvatar(context.Context, []v3.FileModel, string, v3.FileModel, *multipart.FileHeader, []*multipart.FileHeader) (int, interface{}, error)
36 | 
37 | 	// comment5
38 | 	DownloadAvatar(ctx context.Context, userId interface{}, data []byte, price decimal.Decimal, userAttrs ...string) (*os.File, error)
39 | 
40 | 	GetQuery_range(ctx context.Context) error
41 | 	GetShelves_ShelfBooks_Book(ctx context.Context) error
42 | }
```

cmd/internal/svc/codegen/testdata/svcimpl.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"mime/multipart"
6 | 	"os"
7 | 	"testdata/config"
8 | 	"testdata/vo"
9 | 
10 | 	"github.com/brianvoe/gofakeit/v6"
11 | 	"github.com/jmoiron/sqlx"
12 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
13 | )
14 | 
15 | type UsersvcImpl struct {
16 | 	conf *config.Config
17 | }
18 | 
19 | func (receiver *UsersvcImpl) PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, msg error) {
20 | 	var _result struct {
21 | 		Code int
22 | 		Data vo.PageRet
23 | 	}
24 | 	_ = gofakeit.Struct(&_result)
25 | 	return _result.Code, _result.Data, nil
26 | }
27 | func (receiver *UsersvcImpl) GetUser(ctx context.Context, userId string, photo string) (code int, data string, msg error) {
28 | 	var _result struct {
29 | 		Code int
30 | 		Data string
31 | 	}
32 | 	_ = gofakeit.Struct(&_result)
33 | 	return _result.Code, _result.Data, nil
34 | }
35 | func (receiver *UsersvcImpl) SignUp(ctx context.Context, username string, password int, actived bool, score []int) (code int, data string, msg error) {
36 | 	var _result struct {
37 | 		Code int
38 | 		Data string
39 | 	}
40 | 	_ = gofakeit.Struct(&_result)
41 | 	return _result.Code, _result.Data, nil
42 | }
43 | func (receiver *UsersvcImpl) UploadAvatar(pc context.Context, pf []v3.FileModel, ps string, pf2 v3.FileModel, pf3 *multipart.FileHeader, pf4 []*multipart.FileHeader) (ri int, rs string, re error) {
44 | 	var _result struct {
45 | 		Ri int
46 | 		Rs string
47 | 	}
48 | 	_ = gofakeit.Struct(&_result)
49 | 	return _result.Ri, _result.Rs, nil
50 | }
51 | func (receiver *UsersvcImpl) DownloadAvatar(ctx context.Context, userId string, userAttrs ...string) (rf *os.File, re error) {
52 | 	var _result struct {
53 | 		Rf *os.File
54 | 	}
55 | 	_ = gofakeit.Struct(&_result)
56 | 	return _result.Rf, nil
57 | }
58 | 
59 | func NewUsersvc(conf *config.Config, db *sqlx.DB) Usersvc {
60 | 	return &UsersvcImpl{
61 | 		conf,
62 | 	}
63 | }
```

cmd/internal/svc/codegen/testdata/svcp.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"os"
6 | 	"testdata/vo"
7 | 
8 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
9 | )
10 | 
11 | // 用户服务接口
12 | // v1版本
13 | type UsersvcPanic interface {
14 | 	// You can define your service methods as your need. Below is an example.
15 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, msg error)
16 | 
17 | 	// comment1
18 | 	// comment2
19 | 	GetUser(ctx context.Context,
20 | 		// 用户ID
21 | 		userId string,
22 | 		// 图片地址
23 | 		photo string,
24 | 	) (code int, data string, msg error)
25 | 
26 | 	// comment3
27 | 	SignUp(ctx context.Context, username string, password int, actived bool, score float64) (code int, data string, msg error)
28 | 
29 | 	// comment4
30 | 	UploadAvatar(context.Context, []v3.FileModel, string) (int, string, error)
31 | 
32 | 	// comment5
33 | 	DownloadAvatar(ctx context.Context, userId string) (*os.File, error)
34 | 
35 | 	// Wrong1
36 | 	Wrong1(ctx context.Context, userId string, query vo.PageQuery, files []v3.FileModel) (*os.File, error)
37 | 
38 | 	// Wrong2
39 | 	Wrong2(ctx context.Context, ch chan string) (*os.File, error)
40 | 
41 | 	// Wrong3
42 | 	Wrong3(ctx context.Context, fun func()) (*os.File, error)
43 | }
```

cmd/internal/svc/codegen/testdata/testcode.postman_collection.json
```
1 | {
2 | 	"info": {
3 | 		"_postman_id": "b28926a8-ace1-437e-9d82-ab61b390d1c1",
4 | 		"name": "TestCode",
5 | 		"description": "测试集成测试代码生成",
6 | 		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
7 | 	},
8 | 	"item": [
9 | 		{
10 | 			"name": "user",
11 | 			"item": [
12 | 				{
13 | 					"name": "/user/1234",
14 | 					"request": {
15 | 						"method": "GET",
16 | 						"header": [
17 | 							{
18 | 								"key": "Accept",
19 | 								"value": "application/json"
20 | 							}
21 | 						],
22 | 						"url": {
23 | 							"raw": "{{baseUrl}}/user/1234?userId=2863467",
24 | 							"host": [
25 | 								"{{baseUrl}}"
26 | 							],
27 | 							"path": [
28 | 								"user",
29 | 								"1234"
30 | 							],
31 | 							"query": [
32 | 								{
33 | 									"key": "userId",
34 | 									"value": "2863467"
35 | 								},
36 | 								{
37 | 									"key": "ipAddr",
38 | 									"value": "consequat in minim culpa",
39 | 									"disabled": true
40 | 								}
41 | 							]
42 | 						},
43 | 						"description": "测试集成测试代码生成"
44 | 					},
45 | 					"response": [
46 | 						{
47 | 							"name": "测试1",
48 | 							"originalRequest": {
49 | 								"method": "GET",
50 | 								"header": [
51 | 									{
52 | 										"key": "Accept",
53 | 										"value": "application/json"
54 | 									}
55 | 								],
56 | 								"url": {
57 | 									"raw": "{{baseUrl}}/user/1234?userId=2621936",
58 | 									"host": [
59 | 										"{{baseUrl}}"
60 | 									],
61 |                                     "path": [
62 |                                       "user",
63 |                                       "1234"
64 |                                     ],
65 | 									"query": [
66 | 										{
67 | 											"key": "userId",
68 | 											"value": "2621936"
69 | 										},
70 | 										{
71 | 											"key": "ipAddr",
72 | 											"value": "consequat in minim culpa",
73 | 											"disabled": true
74 | 										}
75 | 									]
76 | 								}
77 | 							},
78 | 							"status": "OK",
79 | 							"code": 200,
80 | 							"_postman_previewlanguage": "json",
81 | 							"header": [
82 | 								{
83 | 									"key": "Content-Type",
84 | 									"value": "application/json; charset=UTF-8"
85 | 								},
86 | 								{
87 | 									"key": "Date",
88 | 									"value": "Sat, 30 Jul 2022 15:38:32 GMT"
89 | 								},
90 | 								{
91 | 									"key": "Content-Length",
92 | 									"value": "54"
93 | 								}
94 | 							],
95 | 							"cookie": [],
96 | 							"body": "{\n    \"data\": {\n        \"prizePool\": [\n            1,\n            1,\n            36,\n            1,\n            1,\n            11,\n            1,\n            23\n        ],\n        \"prize\": 1\n    }\n}"
97 | 						},
98 | 						{
99 | 							"name": "测试2",
100 | 							"originalRequest": {
101 | 								"method": "GET",
102 | 								"header": [
103 | 									{
104 | 										"key": "Accept",
105 | 										"value": "application/json"
106 | 									}
107 | 								],
108 | 								"url": {
109 | 									"raw": "{{baseUrl}}/user/1234?userId=2863467",
110 | 									"host": [
111 | 										"{{baseUrl}}"
112 | 									],
113 |                                     "path": [
114 |                                       "user",
115 |                                       "1234"
116 |                                     ],
117 | 									"query": [
118 | 										{
119 | 											"key": "userId",
120 | 											"value": "2863467"
121 | 										},
122 | 										{
123 | 											"key": "ipAddr",
124 | 											"value": "consequat in minim culpa",
125 | 											"disabled": true
126 | 										}
127 | 									]
128 | 								}
129 | 							},
130 | 							"status": "OK",
131 | 							"code": 200,
132 | 							"_postman_previewlanguage": "json",
133 | 							"header": [
134 | 								{
135 | 									"key": "Content-Encoding",
136 | 									"value": "gzip"
137 | 								},
138 | 								{
139 | 									"key": "Content-Type",
140 | 									"value": "application/json; charset=UTF-8"
141 | 								},
142 | 								{
143 | 									"key": "Vary",
144 | 									"value": "Accept-Encoding"
145 | 								},
146 | 								{
147 | 									"key": "Date",
148 | 									"value": "Sat, 30 Jul 2022 15:40:55 GMT"
149 | 								},
150 | 								{
151 | 									"key": "Content-Length",
152 | 									"value": "71"
153 | 								}
154 | 							],
155 | 							"cookie": [],
156 | 							"body": "{\n    \"data\": {\n        \"prizePool\": [\n            1,\n            1,\n            62,\n            1,\n            65,\n            63,\n            1,\n            61\n        ],\n        \"prize\": 65\n    }\n}"
157 | 						}
158 | 					]
159 | 				}
160 | 			]
161 | 		},
162 | 		{
163 | 			"name": "/algo/percent",
164 | 			"request": {
165 | 				"method": "POST",
166 | 				"header": [
167 | 					{
168 | 						"key": "Content-Type",
169 | 						"value": "application/json"
170 | 					},
171 | 					{
172 | 						"key": "Accept",
173 | 						"value": "application/json"
174 | 					}
175 | 				],
176 | 				"body": {
177 | 					"mode": "raw",
178 | 					"raw": "{\n    \"data\": [\n        {\n            \"value\": 10,\n            \"key\": \"a\"\n        },\n        {\n            \"value\": 12,\n            \"key\": \"b\"\n        },\n        {\n            \"value\": 7,\n            \"key\": \"c\"\n        }\n    ],\n    \"places\": 0\n}",
179 | 					"options": {
180 | 						"raw": {
181 | 							"language": "json"
182 | 						}
183 | 					}
184 | 				},
185 | 				"url": {
186 | 					"raw": "{{baseUrl}}/algo/percent",
187 | 					"host": [
188 | 						"{{baseUrl}}"
189 | 					],
190 | 					"path": [
191 | 						"algo",
192 | 						"percent"
193 | 					]
194 | 				},
195 | 				"description": "测试集成测试代码生成"
196 | 			},
197 | 			"response": [
198 | 				{
199 | 					"name": "/algo/percent",
200 | 					"originalRequest": {
201 | 						"method": "POST",
202 | 						"header": [
203 | 							{
204 | 								"key": "Content-Type",
205 | 								"value": "application/json"
206 | 							},
207 | 							{
208 | 								"key": "Accept",
209 | 								"value": "application/json"
210 | 							}
211 | 						],
212 | 						"body": {
213 | 							"mode": "raw",
214 | 							"raw": "{\n    \"data\": [\n        {\n            \"value\": 10,\n            \"key\": \"a\"\n        },\n        {\n            \"value\": 12,\n            \"key\": \"b\"\n        },\n        {\n            \"value\": 7,\n            \"key\": \"c\"\n        }\n    ],\n    \"places\": 0\n}",
215 | 							"options": {
216 | 								"raw": {
217 | 									"language": "json"
218 | 								}
219 | 							}
220 | 						},
221 | 						"url": {
222 | 							"raw": "{{baseUrl}}/algo/percent",
223 | 							"host": [
224 | 								"{{baseUrl}}"
225 | 							],
226 | 							"path": [
227 | 								"algo",
228 | 								"percent"
229 | 							]
230 | 						}
231 | 					},
232 | 					"status": "OK",
233 | 					"code": 200,
234 | 					"_postman_previewlanguage": "json",
235 | 					"header": [
236 | 						{
237 | 							"key": "Content-Type",
238 | 							"value": "application/json; charset=UTF-8"
239 | 						},
240 | 						{
241 | 							"key": "Date",
242 | 							"value": "Sun, 31 Jul 2022 13:48:00 GMT"
243 | 						},
244 | 						{
245 | 							"key": "Content-Length",
246 | 							"value": "193"
247 | 						}
248 | 					],
249 | 					"cookie": [],
250 | 					"body": "{\n    \"data\": [\n        {\n            \"value\": 10,\n            \"key\": \"a\",\n            \"percent\": 34,\n            \"percentFormatted\": \"34%\"\n        },\n        {\n            \"value\": 12,\n            \"key\": \"b\",\n            \"percent\": 42,\n            \"percentFormatted\": \"42%\"\n        },\n        {\n            \"value\": 7,\n            \"key\": \"c\",\n            \"percent\": 24,\n            \"percentFormatted\": \"24%\"\n        }\n    ]\n}"
251 | 				}
252 | 			]
253 | 		}
254 | 	],
255 | 	"event": [
256 | 		{
257 | 			"listen": "prerequest",
258 | 			"script": {
259 | 				"type": "text/javascript",
260 | 				"exec": [
261 | 					""
262 | 				]
263 | 			}
264 | 		},
265 | 		{
266 | 			"listen": "test",
267 | 			"script": {
268 | 				"type": "text/javascript",
269 | 				"exec": [
270 | 					""
271 | 				]
272 | 			}
273 | 		}
274 | 	],
275 | 	"variable": [
276 | 		{
277 | 			"key": "baseUrl",
278 | 			"value": "http://localhost:11000",
279 | 			"type": "string",
280 | 			"disabled": true
281 | 		}
282 | 	]
283 | }
```

cmd/internal/svc/codegen/testdata/usersvc_openapi3.go
```
1 | package service
2 | 
3 | import "github.com/unionj-cloud/go-doudou/v2/framework/rest"
4 | 
5 | func init() {
6 | 	rest.Oas = `{"openapi":"3.0.2","info":{"title":"Usersvc","description":"用户服务接口\nv1版本","version":"v20230117"},"servers":[{"url":"http://localhost:6060"}],"paths":{"/usersvc/downloadavatar":{"post":{"description":"comment5","parameters":[{"name":"data","in":"query","required":true,"schema":{"type":"string"}},{"name":"price","in":"query","required":true,"schema":{"type":"string","format":"decimal"}},{"name":"userAttrs","in":"query","schema":{"type":"array","items":{"type":"string"}}}],"requestBody":{"content":{"application/json":{"schema":{"type":"object"}}},"required":true},"responses":{"200":{"description":"","content":{"application/octet-stream":{"schema":{"type":"string","format":"binary"}}}}}}},"/usersvc/pageusers":{"post":{"description":"You can define your service methods as your need. Below is an example.@role(user)","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageQuery"}}},"required":true},"responses":{"200":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageUsersResp"}}}}}}},"/usersvc/signup":{"post":{"description":"comment3\n@permission(create,update)@role(admin)","requestBody":{"content":{"application/x-www-form-urlencoded":{"schema":{"$ref":"#/components/schemas/SignUpReq"}}},"required":true},"responses":{"200":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/SignUpResp"}}}}}}},"/usersvc/uploadavatar":{"post":{"description":"comment4\n@role(user)","requestBody":{"content":{"multipart/form-data":{"schema":{"$ref":"#/components/schemas/UploadAvatarReq"}}},"required":true},"responses":{"200":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UploadAvatarResp"}}}}}}},"/usersvc/user":{"get":{"description":"comment1\ncomment2\n@role(admin)","parameters":[{"name":"userId","in":"query","description":"用户ID","required":true,"schema":{"type":"string","description":"用户ID"}},{"name":"photo","in":"query","description":"图片地址","required":true,"schema":{"type":"string","description":"图片地址"}}],"responses":{"200":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/GetUserResp"}}}}}}}},"components":{"schemas":{"Event":{"title":"Event","type":"object","properties":{"EventType":{"type":"integer","format":"int32"},"Name":{"type":"string"}},"required":["Name","EventType"]},"GetUserResp":{"title":"GetUserResp","type":"object","properties":{"code":{"type":"integer","format":"int32"},"data":{"type":"string"}},"required":["code","data"]},"Keyboard":{"title":"Keyboard","type":"object","properties":{"backlit":{"type":"boolean"},"layout":{"type":"string","default":"UNKNOWN","enum":["UNKNOWN","QWERTZ","AZERTY","QWERTY"]}},"required":["layout","backlit"]},"Order":{"title":"Order","type":"object","properties":{"Col":{"type":"string"},"Sort":{"type":"string"}},"description":"排序条件","required":["Col","Sort"]},"Page":{"title":"Page","type":"object","properties":{"Orders":{"type":"array","items":{"$ref":"#/components/schemas/Order"},"description":"排序规则"},"PageNo":{"type":"integer","format":"int32","description":"页码"},"Size":{"type":"integer","format":"int32","description":"每页行数"},"User":{"$ref":"#/components/schemas/UserVo"}},"required":["Orders","PageNo","Size","User"]},"PageFilter":{"title":"PageFilter","type":"object","properties":{"Dept":{"type":"integer","format":"int32","description":"所属部门ID"},"Name":{"type":"string","description":"真实姓名，前缀匹配"}},"description":"筛选条件","required":["Name","Dept"]},"PageQuery":{"title":"PageQuery","type":"object","properties":{"Filter":{"$ref":"#/components/schemas/PageFilter"},"Page":{"$ref":"#/components/schemas/Page"}},"description":"\n分页筛选条件","required":["Filter","Page"]},"PageRet":{"title":"PageRet","type":"object","properties":{"HasNext":{"type":"boolean"},"Items":{"type":"object"},"PageNo":{"type":"integer","format":"int32"},"PageSize":{"type":"integer","format":"int32"},"Price":{"type":"string","format":"decimal"},"Total":{"type":"integer","format":"int32"}},"description":"\n","required":["Items","PageNo","PageSize","Total","HasNext","Price"]},"PageUsersResp":{"title":"PageUsersResp","type":"object","properties":{"code":{"type":"integer","format":"int32"},"data":{"$ref":"#/components/schemas/PageRet"}},"required":["code","data"]},"SignUpReq":{"title":"SignUpReq","type":"object","properties":{"actived":{"type":"boolean"},"password":{"type":"integer","format":"int32"},"score":{"type":"array","items":{"type":"integer","format":"int32"}},"username":{"type":"string"}},"required":["username","password","actived","score"]},"SignUpResp":{"title":"SignUpResp","type":"object","properties":{"code":{"type":"integer","format":"int32"},"data":{"type":"string"}},"required":["code","data"]},"TestAlias":{"title":"TestAlias","type":"object","properties":{"Age":{"type":"object"},"School":{"type":"array","items":{"type":"object","properties":{"Addr":{"type":"object","properties":{"Block":{"type":"string"},"Full":{"type":"string"},"Zip":{"type":"string"}},"required":["Zip","Block","Full"]},"Name":{"type":"string"}},"required":["Name","Addr"]}}},"required":["Age","School"]},"TestExprStringP":{"title":"TestExprStringP","type":"object","properties":{"Age":{"type":"object"},"Data":{"type":"object","additionalProperties":{"type":"string"},"x-map-type":"map[string]string"},"Hobbies":{"type":"array","items":{"type":"string"}},"School":{"type":"array","items":{"type":"object","properties":{"Addr":{"type":"object","properties":{"Block":{"type":"string"},"Full":{"type":"string"},"Zip":{"type":"string"}},"required":["Zip","Block","Full"]},"Name":{"type":"string"}},"required":["Name","Addr"]}}},"required":["Age","Hobbies","Data","School"]},"UploadAvatarReq":{"title":"UploadAvatarReq","type":"object","properties":{"pf":{"type":"array","items":{"type":"string","format":"binary"}},"pf2":{"type":"string","format":"binary"},"pf3":{"type":"string","format":"binary"},"pf4":{"type":"array","items":{"type":"string","format":"binary"}},"ps":{"type":"string"}},"required":["pf","ps","pf2","pf4"]},"UploadAvatarResp":{"title":"UploadAvatarResp","type":"object","properties":{"ri":{"type":"integer","format":"int32"},"ri2":{"type":"object"}},"required":["ri","ri2"]},"UserVo":{"title":"UserVo","type":"object","properties":{"Dept":{"type":"string"},"Id":{"type":"integer","format":"int32"},"Name":{"type":"string"},"Phone":{"type":"string"}},"required":["Id","Name","Phone","Dept"]}}}}`
7 | }
```

cmd/internal/svc/codegen/testdata/usersvc_openapi3.json
```
1 | {
2 |   "openapi": "3.0.2",
3 |   "info": {
4 |     "title": "Usersvc",
5 |     "description": "用户服务接口\nv1版本",
6 |     "version": "v20230117"
7 |   },
8 |   "servers": [
9 |     {
10 |       "url": "http://localhost:6060"
11 |     }
12 |   ],
13 |   "paths": {
14 |     "/usersvc/downloadavatar": {
15 |       "post": {
16 |         "description": "comment5",
17 |         "parameters": [
18 |           {
19 |             "name": "data",
20 |             "in": "query",
21 |             "required": true,
22 |             "schema": {
23 |               "type": "string"
24 |             }
25 |           },
26 |           {
27 |             "name": "price",
28 |             "in": "query",
29 |             "required": true,
30 |             "schema": {
31 |               "type": "string",
32 |               "format": "decimal"
33 |             }
34 |           },
35 |           {
36 |             "name": "userAttrs",
37 |             "in": "query",
38 |             "schema": {
39 |               "type": "array",
40 |               "items": {
41 |                 "type": "string"
42 |               }
43 |             }
44 |           }
45 |         ],
46 |         "requestBody": {
47 |           "content": {
48 |             "application/json": {
49 |               "schema": {
50 |                 "type": "object"
51 |               }
52 |             }
53 |           },
54 |           "required": true
55 |         },
56 |         "responses": {
57 |           "200": {
58 |             "description": "",
59 |             "content": {
60 |               "application/octet-stream": {
61 |                 "schema": {
62 |                   "type": "string",
63 |                   "format": "binary"
64 |                 }
65 |               }
66 |             }
67 |           }
68 |         }
69 |       }
70 |     },
71 |     "/usersvc/pageusers": {
72 |       "post": {
73 |         "description": "You can define your service methods as your need. Below is an example.@role(user)",
74 |         "requestBody": {
75 |           "content": {
76 |             "application/json": {
77 |               "schema": {
78 |                 "$ref": "#/components/schemas/PageQuery"
79 |               }
80 |             }
81 |           },
82 |           "required": true
83 |         },
84 |         "responses": {
85 |           "200": {
86 |             "description": "",
87 |             "content": {
88 |               "application/json": {
89 |                 "schema": {
90 |                   "$ref": "#/components/schemas/PageUsersResp"
91 |                 }
92 |               }
93 |             }
94 |           }
95 |         }
96 |       }
97 |     },
98 |     "/usersvc/signup": {
99 |       "post": {
100 |         "description": "comment3\n@permission(create,update)@role(admin)",
101 |         "requestBody": {
102 |           "content": {
103 |             "application/x-www-form-urlencoded": {
104 |               "schema": {
105 |                 "$ref": "#/components/schemas/SignUpReq"
106 |               }
107 |             }
108 |           },
109 |           "required": true
110 |         },
111 |         "responses": {
112 |           "200": {
113 |             "description": "",
114 |             "content": {
115 |               "application/json": {
116 |                 "schema": {
117 |                   "$ref": "#/components/schemas/SignUpResp"
118 |                 }
119 |               }
120 |             }
121 |           }
122 |         }
123 |       }
124 |     },
125 |     "/usersvc/uploadavatar": {
126 |       "post": {
127 |         "description": "comment4\n@role(user)",
128 |         "requestBody": {
129 |           "content": {
130 |             "multipart/form-data": {
131 |               "schema": {
132 |                 "$ref": "#/components/schemas/UploadAvatarReq"
133 |               }
134 |             }
135 |           },
136 |           "required": true
137 |         },
138 |         "responses": {
139 |           "200": {
140 |             "description": "",
141 |             "content": {
142 |               "application/json": {
143 |                 "schema": {
144 |                   "$ref": "#/components/schemas/UploadAvatarResp"
145 |                 }
146 |               }
147 |             }
148 |           }
149 |         }
150 |       }
151 |     },
152 |     "/usersvc/user": {
153 |       "get": {
154 |         "description": "comment1\ncomment2\n@role(admin)",
155 |         "parameters": [
156 |           {
157 |             "name": "userId",
158 |             "in": "query",
159 |             "description": "用户ID",
160 |             "required": true,
161 |             "schema": {
162 |               "type": "string",
163 |               "description": "用户ID"
164 |             }
165 |           },
166 |           {
167 |             "name": "photo",
168 |             "in": "query",
169 |             "description": "图片地址",
170 |             "required": true,
171 |             "schema": {
172 |               "type": "string",
173 |               "description": "图片地址"
174 |             }
175 |           }
176 |         ],
177 |         "responses": {
178 |           "200": {
179 |             "description": "",
180 |             "content": {
181 |               "application/json": {
182 |                 "schema": {
183 |                   "$ref": "#/components/schemas/GetUserResp"
184 |                 }
185 |               }
186 |             }
187 |           }
188 |         }
189 |       }
190 |     }
191 |   },
192 |   "components": {
193 |     "schemas": {
194 |       "Event": {
195 |         "title": "Event",
196 |         "type": "object",
197 |         "properties": {
198 |           "EventType": {
199 |             "type": "integer",
200 |             "format": "int32"
201 |           },
202 |           "Name": {
203 |             "type": "string"
204 |           }
205 |         },
206 |         "required": [
207 |           "Name",
208 |           "EventType"
209 |         ]
210 |       },
211 |       "GetUserResp": {
212 |         "title": "GetUserResp",
213 |         "type": "object",
214 |         "properties": {
215 |           "code": {
216 |             "type": "integer",
217 |             "format": "int32"
218 |           },
219 |           "data": {
220 |             "type": "string"
221 |           }
222 |         },
223 |         "required": [
224 |           "code",
225 |           "data"
226 |         ]
227 |       },
228 |       "Keyboard": {
229 |         "title": "Keyboard",
230 |         "type": "object",
231 |         "properties": {
232 |           "backlit": {
233 |             "type": "boolean"
234 |           },
235 |           "layout": {
236 |             "type": "string",
237 |             "default": "UNKNOWN",
238 |             "enum": [
239 |               "UNKNOWN",
240 |               "QWERTZ",
241 |               "AZERTY",
242 |               "QWERTY"
243 |             ]
244 |           }
245 |         },
246 |         "required": [
247 |           "layout",
248 |           "backlit"
249 |         ]
250 |       },
251 |       "Order": {
252 |         "title": "Order",
253 |         "type": "object",
254 |         "properties": {
255 |           "Col": {
256 |             "type": "string"
257 |           },
258 |           "Sort": {
259 |             "type": "string"
260 |           }
261 |         },
262 |         "description": "排序条件",
263 |         "required": [
264 |           "Col",
265 |           "Sort"
266 |         ]
267 |       },
268 |       "Page": {
269 |         "title": "Page",
270 |         "type": "object",
271 |         "properties": {
272 |           "Orders": {
273 |             "type": "array",
274 |             "items": {
275 |               "$ref": "#/components/schemas/Order"
276 |             },
277 |             "description": "排序规则"
278 |           },
279 |           "PageNo": {
280 |             "type": "integer",
281 |             "format": "int32",
282 |             "description": "页码"
283 |           },
284 |           "Size": {
285 |             "type": "integer",
286 |             "format": "int32",
287 |             "description": "每页行数"
288 |           },
289 |           "User": {
290 |             "$ref": "#/components/schemas/UserVo"
291 |           }
292 |         },
293 |         "required": [
294 |           "Orders",
295 |           "PageNo",
296 |           "Size",
297 |           "User"
298 |         ]
299 |       },
300 |       "PageFilter": {
301 |         "title": "PageFilter",
302 |         "type": "object",
303 |         "properties": {
304 |           "Dept": {
305 |             "type": "integer",
306 |             "format": "int32",
307 |             "description": "所属部门ID"
308 |           },
309 |           "Name": {
310 |             "type": "string",
311 |             "description": "真实姓名，前缀匹配"
312 |           }
313 |         },
314 |         "description": "筛选条件",
315 |         "required": [
316 |           "Name",
317 |           "Dept"
318 |         ]
319 |       },
320 |       "PageQuery": {
321 |         "title": "PageQuery",
322 |         "type": "object",
323 |         "properties": {
324 |           "Filter": {
325 |             "$ref": "#/components/schemas/PageFilter"
326 |           },
327 |           "Page": {
328 |             "$ref": "#/components/schemas/Page"
329 |           }
330 |         },
331 |         "description": "\n分页筛选条件",
332 |         "required": [
333 |           "Filter",
334 |           "Page"
335 |         ]
336 |       },
337 |       "PageRet": {
338 |         "title": "PageRet",
339 |         "type": "object",
340 |         "properties": {
341 |           "HasNext": {
342 |             "type": "boolean"
343 |           },
344 |           "Items": {
345 |             "type": "object"
346 |           },
347 |           "PageNo": {
348 |             "type": "integer",
349 |             "format": "int32"
350 |           },
351 |           "PageSize": {
352 |             "type": "integer",
353 |             "format": "int32"
354 |           },
355 |           "Price": {
356 |             "type": "string",
357 |             "format": "decimal"
358 |           },
359 |           "Total": {
360 |             "type": "integer",
361 |             "format": "int32"
362 |           }
363 |         },
364 |         "description": "\n",
365 |         "required": [
366 |           "Items",
367 |           "PageNo",
368 |           "PageSize",
369 |           "Total",
370 |           "HasNext",
371 |           "Price"
372 |         ]
373 |       },
374 |       "PageUsersResp": {
375 |         "title": "PageUsersResp",
376 |         "type": "object",
377 |         "properties": {
378 |           "code": {
379 |             "type": "integer",
380 |             "format": "int32"
381 |           },
382 |           "data": {
383 |             "$ref": "#/components/schemas/PageRet"
384 |           }
385 |         },
386 |         "required": [
387 |           "code",
388 |           "data"
389 |         ]
390 |       },
391 |       "SignUpReq": {
392 |         "title": "SignUpReq",
393 |         "type": "object",
394 |         "properties": {
395 |           "actived": {
396 |             "type": "boolean"
397 |           },
398 |           "password": {
399 |             "type": "integer",
400 |             "format": "int32"
401 |           },
402 |           "score": {
403 |             "type": "array",
404 |             "items": {
405 |               "type": "integer",
406 |               "format": "int32"
407 |             }
408 |           },
409 |           "username": {
410 |             "type": "string"
411 |           }
412 |         },
413 |         "required": [
414 |           "username",
415 |           "password",
416 |           "actived",
417 |           "score"
418 |         ]
419 |       },
420 |       "SignUpResp": {
421 |         "title": "SignUpResp",
422 |         "type": "object",
423 |         "properties": {
424 |           "code": {
425 |             "type": "integer",
426 |             "format": "int32"
427 |           },
428 |           "data": {
429 |             "type": "string"
430 |           }
431 |         },
432 |         "required": [
433 |           "code",
434 |           "data"
435 |         ]
436 |       },
437 |       "TestAlias": {
438 |         "title": "TestAlias",
439 |         "type": "object",
440 |         "properties": {
441 |           "Age": {
442 |             "type": "object"
443 |           },
444 |           "School": {
445 |             "type": "array",
446 |             "items": {
447 |               "type": "object",
448 |               "properties": {
449 |                 "Addr": {
450 |                   "type": "object",
451 |                   "properties": {
452 |                     "Block": {
453 |                       "type": "string"
454 |                     },
455 |                     "Full": {
456 |                       "type": "string"
457 |                     },
458 |                     "Zip": {
459 |                       "type": "string"
460 |                     }
461 |                   },
462 |                   "required": [
463 |                     "Zip",
464 |                     "Block",
465 |                     "Full"
466 |                   ]
467 |                 },
468 |                 "Name": {
469 |                   "type": "string"
470 |                 }
471 |               },
472 |               "required": [
473 |                 "Name",
474 |                 "Addr"
475 |               ]
476 |             }
477 |           }
478 |         },
479 |         "required": [
480 |           "Age",
481 |           "School"
482 |         ]
483 |       },
484 |       "TestExprStringP": {
485 |         "title": "TestExprStringP",
486 |         "type": "object",
487 |         "properties": {
488 |           "Age": {
489 |             "type": "object"
490 |           },
491 |           "Data": {
492 |             "type": "object",
493 |             "additionalProperties": {
494 |               "type": "string"
495 |             },
496 |             "x-map-type": "map[string]string"
497 |           },
498 |           "Hobbies": {
499 |             "type": "array",
500 |             "items": {
501 |               "type": "string"
502 |             }
503 |           },
504 |           "School": {
505 |             "type": "array",
506 |             "items": {
507 |               "type": "object",
508 |               "properties": {
509 |                 "Addr": {
510 |                   "type": "object",
511 |                   "properties": {
512 |                     "Block": {
513 |                       "type": "string"
514 |                     },
515 |                     "Full": {
516 |                       "type": "string"
517 |                     },
518 |                     "Zip": {
519 |                       "type": "string"
520 |                     }
521 |                   },
522 |                   "required": [
523 |                     "Zip",
524 |                     "Block",
525 |                     "Full"
526 |                   ]
527 |                 },
528 |                 "Name": {
529 |                   "type": "string"
530 |                 }
531 |               },
532 |               "required": [
533 |                 "Name",
534 |                 "Addr"
535 |               ]
536 |             }
537 |           }
538 |         },
539 |         "required": [
540 |           "Age",
541 |           "Hobbies",
542 |           "Data",
543 |           "School"
544 |         ]
545 |       },
546 |       "UploadAvatarReq": {
547 |         "title": "UploadAvatarReq",
548 |         "type": "object",
549 |         "properties": {
550 |           "pf": {
551 |             "type": "array",
552 |             "items": {
553 |               "type": "string",
554 |               "format": "binary"
555 |             }
556 |           },
557 |           "pf2": {
558 |             "type": "string",
559 |             "format": "binary"
560 |           },
561 |           "pf3": {
562 |             "type": "string",
563 |             "format": "binary"
564 |           },
565 |           "pf4": {
566 |             "type": "array",
567 |             "items": {
568 |               "type": "string",
569 |               "format": "binary"
570 |             }
571 |           },
572 |           "ps": {
573 |             "type": "string"
574 |           }
575 |         },
576 |         "required": [
577 |           "pf",
578 |           "ps",
579 |           "pf2",
580 |           "pf4"
581 |         ]
582 |       },
583 |       "UploadAvatarResp": {
584 |         "title": "UploadAvatarResp",
585 |         "type": "object",
586 |         "properties": {
587 |           "ri": {
588 |             "type": "integer",
589 |             "format": "int32"
590 |           },
591 |           "ri2": {
592 |             "type": "object"
593 |           }
594 |         },
595 |         "required": [
596 |           "ri",
597 |           "ri2"
598 |         ]
599 |       },
600 |       "UserVo": {
601 |         "title": "UserVo",
602 |         "type": "object",
603 |         "properties": {
604 |           "Dept": {
605 |             "type": "string"
606 |           },
607 |           "Id": {
608 |             "type": "integer",
609 |             "format": "int32"
610 |           },
611 |           "Name": {
612 |             "type": "string"
613 |           },
614 |           "Phone": {
615 |             "type": "string"
616 |           }
617 |         },
618 |         "required": [
619 |           "Id",
620 |           "Name",
621 |           "Phone",
622 |           "Dept"
623 |         ]
624 |       }
625 |     }
626 |   }
627 | }
```

cmd/internal/svc/testdata/inputanonystruct/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 
6 | 	"github.com/unionj-cloud/go-doudou/v2/framework/testdata/vo"
7 | )
8 | 
9 | // 用户服务接口
10 | // v1版本
11 | type Usersvc interface {
12 | 	// You can define your service methods as your need. Below is an example.
13 | 	PageUsers(ctx context.Context, query struct {
14 | 		Filter vo.PageFilter
15 | 		Page   vo.Page
16 | 	}) (code int, data vo.PageRet, msg error)
17 | }
```

cmd/internal/svc/testdata/nosvc/svc.go
```
1 | package service
```

cmd/internal/svc/testdata/novo/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"mime/multipart"
6 | 	"os"
7 | 
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/testdata/vo"
9 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
10 | )
11 | 
12 | // 用户服务接口
13 | // v1版本
14 | type Usersvc interface {
15 | 	// You can define your service methods as your need. Below is an example.
16 | 	PageUsers(ctx context.Context, query vo.PageQuery) (code int, data vo.PageRet, msg error)
17 | 
18 | 	// comment1
19 | 	// comment2
20 | 	GetUser(ctx context.Context,
21 | 		// 用户ID
22 | 		userId string,
23 | 		// 图片地址
24 | 		photo string,
25 | 	) (code int, data string, msg error)
26 | 
27 | 	// comment3
28 | 	SignUp(ctx context.Context, username string, password int, actived bool, score float64) (code int, data string, msg error)
29 | 
30 | 	// comment4
31 | 	UploadAvatar(context.Context, []*multipart.FileHeader, []*multipart.FileHeader, *multipart.FileHeader, v3.FileModel, string) (int, string, error)
32 | 
33 | 	// comment5
34 | 	DownloadAvatar(ctx context.Context, userId string) (*os.File, error)
35 | }
```

cmd/internal/svc/testdata/openapi/testfilesdoc1_openapi3.json
```
1 | {"openapi":"3.0.2","info":{"title":"Testdatadoc1","version":"v20210625"},"paths":{"/testdatadoc1/pageusers":{"post":{"summary":"You can define your service methods as your need. Below is an example.","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageQuery"}}},"required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PageUsersResp"}}}}}}}},"components":{"schemas":{"Order":{"title":"Order","type":"object","properties":{"Col":{"type":"string"},"Sort":{"type":"string"}}},"Page":{"title":"Page","type":"object","properties":{"Orders":{"type":"array","items":{"$ref":"#/components/schemas/Order"},"description":"排序规则"},"PageNo":{"type":"integer","format":"int32","description":"页码"},"Size":{"type":"integer","format":"int32","description":"每页行数"}}},"PageFilter":{"title":"PageFilter","type":"object","properties":{"Dept":{"type":"integer","format":"int32","description":"所属部门ID"},"Name":{"type":"string","description":"真实姓名，前缀匹配"}}},"PageQuery":{"title":"PageQuery","type":"object","properties":{"Filter":{"$ref":"#/components/schemas/PageFilter"},"Page":{"$ref":"#/components/schemas/Page"}},"description":"分页筛选条件"},"PageRet":{"title":"PageRet","type":"object","properties":{"HasNext":{"type":"boolean"},"Items":{"type":"object"},"PageNo":{"type":"integer","format":"int32"},"PageSize":{"type":"integer","format":"int32"},"Total":{"type":"integer","format":"int32"}}},"PageUsersResp":{"title":"PageUsersResp","type":"object","properties":{"code":{"type":"integer","format":"int32"},"data":{"$ref":"#/components/schemas/PageRet"},"msg":{"type":"string"}}},"UserVo":{"title":"UserVo","type":"object","properties":{"Dept":{"type":"string"},"Id":{"type":"integer","format":"int32"},"Name":{"type":"string"},"Phone":{"type":"string"}}}}}}
```

cmd/internal/svc/testdata/outputanonystruct/svc.go
```
1 | package service
2 | 
3 | import (
4 | 	"context"
5 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/testdata/outputanonystruct/dto"
6 | )
7 | 
8 | // 用户服务接口
9 | // v1版本
10 | type Usersvc interface {
11 | 	// You can define your service methods as your need. Below is an example.
12 | 	PageUsers(ctx context.Context, query dto.PageQuery) (page dto.Page, msg error)
13 | }
```

cmd/internal/svc/testdata/vo/vo.go
```
1 | package vo
2 | 
3 | import "encoding/json"
4 | 
5 | //go:generate go-doudou name --file $GOFILE -o
6 | 
7 | // 筛选条件
8 | type PageFilter struct {
9 | 	// 真实姓名，前缀匹配
10 | 	Name string
11 | 	// 所属部门ID
12 | 	Dept int
13 | }
14 | 
15 | // 排序条件
16 | type Order struct {
17 | 	Col  string
18 | 	Sort string
19 | }
20 | 
21 | type Page struct {
22 | 	// 排序规则
23 | 	Orders []Order
24 | 	// 页码
25 | 	PageNo int
26 | 	// 每页行数
27 | 	Size int
28 | 	User UserVo
29 | }
30 | 
31 | // 分页筛选条件
32 | type PageQuery struct {
33 | 	Filter PageFilter
34 | 	Page   Page
35 | }
36 | 
37 | type PageRet struct {
38 | 	Items    interface{}
39 | 	PageNo   int
40 | 	PageSize int
41 | 	Total    int
42 | 	HasNext  bool
43 | }
44 | 
45 | type UserVo struct {
46 | 	Id    int
47 | 	Name  string
48 | 	Phone string
49 | 	Dept  string
50 | }
51 | 
52 | type KeyboardLayout int
53 | 
54 | const (
55 | 	UNKNOWN KeyboardLayout = iota
56 | 	QWERTZ
57 | 	AZERTY
58 | 	QWERTY
59 | )
60 | 
61 | func (k *KeyboardLayout) StringSetter(value string) {
62 | 	switch value {
63 | 	case "UNKNOWN":
64 | 		*k = UNKNOWN
65 | 	case "QWERTY":
66 | 		*k = QWERTY
67 | 	case "QWERTZ":
68 | 		*k = QWERTZ
69 | 	case "AZERTY":
70 | 		*k = AZERTY
71 | 	default:
72 | 		*k = UNKNOWN
73 | 	}
74 | }
75 | 
76 | func (k *KeyboardLayout) StringGetter() string {
77 | 	switch *k {
78 | 	case UNKNOWN:
79 | 		return "UNKNOWN"
80 | 	case QWERTY:
81 | 		return "QWERTY"
82 | 	case QWERTZ:
83 | 		return "QWERTZ"
84 | 	case AZERTY:
85 | 		return "AZERTY"
86 | 	default:
87 | 		return "UNKNOWN"
88 | 	}
89 | }
90 | 
91 | func (k *KeyboardLayout) UnmarshalJSON(bytes []byte) error {
92 | 	var _k string
93 | 	err := json.Unmarshal(bytes, &_k)
94 | 	if err != nil {
95 | 		return err
96 | 	}
97 | 	k.StringSetter(_k)
98 | 	return nil
99 | }
100 | 
101 | func (k KeyboardLayout) MarshalJSON() ([]byte, error) {
102 | 	return json.Marshal(k.StringGetter())
103 | }
```

cmd/internal/openapi/v3/codegen/server/svc.go
```
1 | package server
2 | 
3 | import (
4 | 	"bufio"
5 | 	"os"
6 | 	"path/filepath"
7 | 	"strings"
8 | 
9 | 	"github.com/iancoleman/strcase"
10 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/openapi/v3/codegen"
11 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
12 | 	"github.com/unionj-cloud/toolkit/assert"
13 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
14 | )
15 | 
16 | var dtoTmpl = templates.EditableHeaderTmpl + `package {{.Pkg}}
17 | 
18 | //go:generate go-doudou name --file $GOFILE
19 | 
20 | {{- range $k, $v := .Schemas }}
21 | {{ toComment $v.Description ($k | toCamel)}}
22 | type {{$k | toCamel}} struct {
23 | {{- range $pk, $pv := $v.Properties }}
24 | 	{{ $pv.Description | toComment }}
25 | 	{{- if stringContains $v.Required $pk }}
26 | 	// required
27 | 	{{ $pk | toCamel}} {{$pv | toGoType }}
28 | 	{{- else }}
29 | 	{{ $pk | toCamel}} {{$pv | toOptionalGoType }}
30 | 	{{- end }}
31 | {{- end }}
32 | }
33 | {{- end }}
34 | `
35 | 
36 | // GenSvcGo may panic if docPath is empty string
37 | func GenSvcGo(dir string, docPath string) {
38 | 	assert.NotEmpty(docPath, "docPath should not be empty")
39 | 	var (
40 | 		f   *os.File
41 | 		err error
42 | 	)
43 | 	svcName := strcase.ToCamel(filepath.Base(dir))
44 | 	svcFile := filepath.Join(dir, "svc.go")
45 | 	if f, err = os.Create(svcFile); err != nil {
46 | 		panic(err)
47 | 	}
48 | 	defer f.Close()
49 | 	modfile := filepath.Join(dir, "go.mod")
50 | 	var modf *os.File
51 | 	if modf, err = os.Open(modfile); err != nil {
52 | 		panic(err)
53 | 	}
54 | 	defer modf.Close()
55 | 	reader := bufio.NewReader(modf)
56 | 	firstLine, _ := reader.ReadString('\n')
57 | 	modName := strings.TrimSpace(strings.TrimPrefix(firstLine, "module"))
58 | 	api := v3.LoadAPI(docPath)
59 | 	generator := &codegen.OpenAPICodeGenerator{
60 | 		Schemas:       api.Components.Schemas,
61 | 		RequestBodies: api.Components.RequestBodies,
62 | 		Responses:     api.Components.Responses,
63 | 		SvcName:       svcName,
64 | 		ModName:       modName,
65 | 		ApiInfo:       api.Info,
66 | 	}
67 | 	operationConverter := &codegen.ServerOperationConverter{
68 | 		Generator: generator,
69 | 	}
70 | 	dtoFile := filepath.Join(dir, "dto", "dto.go")
71 | 	if f, err = os.Create(dtoFile); err != nil {
72 | 		panic(err)
73 | 	}
74 | 	defer f.Close()
75 | 	generator.GenGoDto(api.Components.Schemas, dtoFile, "dto", dtoTmpl)
76 | 	generator.DtoPkg = "dto"
77 | 	generator.GenGoInterface(svcFile, api.Paths, operationConverter)
78 | }
```

cmd/internal/openapi/v3/codegen/server/svc_test.go
```
1 | package server
2 | 
3 | import (
4 | 	"path/filepath"
5 | 	"testing"
6 | )
7 | 
8 | var dir = "../testdata"
9 | 
10 | func TestGenSvcGo(t *testing.T) {
11 | 	type args struct {
12 | 		dir     string
13 | 		docPath string
14 | 	}
15 | 	tests := []struct {
16 | 		name string
17 | 		args args
18 | 	}{
19 | 		{
20 | 			name: "",
21 | 			args: args{
22 | 				dir:     filepath.Join(dir, "testgensvcgo"),
23 | 				docPath: filepath.Join(dir, "prometheus_openapi3.json"),
24 | 			},
25 | 		},
26 | 	}
27 | 	for _, tt := range tests {
28 | 		t.Run(tt.name, func(t *testing.T) {
29 | 			GenSvcGo(tt.args.dir, tt.args.docPath)
30 | 		})
31 | 	}
32 | }
```

cmd/internal/openapi/v3/codegen/client/go.go
```
1 | package client
2 | 
3 | import (
4 | 	"os"
5 | 	"path/filepath"
6 | 	"strings"
7 | 
8 | 	"github.com/sirupsen/logrus"
9 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/openapi/v3/codegen"
10 | 	"github.com/unionj-cloud/go-doudou/v2/cmd/internal/templates"
11 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
12 | )
13 | 
14 | var dtoTmpl = templates.EditableHeaderTmpl + `package {{.Pkg}}
15 | 
16 | {{- range $k, $v := .Schemas }}
17 | {{ toComment $v.Description ($k | toCamel)}}
18 | type {{$k | toCamel}} struct {
19 | {{- range $pk, $pv := $v.Properties }}
20 | 	{{ $pv.Description | toComment }}
21 | 	{{- if stringContains $v.Required $pk }}
22 | 	// required
23 | 	{{ $pk | toCamel}} {{$pv | toGoType }} ` + "`" + `json:"{{$pk}}{{if $.Omit}},omitempty{{end}}" url:"{{$pk}}"` + "`" + `
24 | 	{{- else }}
25 | 	{{ $pk | toCamel}} {{$pv | toOptionalGoType }} ` + "`" + `json:"{{$pk}}{{if $.Omit}},omitempty{{end}}" url:"{{$pk}}"` + "`" + `
26 | 	{{- end }}
27 | {{- end }}
28 | }
29 | {{- end }}
30 | `
31 | 
32 | // GenGoClient generate go http client code from OpenAPI3.0 json document
33 | func GenGoClient(dir string, file string, omit bool, env, pkg string) {
34 | 	var (
35 | 		err       error
36 | 		f         *os.File
37 | 		clientDir string
38 | 		fi        os.FileInfo
39 | 		api       v3.API
40 | 		dtoFile   string
41 | 	)
42 | 	clientDir = filepath.Join(dir, pkg)
43 | 	if err = os.MkdirAll(clientDir, os.ModePerm); err != nil {
44 | 		panic(err)
45 | 	}
46 | 	api = v3.LoadAPI(file)
47 | 	generator := &codegen.OpenAPICodeGenerator{
48 | 		Schemas:       api.Components.Schemas,
49 | 		RequestBodies: api.Components.RequestBodies,
50 | 		Responses:     api.Components.Responses,
51 | 		Omitempty:     omit,
52 | 		ApiInfo:       api.Info,
53 | 	}
54 | 	svcmap := make(map[string]map[string]v3.Path)
55 | 	for endpoint, path := range api.Paths {
56 | 		svcname := strings.Split(strings.Trim(endpoint, "/"), "/")[0]
57 | 		if value, exists := svcmap[svcname]; exists {
58 | 			value[endpoint] = path
59 | 		} else {
60 | 			svcmap[svcname] = make(map[string]v3.Path)
61 | 			svcmap[svcname][endpoint] = path
62 | 		}
63 | 	}
64 | 	operationConverter := &codegen.ClientOperationConverter{
65 | 		Generator: generator,
66 | 	}
67 | 	for svcName, paths := range svcmap {
68 | 		generator.GenGoHTTP(paths, svcName, clientDir, env, pkg, operationConverter)
69 | 	}
70 | 	dtoFile = filepath.Join(clientDir, "dto.go")
71 | 	fi, err = os.Stat(dtoFile)
72 | 	if err != nil && !os.IsNotExist(err) {
73 | 		panic(err)
74 | 	}
75 | 	if fi != nil {
76 | 		logrus.Warningln("file dto.go will be overwritten")
77 | 	}
78 | 	if f, err = os.Create(dtoFile); err != nil {
79 | 		panic(err)
80 | 	}
81 | 	defer f.Close()
82 | 	generator.GenGoDto(api.Components.Schemas, dtoFile, pkg, dtoTmpl)
83 | }
```

cmd/internal/openapi/v3/codegen/client/go_test.go
```
1 | package client
2 | 
3 | import (
4 | 	"os"
5 | 	"testing"
6 | 
7 | 	"github.com/stretchr/testify/assert"
8 | )
9 | 
10 | func TestGenGoClient(t *testing.T) {
11 | 	dir := "testdata/testclient"
12 | 	defer os.RemoveAll(dir)
13 | 	assert.NotPanics(t, func() {
14 | 		GenGoClient(dir, "../testdata/petstore3.json", true, "", "client")
15 | 	})
16 | }
17 | 
18 | func TestGenGoClient2(t *testing.T) {
19 | 	dir := "testdata/testclient2"
20 | 	defer os.RemoveAll(dir)
21 | 	assert.NotPanics(t, func() {
22 | 		GenGoClient(dir, "../testdata/swagger.json", true, "", "client")
23 | 	})
24 | }
```

cmd/internal/openapi/v3/codegen/testdata/api-docs.json
```
1 | {
2 |   "openapi": "3.0.1",
3 |   "info": {
4 |     "title": "报告生成 API",
5 |     "description": "报告生成api服务",
6 |     "version": "1.4.8"
7 |   },
8 |   "servers": [
9 |     {
10 |       "url": "http://report.xicheng.c92358f369e164c2bbbdee14238b6e9a6.cn-beijing.alicontainer.com",
11 |       "description": "Generated server url"
12 |     }
13 |   ],
14 |   "paths": {
15 |     "/text/extractFromUrl": {
16 |       "get": {
17 |         "tags": [
18 |           "text-controller"
19 |         ],
20 |         "description": "提取文本",
21 |         "operationId": "download",
22 |         "parameters": [
23 |           {
24 |             "name": "url",
25 |             "in": "query",
26 |             "description": "文件地址",
27 |             "required": true,
28 |             "schema": {
29 |               "type": "string"
30 |             }
31 |           },
32 |           {
33 |             "name": "clearFormat",
34 |             "in": "query",
35 |             "description": "是否清除格式，即替换连续空白字符为单一空格",
36 |             "required": false,
37 |             "schema": {
38 |               "type": "boolean",
39 |               "default": false
40 |             }
41 |           }
42 |         ],
43 |         "responses": {
44 |           "500": {
45 |             "description": "Internal Server Error",
46 |             "content": {
47 |               "*/*": {
48 |                 "schema": {
49 |                   "type": "string"
50 |                 }
51 |               }
52 |             }
53 |           },
54 |           "403": {
55 |             "description": "Forbidden",
56 |             "content": {
57 |               "*/*": {
58 |                 "schema": {
59 |                   "type": "string"
60 |                 }
61 |               }
62 |             }
63 |           },
64 |           "200": {
65 |             "description": "OK",
66 |             "content": {
67 |               "*/*": {
68 |                 "schema": {
69 |                   "$ref": "#/components/schemas/ResultString"
70 |                 }
71 |               }
72 |             }
73 |           }
74 |         }
75 |       }
76 |     },
77 |     "/text/extractFromFile": {
78 |       "post": {
79 |         "tags": [
80 |           "text-controller"
81 |         ],
82 |         "description": "提取文本",
83 |         "operationId": "download_1",
84 |         "parameters": [
85 |           {
86 |             "name": "clearFormat",
87 |             "in": "query",
88 |             "description": "是否清除格式，即替换连续空白字符为单一空格",
89 |             "required": false,
90 |             "schema": {
91 |               "type": "boolean",
92 |               "default": false
93 |             }
94 |           }
95 |         ],
96 |         "requestBody": {
97 |           "content": {
98 |             "multipart/form-data": {
99 |               "schema": {
100 |                 "type": "object",
101 |                 "properties": {
102 |                   "file": {
103 |                     "type": "string",
104 |                     "format": "binary"
105 |                   }
106 |                 }
107 |               }
108 |             }
109 |           }
110 |         },
111 |         "responses": {
112 |           "500": {
113 |             "description": "Internal Server Error",
114 |             "content": {
115 |               "*/*": {
116 |                 "schema": {
117 |                   "type": "string"
118 |                 }
119 |               }
120 |             }
121 |           },
122 |           "403": {
123 |             "description": "Forbidden",
124 |             "content": {
125 |               "*/*": {
126 |                 "schema": {
127 |                   "type": "string"
128 |                 }
129 |               }
130 |             }
131 |           },
132 |           "200": {
133 |             "description": "OK",
134 |             "content": {
135 |               "*/*": {
136 |                 "schema": {
137 |                   "$ref": "#/components/schemas/ResultString"
138 |                 }
139 |               }
140 |             }
141 |           }
142 |         }
143 |       }
144 |     }
145 |   },
146 |   "components": {
147 |     "schemas": {
148 |       "Word2HtmlRequestPayload": {
149 |         "type": "object",
150 |         "properties": {
151 |           "downloadUrl": {
152 |             "type": "string"
153 |           }
154 |         }
155 |       },
156 |       "ResultString": {
157 |         "type": "object",
158 |         "properties": {
159 |           "code": {
160 |             "type": "integer",
161 |             "description": "返回标记：成功标记=0，失败标记=1",
162 |             "format": "int32"
163 |           },
164 |           "msg": {
165 |             "type": "string",
166 |             "description": "返回信息"
167 |           },
168 |           "data": {
169 |             "type": "string",
170 |             "description": "数据"
171 |           }
172 |         }
173 |       },
174 |       "ResultListWordTemplateSubstitution": {
175 |         "type": "object",
176 |         "properties": {
177 |           "code": {
178 |             "type": "integer",
179 |             "description": "返回标记：成功标记=0，失败标记=1",
180 |             "format": "int32"
181 |           },
182 |           "msg": {
183 |             "type": "string",
184 |             "description": "返回信息"
185 |           },
186 |           "data": {
187 |             "type": "array",
188 |             "description": "数据",
189 |             "items": {
190 |               "$ref": "#/components/schemas/WordTemplateSubstitution"
191 |             }
192 |           }
193 |         }
194 |       },
195 |       "WordTemplateSubstitution": {
196 |         "type": "object",
197 |         "properties": {
198 |           "name": {
199 |             "type": "string",
200 |             "description": "变量名",
201 |             "example": "var1"
202 |           },
203 |           "display": {
204 |             "type": "string",
205 |             "description": "完整变量字符串，用于前端展示",
206 |             "example": "{var1}"
207 |           },
208 |           "type": {
209 |             "type": "string",
210 |             "description": "类型",
211 |             "example": "MERGEFIELD",
212 |             "enum": [
213 |               "MERGEFIELD",
214 |               "IMAGE",
215 |               "CHART",
216 |               "TABLE",
217 |               "UNKNOWN"
218 |             ]
219 |           }
220 |         },
221 |         "description": "模板变量"
222 |       },
223 |       "ChartReportParagraph": {
224 |         "type": "object",
225 |         "description": "图表类型段落",
226 |         "allOf": [
227 |           {
228 |             "$ref": "#/components/schemas/ReportParagraph"
229 |           },
230 |           {
231 |             "type": "object",
232 |             "properties": {
233 |               "chartXlsxTemplateUrl": {
234 |                 "type": "string"
235 |               },
236 |               "reportChartType": {
237 |                 "type": "string",
238 |                 "enum": [
239 |                   "ZHUXINGTU",
240 |                   "ZHEXIANTU",
241 |                   "DUIJIZHEXIANTU",
242 |                   "BINGTU",
243 |                   "TIAOXINGTU",
244 |                   "SANDIANTU",
245 |                   "ZHEXIANZHUXINGTU",
246 |                   "DUIJIZHUXINGTU",
247 |                   "YUANHUANTU",
248 |                   "UNKNOWN"
249 |                 ]
250 |               },
251 |               "data": {
252 |                 "type": "array",
253 |                 "items": {
254 |                   "type": "array",
255 |                   "items": {
256 |                     "type": "object"
257 |                   }
258 |                 }
259 |               },
260 |               "style": {
261 |                 "$ref": "#/components/schemas/ChartReportParagraphStyle"
262 |               }
263 |             }
264 |           }
265 |         ]
266 |       },
267 |       "ChartReportParagraphStyle": {
268 |         "type": "object",
269 |         "properties": {
270 |           "alignment": {
271 |             "type": "string",
272 |             "description": "居左，居中，居右",
273 |             "enum": [
274 |               "LEFT",
275 |               "CENTER",
276 |               "RIGHT"
277 |             ]
278 |           },
279 |           "width": {
280 |             "type": "number",
281 |             "description": "word里面的图表的宽，单位厘米",
282 |             "format": "double"
283 |           },
284 |           "height": {
285 |             "type": "number",
286 |             "description": "word里面的图表的高，单位厘米",
287 |             "format": "double"
288 |           },
289 |           "foreColor": {
290 |             "type": "object",
291 |             "additionalProperties": {
292 |               "type": "string",
293 |               "description": "每个系列的前景色，图例的颜色，柱子的颜色，线条的颜色等"
294 |             },
295 |             "description": "每个系列的前景色，图例的颜色，柱子的颜色，线条的颜色等"
296 |           }
297 |         }
298 |       },
299 |       "ImageReportParagraph": {
300 |         "type": "object",
301 |         "description": "图片类型段落",
302 |         "allOf": [
303 |           {
304 |             "$ref": "#/components/schemas/ReportParagraph"
305 |           },
306 |           {
307 |             "type": "object",
308 |             "properties": {
309 |               "urls": {
310 |                 "type": "array",
311 |                 "items": {
312 |                   "type": "string"
313 |                 }
314 |               },
315 |               "style": {
316 |                 "$ref": "#/components/schemas/ImageReportParagraphStyle"
317 |               }
318 |             }
319 |           }
320 |         ]
321 |       },
322 |       "ImageReportParagraphStyle": {
323 |         "type": "object",
324 |         "properties": {
325 |           "alignment": {
326 |             "type": "string",
327 |             "description": "居左，居中，居右",
328 |             "enum": [
329 |               "LEFT",
330 |               "CENTER",
331 |               "RIGHT"
332 |             ]
333 |           },
334 |           "width": {
335 |             "type": "number",
336 |             "format": "double"
337 |           },
338 |           "height": {
339 |             "type": "number",
340 |             "format": "double"
341 |           },
342 |           "separator": {
343 |             "type": "string"
344 |           }
345 |         }
346 |       },
347 |       "MergeFieldData": {
348 |         "type": "object",
349 |         "properties": {
350 |           "fields": {
351 |             "type": "array",
352 |             "items": {
353 |               "type": "string"
354 |             }
355 |           },
356 |           "values": {
357 |             "type": "array",
358 |             "items": {
359 |               "type": "object"
360 |             }
361 |           }
362 |         }
363 |       },
364 |       "ParagraphWrapper": {
365 |         "required": [
366 |           "type"
367 |         ],
368 |         "type": "object",
369 |         "properties": {
370 |           "type": {
371 |             "type": "string",
372 |             "description": "报告段落类型",
373 |             "example": "TEXT",
374 |             "enum": [
375 |               "TEXT",
376 |               "CHART",
377 |               "CHART2",
378 |               "IMAGE",
379 |               "TABLE",
380 |               "TABLE2"
381 |             ]
382 |           },
383 |           "value": {
384 |             "oneOf": [
385 |               {
386 |                 "$ref": "#/components/schemas/ChartReportParagraph"
387 |               },
388 |               {
389 |                 "$ref": "#/components/schemas/ImageReportParagraph"
390 |               },
391 |               {
392 |                 "$ref": "#/components/schemas/TableReportParagraph"
393 |               },
394 |               {
395 |                 "$ref": "#/components/schemas/TextReportParagraph"
396 |               }
397 |             ]
398 |           }
399 |         },
400 |         "description": "报告段落包装类"
401 |       },
402 |       "ReportParagraph": {
403 |         "type": "object",
404 |         "properties": {
405 |           "bookmark": {
406 |             "type": "string"
407 |           }
408 |         },
409 |         "description": "报告段落内容"
410 |       },
411 |       "TableReportParagraph": {
412 |         "type": "object",
413 |         "description": "表格类型段落",
414 |         "allOf": [
415 |           {
416 |             "$ref": "#/components/schemas/ReportParagraph"
417 |           },
418 |           {
419 |             "type": "object",
420 |             "properties": {
421 |               "hasHeader": {
422 |                 "type": "boolean"
423 |               },
424 |               "data": {
425 |                 "type": "array",
426 |                 "items": {
427 |                   "type": "array",
428 |                   "items": {
429 |                     "type": "object"
430 |                   }
431 |                 }
432 |               }
433 |             }
434 |           }
435 |         ]
436 |       },
437 |       "TextReportParagraph": {
438 |         "type": "object",
439 |         "description": "文本类型段落",
440 |         "allOf": [
441 |           {
442 |             "$ref": "#/components/schemas/ReportParagraph"
443 |           },
444 |           {
445 |             "type": "object",
446 |             "properties": {
447 |               "style": {
448 |                 "$ref": "#/components/schemas/TextReportParagraphStyle"
449 |               },
450 |               "content": {
451 |                 "type": "string"
452 |               },
453 |               "fieldData": {
454 |                 "$ref": "#/components/schemas/MergeFieldData"
455 |               },
456 |               "sentences": {
457 |                 "type": "array",
458 |                 "items": {
459 |                   "$ref": "#/components/schemas/TextReportParagraphSentence"
460 |                 }
461 |               }
462 |             }
463 |           }
464 |         ]
465 |       },
466 |       "TextReportParagraphFont": {
467 |         "type": "object",
468 |         "properties": {
469 |           "fontFamily": {
470 |             "type": "string",
471 |             "description": "字体"
472 |           },
473 |           "fontSize": {
474 |             "type": "number",
475 |             "description": "字号，默认16磅，即三号字体",
476 |             "format": "double"
477 |           },
478 |           "chineseFontSize": {
479 |             "type": "string",
480 |             "description": "中文字号，优先级高于fontSize",
481 |             "enum": [
482 |               "初号",
483 |               "小初",
484 |               "一号",
485 |               "小一",
486 |               "二号",
487 |               "小二",
488 |               "三号",
489 |               "小三",
490 |               "四号",
491 |               "小四",
492 |               "五号",
493 |               "小五",
494 |               "六号",
495 |               "小六",
496 |               "七号",
497 |               "八号"
498 |             ]
499 |           },
500 |           "fontColor": {
501 |             "type": "string",
502 |             "description": "字体颜色，只支持黑色，红色和黄色",
503 |             "enum": [
504 |               "BLACK",
505 |               "RED",
506 |               "YELLOW"
507 |             ]
508 |           },
509 |           "isBold": {
510 |             "type": "boolean",
511 |             "description": "是否加粗，默认false"
512 |           }
513 |         },
514 |         "description": "设置字体样式"
515 |       },
516 |       "TextReportParagraphSentence": {
517 |         "type": "object",
518 |         "properties": {
519 |           "font": {
520 |             "$ref": "#/components/schemas/TextReportParagraphFont"
521 |           },
522 |           "inline": {
523 |             "type": "boolean",
524 |             "description": "inline默认值为true，表示不换行"
525 |           },
526 |           "content": {
527 |             "type": "string",
528 |             "description": "文本"
529 |           }
530 |         },
531 |         "description": "文本类型句子短语"
532 |       },
533 |       "TextReportParagraphStyle": {
534 |         "type": "object",
535 |         "properties": {
536 |           "alignment": {
537 |             "type": "string",
538 |             "description": "居左，居中，居右",
539 |             "enum": [
540 |               "LEFT",
541 |               "CENTER",
542 |               "RIGHT"
543 |             ]
544 |           },
545 |           "font": {
546 |             "$ref": "#/components/schemas/TextReportParagraphFont"
547 |           },
548 |           "lineSpacing": {
549 |             "type": "number",
550 |             "description": "设置行距，单位磅，默认单倍行距，即12磅",
551 |             "format": "double"
552 |           },
553 |           "indent": {
554 |             "type": "number",
555 |             "description": "设置首行缩进，单位磅",
556 |             "format": "double"
557 |           },
558 |           "inline": {
559 |             "type": "boolean",
560 |             "description": "如果inline为true，表示不换行"
561 |           },
562 |           "clearOldStyle": {
563 |             "type": "boolean",
564 |             "description": "是否清除原有段落格式"
565 |           }
566 |         }
567 |       },
568 |       "ResultInteger": {
569 |         "type": "object",
570 |         "properties": {
571 |           "code": {
572 |             "type": "integer",
573 |             "description": "返回标记：成功标记=0，失败标记=1",
574 |             "format": "int32"
575 |           },
576 |           "msg": {
577 |             "type": "string",
578 |             "description": "返回信息"
579 |           },
580 |           "data": {
581 |             "type": "integer",
582 |             "description": "数据",
583 |             "format": "int32"
584 |           }
585 |         }
586 |       },
587 |       "ReportPage": {
588 |         "type": "object",
589 |         "properties": {
590 |           "orientationType": {
591 |             "type": "string",
592 |             "description": "页面是横向还是纵向",
593 |             "enum": [
594 |               "HORIZONTAL",
595 |               "VERTICAL"
596 |             ]
597 |           },
598 |           "paperSizeType": {
599 |             "type": "string",
600 |             "description": "页面纸张大小",
601 |             "enum": [
602 |               "A3",
603 |               "A4",
604 |               "A5",
605 |               "B4",
606 |               "B5"
607 |             ]
608 |           },
609 |           "topMargin": {
610 |             "type": "number",
611 |             "description": "页面上边距，单位厘米",
612 |             "format": "double"
613 |           },
614 |           "bottomMargin": {
615 |             "type": "number",
616 |             "description": "页面下边距，单位厘米",
617 |             "format": "double"
618 |           },
619 |           "leftMargin": {
620 |             "type": "number",
621 |             "description": "页面左边距，单位厘米",
622 |             "format": "double"
623 |           },
624 |           "rightMargin": {
625 |             "type": "number",
626 |             "description": "页面右边距，单位厘米",
627 |             "format": "double"
628 |           }
629 |         }
630 |       },
631 |       "RequestPayload": {
632 |         "type": "object",
633 |         "properties": {
634 |           "templateUrl": {
635 |             "type": "string"
636 |           },
637 |           "reportFileName": {
638 |             "type": "string"
639 |           },
640 |           "paragraphList": {
641 |             "type": "array",
642 |             "items": {
643 |               "$ref": "#/components/schemas/ParagraphWrapper"
644 |             }
645 |           },
646 |           "reportPage": {
647 |             "$ref": "#/components/schemas/ReportPage"
648 |           },
649 |           "storageMode": {
650 |             "type": "string"
651 |           }
652 |         }
653 |       }
654 |     }
655 |   }
656 | }
```

cmd/internal/openapi/v3/codegen/testdata/petstore3.json
```
1 | {
2 |   "openapi": "3.0.2",
3 |   "info": {
4 |     "title": "Swagger Petstore - OpenAPI 3.0",
5 |     "description": "This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\nSwagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\nYou can now help us improve the API whether it's by making changes to the definition itself or to the code.\nThat way, with time, we can improve the API in general, and expose some of the new features in OAS3.\n\nSome useful links:\n- [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\n- [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)",
6 |     "termsOfService": "http://swagger.io/terms/",
7 |     "contact": {
8 |       "email": "apiteam@swagger.io"
9 |     },
10 |     "license": {
11 |       "name": "Apache 2.0",
12 |       "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
13 |     },
14 |     "version": "1.0.17"
15 |   },
16 |   "externalDocs": {
17 |     "description": "Find out more about Swagger",
18 |     "url": "http://swagger.io"
19 |   },
20 |   "servers": [
21 |     {
22 |       "url": "/api/v3"
23 |     }
24 |   ],
25 |   "tags": [
26 |     {
27 |       "name": "pet",
28 |       "description": "Everything about your Pets",
29 |       "externalDocs": {
30 |         "description": "Find out more",
31 |         "url": "http://swagger.io"
32 |       }
33 |     },
34 |     {
35 |       "name": "store",
36 |       "description": "Access to Petstore orders",
37 |       "externalDocs": {
38 |         "description": "Find out more about our store",
39 |         "url": "http://swagger.io"
40 |       }
41 |     },
42 |     {
43 |       "name": "user",
44 |       "description": "Operations about user"
45 |     }
46 |   ],
47 |   "paths": {
48 |     "/pet": {
49 |       "put": {
50 |         "tags": [
51 |           "pet"
52 |         ],
53 |         "summary": "Update an existing pet",
54 |         "description": "Update an existing pet by Id",
55 |         "operationId": "updatePet",
56 |         "requestBody": {
57 |           "description": "Update an existent pet in the store",
58 |           "content": {
59 |             "application/json": {
60 |               "schema": {
61 |                 "$ref": "#/components/schemas/Pet"
62 |               }
63 |             },
64 |             "application/xml": {
65 |               "schema": {
66 |                 "$ref": "#/components/schemas/Pet"
67 |               }
68 |             },
69 |             "application/x-www-form-urlencoded": {
70 |               "schema": {
71 |                 "$ref": "#/components/schemas/Pet"
72 |               }
73 |             }
74 |           },
75 |           "required": true
76 |         },
77 |         "responses": {
78 |           "200": {
79 |             "description": "Successful operation",
80 |             "content": {
81 |               "application/xml": {
82 |                 "schema": {
83 |                   "$ref": "#/components/schemas/Pet"
84 |                 }
85 |               },
86 |               "application/json": {
87 |                 "schema": {
88 |                   "$ref": "#/components/schemas/Pet"
89 |                 }
90 |               }
91 |             }
92 |           },
93 |           "400": {
94 |             "description": "Invalid ID supplied"
95 |           },
96 |           "404": {
97 |             "description": "Pet not found"
98 |           },
99 |           "405": {
100 |             "description": "Validation exception"
101 |           }
102 |         },
103 |         "security": [
104 |           {
105 |             "petstore_auth": [
106 |               "write:pets",
107 |               "read:pets"
108 |             ]
109 |           }
110 |         ]
111 |       },
112 |       "post": {
113 |         "tags": [
114 |           "pet"
115 |         ],
116 |         "summary": "Add a new pet to the store",
117 |         "description": "Add a new pet to the store",
118 |         "operationId": "addPet",
119 |         "requestBody": {
120 |           "description": "Create a new pet in the store",
121 |           "content": {
122 |             "application/json": {
123 |               "schema": {
124 |                 "$ref": "#/components/schemas/Pet"
125 |               }
126 |             },
127 |             "application/xml": {
128 |               "schema": {
129 |                 "$ref": "#/components/schemas/Pet"
130 |               }
131 |             },
132 |             "application/x-www-form-urlencoded": {
133 |               "schema": {
134 |                 "$ref": "#/components/schemas/Pet"
135 |               }
136 |             }
137 |           },
138 |           "required": true
139 |         },
140 |         "responses": {
141 |           "200": {
142 |             "description": "Successful operation",
143 |             "content": {
144 |               "application/xml": {
145 |                 "schema": {
146 |                   "$ref": "#/components/schemas/Pet"
147 |                 }
148 |               },
149 |               "application/json": {
150 |                 "schema": {
151 |                   "$ref": "#/components/schemas/Pet"
152 |                 }
153 |               }
154 |             }
155 |           },
156 |           "405": {
157 |             "description": "Invalid input"
158 |           }
159 |         },
160 |         "security": [
161 |           {
162 |             "petstore_auth": [
163 |               "write:pets",
164 |               "read:pets"
165 |             ]
166 |           }
167 |         ]
168 |       }
169 |     },
170 |     "/pet/findByStatus": {
171 |       "get": {
172 |         "tags": [
173 |           "pet"
174 |         ],
175 |         "summary": "Finds Pets by status",
176 |         "description": "Multiple status values can be provided with comma separated strings",
177 |         "operationId": "findPetsByStatus",
178 |         "parameters": [
179 |           {
180 |             "name": "status",
181 |             "in": "query",
182 |             "description": "Status values that need to be considered for filter",
183 |             "required": false,
184 |             "explode": true,
185 |             "schema": {
186 |               "type": "string",
187 |               "default": "available",
188 |               "enum": [
189 |                 "available",
190 |                 "pending",
191 |                 "sold"
192 |               ]
193 |             }
194 |           }
195 |         ],
196 |         "responses": {
197 |           "200": {
198 |             "description": "successful operation",
199 |             "content": {
200 |               "application/xml": {
201 |                 "schema": {
202 |                   "type": "array",
203 |                   "items": {
204 |                     "$ref": "#/components/schemas/Pet"
205 |                   }
206 |                 }
207 |               },
208 |               "application/json": {
209 |                 "schema": {
210 |                   "type": "array",
211 |                   "items": {
212 |                     "$ref": "#/components/schemas/Pet"
213 |                   }
214 |                 }
215 |               }
216 |             }
217 |           },
218 |           "400": {
219 |             "description": "Invalid status value"
220 |           }
221 |         },
222 |         "security": [
223 |           {
224 |             "petstore_auth": [
225 |               "write:pets",
226 |               "read:pets"
227 |             ]
228 |           }
229 |         ]
230 |       }
231 |     },
232 |     "/pet/findByTags": {
233 |       "get": {
234 |         "tags": [
235 |           "pet"
236 |         ],
237 |         "summary": "Finds Pets by tags",
238 |         "description": "Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.",
239 |         "operationId": "findPetsByTags",
240 |         "parameters": [
241 |           {
242 |             "name": "tags",
243 |             "in": "query",
244 |             "description": "Tags to filter by",
245 |             "required": false,
246 |             "explode": true,
247 |             "schema": {
248 |               "type": "array",
249 |               "items": {
250 |                 "type": "string"
251 |               }
252 |             }
253 |           }
254 |         ],
255 |         "responses": {
256 |           "200": {
257 |             "description": "successful operation",
258 |             "content": {
259 |               "application/xml": {
260 |                 "schema": {
261 |                   "type": "array",
262 |                   "items": {
263 |                     "$ref": "#/components/schemas/Pet"
264 |                   }
265 |                 }
266 |               },
267 |               "application/json": {
268 |                 "schema": {
269 |                   "type": "array",
270 |                   "items": {
271 |                     "$ref": "#/components/schemas/Pet"
272 |                   }
273 |                 }
274 |               }
275 |             }
276 |           },
277 |           "400": {
278 |             "description": "Invalid tag value"
279 |           }
280 |         },
281 |         "security": [
282 |           {
283 |             "petstore_auth": [
284 |               "write:pets",
285 |               "read:pets"
286 |             ]
287 |           }
288 |         ]
289 |       }
290 |     },
291 |     "/pet/{petId}": {
292 |       "get": {
293 |         "tags": [
294 |           "pet"
295 |         ],
296 |         "summary": "Find pet by ID",
297 |         "description": "Returns a single pet",
298 |         "operationId": "getPetById",
299 |         "parameters": [
300 |           {
301 |             "name": "petId",
302 |             "in": "path",
303 |             "description": "ID of pet to return",
304 |             "required": true,
305 |             "schema": {
306 |               "type": "integer",
307 |               "format": "int64"
308 |             }
309 |           }
310 |         ],
311 |         "responses": {
312 |           "200": {
313 |             "description": "successful operation",
314 |             "content": {
315 |               "application/xml": {
316 |                 "schema": {
317 |                   "$ref": "#/components/schemas/Pet"
318 |                 }
319 |               },
320 |               "application/json": {
321 |                 "schema": {
322 |                   "$ref": "#/components/schemas/Pet"
323 |                 }
324 |               }
325 |             }
326 |           },
327 |           "400": {
328 |             "description": "Invalid ID supplied"
329 |           },
330 |           "404": {
331 |             "description": "Pet not found"
332 |           }
333 |         },
334 |         "security": [
335 |           {
336 |             "api_key": []
337 |           },
338 |           {
339 |             "petstore_auth": [
340 |               "write:pets",
341 |               "read:pets"
342 |             ]
343 |           }
344 |         ]
345 |       },
346 |       "post": {
347 |         "tags": [
348 |           "pet"
349 |         ],
350 |         "summary": "Updates a pet in the store with form data",
351 |         "description": "",
352 |         "operationId": "updatePetWithForm",
353 |         "parameters": [
354 |           {
355 |             "name": "petId",
356 |             "in": "path",
357 |             "description": "ID of pet that needs to be updated",
358 |             "required": true,
359 |             "schema": {
360 |               "type": "integer",
361 |               "format": "int64"
362 |             }
363 |           },
364 |           {
365 |             "name": "name",
366 |             "in": "query",
367 |             "description": "Name of pet that needs to be updated",
368 |             "schema": {
369 |               "type": "string"
370 |             }
371 |           },
372 |           {
373 |             "name": "status",
374 |             "in": "query",
375 |             "description": "Status of pet that needs to be updated",
376 |             "schema": {
377 |               "type": "string"
378 |             }
379 |           }
380 |         ],
381 |         "responses": {
382 |           "405": {
383 |             "description": "Invalid input"
384 |           }
385 |         },
386 |         "security": [
387 |           {
388 |             "petstore_auth": [
389 |               "write:pets",
390 |               "read:pets"
391 |             ]
392 |           }
393 |         ]
394 |       },
395 |       "delete": {
396 |         "tags": [
397 |           "pet"
398 |         ],
399 |         "summary": "Deletes a pet",
400 |         "description": "",
401 |         "operationId": "deletePet",
402 |         "parameters": [
403 |           {
404 |             "name": "api_key",
405 |             "in": "header",
406 |             "description": "",
407 |             "required": false,
408 |             "schema": {
409 |               "type": "string"
410 |             }
411 |           },
412 |           {
413 |             "name": "petId",
414 |             "in": "path",
415 |             "description": "Pet id to delete",
416 |             "required": true,
417 |             "schema": {
418 |               "type": "integer",
419 |               "format": "int64"
420 |             }
421 |           }
422 |         ],
423 |         "responses": {
424 |           "400": {
425 |             "description": "Invalid pet value"
426 |           }
427 |         },
428 |         "security": [
429 |           {
430 |             "petstore_auth": [
431 |               "write:pets",
432 |               "read:pets"
433 |             ]
434 |           }
435 |         ]
436 |       }
437 |     },
438 |     "/pet/{petId}/uploadImage": {
439 |       "post": {
440 |         "tags": [
441 |           "pet"
442 |         ],
443 |         "summary": "uploads an image",
444 |         "description": "",
445 |         "operationId": "uploadFile",
446 |         "parameters": [
447 |           {
448 |             "name": "petId",
449 |             "in": "path",
450 |             "description": "ID of pet to update",
451 |             "required": true,
452 |             "schema": {
453 |               "type": "integer",
454 |               "format": "int64"
455 |             }
456 |           },
457 |           {
458 |             "name": "additionalMetadata",
459 |             "in": "query",
460 |             "description": "Additional Metadata",
461 |             "required": false,
462 |             "schema": {
463 |               "type": "string"
464 |             }
465 |           }
466 |         ],
467 |         "requestBody": {
468 |           "content": {
469 |             "application/octet-stream": {
470 |               "schema": {
471 |                 "type": "string",
472 |                 "format": "binary"
473 |               }
474 |             }
475 |           }
476 |         },
477 |         "responses": {
478 |           "200": {
479 |             "description": "successful operation",
480 |             "content": {
481 |               "application/json": {
482 |                 "schema": {
483 |                   "$ref": "#/components/schemas/ApiResponse"
484 |                 }
485 |               }
486 |             }
487 |           }
488 |         },
489 |         "security": [
490 |           {
491 |             "petstore_auth": [
492 |               "write:pets",
493 |               "read:pets"
494 |             ]
495 |           }
496 |         ]
497 |       }
498 |     },
499 |     "/store/inventory": {
500 |       "get": {
501 |         "tags": [
502 |           "store"
503 |         ],
504 |         "summary": "Returns pet inventories by status",
505 |         "description": "Returns a map of status codes to quantities",
506 |         "operationId": "getInventory",
507 |         "responses": {
508 |           "200": {
509 |             "description": "successful operation",
510 |             "content": {
511 |               "application/json": {
512 |                 "schema": {
513 |                   "type": "object",
514 |                   "additionalProperties": {
515 |                     "type": "integer",
516 |                     "format": "int32"
517 |                   }
518 |                 }
519 |               }
520 |             }
521 |           }
522 |         },
523 |         "security": [
524 |           {
525 |             "api_key": []
526 |           }
527 |         ]
528 |       }
529 |     },
530 |     "/store/order": {
531 |       "post": {
532 |         "tags": [
533 |           "store"
534 |         ],
535 |         "summary": "Place an order for a pet",
536 |         "description": "Place a new order in the store",
537 |         "operationId": "placeOrder",
538 |         "requestBody": {
539 |           "content": {
540 |             "application/json": {
541 |               "schema": {
542 |                 "$ref": "#/components/schemas/Order"
543 |               }
544 |             },
545 |             "application/xml": {
546 |               "schema": {
547 |                 "$ref": "#/components/schemas/Order"
548 |               }
549 |             },
550 |             "application/x-www-form-urlencoded": {
551 |               "schema": {
552 |                 "$ref": "#/components/schemas/Order"
553 |               }
554 |             }
555 |           }
556 |         },
557 |         "responses": {
558 |           "200": {
559 |             "description": "successful operation",
560 |             "content": {
561 |               "application/json": {
562 |                 "schema": {
563 |                   "$ref": "#/components/schemas/Order"
564 |                 }
565 |               }
566 |             }
567 |           },
568 |           "405": {
569 |             "description": "Invalid input"
570 |           }
571 |         }
572 |       }
573 |     },
574 |     "/store/order/{orderId}": {
575 |       "get": {
576 |         "tags": [
577 |           "store"
578 |         ],
579 |         "summary": "Find purchase order by ID",
580 |         "description": "For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.",
581 |         "operationId": "getOrderById",
582 |         "parameters": [
583 |           {
584 |             "name": "orderId",
585 |             "in": "path",
586 |             "description": "ID of order that needs to be fetched",
587 |             "required": true,
588 |             "schema": {
589 |               "type": "integer",
590 |               "format": "int64"
591 |             }
592 |           }
593 |         ],
594 |         "responses": {
595 |           "200": {
596 |             "description": "successful operation",
597 |             "content": {
598 |               "application/xml": {
599 |                 "schema": {
600 |                   "$ref": "#/components/schemas/Order"
601 |                 }
602 |               },
603 |               "application/json": {
604 |                 "schema": {
605 |                   "$ref": "#/components/schemas/Order"
606 |                 }
607 |               }
608 |             }
609 |           },
610 |           "400": {
611 |             "description": "Invalid ID supplied"
612 |           },
613 |           "404": {
614 |             "description": "Order not found"
615 |           }
616 |         }
617 |       },
618 |       "delete": {
619 |         "tags": [
620 |           "store"
621 |         ],
622 |         "summary": "Delete purchase order by ID",
623 |         "description": "For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors",
624 |         "operationId": "deleteOrder",
625 |         "parameters": [
626 |           {
627 |             "name": "orderId",
628 |             "in": "path",
629 |             "description": "ID of the order that needs to be deleted",
630 |             "required": true,
631 |             "schema": {
632 |               "type": "integer",
633 |               "format": "int64"
634 |             }
635 |           }
636 |         ],
637 |         "responses": {
638 |           "400": {
639 |             "description": "Invalid ID supplied"
640 |           },
641 |           "404": {
642 |             "description": "Order not found"
643 |           }
644 |         }
645 |       }
646 |     },
647 |     "/user": {
648 |       "post": {
649 |         "tags": [
650 |           "user"
651 |         ],
652 |         "summary": "Create user",
653 |         "description": "This can only be done by the logged in user.",
654 |         "operationId": "createUser",
655 |         "requestBody": {
656 |           "description": "Created user object",
657 |           "content": {
658 |             "application/json": {
659 |               "schema": {
660 |                 "$ref": "#/components/schemas/User"
661 |               }
662 |             },
663 |             "application/xml": {
664 |               "schema": {
665 |                 "$ref": "#/components/schemas/User"
666 |               }
667 |             },
668 |             "application/x-www-form-urlencoded": {
669 |               "schema": {
670 |                 "$ref": "#/components/schemas/User"
671 |               }
672 |             }
673 |           }
674 |         },
675 |         "responses": {
676 |           "default": {
677 |             "description": "successful operation",
678 |             "content": {
679 |               "application/json": {
680 |                 "schema": {
681 |                   "$ref": "#/components/schemas/User"
682 |                 }
683 |               },
684 |               "application/xml": {
685 |                 "schema": {
686 |                   "$ref": "#/components/schemas/User"
687 |                 }
688 |               }
689 |             }
690 |           }
691 |         }
692 |       }
693 |     },
694 |     "/user/createWithList": {
695 |       "post": {
696 |         "tags": [
697 |           "user"
698 |         ],
699 |         "summary": "Creates list of users with given input array",
700 |         "description": "Creates list of users with given input array",
701 |         "operationId": "createUsersWithListInput",
702 |         "requestBody": {
703 |           "content": {
704 |             "application/json": {
705 |               "schema": {
706 |                 "type": "array",
707 |                 "items": {
708 |                   "$ref": "#/components/schemas/User"
709 |                 }
710 |               }
711 |             }
712 |           }
713 |         },
714 |         "responses": {
715 |           "200": {
716 |             "description": "Successful operation",
717 |             "content": {
718 |               "application/xml": {
719 |                 "schema": {
720 |                   "$ref": "#/components/schemas/User"
721 |                 }
722 |               },
723 |               "application/json": {
724 |                 "schema": {
725 |                   "$ref": "#/components/schemas/User"
726 |                 }
727 |               }
728 |             }
729 |           },
730 |           "default": {
731 |             "description": "successful operation"
732 |           }
733 |         }
734 |       }
735 |     },
736 |     "/user/login": {
737 |       "get": {
738 |         "tags": [
739 |           "user"
740 |         ],
741 |         "summary": "Logs user into the system",
742 |         "description": "",
743 |         "operationId": "loginUser",
744 |         "parameters": [
745 |           {
746 |             "name": "username",
747 |             "in": "query",
748 |             "description": "The user name for login",
749 |             "required": false,
750 |             "schema": {
751 |               "type": "string"
752 |             }
753 |           },
754 |           {
755 |             "name": "password",
756 |             "in": "query",
757 |             "description": "The password for login in clear text",
758 |             "required": false,
759 |             "schema": {
760 |               "type": "string"
761 |             }
762 |           }
763 |         ],
764 |         "responses": {
765 |           "200": {
766 |             "description": "successful operation",
767 |             "headers": {
768 |               "X-Rate-Limit": {
769 |                 "description": "calls per hour allowed by the user",
770 |                 "schema": {
771 |                   "type": "integer",
772 |                   "format": "int32"
773 |                 }
774 |               },
775 |               "X-Expires-After": {
776 |                 "description": "date in UTC when token expires",
777 |                 "schema": {
778 |                   "type": "string",
779 |                   "format": "date-time"
780 |                 }
781 |               }
782 |             },
783 |             "content": {
784 |               "application/xml": {
785 |                 "schema": {
786 |                   "type": "string"
[TRUNCATED]
```

cmd/internal/openapi/v3/codegen/testdata/prometheus_openapi3.json
```
1 | {
2 |   "openapi": "3.0.1",
3 |   "info": {
4 |     "title": "Prometheus HTTP API",
5 |     "description": "The current stable HTTP API is reachable under /api/v1 on a Prometheus server. Any non-breaking additions will be added under that endpoint.\n\n# Format overview\nThe API response format is JSON. Every successful API request returns a ```2xx``` status code.\n\nInvalid requests that reach the API handlers return a JSON error object and one of the following HTTP response codes:\n\n```400 Bad Request``` when parameters are missing or incorrect.\n```422 Unprocessable Entity``` when an expression can't be executed ([RFC4918](https://datatracker.ietf.org/doc/html/rfc4918#page-78)).\n```503 Service Unavailable``` when queries time out or abort.\n\nOther non-```2xx``` codes may be returned for errors occurring before the API endpoint is reached.\n\nAn array of warnings may be returned if there are errors that do not inhibit the request execution. All of the data that was successfully collected will be returned in the data field.\n\nThe JSON response envelope format is as follows:\n\n```\n{\n  \"status\": \"success\" | \"error\",\n  \"data\": <data>,\n\n  // Only set if status is \"error\". The data field may still hold\n  // additional data.\n  \"errorType\": \"<string>\",\n  \"error\": \"<string>\",\n\n  // Only if there were warnings while executing the request.\n  // There will still be data in the data field.\n  \"warnings\": [\"<string>\"]\n}\n```\n# Generic placeholders:\n\n```<rfc3339 | unix_timestamp>```: Input timestamps may be provided either in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format or as a Unix timestamp in seconds, with optional decimal places for sub-second precision. Output timestamps are always represented as Unix timestamps in seconds.\n\n```<series_selector>```: Prometheus [time series selectors](https://prometheus.io/docs/prometheus/latest/querying/basics/#time-series-selectors) like ```http_requests_total``` or ```http_requests_total{method=~\"(GET|POST)\"}``` and need to be URL-encoded.\n\n```<duration>```: [Prometheus duration strings](https://prometheus.io/docs/prometheus/latest/querying/basics/#time_durations). For example, ```5m``` refers to a duration of 5 minutes.\n\n```<bool>```: boolean values (strings ```true``` and ```false```).\n\n**Note**: Names of query parameters that may be repeated end with ```[]```.\n",
6 |     "version": "v2"
7 |   },
8 |   "servers": [
9 |     {
10 |       "url": "/api/v1"
11 |     }
12 |   ],
13 |   "tags": [
14 |     {
15 |       "name": "Expression query",
16 |       "description": "Query language expressions may be evaluated at a single instant or over a range of time.\n",
17 |       "x-displayName": "Expression queries"
18 |     },
19 |     {
20 |       "name": "Querying metadata",
21 |       "description": "Query metadata about series and their labels.\n",
22 |       "x-displayName": "Querying metadata"
23 |     },
24 |     {
25 |       "name": "Default",
26 |       "x-displayName": "Default"
27 |     },
28 |     {
29 |       "name": "Status",
30 |       "description": "Expose current Prometheus configuration.\n",
31 |       "x-displayName": "Status"
32 |     },
33 |     {
34 |       "name": "TSDB Admin API",
35 |       "description": "Expose database functionalities for the advanced user. \n\nThese APIs are not enabled unless the ```--web.enable-admin-api``` is set.\n",
36 |       "x-displayName": "TSDB Admin APIs"
37 |     }
38 |   ],
39 |   "paths": {
40 |     "/admin/tsdb/clean_tombstones": {
41 |       "put": {
42 |         "tags": [
43 |           "TSDB Admin API"
44 |         ],
45 |         "summary": "Removes deleted data",
46 |         "description": "CleanTombstones removes the deleted data from disk and cleans up the existing tombstones. This can be used after deleting series to free up space.\n\n<i>New in v2.1 and supports PUT from v2.9</i>\n",
47 |         "operationId": "cleanTombstonesPUT",
48 |         "responses": {
49 |           "204": {
50 |             "description": "Successful",
51 |             "content": {}
52 |           }
53 |         }
54 |       },
55 |       "post": {
56 |         "tags": [
57 |           "TSDB Admin API"
58 |         ],
59 |         "summary": "Removes deleted data",
60 |         "description": "CleanTombstones removes the deleted data from disk and cleans up the existing tombstones. This can be used after deleting series to free up space.\n\n<i>New in v2.1 and supports PUT from v2.9</i>\n",
61 |         "operationId": "cleanTombstonesPOST",
62 |         "responses": {
63 |           "204": {
64 |             "description": "Successful",
65 |             "content": {}
66 |           }
67 |         }
68 |       }
69 |     },
70 |     "/admin/tsdb/delete_series": {
71 |       "put": {
72 |         "tags": [
73 |           "TSDB Admin API"
74 |         ],
75 |         "summary": "Deletes selected data",
76 |         "description": "DeleteSeries deletes data for a selection of series in a time range. The actual data still exists on disk and is cleaned up in future compactions or can be explicitly cleaned up by hitting the [Clean Tombstones](https://prometheus.io/docs/prometheus/latest/querying/api/#clean-tombstones) endpoint.\n\nNew in v2.1 and supports PUT from v2.9\n",
77 |         "operationId": "deleteSeriesPUT",
78 |         "parameters": [
79 |           {
80 |             "name": "match[]",
81 |             "in": "query",
82 |             "description": "Repeated label matcher argument that selects the series to delete. At least one match[] argument must be provided.\n\nExample: ```?match[]=up&match[]=process_start_time_seconds{job=\"prometheus\"}'```\n",
83 |             "required": true,
84 |             "schema": {
85 |               "type": "string",
86 |               "format": "series_selector"
87 |             }
88 |           },
89 |           {
90 |             "name": "start",
91 |             "in": "query",
92 |             "description": "Start timestamp. Optional and defaults to minimum possible time.",
93 |             "schema": {
94 |               "type": "string",
95 |               "format": "rfc3339 | unix_timestamp"
96 |             }
97 |           },
98 |           {
99 |             "name": "end",
100 |             "in": "query",
101 |             "description": "End timestamp. Optional and defaults to maximum possible time.\n\nNot mentioning both start and end times would clear all the data for the matched series in the database.\n",
102 |             "schema": {
103 |               "type": "string",
104 |               "format": "rfc3339 | unix_timestamp"
105 |             }
106 |           }
107 |         ],
108 |         "responses": {
109 |           "204": {
110 |             "description": "Successful",
111 |             "content": {}
112 |           }
113 |         }
114 |       },
115 |       "post": {
116 |         "tags": [
117 |           "TSDB Admin API"
118 |         ],
119 |         "summary": "Deletes selected data",
120 |         "description": "DeleteSeries deletes data for a selection of series in a time range. The actual data still exists on disk and is cleaned up in future compactions or can be explicitly cleaned up by hitting the [Clean Tombstones](https://prometheus.io/docs/prometheus/latest/querying/api/#clean-tombstones) endpoint.\n\n---\n**NOTE:** This endpoint marks samples from series as deleted, but will not necessarily prevent associated series metadata from still being returned in metadata queries for the affected time range (even after cleaning tombstones). The exact extent of metadata deletion is an implementation detail that may change in the future.\n\n---\n\nNew in v2.1 and supports PUT from v2.9\n",
121 |         "operationId": "deleteSeriesPOST",
122 |         "parameters": [
123 |           {
124 |             "name": "match[]",
125 |             "in": "query",
126 |             "description": "Repeated label matcher argument that selects the series to delete. At least one match[] argument must be provided.\n\nExample: ```?match[]=up&match[]=process_start_time_seconds{job=\"prometheus\"}'```\n",
127 |             "required": true,
128 |             "schema": {
129 |               "type": "string",
130 |               "format": "series_selector"
131 |             }
132 |           },
133 |           {
134 |             "name": "start",
135 |             "in": "query",
136 |             "description": "Start timestamp. Optional and defaults to minimum possible time.",
137 |             "schema": {
138 |               "type": "string",
139 |               "format": "rfc3339 | unix_timestamp"
140 |             }
141 |           },
142 |           {
143 |             "name": "end",
144 |             "in": "query",
145 |             "description": "End timestamp. Optional and defaults to maximum possible time.\n\nNot mentioning both start and end times would clear all the data for the matched series in the database.\n",
146 |             "schema": {
147 |               "type": "string",
148 |               "format": "rfc3339 | unix_timestamp"
149 |             }
150 |           }
151 |         ],
152 |         "responses": {
153 |           "204": {
154 |             "description": "Successful",
155 |             "content": {}
156 |           }
157 |         }
158 |       }
159 |     },
160 |     "/admin/tsdb/snapshot": {
161 |       "put": {
162 |         "tags": [
163 |           "TSDB Admin API"
164 |         ],
165 |         "summary": "Creates Snapshot of current data",
166 |         "description": "Snapshot creates a snapshot of all current data into ```snapshots/<datetime>-<rand>``` under the TSDB's data directory and returns the directory as response. It will optionally skip snapshotting data that is only present in the head block, and which has not yet been compacted to disk.\n\nNew in v2.1 and supports PUT from v2.9\n",
167 |         "operationId": "snapshotPUT",
168 |         "parameters": [
169 |           {
170 |             "name": "skip_head",
171 |             "in": "query",
172 |             "description": "Skip data present in the head block. Optional.\n",
173 |             "schema": {
174 |               "type": "boolean"
175 |             }
176 |           }
177 |         ],
178 |         "responses": {
179 |           "200": {
180 |             "description": "The snapshot now exists at ```<data-dir>/snapshots/20171210T211224Z-2be650b6d019eb54```",
181 |             "content": {
182 |               "application/json": {
183 |                 "schema": {
184 |                   "$ref": "#/components/schemas/responseSnapshot"
185 |                 },
186 |                 "example": {
187 |                   "status": "success",
188 |                   "data": {
189 |                     "name": "20171210T211224Z-2be650b6d019eb54"
190 |                   }
191 |                 }
192 |               }
193 |             }
194 |           }
195 |         }
196 |       },
197 |       "post": {
198 |         "tags": [
199 |           "TSDB Admin API"
200 |         ],
201 |         "summary": "Creates Snapshot of current data",
202 |         "description": "Snapshot creates a snapshot of all current data into ```snapshots/<datetime>-<rand>``` under the TSDB's data directory and returns the directory as response. It will optionally skip snapshotting data that is only present in the head block, and which has not yet been compacted to disk.\n\nNew in v2.1 and supports PUT from v2.9\n",
203 |         "operationId": "snapshotPOST",
204 |         "parameters": [
205 |           {
206 |             "name": "skip_head",
207 |             "in": "query",
208 |             "description": "Skip data present in the head block. Optional.\n",
209 |             "schema": {
210 |               "type": "boolean"
211 |             }
212 |           }
213 |         ],
214 |         "responses": {
215 |           "200": {
216 |             "description": "The snapshot now exists at ```<data-dir>/snapshots/20171210T211224Z-2be650b6d019eb54```",
217 |             "content": {
218 |               "application/json": {
219 |                 "schema": {
220 |                   "$ref": "#/components/schemas/responseSnapshot"
221 |                 },
222 |                 "example": {
223 |                   "status": "success",
224 |                   "data": {
225 |                     "name": "20171210T211224Z-2be650b6d019eb54"
226 |                   }
227 |                 }
228 |               }
229 |             }
230 |           }
231 |         }
232 |       }
233 |     },
234 |     "/alertmanagers": {
235 |       "get": {
236 |         "tags": [
237 |           "Default"
238 |         ],
239 |         "summary": "Returns current alertmanager discovery",
240 |         "description": "Returns an overview of the current state of the Prometheus alertmanager discovery\n\nBoth the active and dropped Alertmanagers are part of the response.\n",
241 |         "operationId": "alertManagersGET",
242 |         "responses": {
243 |           "200": {
244 |             "description": "Success",
245 |             "content": {
246 |               "application/json": {
247 |                 "schema": {
248 |                   "$ref": "#/components/schemas/AlertmanagerDiscovery"
249 |                 },
250 |                 "example": {
251 |                   "status": "success",
252 |                   "data": {
253 |                     "activeAlertmanagers": [
254 |                       {
255 |                         "url": "http://127.0.0.1:9090/api/v1/alerts"
256 |                       }
257 |                     ],
258 |                     "droppedAlertmanagers": [
259 |                       {
260 |                         "url": "http://127.0.0.1:9093/api/v1/alerts"
261 |                       }
262 |                     ]
263 |                   }
264 |                 }
265 |               }
266 |             }
267 |           }
268 |         }
269 |       }
270 |     },
271 |     "/alerts": {
272 |       "get": {
273 |         "tags": [
274 |           "Default"
275 |         ],
276 |         "summary": "Returns active alerts",
277 |         "description": "The /alerts endpoint returns a list of all active alerts.\n\nAs the /alerts endpoint is fairly new, it does not have the same stability guarantees as the overarching API v1.\n",
278 |         "operationId": "AlertsGET",
279 |         "responses": {
280 |           "200": {
281 |             "description": "Success",
282 |             "content": {
283 |               "application/json": {
284 |                 "schema": {
285 |                   "$ref": "#/components/schemas/Alert"
286 |                 },
287 |                 "example": {
288 |                   "data": {
289 |                     "alerts": [
290 |                       {
291 |                         "activeAt": "2018-07-04T18:27:12.606Z",
292 |                         "annotations": {},
293 |                         "labels": {
294 |                           "alertname": "my-alert"
295 |                         },
296 |                         "state": "firing",
297 |                         "value": 1
298 |                       }
299 |                     ]
300 |                   },
301 |                   "status": "success"
302 |                 }
303 |               }
304 |             }
305 |           }
306 |         }
307 |       }
308 |     },
309 |     "/label/{label_name}/values": {
310 |       "get": {
311 |         "tags": [
312 |           "Querying metadata"
313 |         ],
314 |         "summary": "Returns label values",
315 |         "description": "The following endpoint returns a list of label values for a provided label name\n\nThe ```data``` section of the JSON response is a list of string label values.\n\n---\n**NOTE:** These API endpoints may return metadata for series for which there is no sample within the selected time range, and/or for series whose samples have been marked as deleted via the deletion API endpoint. The exact extent of additionally returned series metadata is an implementation detail that may change in the future.\n\n---\n",
316 |         "operationId": "labelValuesGET",
317 |         "parameters": [
318 |           {
319 |             "name": "label_name",
320 |             "in": "path",
321 |             "description": "Label name\n\nExample: ```/label/job/values```\n",
322 |             "required": true,
323 |             "schema": {
324 |               "type": "string"
325 |             }
326 |           },
327 |           {
328 |             "name": "start",
329 |             "in": "query",
330 |             "description": "Start timestamp. Optional.\n",
331 |             "schema": {
332 |               "type": "string",
333 |               "format": "rfc3339 | unix_timestamp"
334 |             }
335 |           },
336 |           {
337 |             "name": "end",
338 |             "in": "query",
339 |             "description": "End timestamp. Optional.\n",
340 |             "schema": {
341 |               "type": "string",
342 |               "format": "rfc3339 | unix_timestamp"
343 |             }
344 |           },
345 |           {
346 |             "name": "match[]",
347 |             "in": "query",
348 |             "description": "Repeated series selector argument that selects the series from which to read the label values. Optional.\n",
349 |             "schema": {
350 |               "type": "string",
351 |               "format": "series_selector"
352 |             }
353 |           }
354 |         ],
355 |         "responses": {
356 |           "200": {
357 |             "description": "Success\n\nThis example queries for all label values for the job label\n",
358 |             "content": {
359 |               "application/json": {
360 |                 "schema": {
361 |                   "$ref": "#/components/schemas/responseLabelValues"
362 |                 },
363 |                 "example": {
364 |                   "status": "success",
365 |                   "data": [
366 |                     "node",
367 |                     "prometheus"
368 |                   ]
369 |                 }
370 |               }
371 |             }
372 |           }
373 |         }
374 |       }
375 |     },
376 |     "/labels": {
377 |       "get": {
378 |         "tags": [
379 |           "Querying metadata"
380 |         ],
381 |         "summary": "Returns label names",
382 |         "description": "The following endpoint returns a list of label names\n\nThe ```data``` section of the JSON response is a list of string label names.\n\n---\n**NOTE:** These API endpoints may return metadata for series for which there is no sample within the selected time range, and/or for series whose samples have been marked as deleted via the deletion API endpoint. The exact extent of additionally returned series metadata is an implementation detail that may change in the future.\n\n---\n",
383 |         "operationId": "labelNamesGET",
384 |         "parameters": [
385 |           {
386 |             "name": "start",
387 |             "in": "query",
388 |             "description": "Start timestamp. Optional.\n",
389 |             "schema": {
390 |               "type": "string",
391 |               "format": "rfc3339 | unix_timestamp"
392 |             }
393 |           },
394 |           {
395 |             "name": "end",
396 |             "in": "query",
397 |             "description": "End timestamp. Optional.\n",
398 |             "schema": {
399 |               "type": "string",
400 |               "format": "rfc3339 | unix_timestamp"
401 |             }
402 |           },
403 |           {
404 |             "name": "match[]",
405 |             "in": "query",
406 |             "description": "Repeated series selector argument that selects the series from which to read the label values. Optional.\n",
407 |             "schema": {
408 |               "type": "string",
409 |               "format": "series_selector"
410 |             }
411 |           }
412 |         ],
413 |         "responses": {
414 |           "200": {
415 |             "description": "Success",
416 |             "content": {
417 |               "application/json": {
418 |                 "schema": {
419 |                   "$ref": "#/components/schemas/responseLabelNames"
420 |                 },
421 |                 "example": {
422 |                   "status": "success",
423 |                   "data": [
424 |                     "__name__",
425 |                     "call",
426 |                     "code",
427 |                     "config",
428 |                     "dialer_name",
429 |                     "endpoint",
430 |                     "event",
431 |                     "goversion",
432 |                     "handler",
433 |                     "instance",
434 |                     "interval",
435 |                     "job",
436 |                     "le",
437 |                     "listener_name",
438 |                     "name",
439 |                     "quantile",
440 |                     "reason",
441 |                     "role",
442 |                     "scrape_job",
443 |                     "slice",
444 |                     "version"
445 |                   ]
446 |                 }
447 |               }
448 |             }
449 |           }
450 |         }
451 |       },
452 |       "post": {
453 |         "tags": [
454 |           "Querying metadata"
455 |         ],
456 |         "summary": "Returns label names",
457 |         "description": "The following endpoint returns a list of label names\n\nThe ```data``` section of the JSON response is a list of string label names.\n",
458 |         "operationId": "labelNamesPOST",
459 |         "parameters": [
460 |           {
461 |             "name": "start",
462 |             "in": "query",
463 |             "description": "Start timestamp. Optional.\n",
464 |             "schema": {
465 |               "type": "string",
466 |               "format": "rfc3339 | unix_timestamp"
467 |             }
468 |           },
469 |           {
470 |             "name": "end",
471 |             "in": "query",
472 |             "description": "End timestamp. Optional.\n",
473 |             "schema": {
474 |               "type": "string",
475 |               "format": "rfc3339 | unix_timestamp"
476 |             }
477 |           },
478 |           {
479 |             "name": "match[]",
480 |             "in": "query",
481 |             "description": "Repeated series selector argument that selects the series from which to read the label values. Optional.\n",
482 |             "schema": {
483 |               "type": "string",
484 |               "format": "series_selector"
485 |             }
486 |           }
487 |         ],
488 |         "responses": {
489 |           "200": {
490 |             "description": "Success",
491 |             "content": {
[TRUNCATED]
```

cmd/internal/openapi/v3/codegen/testdata/swagger.json
```
1 | {
2 |   "swagger": "2.0",
3 |   "info": {
4 |     "description": "This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.",
5 |     "version": "1.0.6",
6 |     "title": "Swagger Petstore",
7 |     "termsOfService": "http://swagger.io/terms/",
8 |     "contact": {
9 |       "email": "apiteam@swagger.io"
10 |     },
11 |     "license": {
12 |       "name": "Apache 2.0",
13 |       "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
14 |     }
15 |   },
16 |   "host": "petstore.swagger.io",
17 |   "basePath": "/v2",
18 |   "tags": [
19 |     {
20 |       "name": "pet",
21 |       "description": "Everything about your Pets",
22 |       "externalDocs": {
23 |         "description": "Find out more",
24 |         "url": "http://swagger.io"
25 |       }
26 |     },
27 |     {
28 |       "name": "store",
29 |       "description": "Access to Petstore orders"
30 |     },
31 |     {
32 |       "name": "user",
33 |       "description": "Operations about user",
34 |       "externalDocs": {
35 |         "description": "Find out more about our store",
36 |         "url": "http://swagger.io"
37 |       }
38 |     }
39 |   ],
40 |   "schemes": [
41 |     "https",
42 |     "http"
43 |   ],
44 |   "paths": {
45 |     "/pet/{petId}/uploadImage": {
46 |       "post": {
47 |         "tags": [
48 |           "pet"
49 |         ],
50 |         "summary": "uploads an image",
51 |         "description": "",
52 |         "operationId": "uploadFile",
53 |         "consumes": [
54 |           "multipart/form-data"
55 |         ],
56 |         "produces": [
57 |           "application/json"
58 |         ],
59 |         "parameters": [
60 |           {
61 |             "name": "petId",
62 |             "in": "path",
63 |             "description": "ID of pet to update",
64 |             "required": true,
65 |             "type": "integer",
66 |             "format": "int64"
67 |           },
68 |           {
69 |             "name": "additionalMetadata",
70 |             "in": "formData",
71 |             "description": "Additional data to pass to server",
72 |             "required": false,
73 |             "type": "string"
74 |           },
75 |           {
76 |             "name": "file",
77 |             "in": "formData",
78 |             "description": "file to upload",
79 |             "required": false,
80 |             "type": "file"
81 |           }
82 |         ],
83 |         "responses": {
84 |           "200": {
85 |             "description": "successful operation",
86 |             "schema": {
87 |               "$ref": "#/definitions/ApiResponse"
88 |             }
89 |           }
90 |         },
91 |         "security": [
92 |           {
93 |             "petstore_auth": [
94 |               "write:pets",
95 |               "read:pets"
96 |             ]
97 |           }
98 |         ]
99 |       }
100 |     },
101 |     "/pet": {
102 |       "post": {
103 |         "tags": [
104 |           "pet"
105 |         ],
106 |         "summary": "Add a new pet to the store",
107 |         "description": "",
108 |         "operationId": "addPet",
109 |         "consumes": [
110 |           "application/json",
111 |           "application/xml"
112 |         ],
113 |         "produces": [
114 |           "application/json",
115 |           "application/xml"
116 |         ],
117 |         "parameters": [
118 |           {
119 |             "in": "body",
120 |             "name": "body",
121 |             "description": "Pet object that needs to be added to the store",
122 |             "required": true,
123 |             "schema": {
124 |               "$ref": "#/definitions/Pet"
125 |             }
126 |           }
127 |         ],
128 |         "responses": {
129 |           "405": {
130 |             "description": "Invalid input"
131 |           }
132 |         },
133 |         "security": [
134 |           {
135 |             "petstore_auth": [
136 |               "write:pets",
137 |               "read:pets"
138 |             ]
139 |           }
140 |         ]
141 |       },
142 |       "put": {
143 |         "tags": [
144 |           "pet"
145 |         ],
146 |         "summary": "Update an existing pet",
147 |         "description": "",
148 |         "operationId": "updatePet",
149 |         "consumes": [
150 |           "application/json",
151 |           "application/xml"
152 |         ],
153 |         "produces": [
154 |           "application/json",
155 |           "application/xml"
156 |         ],
157 |         "parameters": [
158 |           {
159 |             "in": "body",
160 |             "name": "body",
161 |             "description": "Pet object that needs to be added to the store",
162 |             "required": true,
163 |             "schema": {
164 |               "$ref": "#/definitions/Pet"
165 |             }
166 |           }
167 |         ],
168 |         "responses": {
169 |           "400": {
170 |             "description": "Invalid ID supplied"
171 |           },
172 |           "404": {
173 |             "description": "Pet not found"
174 |           },
175 |           "405": {
176 |             "description": "Validation exception"
177 |           }
178 |         },
179 |         "security": [
180 |           {
181 |             "petstore_auth": [
182 |               "write:pets",
183 |               "read:pets"
184 |             ]
185 |           }
186 |         ]
187 |       }
188 |     },
189 |     "/pet/findByStatus": {
190 |       "get": {
191 |         "tags": [
192 |           "pet"
193 |         ],
194 |         "summary": "Finds Pets by status",
195 |         "description": "Multiple status values can be provided with comma separated strings",
196 |         "operationId": "findPetsByStatus",
197 |         "produces": [
198 |           "application/json",
199 |           "application/xml"
200 |         ],
201 |         "parameters": [
202 |           {
203 |             "name": "status",
204 |             "in": "query",
205 |             "description": "Status values that need to be considered for filter",
206 |             "required": true,
207 |             "type": "array",
208 |             "items": {
209 |               "type": "string",
210 |               "enum": [
211 |                 "available",
212 |                 "pending",
213 |                 "sold"
214 |               ],
215 |               "default": "available"
216 |             },
217 |             "collectionFormat": "multi"
218 |           }
219 |         ],
220 |         "responses": {
221 |           "200": {
222 |             "description": "successful operation",
223 |             "schema": {
224 |               "type": "array",
225 |               "items": {
226 |                 "$ref": "#/definitions/Pet"
227 |               }
228 |             }
229 |           },
230 |           "400": {
231 |             "description": "Invalid status value"
232 |           }
233 |         },
234 |         "security": [
235 |           {
236 |             "petstore_auth": [
237 |               "write:pets",
238 |               "read:pets"
239 |             ]
240 |           }
241 |         ]
242 |       }
243 |     },
244 |     "/pet/findByTags": {
245 |       "get": {
246 |         "tags": [
247 |           "pet"
248 |         ],
249 |         "summary": "Finds Pets by tags",
250 |         "description": "Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.",
251 |         "operationId": "findPetsByTags",
252 |         "produces": [
253 |           "application/json",
254 |           "application/xml"
255 |         ],
256 |         "parameters": [
257 |           {
258 |             "name": "tags",
259 |             "in": "query",
260 |             "description": "Tags to filter by",
261 |             "required": true,
262 |             "type": "array",
263 |             "items": {
264 |               "type": "string"
265 |             },
266 |             "collectionFormat": "multi"
267 |           }
268 |         ],
269 |         "responses": {
270 |           "200": {
271 |             "description": "successful operation",
272 |             "schema": {
273 |               "type": "array",
274 |               "items": {
275 |                 "$ref": "#/definitions/Pet"
276 |               }
277 |             }
278 |           },
279 |           "400": {
280 |             "description": "Invalid tag value"
281 |           }
282 |         },
283 |         "security": [
284 |           {
285 |             "petstore_auth": [
286 |               "write:pets",
287 |               "read:pets"
288 |             ]
289 |           }
290 |         ],
291 |         "deprecated": true
292 |       }
293 |     },
294 |     "/pet/{petId}": {
295 |       "get": {
296 |         "tags": [
297 |           "pet"
298 |         ],
299 |         "summary": "Find pet by ID",
300 |         "description": "Returns a single pet",
301 |         "operationId": "getPetById",
302 |         "produces": [
303 |           "application/json",
304 |           "application/xml"
305 |         ],
306 |         "parameters": [
307 |           {
308 |             "name": "petId",
309 |             "in": "path",
310 |             "description": "ID of pet to return",
311 |             "required": true,
312 |             "type": "integer",
313 |             "format": "int64"
314 |           }
315 |         ],
316 |         "responses": {
317 |           "200": {
318 |             "description": "successful operation",
319 |             "schema": {
320 |               "$ref": "#/definitions/Pet"
321 |             }
322 |           },
323 |           "400": {
324 |             "description": "Invalid ID supplied"
325 |           },
326 |           "404": {
327 |             "description": "Pet not found"
328 |           }
329 |         },
330 |         "security": [
331 |           {
332 |             "api_key": []
333 |           }
334 |         ]
335 |       },
336 |       "post": {
337 |         "tags": [
338 |           "pet"
339 |         ],
340 |         "summary": "Updates a pet in the store with form data",
341 |         "description": "",
342 |         "operationId": "updatePetWithForm",
343 |         "consumes": [
344 |           "application/x-www-form-urlencoded"
345 |         ],
346 |         "produces": [
347 |           "application/json",
348 |           "application/xml"
349 |         ],
350 |         "parameters": [
351 |           {
352 |             "name": "petId",
353 |             "in": "path",
354 |             "description": "ID of pet that needs to be updated",
355 |             "required": true,
356 |             "type": "integer",
357 |             "format": "int64"
358 |           },
359 |           {
360 |             "name": "name",
361 |             "in": "formData",
362 |             "description": "Updated name of the pet",
363 |             "required": false,
364 |             "type": "string"
365 |           },
366 |           {
367 |             "name": "status",
368 |             "in": "formData",
369 |             "description": "Updated status of the pet",
370 |             "required": false,
371 |             "type": "string"
372 |           }
373 |         ],
374 |         "responses": {
375 |           "405": {
376 |             "description": "Invalid input"
377 |           }
378 |         },
379 |         "security": [
380 |           {
381 |             "petstore_auth": [
382 |               "write:pets",
383 |               "read:pets"
384 |             ]
385 |           }
386 |         ]
387 |       },
388 |       "delete": {
389 |         "tags": [
390 |           "pet"
391 |         ],
392 |         "summary": "Deletes a pet",
393 |         "description": "",
394 |         "operationId": "deletePet",
395 |         "produces": [
396 |           "application/json",
397 |           "application/xml"
398 |         ],
399 |         "parameters": [
400 |           {
401 |             "name": "api_key",
402 |             "in": "header",
403 |             "required": false,
404 |             "type": "string"
405 |           },
406 |           {
407 |             "name": "petId",
408 |             "in": "path",
409 |             "description": "Pet id to delete",
410 |             "required": true,
411 |             "type": "integer",
412 |             "format": "int64"
413 |           }
414 |         ],
415 |         "responses": {
416 |           "400": {
417 |             "description": "Invalid ID supplied"
418 |           },
419 |           "404": {
420 |             "description": "Pet not found"
421 |           }
422 |         },
423 |         "security": [
424 |           {
425 |             "petstore_auth": [
426 |               "write:pets",
427 |               "read:pets"
428 |             ]
429 |           }
430 |         ]
431 |       }
432 |     },
433 |     "/store/order": {
434 |       "post": {
435 |         "tags": [
436 |           "store"
437 |         ],
438 |         "summary": "Place an order for a pet",
439 |         "description": "",
440 |         "operationId": "placeOrder",
441 |         "consumes": [
442 |           "application/json"
443 |         ],
444 |         "produces": [
445 |           "application/json",
446 |           "application/xml"
447 |         ],
448 |         "parameters": [
449 |           {
450 |             "in": "body",
451 |             "name": "body",
452 |             "description": "order placed for purchasing the pet",
453 |             "required": true,
454 |             "schema": {
455 |               "$ref": "#/definitions/Order"
456 |             }
457 |           }
458 |         ],
459 |         "responses": {
460 |           "200": {
461 |             "description": "successful operation",
462 |             "schema": {
463 |               "$ref": "#/definitions/Order"
464 |             }
465 |           },
466 |           "400": {
467 |             "description": "Invalid Order"
468 |           }
469 |         }
470 |       }
471 |     },
472 |     "/store/order/{orderId}": {
473 |       "get": {
474 |         "tags": [
475 |           "store"
476 |         ],
477 |         "summary": "Find purchase order by ID",
478 |         "description": "For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions",
479 |         "operationId": "getOrderById",
480 |         "produces": [
481 |           "application/json",
482 |           "application/xml"
483 |         ],
484 |         "parameters": [
485 |           {
486 |             "name": "orderId",
487 |             "in": "path",
488 |             "description": "ID of pet that needs to be fetched",
489 |             "required": true,
490 |             "type": "integer",
491 |             "maximum": 10,
492 |             "minimum": 1,
493 |             "format": "int64"
494 |           }
495 |         ],
496 |         "responses": {
497 |           "200": {
498 |             "description": "successful operation",
499 |             "schema": {
500 |               "$ref": "#/definitions/Order"
501 |             }
502 |           },
503 |           "400": {
504 |             "description": "Invalid ID supplied"
505 |           },
506 |           "404": {
507 |             "description": "Order not found"
508 |           }
509 |         }
510 |       },
511 |       "delete": {
512 |         "tags": [
513 |           "store"
514 |         ],
515 |         "summary": "Delete purchase order by ID",
516 |         "description": "For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors",
517 |         "operationId": "deleteOrder",
518 |         "produces": [
519 |           "application/json",
520 |           "application/xml"
521 |         ],
522 |         "parameters": [
523 |           {
524 |             "name": "orderId",
525 |             "in": "path",
526 |             "description": "ID of the order that needs to be deleted",
527 |             "required": true,
528 |             "type": "integer",
529 |             "minimum": 1,
530 |             "format": "int64"
531 |           }
532 |         ],
533 |         "responses": {
534 |           "400": {
535 |             "description": "Invalid ID supplied"
536 |           },
537 |           "404": {
538 |             "description": "Order not found"
539 |           }
540 |         }
541 |       }
542 |     },
543 |     "/store/inventory": {
544 |       "get": {
545 |         "tags": [
546 |           "store"
547 |         ],
548 |         "summary": "Returns pet inventories by status",
549 |         "description": "Returns a map of status codes to quantities",
550 |         "operationId": "getInventory",
551 |         "produces": [
552 |           "application/json"
553 |         ],
554 |         "parameters": [],
555 |         "responses": {
556 |           "200": {
557 |             "description": "successful operation",
558 |             "schema": {
559 |               "type": "object",
560 |               "additionalProperties": {
561 |                 "type": "integer",
562 |                 "format": "int32"
563 |               }
564 |             }
565 |           }
566 |         },
567 |         "security": [
568 |           {
569 |             "api_key": []
570 |           }
571 |         ]
572 |       }
573 |     },
574 |     "/user/createWithArray": {
575 |       "post": {
576 |         "tags": [
577 |           "user"
578 |         ],
579 |         "summary": "Creates list of users with given input array",
580 |         "description": "",
581 |         "operationId": "createUsersWithArrayInput",
582 |         "consumes": [
583 |           "application/json"
584 |         ],
585 |         "produces": [
586 |           "application/json",
587 |           "application/xml"
588 |         ],
589 |         "parameters": [
590 |           {
591 |             "in": "body",
592 |             "name": "body",
593 |             "description": "List of user object",
594 |             "required": true,
595 |             "schema": {
596 |               "type": "array",
597 |               "items": {
598 |                 "$ref": "#/definitions/User"
599 |               }
600 |             }
601 |           }
602 |         ],
603 |         "responses": {
604 |           "default": {
605 |             "description": "successful operation"
606 |           }
607 |         }
608 |       }
609 |     },
610 |     "/user/createWithList": {
611 |       "post": {
612 |         "tags": [
613 |           "user"
614 |         ],
615 |         "summary": "Creates list of users with given input array",
616 |         "description": "",
617 |         "operationId": "createUsersWithListInput",
618 |         "consumes": [
619 |           "application/json"
620 |         ],
621 |         "produces": [
622 |           "application/json",
623 |           "application/xml"
624 |         ],
625 |         "parameters": [
626 |           {
627 |             "in": "body",
628 |             "name": "body",
629 |             "description": "List of user object",
630 |             "required": true,
631 |             "schema": {
632 |               "type": "array",
633 |               "items": {
634 |                 "$ref": "#/definitions/User"
635 |               }
636 |             }
637 |           }
638 |         ],
639 |         "responses": {
640 |           "default": {
641 |             "description": "successful operation"
642 |           }
643 |         }
644 |       }
645 |     },
646 |     "/user/{username}": {
647 |       "get": {
648 |         "tags": [
649 |           "user"
650 |         ],
651 |         "summary": "Get user by user name",
652 |         "description": "",
653 |         "operationId": "getUserByName",
654 |         "produces": [
655 |           "application/json",
656 |           "application/xml"
657 |         ],
658 |         "parameters": [
659 |           {
660 |             "name": "username",
661 |             "in": "path",
662 |             "description": "The name that needs to be fetched. Use user1 for testing. ",
663 |             "required": true,
664 |             "type": "string"
665 |           }
666 |         ],
667 |         "responses": {
668 |           "200": {
669 |             "description": "successful operation",
670 |             "schema": {
671 |               "$ref": "#/definitions/User"
672 |             }
673 |           },
674 |           "400": {
675 |             "description": "Invalid username supplied"
676 |           },
677 |           "404": {
678 |             "description": "User not found"
679 |           }
680 |         }
681 |       },
682 |       "put": {
683 |         "tags": [
684 |           "user"
685 |         ],
686 |         "summary": "Updated user",
687 |         "description": "This can only be done by the logged in user.",
688 |         "operationId": "updateUser",
689 |         "consumes": [
690 |           "application/json"
691 |         ],
692 |         "produces": [
693 |           "application/json",
694 |           "application/xml"
695 |         ],
696 |         "parameters": [
697 |           {
698 |             "name": "username",
699 |             "in": "path",
700 |             "description": "name that need to be updated",
701 |             "required": true,
702 |             "type": "string"
703 |           },
704 |           {
705 |             "in": "body",
706 |             "name": "body",
707 |             "description": "Updated user object",
708 |             "required": true,
709 |             "schema": {
710 |               "$ref": "#/definitions/User"
711 |             }
712 |           }
713 |         ],
714 |         "responses": {
715 |           "400": {
716 |             "description": "Invalid user supplied"
717 |           },
718 |           "404": {
719 |             "description": "User not found"
720 |           }
721 |         }
722 |       },
723 |       "delete": {
724 |         "tags": [
725 |           "user"
726 |         ],
727 |         "summary": "Delete user",
728 |         "description": "This can only be done by the logged in user.",
729 |         "operationId": "deleteUser",
730 |         "produces": [
731 |           "application/json",
732 |           "application/xml"
733 |         ],
734 |         "parameters": [
735 |           {
736 |             "name": "username",
737 |             "in": "path",
738 |             "description": "The name that needs to be deleted",
739 |             "required": true,
740 |             "type": "string"
741 |           }
742 |         ],
743 |         "responses": {
744 |           "400": {
745 |             "description": "Invalid username supplied"
746 |           },
747 |           "404": {
748 |             "description": "User not found"
749 |           }
750 |         }
751 |       }
752 |     },
753 |     "/user/login": {
754 |       "get": {
755 |         "tags": [
756 |           "user"
757 |         ],
758 |         "summary": "Logs user into the system",
759 |         "description": "",
760 |         "operationId": "loginUser",
761 |         "produces": [
762 |           "application/json",
763 |           "application/xml"
764 |         ],
765 |         "parameters": [
766 |           {
767 |             "name": "username",
768 |             "in": "query",
769 |             "description": "The user name for login",
770 |             "required": true,
771 |             "type": "string"
772 |           },
773 |           {
774 |             "name": "password",
775 |             "in": "query",
776 |             "description": "The password for login in clear text",
777 |             "required": true,
778 |             "type": "string"
779 |           }
780 |         ],
781 |         "responses": {
782 |           "200": {
783 |             "description": "successful operation",
784 |             "headers": {
785 |               "X-Expires-After": {
786 |                 "type": "string",
787 |                 "format": "date-time",
788 |                 "description": "date in UTC when token expires"
789 |               },
790 |               "X-Rate-Limit": {
791 |                 "type": "integer",
792 |                 "format": "int32",
793 |                 "description": "calls per hour allowed by the user"
794 |               }
795 |             },
796 |             "schema": {
[TRUNCATED]
```

cmd/internal/openapi/v3/codegen/testdata/test1.json
```
1 | {
2 |   "openapi": "3.0.2",
3 |   "info": {
4 |     "title": "Swagger Petstore - OpenAPI 3.0",
5 |     "description": "This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\nSwagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\nYou can now help us improve the API whether it's by making changes to the definition itself or to the code.\nThat way, with time, we can improve the API in general, and expose some of the new features in OAS3.\n\nSome useful links:\n- [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\n- [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)",
6 |     "termsOfService": "http://swagger.io/terms/",
7 |     "contact": {
8 |       "email": "apiteam@swagger.io"
9 |     },
10 |     "license": {
11 |       "name": "Apache 2.0",
12 |       "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
13 |     },
14 |     "version": "1.0.5"
15 |   },
16 |   "externalDocs": {
17 |     "description": "Find out more about Swagger",
18 |     "url": "http://swagger.io"
19 |   },
20 |   "servers": [
21 |     {
22 |       "url": "/api/v3"
23 |     }
24 |   ],
25 |   "tags": [
26 |     {
27 |       "name": "pet",
28 |       "description": "Everything about your Pets",
29 |       "externalDocs": {
30 |         "description": "Find out more",
31 |         "url": "http://swagger.io"
32 |       }
33 |     },
34 |     {
35 |       "name": "store",
36 |       "description": "Operations about user"
37 |     },
38 |     {
39 |       "name": "user",
40 |       "description": "Access to Petstore orders",
41 |       "externalDocs": {
42 |         "description": "Find out more about our store",
43 |         "url": "http://swagger.io"
44 |       }
45 |     }
46 |   ],
47 |   "paths": {
48 |     "/unipay/startUnionPay": {
49 |       "get": {
50 |         "description": "",
51 |         "parameters": [
52 |           {
53 |             "name": "txnAmt",
54 |             "in": "query",
55 |             "required": true,
56 |             "schema": {
57 |               "type": "string"
58 |             }
59 |           },
60 |           {
61 |             "name": "token",
62 |             "in": "query",
63 |             "required": true,
64 |             "description": "token",
65 |             "schema": {
66 |               "type": "string"
67 |             }
68 |           },
69 |           {
70 |             "name": "companyId",
71 |             "in": "query",
72 |             "required": true,
73 |             "schema": {
74 |               "type": "string"
75 |             }
76 |           },
77 |           {
78 |             "name": "frontUrl",
79 |             "in": "query",
80 |             "required": true,
81 |             "schema": {
82 |               "type": "string"
83 |             }
84 |           }
85 |         ],
86 |         "responses": {
87 |           "200": {
88 |             "description": "successful operation",
89 |             "content": {
90 |               "*/*": {
91 |                 "schema": {
92 |                   "type": "string",
93 |                   "description": "html"
94 |                 }
95 |               }
96 |             }
97 |           }
98 |         }
99 |       }
100 |     }
101 |   },
102 |   "components": {
103 |     "schemas": {
104 |       "Order": {
105 |         "type": "object",
106 |         "properties": {
107 |           "id": {
108 |             "type": "integer",
109 |             "format": "int64",
110 |             "example": 10
111 |           },
112 |           "petId": {
113 |             "type": "integer",
114 |             "format": "int64",
115 |             "example": 198772
116 |           },
117 |           "quantity": {
118 |             "type": "integer",
119 |             "format": "int32",
120 |             "example": 7
121 |           },
122 |           "shipDate": {
123 |             "type": "string",
124 |             "format": "date-time"
125 |           },
126 |           "status": {
127 |             "type": "string",
128 |             "description": "Order Status",
129 |             "example": "approved",
130 |             "enum": [
131 |               "placed",
132 |               "approved",
133 |               "delivered"
134 |             ]
135 |           },
136 |           "complete": {
137 |             "type": "boolean"
138 |           },
139 |           "customer": {
140 |             "type": "object",
141 |             "description": "客户信息结构体\n用于描述客户相关的信息",
142 |             "properties": {
143 |               "id": {
144 |                 "type": "integer",
145 |                 "format": "int64",
146 |                 "example": 100000,
147 |                 "description": "用户ID"
148 |               },
149 |               "username": {
150 |                 "type": "string",
151 |                 "example": "fehguy",
152 |                 "description": "用户名"
153 |               },
154 |               "address": {
155 |                 "type": "array",
156 |                 "xml": {
157 |                   "name": "addresses",
158 |                   "wrapped": true
159 |                 },
160 |                 "items": {
161 |                   "$ref": "#/components/schemas/Address"
162 |                 },
163 |                 "description": "用户地址\n例如：北京海淀区xxx街道\n某某小区"
164 |               }
165 |             },
166 |             "xml": {
167 |               "name": "customer"
168 |             }
169 |           }
170 |         },
171 |         "xml": {
172 |           "name": "order"
173 |         }
174 |       },
175 |       "Customer": {
176 |         "type": "object",
177 |         "properties": {
178 |           "id": {
179 |             "type": "integer",
180 |             "format": "int64",
181 |             "example": 100000
182 |           },
183 |           "username": {
184 |             "type": "string",
185 |             "example": "fehguy"
186 |           },
187 |           "address": {
188 |             "type": "array",
189 |             "xml": {
190 |               "name": "addresses",
191 |               "wrapped": true
192 |             },
193 |             "items": {
194 |               "$ref": "#/components/schemas/Address"
195 |             }
196 |           }
197 |         },
198 |         "xml": {
199 |           "name": "customer"
200 |         }
201 |       },
202 |       "Address": {
203 |         "type": "object",
204 |         "properties": {
205 |           "street": {
206 |             "type": "string",
207 |             "example": "437 Lytton"
208 |           },
209 |           "city": {
210 |             "type": "string",
211 |             "example": "Palo Alto"
212 |           },
213 |           "state": {
214 |             "type": "string",
215 |             "example": "CA"
216 |           },
217 |           "zip": {
218 |             "type": "string",
219 |             "example": "94301"
220 |           }
221 |         },
222 |         "xml": {
223 |           "name": "address"
224 |         }
225 |       },
226 |       "Category": {
227 |         "type": "object",
228 |         "properties": {
229 |           "id": {
230 |             "type": "integer",
231 |             "format": "int64",
232 |             "example": 1
233 |           },
234 |           "name": {
235 |             "type": "string",
236 |             "example": "Dogs"
237 |           }
238 |         },
239 |         "xml": {
240 |           "name": "category"
241 |         }
242 |       },
243 |       "User": {
244 |         "type": "object",
245 |         "properties": {
246 |           "id": {
247 |             "type": "integer",
248 |             "format": "int64",
249 |             "example": 10
250 |           },
251 |           "username": {
252 |             "type": "string",
253 |             "example": "theUser"
254 |           },
255 |           "firstName": {
256 |             "type": "string",
257 |             "example": "John"
258 |           },
259 |           "lastName": {
260 |             "type": "string",
261 |             "example": "James"
262 |           },
263 |           "email": {
264 |             "type": "string",
265 |             "example": "john@email.com"
266 |           },
267 |           "password": {
268 |             "type": "string",
269 |             "example": "12345"
270 |           },
271 |           "phone": {
272 |             "type": "string",
273 |             "example": "12345"
274 |           },
275 |           "userStatus": {
276 |             "type": "integer",
277 |             "description": "User Status",
278 |             "format": "int32",
279 |             "example": 1
280 |           },
281 |           "avatar": {
282 |             "type": "string",
283 |             "format": "binary"
284 |           },
285 |           "additional1": {
286 |             "type": "object",
287 |             "additionalProperties": {
288 |               "type": "string",
289 |               "format": "int64"
290 |             }
291 |           },
292 |           "additional2": {
293 |             "type": "object",
294 |             "additionalProperties": {
295 |               "$ref": "#/components/schemas/Tag"
296 |             }
297 |           }
298 |         },
299 |         "xml": {
300 |           "name": "user"
301 |         }
302 |       },
303 |       "Tag": {
304 |         "type": "object",
305 |         "properties": {
306 |           "id": {
307 |             "type": "integer",
308 |             "format": "int64"
309 |           },
310 |           "name": {
311 |             "type": "string",
312 |             "format": "tag"
313 |           }
314 |         },
315 |         "xml": {
316 |           "name": "tag"
317 |         }
318 |       },
319 |       "Pet": {
320 |         "required": [
321 |           "name",
322 |           "photoUrls"
323 |         ],
324 |         "type": "object",
325 |         "properties": {
326 |           "id": {
327 |             "type": "integer",
328 |             "format": "int64",
329 |             "example": 10
330 |           },
331 |           "name": {
332 |             "type": "string",
333 |             "example": "doggie",
334 |             "format": "dog"
335 |           },
336 |           "category": {
337 |             "$ref": "#/components/schemas/Category"
338 |           },
339 |           "photoUrls": {
340 |             "type": "array",
341 |             "xml": {
342 |               "wrapped": true
343 |             },
344 |             "items": {
345 |               "type": "string",
346 |               "xml": {
347 |                 "name": "photoUrl"
348 |               },
349 |               "format": "image"
350 |             }
351 |           },
352 |           "tags": {
353 |             "type": "array",
354 |             "xml": {
355 |               "wrapped": true
356 |             },
357 |             "items": {
358 |               "$ref": "#/components/schemas/Tag"
359 |             }
360 |           },
361 |           "status": {
362 |             "type": "string",
363 |             "description": "pet status in the store\nthis is another line for test use",
364 |             "enum": [
365 |               "available",
366 |               "pending",
367 |               "sold"
368 |             ]
369 |           }
370 |         },
371 |         "xml": {
372 |           "name": "pet"
373 |         }
374 |       },
375 |       "ApiResponse": {
376 |         "type": "object",
377 |         "properties": {
378 |           "code": {
379 |             "type": "integer",
380 |             "format": "int32"
381 |           },
382 |           "type": {
383 |             "type": "string"
384 |           },
385 |           "message": {
386 |             "type": "string"
387 |           }
388 |         },
389 |         "xml": {
390 |           "name": "##default"
391 |         }
392 |       }
393 |     },
394 |     "requestBodies": {
395 |       "Pet": {
396 |         "description": "Pet object that needs to be added to the store",
397 |         "content": {
398 |           "application/json": {
399 |             "schema": {
400 |               "$ref": "#/components/schemas/Pet"
401 |             }
402 |           },
403 |           "application/xml": {
404 |             "schema": {
405 |               "$ref": "#/components/schemas/Pet"
406 |             }
407 |           }
408 |         }
409 |       },
410 |       "UserArray": {
411 |         "description": "List of user object",
412 |         "content": {
413 |           "application/json": {
414 |             "schema": {
415 |               "type": "array",
416 |               "items": {
417 |                 "$ref": "#/components/schemas/User"
418 |               }
419 |             }
420 |           }
421 |         }
422 |       }
423 |     },
424 |     "securitySchemes": {
425 |       "petstore_auth": {
426 |         "type": "oauth2",
427 |         "flows": {
428 |           "implicit": {
429 |             "authorizationUrl": "https://petstore3.swagger.io/oauth/authorize",
430 |             "scopes": {
431 |               "write:pets": "modify pets in your account",
432 |               "read:pets": "read your pets"
433 |             }
434 |           }
435 |         }
436 |       },
437 |       "api_key": {
438 |         "type": "apiKey",
439 |         "name": "api_key",
440 |         "in": "header"
441 |       }
442 |     }
443 |   }
444 | }
```

cmd/internal/openapi/v3/codegen/testdata/test2.json
```
1 | {
2 |   "openapi": "3.0.2",
3 |   "info": {
4 |     "title": "Swagger Petstore - OpenAPI 3.0",
5 |     "description": "This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\nSwagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\nYou can now help us improve the API whether it's by making changes to the definition itself or to the code.\nThat way, with time, we can improve the API in general, and expose some of the new features in OAS3.\n\nSome useful links:\n- [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\n- [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)",
6 |     "termsOfService": "http://swagger.io/terms/",
7 |     "contact": {
8 |       "email": "apiteam@swagger.io"
9 |     },
10 |     "license": {
11 |       "name": "Apache 2.0",
12 |       "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
13 |     },
14 |     "version": "1.0.5"
15 |   },
16 |   "externalDocs": {
17 |     "description": "Find out more about Swagger",
18 |     "url": "http://swagger.io"
19 |   },
20 |   "servers": [
21 |     {
22 |       "url": "/api/v3"
23 |     }
24 |   ],
25 |   "tags": [
26 |     {
27 |       "name": "pet",
28 |       "description": "Everything about your Pets",
29 |       "externalDocs": {
30 |         "description": "Find out more",
31 |         "url": "http://swagger.io"
32 |       }
33 |     },
34 |     {
35 |       "name": "store",
36 |       "description": "Operations about user"
37 |     },
38 |     {
39 |       "name": "user",
40 |       "description": "Access to Petstore orders",
41 |       "externalDocs": {
42 |         "description": "Find out more about our store",
43 |         "url": "http://swagger.io"
44 |       }
45 |     }
46 |   ],
47 |   "paths": {
48 |     "/user": {
49 |       "delete": {
50 |         "tags": [
51 |           "user"
52 |         ],
53 |         "summary": "Delete user",
54 |         "description": "This can only be done by the logged in user.",
55 |         "requestBody": {
56 |           "description": "Delete user object",
57 |           "content": {
58 |             "application/json": {
59 |               "schema": {
60 |                 "$ref": "#/components/schemas/User"
61 |               }
62 |             }
63 |           }
64 |         },
65 |         "responses": {
66 |           "default": {
67 |             "description": "successful operation",
68 |             "content": {
69 |               "application/json": {
70 |                 "schema": {
71 |                   "$ref": "#/components/schemas/User"
72 |                 }
73 |               }
74 |             }
75 |           }
76 |         }
77 |       },
78 |       "post": {
79 |         "tags": [
80 |           "user"
81 |         ],
82 |         "summary": "Create user",
83 |         "description": "This can only be done by the logged in user.",
84 |         "operationId": "createUser",
85 |         "requestBody": {
86 |           "description": "Created user object",
87 |           "content": {
88 |             "application/json": {
89 |               "schema": {
90 |                 "$ref": "#/components/schemas/User"
91 |               }
92 |             },
93 |             "application/xml": {
94 |               "schema": {
95 |                 "$ref": "#/components/schemas/User"
96 |               }
97 |             },
98 |             "application/x-www-form-urlencoded": {
99 |               "schema": {
100 |                 "$ref": "#/components/schemas/User"
101 |               }
102 |             }
103 |           }
104 |         },
105 |         "responses": {
106 |           "default": {
107 |             "description": "successful operation",
108 |             "content": {
109 |               "application/json": {
110 |                 "schema": {
111 |                   "$ref": "#/components/schemas/User"
112 |                 }
113 |               },
114 |               "application/xml": {
115 |                 "schema": {
116 |                   "$ref": "#/components/schemas/User"
117 |                 }
118 |               }
119 |             }
120 |           }
121 |         }
122 |       }
123 |     },
124 |     "/user/createWithList": {
125 |       "post": {
126 |         "tags": [
127 |           "user"
128 |         ],
129 |         "summary": "Creates list of users with given input array",
130 |         "description": "Creates list of users with given input array",
131 |         "operationId": "createUsersWithListInput",
132 |         "requestBody": {
133 |           "content": {
134 |             "application/json": {
135 |               "schema": {
136 |                 "type": "array",
137 |                 "items": {
138 |                   "$ref": "#/components/schemas/User"
139 |                 }
140 |               }
141 |             }
142 |           }
143 |         },
144 |         "responses": {
145 |           "200": {
146 |             "description": "Successful operation",
147 |             "content": {
148 |               "application/xml": {
149 |                 "schema": {
150 |                   "$ref": "#/components/schemas/User"
151 |                 }
152 |               },
153 |               "application/json": {
154 |                 "schema": {
155 |                   "$ref": "#/components/schemas/User"
156 |                 }
157 |               }
158 |             }
159 |           },
160 |           "default": {
161 |             "description": "successful operation"
162 |           }
163 |         }
164 |       }
165 |     },
166 |     "/user/login": {
167 |       "get": {
168 |         "tags": [
169 |           "user"
170 |         ],
171 |         "summary": "Logs user into the system",
172 |         "description": "",
173 |         "operationId": "loginUser",
174 |         "parameters": [
175 |           {
176 |             "name": "username",
177 |             "in": "query",
178 |             "description": "The user name for login",
179 |             "required": false,
180 |             "schema": {
181 |               "type": "string"
182 |             }
183 |           },
184 |           {
185 |             "name": "password",
186 |             "in": "query",
187 |             "description": "The password for login in clear text",
188 |             "required": false,
189 |             "schema": {
190 |               "type": "string"
191 |             }
192 |           }
193 |         ],
194 |         "responses": {
195 |           "200": {
196 |             "description": "successful operation",
197 |             "headers": {
198 |               "X-Rate-Limit": {
199 |                 "description": "calls per hour allowed by the user",
200 |                 "schema": {
201 |                   "type": "integer",
202 |                   "format": "int32"
203 |                 }
204 |               },
205 |               "X-Expires-After": {
206 |                 "description": "date in UTC when toekn expires",
207 |                 "schema": {
208 |                   "type": "string",
209 |                   "format": "date-time"
210 |                 }
211 |               }
212 |             },
213 |             "content": {
214 |               "application/xml": {
215 |                 "schema": {
216 |                   "type": "string"
217 |                 }
218 |               },
219 |               "application/json": {
220 |                 "schema": {
221 |                   "type": "string"
222 |                 }
223 |               }
224 |             }
225 |           },
226 |           "400": {
227 |             "description": "Invalid username/password supplied"
228 |           }
229 |         }
230 |       }
231 |     },
232 |     "/user/logout": {
233 |       "get": {
234 |         "tags": [
235 |           "user"
236 |         ],
237 |         "summary": "Logs out current logged in user session",
238 |         "description": "",
239 |         "operationId": "logoutUser",
240 |         "parameters": [],
241 |         "responses": {
242 |           "default": {
243 |             "description": "successful operation"
244 |           }
245 |         }
246 |       }
247 |     },
248 |     "/user/{username}": {
249 |       "get": {
250 |         "tags": [
251 |           "user"
252 |         ],
253 |         "summary": "Get user by user name",
254 |         "description": "",
255 |         "operationId": "getUserByName",
256 |         "parameters": [
257 |           {
258 |             "name": "username",
259 |             "in": "path",
260 |             "description": "The name that needs to be fetched. Use user1 for testing. ",
261 |             "required": true,
262 |             "schema": {
263 |               "type": "string"
264 |             }
265 |           }
266 |         ],
267 |         "responses": {
268 |           "200": {
269 |             "description": "successful operation",
270 |             "content": {
271 |               "application/xml": {
272 |                 "schema": {
273 |                   "$ref": "#/components/schemas/User"
274 |                 }
275 |               },
276 |               "application/json": {
277 |                 "schema": {
278 |                   "$ref": "#/components/schemas/User"
279 |                 }
280 |               }
281 |             }
282 |           },
283 |           "400": {
284 |             "description": "Invalid username supplied"
285 |           },
286 |           "404": {
287 |             "description": "User not found"
288 |           }
289 |         }
290 |       },
291 |       "put": {
292 |         "tags": [
293 |           "user"
294 |         ],
295 |         "summary": "Update user",
296 |         "description": "This can only be done by the logged in user.",
297 |         "operationId": "updateUser",
298 |         "parameters": [
299 |           {
300 |             "name": "username",
301 |             "in": "path",
302 |             "description": "name that need to be deleted",
303 |             "required": true,
304 |             "schema": {
305 |               "type": "string"
306 |             }
307 |           }
308 |         ],
309 |         "requestBody": {
310 |           "description": "Update an existent user in the store",
311 |           "content": {
312 |             "application/json": {
313 |               "schema": {
314 |                 "$ref": "#/components/schemas/User"
315 |               }
316 |             },
317 |             "application/xml": {
318 |               "schema": {
319 |                 "$ref": "#/components/schemas/User"
320 |               }
321 |             },
322 |             "application/x-www-form-urlencoded": {
323 |               "schema": {
324 |                 "$ref": "#/components/schemas/User"
325 |               }
326 |             }
327 |           }
328 |         },
329 |         "responses": {
330 |           "default": {
331 |             "description": "successful operation"
332 |           }
333 |         }
334 |       },
335 |       "delete": {
336 |         "tags": [
337 |           "user"
338 |         ],
339 |         "summary": "Delete user",
340 |         "description": "This can only be done by the logged in user.",
341 |         "operationId": "deleteUser",
342 |         "parameters": [
343 |           {
344 |             "name": "username",
345 |             "in": "path",
346 |             "description": "The name that needs to be deleted",
347 |             "required": true,
348 |             "schema": {
349 |               "type": "string"
350 |             }
351 |           }
352 |         ],
353 |         "responses": {
354 |           "400": {
355 |             "description": "Invalid username supplied"
356 |           },
357 |           "404": {
358 |             "description": "User not found"
359 |           }
360 |         }
361 |       }
362 |     }
363 |   },
364 |   "components": {
365 |     "schemas": {
366 |       "Order": {
367 |         "type": "object",
368 |         "properties": {
369 |           "id": {
370 |             "type": "integer",
371 |             "format": "int64",
372 |             "example": 10
373 |           },
374 |           "petId": {
375 |             "type": "integer",
376 |             "format": "int64",
377 |             "example": 198772
378 |           },
379 |           "quantity": {
380 |             "type": "integer",
381 |             "format": "int32",
382 |             "example": 7
383 |           },
384 |           "shipDate": {
385 |             "type": "string",
386 |             "format": "date-time"
387 |           },
388 |           "status": {
389 |             "type": "string",
390 |             "description": "Order Status",
391 |             "example": "approved",
392 |             "enum": [
393 |               "placed",
394 |               "approved",
395 |               "delivered"
396 |             ]
397 |           },
398 |           "complete": {
399 |             "type": "boolean"
400 |           },
401 |           "customer": {
402 |             "type": "object",
403 |             "description": "客户信息结构体\n用于描述客户相关的信息",
404 |             "properties": {
405 |               "id": {
406 |                 "type": "integer",
407 |                 "format": "int64",
408 |                 "example": 100000,
409 |                 "description": "用户ID"
410 |               },
411 |               "username": {
412 |                 "type": "string",
413 |                 "example": "fehguy",
414 |                 "description": "用户名"
415 |               },
416 |               "address": {
417 |                 "type": "array",
418 |                 "xml": {
419 |                   "name": "addresses",
420 |                   "wrapped": true
421 |                 },
422 |                 "items": {
423 |                   "$ref": "#/components/schemas/Address"
424 |                 },
425 |                 "description": "用户地址\n例如：北京海淀区xxx街道\n某某小区"
426 |               }
427 |             },
428 |             "xml": {
429 |               "name": "customer"
430 |             }
431 |           }
432 |         },
433 |         "xml": {
434 |           "name": "order"
435 |         }
436 |       },
437 |       "Customer": {
438 |         "type": "object",
439 |         "properties": {
440 |           "id": {
441 |             "type": "integer",
442 |             "format": "int64",
443 |             "example": 100000
444 |           },
445 |           "username": {
446 |             "type": "string",
447 |             "example": "fehguy"
448 |           },
449 |           "address": {
450 |             "type": "array",
451 |             "xml": {
452 |               "name": "addresses",
453 |               "wrapped": true
454 |             },
455 |             "items": {
456 |               "$ref": "#/components/schemas/Address"
457 |             }
458 |           }
459 |         },
460 |         "xml": {
461 |           "name": "customer"
462 |         }
463 |       },
464 |       "Address": {
465 |         "type": "object",
466 |         "properties": {
467 |           "street": {
468 |             "type": "string",
469 |             "example": "437 Lytton"
470 |           },
471 |           "city": {
472 |             "type": "string",
473 |             "example": "Palo Alto"
474 |           },
475 |           "state": {
476 |             "type": "string",
477 |             "example": "CA"
478 |           },
479 |           "zip": {
480 |             "type": "string",
481 |             "example": "94301"
482 |           }
483 |         },
484 |         "xml": {
485 |           "name": "address"
486 |         }
487 |       },
488 |       "Category": {
489 |         "type": "object",
490 |         "properties": {
491 |           "id": {
492 |             "type": "integer",
493 |             "format": "int64",
494 |             "example": 1
495 |           },
496 |           "name": {
497 |             "type": "string",
498 |             "example": "Dogs"
499 |           }
500 |         },
501 |         "xml": {
502 |           "name": "category"
503 |         }
504 |       },
505 |       "User": {
506 |         "type": "object",
507 |         "properties": {
508 |           "id": {
509 |             "type": "integer",
510 |             "format": "int64",
511 |             "example": 10
512 |           },
513 |           "username": {
514 |             "type": "string",
515 |             "example": "theUser"
516 |           },
517 |           "firstName": {
518 |             "type": "string",
519 |             "example": "John"
520 |           },
521 |           "lastName": {
522 |             "type": "string",
523 |             "example": "James"
524 |           },
525 |           "email": {
526 |             "type": "string",
527 |             "example": "john@email.com"
528 |           },
529 |           "password": {
530 |             "type": "string",
531 |             "example": "12345"
532 |           },
533 |           "phone": {
534 |             "type": "string",
535 |             "example": "12345"
536 |           },
537 |           "userStatus": {
538 |             "type": "integer",
539 |             "description": "User Status",
540 |             "format": "int32",
541 |             "example": 1
542 |           },
543 |           "avatar": {
544 |             "type": "string",
545 |             "format": "binary"
546 |           },
547 |           "additional1": {
548 |             "type": "object",
549 |             "additionalProperties": {
550 |               "type": "string",
551 |               "format": "int64"
552 |             }
553 |           },
554 |           "additional2": {
555 |             "type": "object",
556 |             "additionalProperties": {
557 |               "$ref": "#/components/schemas/Tag"
558 |             }
559 |           }
560 |         },
561 |         "xml": {
562 |           "name": "user"
563 |         }
564 |       },
565 |       "Tag": {
566 |         "type": "object",
567 |         "properties": {
568 |           "id": {
569 |             "type": "integer",
570 |             "format": "int64"
571 |           },
572 |           "name": {
573 |             "type": "string",
574 |             "format": "tag"
575 |           }
576 |         },
577 |         "xml": {
578 |           "name": "tag"
579 |         }
580 |       },
581 |       "Pet": {
582 |         "required": [
583 |           "name",
584 |           "photoUrls"
585 |         ],
586 |         "type": "object",
587 |         "properties": {
588 |           "id": {
589 |             "type": "integer",
590 |             "format": "int64",
591 |             "example": 10
592 |           },
593 |           "name": {
594 |             "type": "string",
595 |             "example": "doggie",
596 |             "format": "dog"
597 |           },
598 |           "category": {
599 |             "$ref": "#/components/schemas/Category"
600 |           },
601 |           "photoUrls": {
602 |             "type": "array",
603 |             "xml": {
604 |               "wrapped": true
605 |             },
606 |             "items": {
607 |               "type": "string",
608 |               "xml": {
609 |                 "name": "photoUrl"
610 |               },
611 |               "format": "image"
612 |             }
613 |           },
614 |           "tags": {
615 |             "type": "array",
616 |             "xml": {
617 |               "wrapped": true
618 |             },
619 |             "items": {
620 |               "$ref": "#/components/schemas/Tag"
621 |             }
622 |           },
623 |           "status": {
624 |             "type": "string",
625 |             "description": "pet status in the store\nthis is another line for test use",
626 |             "enum": [
627 |               "available",
628 |               "pending",
629 |               "sold"
630 |             ]
631 |           }
632 |         },
633 |         "xml": {
634 |           "name": "pet"
635 |         }
636 |       },
637 |       "ApiResponse": {
638 |         "type": "object",
639 |         "properties": {
640 |           "code": {
641 |             "type": "integer",
642 |             "format": "int32"
643 |           },
644 |           "type": {
645 |             "type": "string"
646 |           },
647 |           "message": {
648 |             "type": "string"
649 |           }
650 |         },
651 |         "xml": {
652 |           "name": "##default"
653 |         }
654 |       }
655 |     },
656 |     "requestBodies": {
657 |       "Pet": {
658 |         "description": "Pet object that needs to be added to the store",
659 |         "content": {
660 |           "application/json": {
661 |             "schema": {
662 |               "$ref": "#/components/schemas/Pet"
663 |             }
664 |           },
665 |           "application/xml": {
666 |             "schema": {
667 |               "$ref": "#/components/schemas/Pet"
668 |             }
669 |           }
670 |         }
671 |       },
672 |       "UserArray": {
673 |         "description": "List of user object",
674 |         "content": {
675 |           "application/json": {
676 |             "schema": {
677 |               "type": "array",
678 |               "items": {
679 |                 "$ref": "#/components/schemas/User"
680 |               }
681 |             }
682 |           }
683 |         }
684 |       }
685 |     },
686 |     "securitySchemes": {
687 |       "petstore_auth": {
688 |         "type": "oauth2",
689 |         "flows": {
690 |           "implicit": {
691 |             "authorizationUrl": "https://petstore3.swagger.io/oauth/authorize",
692 |             "scopes": {
693 |               "write:pets": "modify pets in your account",
694 |               "read:pets": "read your pets"
695 |             }
696 |           }
697 |         }
698 |       },
699 |       "api_key": {
700 |         "type": "apiKey",
701 |         "name": "api_key",
702 |         "in": "header"
703 |       }
704 |     }
705 |   }
706 | }
```

cmd/internal/openapi/v3/codegen/testdata/test3.json
```
1 | {
2 |   "openapi": "3.0.2",
3 |   "info": {
4 |     "title": "Swagger Petstore - OpenAPI 3.0",
5 |     "description": "This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\nSwagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\nYou can now help us improve the API whether it's by making changes to the definition itself or to the code.\nThat way, with time, we can improve the API in general, and expose some of the new features in OAS3.\n\nSome useful links:\n- [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\n- [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)",
6 |     "termsOfService": "http://swagger.io/terms/",
7 |     "contact": {
8 |       "email": "apiteam@swagger.io"
9 |     },
10 |     "license": {
11 |       "name": "Apache 2.0",
12 |       "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
13 |     },
14 |     "version": "1.0.5"
15 |   },
16 |   "externalDocs": {
17 |     "description": "Find out more about Swagger",
18 |     "url": "http://swagger.io"
19 |   },
20 |   "servers": [
21 |     {
22 |       "url": "/api/v3"
23 |     }
24 |   ],
25 |   "tags": [
26 |     {
27 |       "name": "pet",
28 |       "description": "Everything about your Pets",
29 |       "externalDocs": {
30 |         "description": "Find out more",
31 |         "url": "http://swagger.io"
32 |       }
33 |     },
34 |     {
35 |       "name": "store",
36 |       "description": "Operations about user"
37 |     },
38 |     {
39 |       "name": "user",
40 |       "description": "Access to Petstore orders",
41 |       "externalDocs": {
42 |         "description": "Find out more about our store",
43 |         "url": "http://swagger.io"
44 |       }
45 |     }
46 |   ],
47 |   "paths": {
48 |     "/customer/validateToken": {
49 |       "get": {
50 |         "parameters": [
51 |           {
52 |             "name": "token",
53 |             "in": "query",
54 |             "required": true,
55 |             "description": "",
56 |             "schema": {
57 |               "type": "string"
58 |             }
59 |           }
60 |         ],
61 |         "requestBody": {
62 |           "$ref": "#/components/requestBodies/Raw3"
63 |         },
64 |         "responses": {
65 |           "200": {
66 |             "description": "successful operation",
67 |             "content": {
68 |               "*/*": {
69 |                 "schema": {
70 |                   "type": "boolean"
71 |                 }
72 |               }
73 |             }
74 |           }
75 |         }
76 |       }
77 |     }
78 |   },
79 |   "components": {
80 |     "requestBodies": {
81 |       "Raw3": {
82 |         "content": {
83 |           "text/plain": {
84 |             "schema": {
85 |               "type": "string",
86 |               "format": "binary"
87 |             }
88 |           }
89 |         },
90 |         "description": "raw paramter"
91 |       }
92 |     },
93 |     "schemas": {
94 |       "Order": {
95 |         "type": "object",
96 |         "properties": {
97 |           "id": {
98 |             "type": "integer",
99 |             "format": "int64",
100 |             "example": 10
101 |           },
102 |           "petId": {
103 |             "type": "integer",
104 |             "format": "int64",
105 |             "example": 198772
106 |           },
107 |           "quantity": {
108 |             "type": "integer",
109 |             "format": "int32",
110 |             "example": 7
111 |           },
112 |           "shipDate": {
113 |             "type": "string",
114 |             "format": "date-time"
115 |           },
116 |           "status": {
117 |             "type": "string",
118 |             "description": "Order Status",
119 |             "example": "approved",
120 |             "enum": [
121 |               "placed",
122 |               "approved",
123 |               "delivered"
124 |             ]
125 |           },
126 |           "complete": {
127 |             "type": "boolean"
128 |           },
129 |           "customer": {
130 |             "type": "object",
131 |             "description": "客户信息结构体\n用于描述客户相关的信息",
132 |             "properties": {
133 |               "id": {
134 |                 "type": "integer",
135 |                 "format": "int64",
136 |                 "example": 100000,
137 |                 "description": "用户ID"
138 |               },
139 |               "username": {
140 |                 "type": "string",
141 |                 "example": "fehguy",
142 |                 "description": "用户名"
143 |               },
144 |               "address": {
145 |                 "type": "array",
146 |                 "xml": {
147 |                   "name": "addresses",
148 |                   "wrapped": true
149 |                 },
150 |                 "items": {
151 |                   "$ref": "#/components/schemas/Address"
152 |                 },
153 |                 "description": "用户地址\n例如：北京海淀区xxx街道\n某某小区"
154 |               }
155 |             },
156 |             "xml": {
157 |               "name": "customer"
158 |             }
159 |           }
160 |         },
161 |         "xml": {
162 |           "name": "order"
163 |         }
164 |       },
165 |       "Customer": {
166 |         "type": "object",
167 |         "properties": {
168 |           "id": {
169 |             "type": "integer",
170 |             "format": "int64",
171 |             "example": 100000
172 |           },
173 |           "username": {
174 |             "type": "string",
175 |             "example": "fehguy"
176 |           },
177 |           "address": {
178 |             "type": "array",
179 |             "xml": {
180 |               "name": "addresses",
181 |               "wrapped": true
182 |             },
183 |             "items": {
184 |               "$ref": "#/components/schemas/Address"
185 |             }
186 |           }
187 |         },
188 |         "xml": {
189 |           "name": "customer"
190 |         }
191 |       },
192 |       "Address": {
193 |         "type": "object",
194 |         "properties": {
195 |           "street": {
196 |             "type": "string",
197 |             "example": "437 Lytton"
198 |           },
199 |           "city": {
200 |             "type": "string",
201 |             "example": "Palo Alto"
202 |           },
203 |           "state": {
204 |             "type": "string",
205 |             "example": "CA"
206 |           },
207 |           "zip": {
208 |             "type": "string",
209 |             "example": "94301"
210 |           }
211 |         },
212 |         "xml": {
213 |           "name": "address"
214 |         }
215 |       },
216 |       "Category": {
217 |         "type": "object",
218 |         "properties": {
219 |           "id": {
220 |             "type": "integer",
221 |             "format": "int64",
222 |             "example": 1
223 |           },
224 |           "name": {
225 |             "type": "string",
226 |             "example": "Dogs"
227 |           }
228 |         },
229 |         "xml": {
230 |           "name": "category"
231 |         }
232 |       },
233 |       "User": {
234 |         "type": "object",
235 |         "properties": {
236 |           "id": {
237 |             "type": "integer",
238 |             "format": "int64",
239 |             "example": 10
240 |           },
241 |           "username": {
242 |             "type": "string",
243 |             "example": "theUser"
244 |           },
245 |           "firstName": {
246 |             "type": "string",
247 |             "example": "John"
248 |           },
249 |           "lastName": {
250 |             "type": "string",
251 |             "example": "James"
252 |           },
253 |           "email": {
254 |             "type": "string",
255 |             "example": "john@email.com"
256 |           },
257 |           "password": {
258 |             "type": "string",
259 |             "example": "12345"
260 |           },
261 |           "phone": {
262 |             "type": "string",
263 |             "example": "12345"
264 |           },
265 |           "userStatus": {
266 |             "type": "integer",
267 |             "description": "User Status",
268 |             "format": "int32",
269 |             "example": 1
270 |           },
271 |           "avatar": {
272 |             "type": "string",
273 |             "format": "binary"
274 |           },
275 |           "additional1": {
276 |             "type": "object",
277 |             "additionalProperties": {
278 |               "type": "string",
279 |               "format": "int64"
280 |             }
281 |           },
282 |           "additional2": {
283 |             "type": "object",
284 |             "additionalProperties": {
285 |               "$ref": "#/components/schemas/Tag"
286 |             }
287 |           }
288 |         },
289 |         "xml": {
290 |           "name": "user"
291 |         }
292 |       },
293 |       "Tag": {
294 |         "type": "object",
295 |         "properties": {
296 |           "id": {
297 |             "type": "integer",
298 |             "format": "int64"
299 |           },
300 |           "name": {
301 |             "type": "string",
302 |             "format": "tag"
303 |           }
304 |         },
305 |         "xml": {
306 |           "name": "tag"
307 |         }
308 |       },
309 |       "Pet": {
310 |         "required": [
311 |           "name",
312 |           "photoUrls"
313 |         ],
314 |         "type": "object",
315 |         "properties": {
316 |           "id": {
317 |             "type": "integer",
318 |             "format": "int64",
319 |             "example": 10
320 |           },
321 |           "name": {
322 |             "type": "string",
323 |             "example": "doggie",
324 |             "format": "dog"
325 |           },
326 |           "category": {
327 |             "$ref": "#/components/schemas/Category"
328 |           },
329 |           "photoUrls": {
330 |             "type": "array",
331 |             "xml": {
332 |               "wrapped": true
333 |             },
334 |             "items": {
335 |               "type": "string",
336 |               "xml": {
337 |                 "name": "photoUrl"
338 |               },
339 |               "format": "image"
340 |             }
341 |           },
342 |           "tags": {
343 |             "type": "array",
344 |             "xml": {
345 |               "wrapped": true
346 |             },
347 |             "items": {
348 |               "$ref": "#/components/schemas/Tag"
349 |             }
350 |           },
351 |           "status": {
352 |             "type": "string",
353 |             "description": "pet status in the store\nthis is another line for test use",
354 |             "enum": [
355 |               "available",
356 |               "pending",
357 |               "sold"
358 |             ]
359 |           }
360 |         },
361 |         "xml": {
362 |           "name": "pet"
363 |         }
364 |       },
365 |       "ApiResponse": {
366 |         "type": "object",
367 |         "properties": {
368 |           "code": {
369 |             "type": "integer",
370 |             "format": "int32"
371 |           },
372 |           "type": {
373 |             "type": "string"
374 |           },
375 |           "message": {
376 |             "type": "string"
377 |           }
378 |         },
379 |         "xml": {
380 |           "name": "##default"
381 |         }
382 |       }
383 |     },
384 |     "requestBodies": {
385 |       "Pet": {
386 |         "description": "Pet object that needs to be added to the store",
387 |         "content": {
388 |           "application/json": {
389 |             "schema": {
390 |               "$ref": "#/components/schemas/Pet"
391 |             }
392 |           },
393 |           "application/xml": {
394 |             "schema": {
395 |               "$ref": "#/components/schemas/Pet"
396 |             }
397 |           }
398 |         }
399 |       },
400 |       "UserArray": {
401 |         "description": "List of user object",
402 |         "content": {
403 |           "application/json": {
404 |             "schema": {
405 |               "type": "array",
406 |               "items": {
407 |                 "$ref": "#/components/schemas/User"
408 |               }
409 |             }
410 |           }
411 |         }
412 |       }
413 |     },
414 |     "securitySchemes": {
415 |       "petstore_auth": {
416 |         "type": "oauth2",
417 |         "flows": {
418 |           "implicit": {
419 |             "authorizationUrl": "https://petstore3.swagger.io/oauth/authorize",
420 |             "scopes": {
421 |               "write:pets": "modify pets in your account",
422 |               "read:pets": "read your pets"
423 |             }
424 |           }
425 |         }
426 |       },
427 |       "api_key": {
428 |         "type": "apiKey",
429 |         "name": "api_key",
430 |         "in": "header"
431 |       }
432 |     }
433 |   }
434 | }
```

cmd/internal/openapi/v3/codegen/testdata/test4.json
```
1 | {
2 |   "openapi": "3.0.2"
3 |   "info": {
4 |     "title": "Swagger Petstore - OpenAPI 3.0",
5 |     "description": "This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\nSwagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\nYou can now help us improve the API whether it's by making changes to the definition itself or to the code.\nThat way, with time, we can improve the API in general, and expose some of the new features in OAS3.\n\nSome useful links:\n- [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\n- [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)",
6 |     "termsOfService": "http://swagger.io/terms/",
7 |     "contact": {
8 |       "email": "apiteam@swagger.io"
9 |     },
10 |     "license": {
11 |       "name": "Apache 2.0",
12 |       "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
13 |     },
14 |     "version": "1.0.5"
15 |   },
16 |   "externalDocs": {
17 |     "description": "Find out more about Swagger",
18 |     "url": "http://swagger.io"
19 |   },
20 |   "servers": [
21 |     {
22 |       "url": "/api/v3"
23 |     }
24 |   ],
25 |   "tags": [
26 |     {
27 |       "name": "pet",
28 |       "description": "Everything about your Pets",
29 |       "externalDocs": {
30 |         "description": "Find out more",
31 |         "url": "http://swagger.io"
32 |       }
33 |     },
34 |     {
35 |       "name": "store",
36 |       "description": "Operations about user"
37 |     },
38 |     {
39 |       "name": "user",
40 |       "description": "Access to Petstore orders",
41 |       "externalDocs": {
42 |         "description": "Find out more about our store",
43 |         "url": "http://swagger.io"
44 |       }
45 |     }
46 |   ],
47 |   "paths": {
48 |     "/customer/validateToken": {
49 |       "get": {
50 |         "parameters": [
51 |           {
52 |             "name": "token",
53 |             "in": "query",
54 |             "required": true,
55 |             "description": "",
56 |             "schema": {
57 |               "type": "string"
58 |             }
59 |           }
60 |         ],
61 |         "requestBody": {
62 |           "$ref": "#/components/requestBodies/Raw3"
63 |         },
64 |         "responses": {
65 |           "200": {
66 |             "description": "successful operation",
67 |             "content": {
68 |               "*/*": {
69 |                 "schema": {
70 |                   "type": "boolean"
71 |                 }
72 |               }
73 |             }
74 |           }
75 |         }
76 |       }
77 |     }
78 |   },
79 |   "components": {
80 |     "requestBodies": {
81 |       "Raw3": {
82 |         "content": {
83 |           "text/plain": {
84 |             "schema": {
85 |               "type": "string",
86 |               "format": "binary"
87 |             }
88 |           }
89 |         },
90 |         "description": "raw paramter"
91 |       }
92 |     },
93 |     "schemas": {
94 |       "Order": {
95 |         "type": "object",
96 |         "properties": {
97 |           "id": {
98 |             "type": "integer",
99 |             "format": "int64",
100 |             "example": 10
101 |           },
102 |           "petId": {
103 |             "type": "integer",
104 |             "format": "int64",
105 |             "example": 198772
106 |           },
107 |           "quantity": {
108 |             "type": "integer",
109 |             "format": "int32",
110 |             "example": 7
111 |           },
112 |           "shipDate": {
113 |             "type": "string",
114 |             "format": "date-time"
115 |           },
116 |           "status": {
117 |             "type": "string",
118 |             "description": "Order Status",
119 |             "example": "approved",
120 |             "enum": [
121 |               "placed",
122 |               "approved",
123 |               "delivered"
124 |             ]
125 |           },
126 |           "complete": {
127 |             "type": "boolean"
128 |           },
129 |           "customer": {
130 |             "type": "object",
131 |             "description": "客户信息结构体\n用于描述客户相关的信息",
132 |             "properties": {
133 |               "id": {
134 |                 "type": "integer",
135 |                 "format": "int64",
136 |                 "example": 100000,
137 |                 "description": "用户ID"
138 |               },
139 |               "username": {
140 |                 "type": "string",
141 |                 "example": "fehguy",
142 |                 "description": "用户名"
143 |               },
144 |               "address": {
145 |                 "type": "array",
146 |                 "xml": {
147 |                   "name": "addresses",
148 |                   "wrapped": true
149 |                 },
150 |                 "items": {
151 |                   "$ref": "#/components/schemas/Address"
152 |                 },
153 |                 "description": "用户地址\n例如：北京海淀区xxx街道\n某某小区"
154 |               }
155 |             },
156 |             "xml": {
157 |               "name": "customer"
158 |             }
159 |           }
160 |         },
161 |         "xml": {
162 |           "name": "order"
163 |         }
164 |       },
165 |       "Customer": {
166 |         "type": "object",
167 |         "properties": {
168 |           "id": {
169 |             "type": "integer",
170 |             "format": "int64",
171 |             "example": 100000
172 |           },
173 |           "username": {
174 |             "type": "string",
175 |             "example": "fehguy"
176 |           },
177 |           "address": {
178 |             "type": "array",
179 |             "xml": {
180 |               "name": "addresses",
181 |               "wrapped": true
182 |             },
183 |             "items": {
184 |               "$ref": "#/components/schemas/Address"
185 |             }
186 |           }
187 |         },
188 |         "xml": {
189 |           "name": "customer"
190 |         }
191 |       },
192 |       "Address": {
193 |         "type": "object",
194 |         "properties": {
195 |           "street": {
196 |             "type": "string",
197 |             "example": "437 Lytton"
198 |           },
199 |           "city": {
200 |             "type": "string",
201 |             "example": "Palo Alto"
202 |           },
203 |           "state": {
204 |             "type": "string",
205 |             "example": "CA"
206 |           },
207 |           "zip": {
208 |             "type": "string",
209 |             "example": "94301"
210 |           }
211 |         },
212 |         "xml": {
213 |           "name": "address"
214 |         }
215 |       },
216 |       "Category": {
217 |         "type": "object",
218 |         "properties": {
219 |           "id": {
220 |             "type": "integer",
221 |             "format": "int64",
222 |             "example": 1
223 |           },
224 |           "name": {
225 |             "type": "string",
226 |             "example": "Dogs"
227 |           }
228 |         },
229 |         "xml": {
230 |           "name": "category"
231 |         }
232 |       },
233 |       "User": {
234 |         "type": "object",
235 |         "properties": {
236 |           "id": {
237 |             "type": "integer",
238 |             "format": "int64",
239 |             "example": 10
240 |           },
241 |           "username": {
242 |             "type": "string",
243 |             "example": "theUser"
244 |           },
245 |           "firstName": {
246 |             "type": "string",
247 |             "example": "John"
248 |           },
249 |           "lastName": {
250 |             "type": "string",
251 |             "example": "James"
252 |           },
253 |           "email": {
254 |             "type": "string",
255 |             "example": "john@email.com"
256 |           },
257 |           "password": {
258 |             "type": "string",
259 |             "example": "12345"
260 |           },
261 |           "phone": {
262 |             "type": "string",
263 |             "example": "12345"
264 |           },
265 |           "userStatus": {
266 |             "type": "integer",
267 |             "description": "User Status",
268 |             "format": "int32",
269 |             "example": 1
270 |           },
271 |           "avatar": {
272 |             "type": "string",
273 |             "format": "binary"
274 |           },
275 |           "additional1": {
276 |             "type": "object",
277 |             "additionalProperties": {
278 |               "type": "string",
279 |               "format": "int64"
280 |             }
281 |           },
282 |           "additional2": {
283 |             "type": "object",
284 |             "additionalProperties": {
285 |               "$ref": "#/components/schemas/Tag"
286 |             }
287 |           }
288 |         },
289 |         "xml": {
290 |           "name": "user"
291 |         }
292 |       },
293 |       "Tag": {
294 |         "type": "object",
295 |         "properties": {
296 |           "id": {
297 |             "type": "integer",
298 |             "format": "int64"
299 |           },
300 |           "name": {
301 |             "type": "string",
302 |             "format": "tag"
303 |           }
304 |         },
305 |         "xml": {
306 |           "name": "tag"
307 |         }
308 |       },
309 |       "Pet": {
310 |         "required": [
311 |           "name",
312 |           "photoUrls"
313 |         ],
314 |         "type": "object",
315 |         "properties": {
316 |           "id": {
317 |             "type": "integer",
318 |             "format": "int64",
319 |             "example": 10
320 |           },
321 |           "name": {
322 |             "type": "string",
323 |             "example": "doggie",
324 |             "format": "dog"
325 |           },
326 |           "category": {
327 |             "$ref": "#/components/schemas/Category"
328 |           },
329 |           "photoUrls": {
330 |             "type": "array",
331 |             "xml": {
332 |               "wrapped": true
333 |             },
334 |             "items": {
335 |               "type": "string",
336 |               "xml": {
337 |                 "name": "photoUrl"
338 |               },
339 |               "format": "image"
340 |             }
341 |           },
342 |           "tags": {
343 |             "type": "array",
344 |             "xml": {
345 |               "wrapped": true
346 |             },
347 |             "items": {
348 |               "$ref": "#/components/schemas/Tag"
349 |             }
350 |           },
351 |           "status": {
352 |             "type": "string",
353 |             "description": "pet status in the store\nthis is another line for test use",
354 |             "enum": [
355 |               "available",
356 |               "pending",
357 |               "sold"
358 |             ]
359 |           }
360 |         },
361 |         "xml": {
362 |           "name": "pet"
363 |         }
364 |       },
365 |       "ApiResponse": {
366 |         "type": "object",
367 |         "properties": {
368 |           "code": {
369 |             "type": "integer",
370 |             "format": "int32"
371 |           },
372 |           "type": {
373 |             "type": "string"
374 |           },
375 |           "message": {
376 |             "type": "string"
377 |           }
378 |         },
379 |         "xml": {
380 |           "name": "##default"
381 |         }
382 |       }
383 |     },
384 |     "requestBodies": {
385 |       "Pet": {
386 |         "description": "Pet object that needs to be added to the store",
387 |         "content": {
388 |           "application/json": {
389 |             "schema": {
390 |               "$ref": "#/components/schemas/Pet"
391 |             }
392 |           },
393 |           "application/xml": {
394 |             "schema": {
395 |               "$ref": "#/components/schemas/Pet"
396 |             }
397 |           }
398 |         }
399 |       },
400 |       "UserArray": {
401 |         "description": "List of user object",
402 |         "content": {
403 |           "application/json": {
404 |             "schema": {
405 |               "type": "array",
406 |               "items": {
407 |                 "$ref": "#/components/schemas/User"
408 |               }
409 |             }
410 |           }
411 |         }
412 |       }
413 |     },
414 |     "securitySchemes": {
415 |       "petstore_auth": {
416 |         "type": "oauth2",
417 |         "flows": {
418 |           "implicit": {
419 |             "authorizationUrl": "https://petstore3.swagger.io/oauth/authorize",
420 |             "scopes": {
421 |               "write:pets": "modify pets in your account",
422 |               "read:pets": "read your pets"
423 |             }
424 |           }
425 |         }
426 |       },
427 |       "api_key": {
428 |         "type": "apiKey",
429 |         "name": "api_key",
430 |         "in": "header"
431 |       }
432 |     }
433 |   }
434 | }
```

cmd/internal/openapi/v3/codegen/testdata/test5.json
```
1 | {
2 |   "openapi": "3.0.2",
3 |   "info": {
4 |     "title": "Usersvc",
5 |     "description": "Usersvc User Center Service",
6 |     "version": "v20220202"
7 |   },
8 |   "paths": {
9 |     "/download/avatar": {
10 |       "get": {
11 |         "description": "GetDownloadAvatar demonstrate how to define download file api\nthere must be *os.File parameter among output parameters",
12 |         "parameters": [
13 |           {
14 |             "name": "userId",
15 |             "in": "query",
16 |             "required": true,
17 |             "schema": {
18 |               "type": "string"
19 |             }
20 |           }
21 |         ],
22 |         "responses": {
23 |           "200": {
24 |             "content": {
25 |               "application/octet-stream": {
26 |                 "schema": {
27 |                   "type": "string",
28 |                   "format": "binary",
29 |                   "description": "download file"
30 |                 }
31 |               }
32 |             }
33 |           }
34 |         }
35 |       }
36 |     },
37 |     "/page/users": {
38 |       "post": {
39 |         "description": "PageUsers demonstrate how to define POST and Content-Type as application/json api",
40 |         "requestBody": {
41 |           "content": {
42 |             "application/json": {
43 |               "schema": {
44 |                 "$ref": "#/components/schemas/PageQuery",
45 |                 "description": "comments above input and output struct type parameters in vo package will display on online document\nnot comments here"
46 |               }
47 |             }
48 |           },
49 |           "required": true
50 |         },
51 |         "responses": {
52 |           "200": {
53 |             "content": {
54 |               "application/json": {
55 |                 "schema": {
56 |                   "$ref": "#/components/schemas/PageUsersResp"
57 |                 }
58 |               }
59 |             }
60 |           }
61 |         }
62 |       }
63 |     },
64 |     "/page/users/2": {
65 |       "post": {
66 |         "description": "PageUsers2 demonstrate how to define POST and Content-Type as application/json api",
67 |         "requestBody": {
68 |           "content": {
69 |             "application/json": {
70 |               "schema": {
71 |                 "$ref": "#/components/schemas/PageQuery",
72 |                 "description": "comments above input and output struct type parameters in vo package will display on online document\nnot comments here"
73 |               }
74 |             }
75 |           }
76 |         },
77 |         "responses": {
78 |           "200": {
79 |             "content": {
80 |               "application/json": {
81 |                 "schema": {
82 |                   "$ref": "#/components/schemas/PageUsers2Resp"
83 |                 }
84 |               }
85 |             }
86 |           }
87 |         }
88 |       }
89 |     },
90 |     "/sign/up": {
91 |       "post": {
92 |         "description": "SignUp demonstrate how to define POST and Content-Type as application/x-www-form-urlencoded api",
93 |         "requestBody": {
94 |           "content": {
95 |             "application/x-www-form-urlencoded": {
96 |               "schema": {
97 |                 "$ref": "#/components/schemas/SignUpReq"
98 |               }
99 |             }
100 |           },
101 |           "required": true
102 |         },
103 |         "responses": {
104 |           "200": {
105 |             "content": {
106 |               "application/json": {
107 |                 "schema": {
108 |                   "$ref": "#/components/schemas/SignUpResp"
109 |                 }
110 |               }
111 |             }
112 |           }
113 |         }
114 |       }
115 |     },
116 |     "/upload/avatar": {
117 |       "post": {
118 |         "description": "UploadAvatar demonstrate how to define upload files api\nthere must be one []v3.FileModel or v3.FileModel parameter among input parameters\nremember to close the readers by Close method of v3.FileModel if you don't need them anymore when you finished your own business logic",
119 |         "requestBody": {
120 |           "content": {
121 |             "multipart/form-data": {
122 |               "schema": {
123 |                 "$ref": "#/components/schemas/UploadAvatarReq"
124 |               }
125 |             }
126 |           },
127 |           "required": true
128 |         },
129 |         "responses": {
130 |           "200": {
131 |             "content": {
132 |               "application/json": {
133 |                 "schema": {
134 |                   "$ref": "#/components/schemas/UploadAvatarResp"
135 |                 }
136 |               }
137 |             }
138 |           }
139 |         }
140 |       }
141 |     },
142 |     "/upload/avatar/2": {
143 |       "post": {
144 |         "description": "UploadAvatar2 demonstrate how to define upload files api\nremember to close the readers by Close method of v3.FileModel if you don't need them anymore when you finished your own business logic",
145 |         "requestBody": {
146 |           "content": {
147 |             "multipart/form-data": {
148 |               "schema": {
149 |                 "$ref": "#/components/schemas/UploadAvatar2Req"
150 |               }
151 |             }
152 |           },
153 |           "required": true
154 |         },
155 |         "responses": {
156 |           "200": {
157 |             "content": {
158 |               "application/json": {
159 |                 "schema": {
160 |                   "$ref": "#/components/schemas/UploadAvatar2Resp"
161 |                 }
162 |               }
163 |             }
164 |           }
165 |         }
166 |       }
167 |     },
168 |     "/user": {
169 |       "get": {
170 |         "description": "GetUser demonstrate how to define GET api with query string parameters",
171 |         "parameters": [
172 |           {
173 |             "name": "userId",
174 |             "in": "query",
175 |             "description": "user id\ncomments above input and output basic type parameters will display on online document",
176 |             "required": true,
177 |             "schema": {
178 |               "type": "string",
179 |               "description": "user id\ncomments above input and output basic type parameters will display on online document"
180 |             }
181 |           },
182 |           {
183 |             "name": "photo",
184 |             "in": "query",
185 |             "required": true,
186 |             "schema": {
187 |               "type": "string"
188 |             }
189 |           }
190 |         ],
191 |         "responses": {
192 |           "200": {
193 |             "content": {
194 |               "application/json": {
195 |                 "schema": {
196 |                   "$ref": "#/components/schemas/GetUserResp"
197 |                 }
198 |               }
199 |             }
200 |           }
201 |         }
202 |       }
203 |     },
204 |     "/user/2": {
205 |       "get": {
206 |         "description": "GetUser2 demonstrate how to define GET api with query string parameters",
207 |         "parameters": [
208 |           {
209 |             "name": "userId",
210 |             "in": "query",
211 |             "description": "user id\ncomments above input and output basic type parameters will display on online document",
212 |             "required": true,
213 |             "schema": {
214 |               "type": "string",
215 |               "description": "user id\ncomments above input and output basic type parameters will display on online document"
216 |             }
217 |           },
218 |           {
219 |             "name": "photo",
220 |             "in": "query",
221 |             "schema": {
222 |               "type": "string"
223 |             }
224 |           }
225 |         ],
226 |         "responses": {
227 |           "200": {
228 |             "content": {
229 |               "application/json": {
230 |                 "schema": {
231 |                   "$ref": "#/components/schemas/GetUser2Resp"
232 |                 }
233 |               }
234 |             }
235 |           }
236 |         }
237 |       }
238 |     },
239 |     "/user/3": {
240 |       "get": {
241 |         "description": "GetUser3 demonstrate how to define GET api with query string parameters",
242 |         "parameters": [
243 |           {
244 |             "name": "userId",
245 |             "in": "query",
246 |             "description": "user id\ncomments above input and output basic type parameters will display on online document",
247 |             "required": true,
248 |             "schema": {
249 |               "type": "string",
250 |               "description": "user id\ncomments above input and output basic type parameters will display on online document"
251 |             }
252 |           },
253 |           {
254 |             "name": "photo",
255 |             "in": "query",
256 |             "schema": {
257 |               "type": "string"
258 |             }
259 |           },
260 |           {
261 |             "name": "attrs",
262 |             "in": "query",
263 |             "required": true,
264 |             "schema": {
265 |               "type": "array",
266 |               "items": {
267 |                 "type": "integer",
268 |                 "format": "int32"
269 |               }
270 |             }
271 |           },
272 |           {
273 |             "name": "pattrs",
274 |             "in": "query",
275 |             "schema": {
276 |               "type": "array",
277 |               "items": {
278 |                 "type": "integer",
279 |                 "format": "int32"
280 |               }
281 |             }
282 |           }
283 |         ],
284 |         "responses": {
285 |           "200": {
286 |             "content": {
287 |               "application/json": {
288 |                 "schema": {
289 |                   "$ref": "#/components/schemas/GetUser3Resp"
290 |                 }
291 |               }
292 |             }
293 |           }
294 |         }
295 |       }
296 |     },
297 |     "/user/4": {
298 |       "get": {
299 |         "description": "GetUser4 demonstrate how to define GET api with query string parameters\nphoto *string, pattrs *[]int 是一类问题， TODO\nattrs2 []int 是一类问题",
300 |         "parameters": [
301 |           {
302 |             "name": "userId",
303 |             "in": "query",
304 |             "description": "user id\ncomments above input and output basic type parameters will display on online document",
305 |             "required": true,
306 |             "schema": {
307 |               "type": "string",
308 |               "description": "user id\ncomments above input and output basic type parameters will display on online document"
309 |             }
310 |           },
311 |           {
312 |             "name": "photo",
313 |             "in": "query",
314 |             "schema": {
315 |               "type": "string"
316 |             }
317 |           },
318 |           {
319 |             "name": "pattrs",
320 |             "in": "query",
321 |             "schema": {
322 |               "type": "array",
323 |               "items": {
324 |                 "type": "integer",
325 |                 "format": "int32"
326 |               }
327 |             }
328 |           },
329 |           {
330 |             "name": "attrs2",
331 |             "in": "query",
332 |             "required": true,
333 |             "schema": {
334 |               "type": "array",
335 |               "items": {
336 |                 "type": "integer",
337 |                 "format": "int32"
338 |               }
339 |             }
340 |           }
341 |         ],
342 |         "responses": {
343 |           "200": {
344 |             "content": {
345 |               "application/json": {
346 |                 "schema": {
347 |                   "$ref": "#/components/schemas/GetUser4Resp"
348 |                 }
349 |               }
350 |             }
351 |           }
352 |         }
353 |       }
354 |     }
355 |   },
356 |   "components": {
357 |     "schemas": {
358 |       "GetUser2Resp": {
359 |         "title": "GetUser2Resp",
360 |         "type": "object",
361 |         "properties": {
362 |           "code": {
363 |             "type": "integer",
364 |             "format": "int32"
365 |           },
366 |           "data": {
367 |             "type": "string"
368 |           }
369 |         },
370 |         "required": [
371 |           "code"
372 |         ]
373 |       },
374 |       "GetUser3Resp": {
375 |         "title": "GetUser3Resp",
376 |         "type": "object",
377 |         "properties": {
378 |           "code": {
379 |             "type": "integer",
380 |             "format": "int32"
381 |           },
382 |           "data": {
383 |             "type": "string"
384 |           }
385 |         },
386 |         "required": [
387 |           "code"
388 |         ]
389 |       },
390 |       "GetUser4Resp": {
391 |         "title": "GetUser4Resp",
392 |         "type": "object",
393 |         "properties": {
394 |           "code": {
395 |             "type": "integer",
396 |             "format": "int32"
397 |           },
398 |           "data": {
399 |             "type": "string"
400 |           },
401 |           "msg": {
402 |             "type": "string"
403 |           }
404 |         },
405 |         "required": [
406 |           "code"
407 |         ]
408 |       },
409 |       "GetUserResp": {
410 |         "title": "GetUserResp",
411 |         "type": "object",
412 |         "properties": {
413 |           "code": {
414 |             "type": "integer",
415 |             "format": "int32"
416 |           },
417 |           "data": {
418 |             "type": "string"
419 |           }
420 |         },
421 |         "required": [
422 |           "code",
423 |           "data"
424 |         ]
425 |       },
426 |       "Order": {
427 |         "title": "Order",
428 |         "type": "object",
429 |         "properties": {
430 |           "col": {
431 |             "type": "string"
432 |           },
433 |           "sort": {
434 |             "type": "string"
435 |           }
436 |         },
437 |         "description": "排序条件",
438 |         "required": [
439 |           "col",
440 |           "sort"
441 |         ]
442 |       },
443 |       "Page": {
444 |         "title": "Page",
445 |         "type": "object",
446 |         "properties": {
447 |           "orders": {
448 |             "type": "array",
449 |             "items": {
450 |               "$ref": "#/components/schemas/Order"
451 |             },
452 |             "description": "排序规则"
453 |           },
454 |           "pageNo": {
455 |             "type": "integer",
456 |             "format": "int32",
457 |             "description": "页码"
458 |           },
459 |           "size": {
460 |             "type": "integer",
461 |             "format": "int32",
462 |             "description": "每页行数"
463 |           }
464 |         },
465 |         "required": [
466 |           "orders",
467 |           "pageNo",
468 |           "size"
469 |         ]
470 |       },
471 |       "PageFilter": {
472 |         "title": "PageFilter",
473 |         "type": "object",
474 |         "properties": {
475 |           "dept": {
476 |             "type": "integer",
477 |             "format": "int32",
478 |             "description": "所属部门ID"
479 |           },
480 |           "name": {
481 |             "type": "string",
482 |             "description": "真实姓名，前缀匹配"
483 |           }
484 |         },
485 |         "description": "筛选条件",
486 |         "required": [
487 |           "name",
488 |           "dept"
489 |         ]
490 |       },
491 |       "PageQuery": {
492 |         "title": "PageQuery",
493 |         "type": "object",
494 |         "properties": {
495 |           "filter": {
496 |             "$ref": "#/components/schemas/PageFilter"
497 |           },
498 |           "page": {
499 |             "$ref": "#/components/schemas/Page"
500 |           }
501 |         },
502 |         "description": "分页筛选条件",
503 |         "required": [
504 |           "filter",
505 |           "page"
506 |         ]
507 |       },
508 |       "PageRet": {
509 |         "title": "PageRet",
510 |         "type": "object",
511 |         "properties": {
512 |           "hasNext": {
513 |             "type": "boolean"
514 |           },
515 |           "items": {
516 |             "type": "object"
517 |           },
518 |           "pageNo": {
519 |             "type": "integer",
520 |             "format": "int32"
521 |           },
522 |           "pageSize": {
523 |             "type": "integer",
524 |             "format": "int32"
525 |           },
526 |           "total": {
527 |             "type": "integer",
528 |             "format": "int32"
529 |           }
530 |         },
531 |         "description": "PageRet pagination query result",
532 |         "required": [
533 |           "items",
534 |           "pageNo",
535 |           "pageSize",
536 |           "total",
537 |           "hasNext"
538 |         ]
539 |       },
540 |       "PageUsers2Resp": {
541 |         "title": "PageUsers2Resp",
542 |         "type": "object",
543 |         "properties": {
544 |           "code": {
545 |             "type": "integer",
546 |             "format": "int32",
547 |             "description": "it indicates there is an error if code is not 0"
548 |           },
549 |           "data": {
550 |             "$ref": "#/components/schemas/PageRet",
551 |             "description": "page data"
552 |           }
553 |         },
554 |         "required": [
555 |           "code",
556 |           "data"
557 |         ]
558 |       },
559 |       "PageUsersResp": {
560 |         "title": "PageUsersResp",
561 |         "type": "object",
562 |         "properties": {
563 |           "code": {
564 |             "type": "integer",
565 |             "format": "int32",
566 |             "description": "it indicates there is an error if code is not 0"
567 |           },
568 |           "data": {
569 |             "$ref": "#/components/schemas/PageRet",
570 |             "description": "page data"
571 |           }
572 |         },
573 |         "required": [
574 |           "code",
575 |           "data"
576 |         ]
577 |       },
578 |       "SignUpReq": {
579 |         "title": "SignUpReq",
580 |         "type": "object",
581 |         "properties": {
582 |           "actived": {
583 |             "type": "boolean"
584 |           },
585 |           "password": {
586 |             "type": "integer",
587 |             "format": "int32"
588 |           },
589 |           "score": {
590 |             "type": "number",
591 |             "format": "double"
592 |           },
593 |           "username": {
594 |             "type": "string"
595 |           }
596 |         },
597 |         "required": [
598 |           "username",
599 |           "password",
600 |           "actived",
601 |           "score"
602 |         ]
603 |       },
604 |       "SignUpResp": {
605 |         "title": "SignUpResp",
606 |         "type": "object",
607 |         "properties": {
608 |           "code": {
609 |             "type": "integer",
610 |             "format": "int32"
611 |           },
612 |           "data": {
613 |             "type": "string"
614 |           }
615 |         },
616 |         "required": [
617 |           "code",
618 |           "data"
619 |         ]
620 |       },
621 |       "UploadAvatar2Req": {
622 |         "title": "UploadAvatar2Req",
623 |         "type": "object",
624 |         "properties": {
625 |           "pf": {
626 |             "type": "array",
627 |             "items": {
628 |               "type": "string",
629 |               "format": "binary"
630 |             }
631 |           },
632 |           "pf2": {
633 |             "type": "string",
634 |             "format": "binary"
635 |           },
636 |           "pf3": {
637 |             "type": "string",
638 |             "format": "binary"
639 |           },
640 |           "ps": {
641 |             "type": "string"
642 |           }
643 |         },
644 |         "required": [
645 |           "pf",
646 |           "ps"
647 |         ]
648 |       },
649 |       "UploadAvatar2Resp": {
650 |         "title": "UploadAvatar2Resp",
651 |         "type": "object",
652 |         "properties": {
653 |           "ri": {
654 |             "type": "integer",
655 |             "format": "int32"
656 |           },
657 |           "rs": {
658 |             "type": "string"
659 |           }
660 |         },
661 |         "required": [
662 |           "ri",
663 |           "rs"
664 |         ]
665 |       },
666 |       "UploadAvatarReq": {
667 |         "title": "UploadAvatarReq",
668 |         "type": "object",
669 |         "properties": {
670 |           "pf": {
671 |             "type": "array",
672 |             "items": {
673 |               "type": "string",
674 |               "format": "binary"
675 |             }
676 |           },
677 |           "ps": {
678 |             "type": "string"
679 |           }
680 |         },
681 |         "required": [
682 |           "pf",
683 |           "ps"
684 |         ]
685 |       },
686 |       "UploadAvatarResp": {
687 |         "title": "UploadAvatarResp",
688 |         "type": "object",
689 |         "properties": {
690 |           "ri": {
691 |             "type": "integer",
692 |             "format": "int32"
693 |           },
694 |           "rs": {
695 |             "type": "string"
696 |           }
697 |         },
698 |         "required": [
699 |           "ri",
700 |           "rs"
701 |         ]
702 |       },
703 |       "UserVo": {
704 |         "title": "UserVo",
705 |         "type": "object",
706 |         "properties": {
707 |           "dept": {
708 |             "type": "string"
709 |           },
710 |           "id": {
711 |             "type": "integer",
712 |             "format": "int32"
713 |           },
714 |           "name": {
715 |             "type": "string"
716 |           },
717 |           "phone": {
718 |             "type": "string"
719 |           }
720 |         },
721 |         "required": [
722 |           "id",
723 |           "name",
724 |           "phone",
725 |           "dept"
726 |         ]
727 |       }
728 |     }
729 |   }
730 | }
```

cmd/internal/svc/codegen/testdata/client/client.go
```
```

cmd/internal/svc/codegen/testdata/client/clientproxy.go
```
1 | package client
2 | 
3 | import (
4 | 	"context"
5 | 	"mime/multipart"
6 | 	"os"
7 | 	"testdata/vo"
8 | 	"time"
9 | 
10 | 	"github.com/go-resty/resty/v2"
11 | 	"github.com/pkg/errors"
12 | 	"github.com/prometheus/client_golang/prometheus"
13 | 	"github.com/sirupsen/logrus"
14 | 	"github.com/slok/goresilience"
15 | 	"github.com/slok/goresilience/circuitbreaker"
16 | 	rerrors "github.com/slok/goresilience/errors"
17 | 	"github.com/slok/goresilience/metrics"
18 | 	"github.com/slok/goresilience/retry"
19 | 	"github.com/slok/goresilience/timeout"
20 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
21 | )
22 | 
23 | type UsersvcClientProxy struct {
24 | 	client *UsersvcClient
25 | 	logger *logrus.Logger
26 | 	runner goresilience.Runner
27 | }
28 | 
29 | func (receiver *UsersvcClientProxy) PageUsers(ctx context.Context, _headers map[string]string, query vo.PageQuery) (_resp *resty.Response, code int, data vo.PageRet, msg error) {
30 | 	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
31 | 		_resp, code, data, msg = receiver.client.PageUsers(
32 | 			ctx,
33 | 			_headers,
34 | 			query,
35 | 		)
36 | 		if msg != nil {
37 | 			return errors.Wrap(msg, "call PageUsers fail")
38 | 		}
39 | 		return nil
40 | 	}); _err != nil {
41 | 		// you can implement your fallback logic here
42 | 		if errors.Is(_err, rerrors.ErrCircuitOpen) {
43 | 			receiver.logger.Error(_err)
44 | 		}
45 | 		msg = errors.Wrap(_err, "call PageUsers fail")
46 | 	}
47 | 	return
48 | }
49 | func (receiver *UsersvcClientProxy) GetUser(ctx context.Context, _headers map[string]string, userId string, photo string) (_resp *resty.Response, code int, data string, msg error) {
50 | 	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
51 | 		_resp, code, data, msg = receiver.client.GetUser(
52 | 			ctx,
53 | 			_headers,
54 | 			userId,
55 | 			photo,
56 | 		)
57 | 		if msg != nil {
58 | 			return errors.Wrap(msg, "call GetUser fail")
59 | 		}
60 | 		return nil
61 | 	}); _err != nil {
62 | 		// you can implement your fallback logic here
63 | 		if errors.Is(_err, rerrors.ErrCircuitOpen) {
64 | 			receiver.logger.Error(_err)
65 | 		}
66 | 		msg = errors.Wrap(_err, "call GetUser fail")
67 | 	}
68 | 	return
69 | }
70 | func (receiver *UsersvcClientProxy) SignUp(ctx context.Context, _headers map[string]string, username string, password int, actived bool, score []int) (_resp *resty.Response, code int, data string, msg error) {
71 | 	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
72 | 		_resp, code, data, msg = receiver.client.SignUp(
73 | 			ctx,
74 | 			_headers,
75 | 			username,
76 | 			password,
77 | 			actived,
78 | 			score,
79 | 		)
80 | 		if msg != nil {
81 | 			return errors.Wrap(msg, "call SignUp fail")
82 | 		}
83 | 		return nil
84 | 	}); _err != nil {
85 | 		// you can implement your fallback logic here
86 | 		if errors.Is(_err, rerrors.ErrCircuitOpen) {
87 | 			receiver.logger.Error(_err)
88 | 		}
89 | 		msg = errors.Wrap(_err, "call SignUp fail")
90 | 	}
91 | 	return
92 | }
93 | func (receiver *UsersvcClientProxy) UploadAvatar(ctx context.Context, _headers map[string]string, pf []v3.FileModel, ps string, pf2 v3.FileModel, pf3 *multipart.FileHeader, pf4 []*multipart.FileHeader) (_resp *resty.Response, ri int, ri2 interface{}, re error) {
94 | 	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
95 | 		_resp, ri, ri2, re = receiver.client.UploadAvatar(
96 | 			ctx,
97 | 			_headers,
98 | 			pf,
99 | 			ps,
100 | 			pf2,
101 | 			pf3,
102 | 			pf4,
103 | 		)
104 | 		if re != nil {
105 | 			return errors.Wrap(re, "call UploadAvatar fail")
106 | 		}
107 | 		return nil
108 | 	}); _err != nil {
109 | 		// you can implement your fallback logic here
110 | 		if errors.Is(_err, rerrors.ErrCircuitOpen) {
111 | 			receiver.logger.Error(_err)
112 | 		}
113 | 		re = errors.Wrap(_err, "call UploadAvatar fail")
114 | 	}
115 | 	return
116 | }
117 | func (receiver *UsersvcClientProxy) DownloadAvatar(ctx context.Context, _headers map[string]string, userId interface{}, userAttrs ...string) (_resp *resty.Response, rf *os.File, re error) {
118 | 	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
119 | 		_resp, rf, re = receiver.client.DownloadAvatar(
120 | 			ctx,
121 | 			_headers,
122 | 			userId,
123 | 			userAttrs...,
124 | 		)
125 | 		if re != nil {
126 | 			return errors.Wrap(re, "call DownloadAvatar fail")
127 | 		}
128 | 		return nil
129 | 	}); _err != nil {
130 | 		// you can implement your fallback logic here
131 | 		if errors.Is(_err, rerrors.ErrCircuitOpen) {
132 | 			receiver.logger.Error(_err)
133 | 		}
134 | 		re = errors.Wrap(_err, "call DownloadAvatar fail")
135 | 	}
136 | 	return
137 | }
138 | 
139 | type ProxyOption func(*UsersvcClientProxy)
140 | 
141 | func WithRunner(runner goresilience.Runner) ProxyOption {
142 | 	return func(proxy *UsersvcClientProxy) {
143 | 		proxy.runner = runner
144 | 	}
145 | }
146 | 
147 | func WithLogger(logger *logrus.Logger) ProxyOption {
148 | 	return func(proxy *UsersvcClientProxy) {
149 | 		proxy.logger = logger
150 | 	}
151 | }
152 | 
153 | func NewUsersvcClientProxy(client *UsersvcClient, opts ...ProxyOption) *UsersvcClientProxy {
154 | 	cp := &UsersvcClientProxy{
155 | 		client: client,
156 | 		logger: logrus.StandardLogger(),
157 | 	}
158 | 
159 | 	for _, opt := range opts {
160 | 		opt(cp)
161 | 	}
162 | 
163 | 	if cp.runner == nil {
164 | 		var mid []goresilience.Middleware
165 | 		mid = append(mid, metrics.NewMiddleware("testdata_client", metrics.NewPrometheusRecorder(prometheus.DefaultRegisterer)))
166 | 		mid = append(mid, circuitbreaker.NewMiddleware(circuitbreaker.Config{
167 | 			ErrorPercentThresholdToOpen:        50,
168 | 			MinimumRequestToOpen:               6,
169 | 			SuccessfulRequiredOnHalfOpen:       1,
170 | 			WaitDurationInOpenState:            5 * time.Second,
171 | 			MetricsSlidingWindowBucketQuantity: 10,
172 | 			MetricsBucketDuration:              1 * time.Second,
173 | 		}),
174 | 			timeout.NewMiddleware(timeout.Config{
175 | 				Timeout: 3 * time.Minute,
176 | 			}),
177 | 			retry.NewMiddleware(retry.Config{
178 | 				Times: 3,
179 | 			}))
180 | 
181 | 		cp.runner = goresilience.RunnerChain(mid...)
182 | 	}
183 | 
184 | 	return cp
185 | }
```

cmd/internal/svc/codegen/testdata/client/iclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * Don't edit!
4 | */
5 | package client
6 | 
7 | import (
8 | 	"context"
9 | 	"github.com/go-resty/resty/v2"
10 | 	"testdata/vo"
11 | 	"testdata/dto"
12 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
13 | 	"os"
14 | )
15 | 
16 | type Options struct {
17 | 	GzipReqBody bool
18 | }
19 | 
20 | type IUsersvcClient interface {
21 | 	PageUsers(ctx context.Context, _headers map[string]string,query vo.PageQuery,, options Options) (_resp *resty.Response,code int,data vo.PageRet,msg error)
22 | 	GetUser(ctx context.Context, _headers map[string]string,userId string,photo string,, options Options) (_resp *resty.Response,code int,data string,msg error)
23 | 	SignUp(ctx context.Context, _headers map[string]string,username string,password int,actived bool,score []int,, options Options) (_resp *resty.Response,code int,data string,msg error)
24 | 	UploadAvatar(ctx context.Context, _headers map[string]string,pf []v3.FileModel,ps string,pf2 v3.FileModel,pf3 *multipart.FileHeader,pf4 []*multipart.FileHeader,, options Options) (_resp *resty.Response,ri int,ri2 interface{},re error)
25 | 	DownloadAvatar(ctx context.Context, _headers map[string]string,userId interface{},data []byte,price decimal.Decimal,userAttrs ...string,, options Options) (_resp *resty.Response,rf *os.File,re error)
26 | 	GetQuery_range(ctx context.Context, _headers map[string]string,, options Options) (_resp *resty.Response,re error)
27 | 	GetShelves_ShelfBooks_Book(ctx context.Context, _headers map[string]string,, options Options) (_resp *resty.Response,re error)
28 | }
```

cmd/internal/svc/codegen/testdata/cmd/main.go
```
1 | package main
2 | 
3 | import (
4 | 	service "testdata"
5 | 	"testdata/config"
6 | 	"testdata/transport/httpsrv"
7 | 
8 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
9 | )
10 | 
11 | func main() {
12 | 	conf := config.LoadFromEnv()
13 | 	svc := service.NewUsersvc(conf)
14 | 	handler := httpsrv.NewUsersvcHandler(svc)
15 | 	srv := rest.NewRestServer()
16 | 	srv.AddRoute(httpsrv.Routes(handler)...)
17 | 	srv.Run()
18 | }
```

cmd/internal/svc/codegen/testdata/config/config.go
```
1 | package config
2 | 
3 | import (
4 | 	"github.com/sirupsen/logrus"
5 | 	"github.com/unionj-cloud/toolkit/envconfig"
6 | )
7 | 
8 | type Config struct {
9 | 	DbConf DbConfig
10 | }
11 | 
12 | type DbConfig struct {
13 | 	Driver  string `default:"mysql"`
14 | 	Host    string `default:"localhost"`
15 | 	Port    string `default:"3306"`
16 | 	User    string
17 | 	Passwd  string
18 | 	Schema  string
19 | 	Charset string `default:"utf8mb4"`
20 | }
21 | 
22 | func LoadFromEnv() *Config {
23 | 	var dbconf DbConfig
24 | 	err := envconfig.Process("db", &dbconf)
25 | 	if err != nil {
26 | 		logrus.Panicln("Error processing env", err)
27 | 	}
28 | 	return &Config{
29 | 		dbconf,
30 | 	}
31 | }
```

cmd/internal/svc/codegen/testdata/dto/dto.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package dto
6 | 
7 | import "github.com/shopspring/decimal"
8 | 
9 | type StringSliceWrapper struct {
10 | 	Value []string
11 | }
12 | 
13 | // DroppedTarget DroppedTarget has the information for one target that was dropped during relabelling.
14 | type DroppedTarget struct {
15 | 	DiscoveredLabels map[string]StringSliceWrapper `json:"discoveredLabels"`
16 | }
17 | 
18 | // Target Target has the information for one target.
19 | type Target struct {
20 | 	DiscoveredLabels map[string]StringSliceWrapper `json:"discoveredLabels"`
21 | 
22 | 	GlobalURL *string `json:"globalURL"`
23 | 
24 | 	Health *TargetHealth `json:"health"`
25 | 
26 | 	Labels *Labels `json:"labels"`
27 | 
28 | 	LastError *string `json:"lastError"`
29 | 
30 | 	LastScrape *string `json:"lastScrape"`
31 | 
32 | 	LastScrapeDuration *float64 `json:"lastScrapeDuration"`
33 | 
34 | 	ScrapePool *string `json:"scrapePool"`
35 | 
36 | 	ScrapeURL *string `json:"scrapeURL"`
37 | }
38 | 
39 | type Laptop struct {
40 | 	Price decimal.Decimal
41 | }
```

cmd/internal/svc/codegen/testdata/entity/base.go
```
1 | package entity
2 | 
3 | import "time"
4 | 
5 | type Base struct {
6 | 	CreateAt *time.Time `dd:"default:CURRENT_TIMESTAMP"`
7 | 	UpdateAt *time.Time `dd:"default:CURRENT_TIMESTAMP;extra:ON UPDATE CURRENT_TIMESTAMP"`
8 | 	DeleteAt *time.Time
9 | }
```

cmd/internal/svc/codegen/testdata/entity/user.go
```
1 | package entity
2 | 
3 | //dd:table
4 | type User struct {
5 | 	ID        int    `dd:"pk;auto"`
6 | 	Name      string `dd:"index:name_phone_idx,2;default:'jack'"`
7 | 	Phone     string `dd:"index:name_phone_idx,1;default:'13552053960';extra:comment '手机号'"`
8 | 	Age       int    `dd:"index"`
9 | 	No        int    `dd:"unique"`
10 | 	School    string `dd:"null;default:'harvard';extra:comment '学校'"`
11 | 	IsStudent bool
12 | 
13 | 	Base
14 | }
```

cmd/internal/svc/codegen/testdata/vo/enum.go
```
1 | package vo
2 | 
3 | import "encoding/json"
4 | 
5 | //go:generate go-doudou name --file $GOFILE -o
6 | 
7 | type KeyboardLayout int
8 | 
9 | const (
10 | 	UNKNOWN KeyboardLayout = iota
11 | 	QWERTZ
12 | 	AZERTY
13 | 	QWERTY
14 | )
15 | 
16 | func (k *KeyboardLayout) StringSetter(value string) {
17 | 	switch value {
18 | 	case "UNKNOWN":
19 | 		*k = UNKNOWN
20 | 	case "QWERTY":
21 | 		*k = QWERTY
22 | 	case "QWERTZ":
23 | 		*k = QWERTZ
24 | 	case "AZERTY":
25 | 		*k = AZERTY
26 | 	default:
27 | 		*k = UNKNOWN
28 | 	}
29 | }
30 | 
31 | func (k *KeyboardLayout) StringGetter() string {
32 | 	switch *k {
33 | 	case UNKNOWN:
34 | 		return "UNKNOWN"
35 | 	case QWERTY:
36 | 		return "QWERTY"
37 | 	case QWERTZ:
38 | 		return "QWERTZ"
39 | 	case AZERTY:
40 | 		return "AZERTY"
41 | 	default:
42 | 		return "UNKNOWN"
43 | 	}
44 | }
45 | 
46 | func (k *KeyboardLayout) UnmarshalJSON(bytes []byte) error {
47 | 	var _k string
48 | 	err := json.Unmarshal(bytes, &_k)
49 | 	if err != nil {
50 | 		return err
51 | 	}
52 | 	k.StringSetter(_k)
53 | 	return nil
54 | }
55 | 
56 | func (k KeyboardLayout) MarshalJSON() ([]byte, error) {
57 | 	return json.Marshal(k.StringGetter())
58 | }
59 | 
60 | type Keyboard struct {
61 | 	Layout  KeyboardLayout `json:"layout,omitempty"`
62 | 	Backlit bool           `json:"backlit,omitempty"`
63 | }
```

cmd/internal/svc/codegen/testdata/vo/vo.go
```
1 | package vo
2 | 
3 | import "github.com/shopspring/decimal"
4 | 
5 | //go:generate go-doudou name --file $GOFILE -o
6 | 
7 | // 筛选条件
8 | type PageFilter struct {
9 | 	// 真实姓名，前缀匹配
10 | 	Name string
11 | 	// 所属部门ID
12 | 	Dept int
13 | }
14 | 
15 | // 排序条件
16 | type Order struct {
17 | 	Col  string
18 | 	Sort string
19 | }
20 | 
21 | type Page struct {
22 | 	// 排序规则
23 | 	Orders []Order
24 | 	// 页码
25 | 	PageNo int
26 | 	// 每页行数
27 | 	Size int
28 | 	User UserVo
29 | }
30 | 
31 | // 分页筛选条件
32 | type PageQuery struct {
33 | 	Filter PageFilter
34 | 	Page   Page
35 | }
36 | 
37 | type PageRet struct {
38 | 	Items    interface{}
39 | 	PageNo   int
40 | 	PageSize int
41 | 	Total    int
42 | 	HasNext  bool
43 | 	Price    decimal.Decimal
44 | }
45 | 
46 | type UserVo struct {
47 | 	Id    int
48 | 	Name  string
49 | 	Phone string
50 | 	Dept  string
51 | }
```

cmd/internal/svc/codegen/testdata/vo/vo1.go
```
1 | package vo
2 | 
3 | type age int
4 | 
5 | type Event struct {
6 | 	Name      string
7 | 	EventType int
8 | }
9 | 
10 | type TestAlias struct {
11 | 	Age    age
12 | 	School []struct {
13 | 		Name string
14 | 		Addr struct {
15 | 			Zip   string
16 | 			Block string
17 | 			Full  string
18 | 		}
19 | 	}
20 | }
```

cmd/internal/svc/codegen/testdata/vo/vo2.go
```
1 | package vo
2 | 
3 | type TestExprStringP struct {
4 | 	Age     age
5 | 	Hobbies [3]string
6 | 	Data    map[string]string
7 | 	School  []struct {
8 | 		Name string
9 | 		Addr struct {
10 | 			Zip   string
11 | 			Block string
12 | 			Full  string
13 | 		}
14 | 	}
15 | }
```

cmd/internal/svc/codegen/testdata/vop/vo3.go
```
1 | package vo
2 | 
3 | type TestExprStringPPanic struct {
4 | 	GetTest func(name string) int
5 | }
```

cmd/internal/svc/codegen/testdata/vop/vo4.go
```
1 | package vo
2 | 
3 | type TestExprStringPPanic2 struct {
4 | 	StringChan chan string
5 | }
```

cmd/internal/svc/testdata/outputanonystruct/dto/dto.go
```
1 | package dto
2 | 
3 | import "encoding/json"
4 | 
5 | //go:generate go-doudou name --file $GOFILE -o
6 | 
7 | // 筛选条件
8 | type PageFilter struct {
9 | 	// 真实姓名，前缀匹配
10 | 	Name string
11 | 	// 所属部门ID
12 | 	Dept int
13 | }
14 | 
15 | // 排序条件
16 | type Order struct {
17 | 	Col  string
18 | 	Sort string
19 | }
20 | 
21 | type Page struct {
22 | 	// 排序规则
23 | 	Orders []Order
24 | 	// 页码
25 | 	PageNo int
26 | 	// 每页行数
27 | 	Size int `json:"size,omitempty"`
28 | 	User UserVo
29 | }
30 | 
31 | // 分页筛选条件
32 | type PageQuery struct {
33 | 	Filter     PageFilter
34 | 	Page       Page
35 | 	Condtions  map[string]interface{}
36 | 	ACondtions []interface{}
37 | 	ID         int64 `json:"id,string"`
38 | 	Options    []struct {
39 | 		Label string `json:"label" form:"label"`
40 | 		Value string `json:"value" form:"value"`
41 | 	} `json:"options" form:"options"`
42 | }
43 | 
44 | type PageRet struct {
45 | 	Items    interface{}
46 | 	PageNo   int
47 | 	PageSize int
48 | 	Total    int
49 | 	HasNext  bool
50 | }
51 | 
52 | type UserVo struct {
53 | 	Id    int
54 | 	Name  string
55 | 	Phone string
56 | 	Dept  string
57 | }
58 | 
59 | type KeyboardLayout int
60 | 
61 | const (
62 | 	UNKNOWN KeyboardLayout = iota
63 | 	QWERTZ
64 | 	AZERTY
65 | 	QWERTY
66 | )
67 | 
68 | func (k *KeyboardLayout) StringSetter(value string) {
69 | 	switch value {
70 | 	case "UNKNOWN":
71 | 		*k = UNKNOWN
72 | 	case "QWERTY":
73 | 		*k = QWERTY
74 | 	case "QWERTZ":
75 | 		*k = QWERTZ
76 | 	case "AZERTY":
77 | 		*k = AZERTY
78 | 	default:
79 | 		*k = UNKNOWN
80 | 	}
81 | }
82 | 
83 | func (k *KeyboardLayout) StringGetter() string {
84 | 	switch *k {
85 | 	case UNKNOWN:
86 | 		return "UNKNOWN"
87 | 	case QWERTY:
88 | 		return "QWERTY"
89 | 	case QWERTZ:
90 | 		return "QWERTZ"
91 | 	case AZERTY:
92 | 		return "AZERTY"
93 | 	default:
94 | 		return "UNKNOWN"
95 | 	}
96 | }
97 | 
98 | func (k *KeyboardLayout) UnmarshalJSON(bytes []byte) error {
99 | 	var _k string
100 | 	err := json.Unmarshal(bytes, &_k)
101 | 	if err != nil {
102 | 		return err
103 | 	}
104 | 	k.StringSetter(_k)
105 | 	return nil
106 | }
107 | 
108 | func (k KeyboardLayout) MarshalJSON() ([]byte, error) {
109 | 	return json.Marshal(k.StringGetter())
110 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/customerclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"net/http"
12 | 
13 | 	"github.com/go-resty/resty/v2"
14 | 	_querystring "github.com/google/go-querystring/query"
15 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
16 | 	"github.com/opentracing/opentracing-go"
17 | 	"github.com/pkg/errors"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
20 | )
21 | 
22 | type CustomerClient struct {
23 | 	provider registry.IServiceProvider
24 | 	client   *resty.Client
25 | 	rootPath string
26 | }
27 | 
28 | func (receiver *CustomerClient) SetRootPath(rootPath string) {
29 | 	receiver.rootPath = rootPath
30 | }
31 | 
32 | func (receiver *CustomerClient) SetProvider(provider registry.IServiceProvider) {
33 | 	receiver.provider = provider
34 | }
35 | 
36 | func (receiver *CustomerClient) SetClient(client *resty.Client) {
37 | 	receiver.client = client
38 | }
39 | func (receiver *CustomerClient) GetCustomerValidateToken(ctx context.Context, _headers map[string]string,
40 | 	queryParams struct {
41 | 		// required
42 | 		Token string `json:"token" url:"token"`
43 | 	}) (ret bool, _resp *resty.Response, err error) {
44 | 	var _err error
45 | 
46 | 	_req := receiver.client.R()
47 | 	_req.SetContext(ctx)
48 | 	if len(_headers) > 0 {
49 | 		_req.SetHeaders(_headers)
50 | 	}
51 | 	_queryParams, _ := _querystring.Values(queryParams)
52 | 	_req.SetQueryParamsFromValues(_queryParams)
53 | 
54 | 	_resp, _err = _req.Get("/customer/validateToken")
55 | 	if _err != nil {
56 | 		err = errors.Wrap(_err, "")
57 | 		return
58 | 	}
59 | 	if _resp.IsError() {
60 | 		err = errors.New(_resp.String())
61 | 		return
62 | 	}
63 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
64 | 		err = errors.Wrap(_err, "")
65 | 		return
66 | 	}
67 | 	return
68 | }
69 | 
70 | func NewCustomer(opts ...restclient.RestClientOption) *CustomerClient {
71 | 	defaultProvider := restclient.NewServiceProvider("CUSTOMER")
72 | 	defaultClient := restclient.NewClient()
73 | 
74 | 	svcClient := &CustomerClient{
75 | 		provider: defaultProvider,
76 | 		client:   defaultClient,
77 | 	}
78 | 
79 | 	for _, opt := range opts {
80 | 		opt(svcClient)
81 | 	}
82 | 
83 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
84 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
85 | 		return nil
86 | 	})
87 | 
88 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
89 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
90 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
91 | 		*request = *traceReq
92 | 		return nil
93 | 	})
94 | 
95 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
96 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
97 | 		return nil
98 | 	})
99 | 
100 | 	return svcClient
101 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/downloadclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"fmt"
10 | 	"io"
11 | 	"net/http"
12 | 	"os"
13 | 	"path/filepath"
14 | 	"strings"
15 | 
16 | 	"github.com/go-resty/resty/v2"
17 | 	_querystring "github.com/google/go-querystring/query"
18 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
19 | 	"github.com/opentracing/opentracing-go"
20 | 	"github.com/pkg/errors"
21 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
22 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
23 | 	"github.com/unionj-cloud/toolkit/fileutils"
24 | 	"github.com/unionj-cloud/toolkit/stringutils"
25 | )
26 | 
27 | type DownloadClient struct {
28 | 	provider registry.IServiceProvider
29 | 	client   *resty.Client
30 | 	rootPath string
31 | }
32 | 
33 | func (receiver *DownloadClient) SetRootPath(rootPath string) {
34 | 	receiver.rootPath = rootPath
35 | }
36 | 
37 | func (receiver *DownloadClient) SetProvider(provider registry.IServiceProvider) {
38 | 	receiver.provider = provider
39 | }
40 | 
41 | func (receiver *DownloadClient) SetClient(client *resty.Client) {
42 | 	receiver.client = client
43 | }
44 | 
45 | // GetDownloadAvatar GetDownloadAvatar demonstrate how to define download file api
46 | // there must be *os.File parameter among output parameters
47 | func (receiver *DownloadClient) GetDownloadAvatar(ctx context.Context, _headers map[string]string,
48 | 	queryParams struct {
49 | 		// required
50 | 		UserId string `json:"userId" url:"userId"`
51 | 	}) (_downloadFile *os.File, _resp *resty.Response, err error) {
52 | 	var _err error
53 | 
54 | 	_req := receiver.client.R()
55 | 	_req.SetContext(ctx)
56 | 	if len(_headers) > 0 {
57 | 		_req.SetHeaders(_headers)
58 | 	}
59 | 	_queryParams, _ := _querystring.Values(queryParams)
60 | 	_req.SetQueryParamsFromValues(_queryParams)
61 | 	_req.SetDoNotParseResponse(true)
62 | 
63 | 	_resp, _err = _req.Get("/download/avatar")
64 | 	if _err != nil {
65 | 		err = errors.Wrap(_err, "")
66 | 		return
67 | 	}
68 | 	if _resp.IsError() {
69 | 		err = errors.New(_resp.String())
70 | 		return
71 | 	}
72 | 	_disp := _resp.Header().Get("Content-Disposition")
73 | 	_file := strings.TrimPrefix(_disp, "attachment; filename=")
74 | 	_output := os.TempDir()
75 | 	if stringutils.IsNotEmpty(_output) {
76 | 		_file = _output + string(filepath.Separator) + _file
77 | 	}
78 | 	_file = filepath.Clean(_file)
79 | 	if _err = fileutils.CreateDirectory(filepath.Dir(_file)); _err != nil {
80 | 		err = errors.Wrap(_err, "")
81 | 		return
82 | 	}
83 | 	_outFile, _err := os.Create(_file)
84 | 	if _err != nil {
85 | 		err = errors.Wrap(_err, "")
86 | 		return
87 | 	}
88 | 	defer _outFile.Close()
89 | 	defer _resp.RawBody().Close()
90 | 	_, _err = io.Copy(_outFile, _resp.RawBody())
91 | 	if _err != nil {
92 | 		err = errors.Wrap(_err, "")
93 | 		return
94 | 	}
95 | 	_downloadFile = _outFile
96 | 	return
97 | }
98 | 
99 | func NewDownload(opts ...restclient.RestClientOption) *DownloadClient {
100 | 	defaultProvider := restclient.NewServiceProvider("DOWNLOAD")
101 | 	defaultClient := restclient.NewClient()
102 | 
103 | 	svcClient := &DownloadClient{
104 | 		provider: defaultProvider,
105 | 		client:   defaultClient,
106 | 	}
107 | 
108 | 	for _, opt := range opts {
109 | 		opt(svcClient)
110 | 	}
111 | 
112 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
113 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
114 | 		return nil
115 | 	})
116 | 
117 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
118 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
119 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
120 | 		*request = *traceReq
121 | 		return nil
122 | 	})
123 | 
124 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
125 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
126 | 		return nil
127 | 	})
128 | 
129 | 	return svcClient
130 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/pageclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"net/http"
12 | 
13 | 	"github.com/go-resty/resty/v2"
14 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
15 | 	"github.com/opentracing/opentracing-go"
16 | 	"github.com/pkg/errors"
17 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
19 | )
20 | 
21 | type PageClient struct {
22 | 	provider registry.IServiceProvider
23 | 	client   *resty.Client
24 | 	rootPath string
25 | }
26 | 
27 | func (receiver *PageClient) SetRootPath(rootPath string) {
28 | 	receiver.rootPath = rootPath
29 | }
30 | 
31 | func (receiver *PageClient) SetProvider(provider registry.IServiceProvider) {
32 | 	receiver.provider = provider
33 | }
34 | 
35 | func (receiver *PageClient) SetClient(client *resty.Client) {
36 | 	receiver.client = client
37 | }
38 | 
39 | // PostPageUsers PageUsers demonstrate how to define POST and Content-Type as application/json api
40 | func (receiver *PageClient) PostPageUsers(ctx context.Context, _headers map[string]string,
41 | 	// comments above input and output struct type parameters in vo package will display on online document
42 | 	// not comments here
43 | 	bodyJSON PageQuery) (ret PageUsersResp, _resp *resty.Response, err error) {
44 | 	var _err error
45 | 
46 | 	_req := receiver.client.R()
47 | 	_req.SetContext(ctx)
48 | 	if len(_headers) > 0 {
49 | 		_req.SetHeaders(_headers)
50 | 	}
51 | 	_req.SetBody(bodyJSON)
52 | 
53 | 	_resp, _err = _req.Post("/page/users")
54 | 	if _err != nil {
55 | 		err = errors.Wrap(_err, "")
56 | 		return
57 | 	}
58 | 	if _resp.IsError() {
59 | 		err = errors.New(_resp.String())
60 | 		return
61 | 	}
62 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
63 | 		err = errors.Wrap(_err, "")
64 | 		return
65 | 	}
66 | 	return
67 | }
68 | 
69 | // PostPageUsers2 PageUsers2 demonstrate how to define POST and Content-Type as application/json api
70 | func (receiver *PageClient) PostPageUsers2(ctx context.Context, _headers map[string]string,
71 | 	// comments above input and output struct type parameters in vo package will display on online document
72 | 	// not comments here
73 | 	bodyJSON *PageQuery) (ret PageUsers2Resp, _resp *resty.Response, err error) {
74 | 	var _err error
75 | 
76 | 	_req := receiver.client.R()
77 | 	_req.SetContext(ctx)
78 | 	if len(_headers) > 0 {
79 | 		_req.SetHeaders(_headers)
80 | 	}
81 | 	_req.SetBody(bodyJSON)
82 | 
83 | 	_resp, _err = _req.Post("/page/users/2")
84 | 	if _err != nil {
85 | 		err = errors.Wrap(_err, "")
86 | 		return
87 | 	}
88 | 	if _resp.IsError() {
89 | 		err = errors.New(_resp.String())
90 | 		return
91 | 	}
92 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
93 | 		err = errors.Wrap(_err, "")
94 | 		return
95 | 	}
96 | 	return
97 | }
98 | 
99 | func NewPage(opts ...restclient.RestClientOption) *PageClient {
100 | 	defaultProvider := restclient.NewServiceProvider("PAGE")
101 | 	defaultClient := restclient.NewClient()
102 | 
103 | 	svcClient := &PageClient{
104 | 		provider: defaultProvider,
105 | 		client:   defaultClient,
106 | 	}
107 | 
108 | 	for _, opt := range opts {
109 | 		opt(svcClient)
110 | 	}
111 | 
112 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
113 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
114 | 		return nil
115 | 	})
116 | 
117 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
118 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
119 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
120 | 		*request = *traceReq
121 | 		return nil
122 | 	})
123 | 
124 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
125 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
126 | 		return nil
127 | 	})
128 | 
129 | 	return svcClient
130 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/petclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"net/http"
12 | 
13 | 	"github.com/go-resty/resty/v2"
14 | 	_querystring "github.com/google/go-querystring/query"
15 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
16 | 	"github.com/opentracing/opentracing-go"
17 | 	"github.com/pkg/errors"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
20 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
21 | )
22 | 
23 | type PetClient struct {
24 | 	provider registry.IServiceProvider
25 | 	client   *resty.Client
26 | 	rootPath string
27 | }
28 | 
29 | func (receiver *PetClient) SetRootPath(rootPath string) {
30 | 	receiver.rootPath = rootPath
31 | }
32 | 
33 | func (receiver *PetClient) SetProvider(provider registry.IServiceProvider) {
34 | 	receiver.provider = provider
35 | }
36 | 
37 | func (receiver *PetClient) SetClient(client *resty.Client) {
38 | 	receiver.client = client
39 | }
40 | 
41 | // GetPetFindByStatus Finds Pets by status
42 | // Multiple status values can be provided with comma separated strings
43 | func (receiver *PetClient) GetPetFindByStatus(ctx context.Context, _headers map[string]string,
44 | 	queryParams *struct {
45 | 		Status *string `json:"status,omitempty" url:"status"`
46 | 	}) (ret []Pet, _resp *resty.Response, err error) {
47 | 	var _err error
48 | 
49 | 	_req := receiver.client.R()
50 | 	_req.SetContext(ctx)
51 | 	if len(_headers) > 0 {
52 | 		_req.SetHeaders(_headers)
53 | 	}
54 | 	_queryParams, _ := _querystring.Values(queryParams)
55 | 	_req.SetQueryParamsFromValues(_queryParams)
56 | 
57 | 	_resp, _err = _req.Get("/pet/findByStatus")
58 | 	if _err != nil {
59 | 		err = errors.Wrap(_err, "")
60 | 		return
61 | 	}
62 | 	if _resp.IsError() {
63 | 		err = errors.New(_resp.String())
64 | 		return
65 | 	}
66 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
67 | 		err = errors.Wrap(_err, "")
68 | 		return
69 | 	}
70 | 	return
71 | }
72 | 
73 | // GetPetFindByTags Finds Pets by tags
74 | // Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
75 | func (receiver *PetClient) GetPetFindByTags(ctx context.Context, _headers map[string]string,
76 | 	queryParams *struct {
77 | 		Tags *[]string `json:"tags,omitempty" url:"tags"`
78 | 	}) (ret []Pet, _resp *resty.Response, err error) {
79 | 	var _err error
80 | 
81 | 	_req := receiver.client.R()
82 | 	_req.SetContext(ctx)
83 | 	if len(_headers) > 0 {
84 | 		_req.SetHeaders(_headers)
85 | 	}
86 | 	_queryParams, _ := _querystring.Values(queryParams)
87 | 	_req.SetQueryParamsFromValues(_queryParams)
88 | 
89 | 	_resp, _err = _req.Get("/pet/findByTags")
90 | 	if _err != nil {
91 | 		err = errors.Wrap(_err, "")
92 | 		return
93 | 	}
94 | 	if _resp.IsError() {
95 | 		err = errors.New(_resp.String())
96 | 		return
97 | 	}
98 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
99 | 		err = errors.Wrap(_err, "")
100 | 		return
101 | 	}
102 | 	return
103 | }
104 | 
105 | // GetPetPetId Find pet by ID
106 | // Returns a single pet
107 | func (receiver *PetClient) GetPetPetId(ctx context.Context, _headers map[string]string,
108 | 	// ID of pet to return
109 | 	// required
110 | 	petId int64) (ret Pet, _resp *resty.Response, err error) {
111 | 	var _err error
112 | 
113 | 	_req := receiver.client.R()
114 | 	_req.SetContext(ctx)
115 | 	if len(_headers) > 0 {
116 | 		_req.SetHeaders(_headers)
117 | 	}
118 | 	_req.SetPathParam("petId", fmt.Sprintf("%v", petId))
119 | 
120 | 	_resp, _err = _req.Get("/pet/{petId}")
121 | 	if _err != nil {
122 | 		err = errors.Wrap(_err, "")
123 | 		return
124 | 	}
125 | 	if _resp.IsError() {
126 | 		err = errors.New(_resp.String())
127 | 		return
128 | 	}
129 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
130 | 		err = errors.Wrap(_err, "")
131 | 		return
132 | 	}
133 | 	return
134 | }
135 | 
136 | // PostPet Add a new pet to the store
137 | // Add a new pet to the store
138 | func (receiver *PetClient) PostPet(ctx context.Context, _headers map[string]string,
139 | 	bodyJSON Pet) (ret Pet, _resp *resty.Response, err error) {
140 | 	var _err error
141 | 
142 | 	_req := receiver.client.R()
143 | 	_req.SetContext(ctx)
144 | 	if len(_headers) > 0 {
145 | 		_req.SetHeaders(_headers)
146 | 	}
147 | 	_req.SetBody(bodyJSON)
148 | 
149 | 	_resp, _err = _req.Post("/pet")
150 | 	if _err != nil {
151 | 		err = errors.Wrap(_err, "")
152 | 		return
153 | 	}
154 | 	if _resp.IsError() {
155 | 		err = errors.New(_resp.String())
156 | 		return
157 | 	}
158 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
159 | 		err = errors.Wrap(_err, "")
160 | 		return
161 | 	}
162 | 	return
163 | }
164 | 
165 | // PostPetPetIdUploadImage uploads an image
166 | func (receiver *PetClient) PostPetPetIdUploadImage(ctx context.Context, _headers map[string]string,
167 | 	queryParams *struct {
168 | 		AdditionalMetadata *string `json:"additionalMetadata,omitempty" url:"additionalMetadata"`
169 | 	},
170 | 	// ID of pet to update
171 | 	// required
172 | 	petId int64,
173 | 	file *v3.FileModel) (ret ApiResponse, _resp *resty.Response, err error) {
174 | 	var _err error
175 | 
176 | 	_req := receiver.client.R()
177 | 	_req.SetContext(ctx)
178 | 	if len(_headers) > 0 {
179 | 		_req.SetHeaders(_headers)
180 | 	}
181 | 	_queryParams, _ := _querystring.Values(queryParams)
182 | 	_req.SetQueryParamsFromValues(_queryParams)
183 | 	_req.SetPathParam("petId", fmt.Sprintf("%v", petId))
184 | 	if file != nil {
185 | 		_req.SetFileReader("file", file.Filename, file.Reader)
186 | 	}
187 | 
188 | 	_resp, _err = _req.Post("/pet/{petId}/uploadImage")
189 | 	if _err != nil {
190 | 		err = errors.Wrap(_err, "")
191 | 		return
192 | 	}
193 | 	if _resp.IsError() {
194 | 		err = errors.New(_resp.String())
195 | 		return
196 | 	}
197 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
198 | 		err = errors.Wrap(_err, "")
199 | 		return
200 | 	}
201 | 	return
202 | }
203 | 
204 | // PutPet Update an existing pet
205 | // Update an existing pet by Id
206 | func (receiver *PetClient) PutPet(ctx context.Context, _headers map[string]string,
207 | 	bodyJSON Pet) (ret Pet, _resp *resty.Response, err error) {
208 | 	var _err error
209 | 
210 | 	_req := receiver.client.R()
211 | 	_req.SetContext(ctx)
212 | 	if len(_headers) > 0 {
213 | 		_req.SetHeaders(_headers)
214 | 	}
215 | 	_req.SetBody(bodyJSON)
216 | 
217 | 	_resp, _err = _req.Put("/pet")
218 | 	if _err != nil {
219 | 		err = errors.Wrap(_err, "")
220 | 		return
221 | 	}
222 | 	if _resp.IsError() {
223 | 		err = errors.New(_resp.String())
224 | 		return
225 | 	}
226 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
227 | 		err = errors.Wrap(_err, "")
228 | 		return
229 | 	}
230 | 	return
231 | }
232 | 
233 | func NewPet(opts ...restclient.RestClientOption) *PetClient {
234 | 	defaultProvider := restclient.NewServiceProvider("PET")
235 | 	defaultClient := restclient.NewClient()
236 | 
237 | 	svcClient := &PetClient{
238 | 		provider: defaultProvider,
239 | 		client:   defaultClient,
240 | 	}
241 | 
242 | 	for _, opt := range opts {
243 | 		opt(svcClient)
244 | 	}
245 | 
246 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
247 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
248 | 		return nil
249 | 	})
250 | 
251 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
252 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
253 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
254 | 		*request = *traceReq
255 | 		return nil
256 | 	})
257 | 
258 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
259 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
260 | 		return nil
261 | 	})
262 | 
263 | 	return svcClient
264 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/signclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"net/http"
12 | 
13 | 	"github.com/go-resty/resty/v2"
14 | 	_querystring "github.com/google/go-querystring/query"
15 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
16 | 	"github.com/opentracing/opentracing-go"
17 | 	"github.com/pkg/errors"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
20 | )
21 | 
22 | type SignClient struct {
23 | 	provider registry.IServiceProvider
24 | 	client   *resty.Client
25 | 	rootPath string
26 | }
27 | 
28 | func (receiver *SignClient) SetRootPath(rootPath string) {
29 | 	receiver.rootPath = rootPath
30 | }
31 | 
32 | func (receiver *SignClient) SetProvider(provider registry.IServiceProvider) {
33 | 	receiver.provider = provider
34 | }
35 | 
36 | func (receiver *SignClient) SetClient(client *resty.Client) {
37 | 	receiver.client = client
38 | }
39 | 
40 | // PostSignUp SignUp demonstrate how to define POST and Content-Type as application/x-www-form-urlencoded api
41 | func (receiver *SignClient) PostSignUp(ctx context.Context, _headers map[string]string,
42 | 	bodyParams SignUpReq) (ret SignUpResp, _resp *resty.Response, err error) {
43 | 	var _err error
44 | 
45 | 	_req := receiver.client.R()
46 | 	_req.SetContext(ctx)
47 | 	if len(_headers) > 0 {
48 | 		_req.SetHeaders(_headers)
49 | 	}
50 | 	_bodyParams, _ := _querystring.Values(bodyParams)
51 | 	_req.SetFormDataFromValues(_bodyParams)
52 | 
53 | 	_resp, _err = _req.Post("/sign/up")
54 | 	if _err != nil {
55 | 		err = errors.Wrap(_err, "")
56 | 		return
57 | 	}
58 | 	if _resp.IsError() {
59 | 		err = errors.New(_resp.String())
60 | 		return
61 | 	}
62 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
63 | 		err = errors.Wrap(_err, "")
64 | 		return
65 | 	}
66 | 	return
67 | }
68 | 
69 | func NewSign(opts ...restclient.RestClientOption) *SignClient {
70 | 	defaultProvider := restclient.NewServiceProvider("SIGN")
71 | 	defaultClient := restclient.NewClient()
72 | 
73 | 	svcClient := &SignClient{
74 | 		provider: defaultProvider,
75 | 		client:   defaultClient,
76 | 	}
77 | 
78 | 	for _, opt := range opts {
79 | 		opt(svcClient)
80 | 	}
81 | 
82 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
83 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
84 | 		return nil
85 | 	})
86 | 
87 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
88 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
89 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
90 | 		*request = *traceReq
91 | 		return nil
92 | 	})
93 | 
94 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
95 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
96 | 		return nil
97 | 	})
98 | 
99 | 	return svcClient
100 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/storeclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"net/http"
12 | 
13 | 	"github.com/go-resty/resty/v2"
14 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
15 | 	"github.com/opentracing/opentracing-go"
16 | 	"github.com/pkg/errors"
17 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
19 | )
20 | 
21 | type StoreClient struct {
22 | 	provider registry.IServiceProvider
23 | 	client   *resty.Client
24 | 	rootPath string
25 | }
26 | 
27 | func (receiver *StoreClient) SetRootPath(rootPath string) {
28 | 	receiver.rootPath = rootPath
29 | }
30 | 
31 | func (receiver *StoreClient) SetProvider(provider registry.IServiceProvider) {
32 | 	receiver.provider = provider
33 | }
34 | 
35 | func (receiver *StoreClient) SetClient(client *resty.Client) {
36 | 	receiver.client = client
37 | }
38 | 
39 | // GetStoreInventory Returns pet inventories by status
40 | // Returns a map of status codes to quantities
41 | func (receiver *StoreClient) GetStoreInventory(ctx context.Context, _headers map[string]string) (ret map[string]int, _resp *resty.Response, err error) {
42 | 	var _err error
43 | 
44 | 	_req := receiver.client.R()
45 | 	_req.SetContext(ctx)
46 | 	if len(_headers) > 0 {
47 | 		_req.SetHeaders(_headers)
48 | 	}
49 | 
50 | 	_resp, _err = _req.Get("/store/inventory")
51 | 	if _err != nil {
52 | 		err = errors.Wrap(_err, "")
53 | 		return
54 | 	}
55 | 	if _resp.IsError() {
56 | 		err = errors.New(_resp.String())
57 | 		return
58 | 	}
59 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
60 | 		err = errors.Wrap(_err, "")
61 | 		return
62 | 	}
63 | 	return
64 | }
65 | 
66 | // GetStoreOrderOrderId Find purchase order by ID
67 | // For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
68 | func (receiver *StoreClient) GetStoreOrderOrderId(ctx context.Context, _headers map[string]string,
69 | 	// ID of order that needs to be fetched
70 | 	// required
71 | 	orderId int64) (ret Order, _resp *resty.Response, err error) {
72 | 	var _err error
73 | 
74 | 	_req := receiver.client.R()
75 | 	_req.SetContext(ctx)
76 | 	if len(_headers) > 0 {
77 | 		_req.SetHeaders(_headers)
78 | 	}
79 | 	_req.SetPathParam("orderId", fmt.Sprintf("%v", orderId))
80 | 
81 | 	_resp, _err = _req.Get("/store/order/{orderId}")
82 | 	if _err != nil {
83 | 		err = errors.Wrap(_err, "")
84 | 		return
85 | 	}
86 | 	if _resp.IsError() {
87 | 		err = errors.New(_resp.String())
88 | 		return
89 | 	}
90 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
91 | 		err = errors.Wrap(_err, "")
92 | 		return
93 | 	}
94 | 	return
95 | }
96 | 
97 | // PostStoreOrder Place an order for a pet
98 | // Place a new order in the store
99 | func (receiver *StoreClient) PostStoreOrder(ctx context.Context, _headers map[string]string,
100 | 	bodyJSON *Order) (ret Order, _resp *resty.Response, err error) {
101 | 	var _err error
102 | 
103 | 	_req := receiver.client.R()
104 | 	_req.SetContext(ctx)
105 | 	if len(_headers) > 0 {
106 | 		_req.SetHeaders(_headers)
107 | 	}
108 | 	_req.SetBody(bodyJSON)
109 | 
110 | 	_resp, _err = _req.Post("/store/order")
111 | 	if _err != nil {
112 | 		err = errors.Wrap(_err, "")
113 | 		return
114 | 	}
115 | 	if _resp.IsError() {
116 | 		err = errors.New(_resp.String())
117 | 		return
118 | 	}
119 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
120 | 		err = errors.Wrap(_err, "")
121 | 		return
122 | 	}
123 | 	return
124 | }
125 | 
126 | func NewStore(opts ...restclient.RestClientOption) *StoreClient {
127 | 	defaultProvider := restclient.NewServiceProvider("STORE")
128 | 	defaultClient := restclient.NewClient()
129 | 
130 | 	svcClient := &StoreClient{
131 | 		provider: defaultProvider,
132 | 		client:   defaultClient,
133 | 	}
134 | 
135 | 	for _, opt := range opts {
136 | 		opt(svcClient)
137 | 	}
138 | 
139 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
140 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
141 | 		return nil
142 | 	})
143 | 
144 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
145 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
146 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
147 | 		*request = *traceReq
148 | 		return nil
149 | 	})
150 | 
151 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
152 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
153 | 		return nil
154 | 	})
155 | 
156 | 	return svcClient
157 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/textclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"net/http"
12 | 
13 | 	"github.com/go-resty/resty/v2"
14 | 	_querystring "github.com/google/go-querystring/query"
15 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
16 | 	"github.com/opentracing/opentracing-go"
17 | 	"github.com/pkg/errors"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
20 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
21 | )
22 | 
23 | type TextClient struct {
24 | 	provider registry.IServiceProvider
25 | 	client   *resty.Client
26 | 	rootPath string
27 | }
28 | 
29 | func (receiver *TextClient) SetRootPath(rootPath string) {
30 | 	receiver.rootPath = rootPath
31 | }
32 | 
33 | func (receiver *TextClient) SetProvider(provider registry.IServiceProvider) {
34 | 	receiver.provider = provider
35 | }
36 | 
37 | func (receiver *TextClient) SetClient(client *resty.Client) {
38 | 	receiver.client = client
39 | }
40 | 
41 | // GetTextExtractFromUrl 提取文本
42 | func (receiver *TextClient) GetTextExtractFromUrl(ctx context.Context, _headers map[string]string,
43 | 	queryParams struct {
44 | 		ClearFormat *bool `json:"clearFormat,omitempty" url:"clearFormat"`
45 | 		// required
46 | 		Url string `json:"url,omitempty" url:"url"`
47 | 	}) (ret ResultString, _resp *resty.Response, err error) {
48 | 	var _err error
49 | 
50 | 	_req := receiver.client.R()
51 | 	_req.SetContext(ctx)
52 | 	if len(_headers) > 0 {
53 | 		_req.SetHeaders(_headers)
54 | 	}
55 | 	_queryParams, _ := _querystring.Values(queryParams)
56 | 	_req.SetQueryParamsFromValues(_queryParams)
57 | 
58 | 	_resp, _err = _req.Get("/text/extractFromUrl")
59 | 	if _err != nil {
60 | 		err = errors.Wrap(_err, "")
61 | 		return
62 | 	}
63 | 	if _resp.IsError() {
64 | 		err = errors.New(_resp.String())
65 | 		return
66 | 	}
67 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
68 | 		err = errors.Wrap(_err, "")
69 | 		return
70 | 	}
71 | 	return
72 | }
73 | 
74 | // PostTextExtractFromFile 提取文本
75 | func (receiver *TextClient) PostTextExtractFromFile(ctx context.Context, _headers map[string]string,
76 | 	queryParams *struct {
77 | 		ClearFormat *bool `json:"clearFormat,omitempty" url:"clearFormat"`
78 | 	},
79 | 	file *v3.FileModel) (ret ResultString, _resp *resty.Response, err error) {
80 | 	var _err error
81 | 
82 | 	_req := receiver.client.R()
83 | 	_req.SetContext(ctx)
84 | 	if len(_headers) > 0 {
85 | 		_req.SetHeaders(_headers)
86 | 	}
87 | 	_queryParams, _ := _querystring.Values(queryParams)
88 | 	_req.SetQueryParamsFromValues(_queryParams)
89 | 	if file != nil {
90 | 		_req.SetFileReader("file", file.Filename, file.Reader)
91 | 	}
92 | 
93 | 	_resp, _err = _req.Post("/text/extractFromFile")
94 | 	if _err != nil {
95 | 		err = errors.Wrap(_err, "")
96 | 		return
97 | 	}
98 | 	if _resp.IsError() {
99 | 		err = errors.New(_resp.String())
100 | 		return
101 | 	}
102 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
103 | 		err = errors.Wrap(_err, "")
104 | 		return
105 | 	}
106 | 	return
107 | }
108 | 
109 | func NewText(opts ...restclient.RestClientOption) *TextClient {
110 | 	defaultProvider := restclient.NewServiceProvider("TEXT")
111 | 	defaultClient := restclient.NewClient()
112 | 
113 | 	svcClient := &TextClient{
114 | 		provider: defaultProvider,
115 | 		client:   defaultClient,
116 | 	}
117 | 
118 | 	for _, opt := range opts {
119 | 		opt(svcClient)
120 | 	}
121 | 
122 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
123 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
124 | 		return nil
125 | 	})
126 | 
127 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
128 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
129 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
130 | 		*request = *traceReq
131 | 		return nil
132 | 	})
133 | 
134 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
135 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
136 | 		return nil
137 | 	})
138 | 
139 | 	return svcClient
140 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/unipayclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"fmt"
10 | 	"net/http"
11 | 
12 | 	"github.com/go-resty/resty/v2"
13 | 	_querystring "github.com/google/go-querystring/query"
14 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
15 | 	"github.com/opentracing/opentracing-go"
16 | 	"github.com/pkg/errors"
17 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
19 | )
20 | 
21 | type UnipayClient struct {
22 | 	provider registry.IServiceProvider
23 | 	client   *resty.Client
24 | 	rootPath string
25 | }
26 | 
27 | func (receiver *UnipayClient) SetRootPath(rootPath string) {
28 | 	receiver.rootPath = rootPath
29 | }
30 | 
31 | func (receiver *UnipayClient) SetProvider(provider registry.IServiceProvider) {
32 | 	receiver.provider = provider
33 | }
34 | 
35 | func (receiver *UnipayClient) SetClient(client *resty.Client) {
36 | 	receiver.client = client
37 | }
38 | func (receiver *UnipayClient) GetUnipayStartUnionPay(ctx context.Context, _headers map[string]string,
39 | 	queryParams struct {
40 | 		// required
41 | 		TxnAmt string `json:"txnAmt" url:"txnAmt"`
42 | 		// required
43 | 		Token string `json:"token" url:"token"`
44 | 		// required
45 | 		CompanyId string `json:"companyId" url:"companyId"`
46 | 		// required
47 | 		FrontUrl string `json:"frontUrl" url:"frontUrl"`
48 | 	}) (ret string, _resp *resty.Response, err error) {
49 | 	var _err error
50 | 
51 | 	_req := receiver.client.R()
52 | 	_req.SetContext(ctx)
53 | 	if len(_headers) > 0 {
54 | 		_req.SetHeaders(_headers)
55 | 	}
56 | 	_queryParams, _ := _querystring.Values(queryParams)
57 | 	_req.SetQueryParamsFromValues(_queryParams)
58 | 
59 | 	_resp, _err = _req.Get("/unipay/startUnionPay")
60 | 	if _err != nil {
61 | 		err = errors.Wrap(_err, "")
62 | 		return
63 | 	}
64 | 	if _resp.IsError() {
65 | 		err = errors.New(_resp.String())
66 | 		return
67 | 	}
68 | 	ret = _resp.String()
69 | 	return
70 | }
71 | 
72 | func NewUnipay(opts ...restclient.RestClientOption) *UnipayClient {
73 | 	defaultProvider := restclient.NewServiceProvider("UNIPAY")
74 | 	defaultClient := restclient.NewClient()
75 | 
76 | 	svcClient := &UnipayClient{
77 | 		provider: defaultProvider,
78 | 		client:   defaultClient,
79 | 	}
80 | 
81 | 	for _, opt := range opts {
82 | 		opt(svcClient)
83 | 	}
84 | 
85 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
86 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
87 | 		return nil
88 | 	})
89 | 
90 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
91 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
92 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
93 | 		*request = *traceReq
94 | 		return nil
95 | 	})
96 | 
97 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
98 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
99 | 		return nil
100 | 	})
101 | 
102 | 	return svcClient
103 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/uploadclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"net/http"
12 | 
13 | 	"github.com/go-resty/resty/v2"
14 | 	_querystring "github.com/google/go-querystring/query"
15 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
16 | 	"github.com/opentracing/opentracing-go"
17 | 	"github.com/pkg/errors"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
20 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
21 | )
22 | 
23 | type UploadClient struct {
24 | 	provider registry.IServiceProvider
25 | 	client   *resty.Client
26 | 	rootPath string
27 | }
28 | 
29 | func (receiver *UploadClient) SetRootPath(rootPath string) {
30 | 	receiver.rootPath = rootPath
31 | }
32 | 
33 | func (receiver *UploadClient) SetProvider(provider registry.IServiceProvider) {
34 | 	receiver.provider = provider
35 | }
36 | 
37 | func (receiver *UploadClient) SetClient(client *resty.Client) {
38 | 	receiver.client = client
39 | }
40 | 
41 | // PostUploadAvatar UploadAvatar demonstrate how to define upload files api
42 | // there must be one []v3.FileModel or v3.FileModel parameter among input parameters
43 | // remember to close the readers by Close method of v3.FileModel if you don't need them anymore when you finished your own business logic
44 | func (receiver *UploadClient) PostUploadAvatar(ctx context.Context, _headers map[string]string,
45 | 	bodyParams struct {
46 | 		// required
47 | 		Ps string `json:"ps" url:"ps"`
48 | 	},
49 | 	pf []v3.FileModel) (ret UploadAvatarResp, _resp *resty.Response, err error) {
50 | 	var _err error
51 | 
52 | 	_req := receiver.client.R()
53 | 	_req.SetContext(ctx)
54 | 	if len(_headers) > 0 {
55 | 		_req.SetHeaders(_headers)
56 | 	}
57 | 	_bodyParams, _ := _querystring.Values(bodyParams)
58 | 	_req.SetFormDataFromValues(_bodyParams)
59 | 	if len(pf) == 0 {
60 | 		err = errors.New("at least one file should be uploaded for parameter pf")
61 | 		return
62 | 	}
63 | 	for _, _f := range pf {
64 | 		_req.SetFileReader("pf", _f.Filename, _f.Reader)
65 | 	}
66 | 
67 | 	_resp, _err = _req.Post("/upload/avatar")
68 | 	if _err != nil {
69 | 		err = errors.Wrap(_err, "")
70 | 		return
71 | 	}
72 | 	if _resp.IsError() {
73 | 		err = errors.New(_resp.String())
74 | 		return
75 | 	}
76 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
77 | 		err = errors.Wrap(_err, "")
78 | 		return
79 | 	}
80 | 	return
81 | }
82 | 
83 | // PostUploadAvatar2 UploadAvatar2 demonstrate how to define upload files api
84 | // remember to close the readers by Close method of v3.FileModel if you don't need them anymore when you finished your own business logic
85 | func (receiver *UploadClient) PostUploadAvatar2(ctx context.Context, _headers map[string]string,
86 | 	bodyParams struct {
87 | 		// required
88 | 		Ps string `json:"ps" url:"ps"`
89 | 	},
90 | 	pf []v3.FileModel,
91 | 	pf2 *v3.FileModel,
92 | 	pf3 *v3.FileModel) (ret UploadAvatar2Resp, _resp *resty.Response, err error) {
93 | 	var _err error
94 | 
95 | 	_req := receiver.client.R()
96 | 	_req.SetContext(ctx)
97 | 	if len(_headers) > 0 {
98 | 		_req.SetHeaders(_headers)
99 | 	}
100 | 	_bodyParams, _ := _querystring.Values(bodyParams)
101 | 	_req.SetFormDataFromValues(_bodyParams)
102 | 	if len(pf) == 0 {
103 | 		err = errors.New("at least one file should be uploaded for parameter pf")
104 | 		return
105 | 	}
106 | 	for _, _f := range pf {
107 | 		_req.SetFileReader("pf", _f.Filename, _f.Reader)
108 | 	}
109 | 	if pf2 != nil {
110 | 		_req.SetFileReader("pf2", pf2.Filename, pf2.Reader)
111 | 	}
112 | 	if pf3 != nil {
113 | 		_req.SetFileReader("pf3", pf3.Filename, pf3.Reader)
114 | 	}
115 | 
116 | 	_resp, _err = _req.Post("/upload/avatar/2")
117 | 	if _err != nil {
118 | 		err = errors.Wrap(_err, "")
119 | 		return
120 | 	}
121 | 	if _resp.IsError() {
122 | 		err = errors.New(_resp.String())
123 | 		return
124 | 	}
125 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
126 | 		err = errors.Wrap(_err, "")
127 | 		return
128 | 	}
129 | 	return
130 | }
131 | 
132 | func NewUpload(opts ...restclient.RestClientOption) *UploadClient {
133 | 	defaultProvider := restclient.NewServiceProvider("UPLOAD")
134 | 	defaultClient := restclient.NewClient()
135 | 
136 | 	svcClient := &UploadClient{
137 | 		provider: defaultProvider,
138 | 		client:   defaultClient,
139 | 	}
140 | 
141 | 	for _, opt := range opts {
142 | 		opt(svcClient)
143 | 	}
144 | 
145 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
146 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
147 | 		return nil
148 | 	})
149 | 
150 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
151 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
152 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
153 | 		*request = *traceReq
154 | 		return nil
155 | 	})
156 | 
157 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
158 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
159 | 		return nil
160 | 	})
161 | 
162 | 	return svcClient
163 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/userclient.go
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * You can edit it as your need.
4 |  */
5 | package test
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"net/http"
12 | 
13 | 	"github.com/go-resty/resty/v2"
14 | 	_querystring "github.com/google/go-querystring/query"
15 | 	"github.com/opentracing-contrib/go-stdlib/nethttp"
16 | 	"github.com/opentracing/opentracing-go"
17 | 	"github.com/pkg/errors"
18 | 	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
20 | )
21 | 
22 | type UserClient struct {
23 | 	provider registry.IServiceProvider
24 | 	client   *resty.Client
25 | 	rootPath string
26 | }
27 | 
28 | func (receiver *UserClient) SetRootPath(rootPath string) {
29 | 	receiver.rootPath = rootPath
30 | }
31 | 
32 | func (receiver *UserClient) SetProvider(provider registry.IServiceProvider) {
33 | 	receiver.provider = provider
34 | }
35 | 
36 | func (receiver *UserClient) SetClient(client *resty.Client) {
37 | 	receiver.client = client
38 | }
39 | 
40 | // GetUserLogin Logs user into the system
41 | func (receiver *UserClient) GetUserLogin(ctx context.Context, _headers map[string]string,
42 | 	queryParams *struct {
43 | 		Username *string `json:"username,omitempty" url:"username"`
44 | 		Password *string `json:"password,omitempty" url:"password"`
45 | 	}) (ret string, _resp *resty.Response, err error) {
46 | 	var _err error
47 | 
48 | 	_req := receiver.client.R()
49 | 	_req.SetContext(ctx)
50 | 	if len(_headers) > 0 {
51 | 		_req.SetHeaders(_headers)
52 | 	}
53 | 	_queryParams, _ := _querystring.Values(queryParams)
54 | 	_req.SetQueryParamsFromValues(_queryParams)
55 | 
56 | 	_resp, _err = _req.Get("/user/login")
57 | 	if _err != nil {
58 | 		err = errors.Wrap(_err, "")
59 | 		return
60 | 	}
61 | 	if _resp.IsError() {
62 | 		err = errors.New(_resp.String())
63 | 		return
64 | 	}
65 | 	ret = _resp.String()
66 | 	return
67 | }
68 | 
69 | // GetUserUsername Get user by user name
70 | func (receiver *UserClient) GetUserUsername(ctx context.Context, _headers map[string]string,
71 | 	// The name that needs to be fetched. Use user1 for testing.
72 | 	// required
73 | 	username string) (ret User, _resp *resty.Response, err error) {
74 | 	var _err error
75 | 
76 | 	_req := receiver.client.R()
77 | 	_req.SetContext(ctx)
78 | 	if len(_headers) > 0 {
79 | 		_req.SetHeaders(_headers)
80 | 	}
81 | 	_req.SetPathParam("username", fmt.Sprintf("%v", username))
82 | 
83 | 	_resp, _err = _req.Get("/user/{username}")
84 | 	if _err != nil {
85 | 		err = errors.Wrap(_err, "")
86 | 		return
87 | 	}
88 | 	if _resp.IsError() {
89 | 		err = errors.New(_resp.String())
90 | 		return
91 | 	}
92 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
93 | 		err = errors.Wrap(_err, "")
94 | 		return
95 | 	}
96 | 	return
97 | }
98 | 
99 | // PostUserCreateWithList Creates list of users with given input array
100 | // Creates list of users with given input array
101 | func (receiver *UserClient) PostUserCreateWithList(ctx context.Context, _headers map[string]string,
102 | 	bodyJSON *[]User) (ret User, _resp *resty.Response, err error) {
103 | 	var _err error
104 | 
105 | 	_req := receiver.client.R()
106 | 	_req.SetContext(ctx)
107 | 	if len(_headers) > 0 {
108 | 		_req.SetHeaders(_headers)
109 | 	}
110 | 	_req.SetBody(bodyJSON)
111 | 
112 | 	_resp, _err = _req.Post("/user/createWithList")
113 | 	if _err != nil {
114 | 		err = errors.Wrap(_err, "")
115 | 		return
116 | 	}
117 | 	if _resp.IsError() {
118 | 		err = errors.New(_resp.String())
119 | 		return
120 | 	}
121 | 	if _err = json.Unmarshal(_resp.Body(), &ret); _err != nil {
122 | 		err = errors.Wrap(_err, "")
123 | 		return
124 | 	}
125 | 	return
126 | }
127 | 
128 | func NewUser(opts ...restclient.RestClientOption) *UserClient {
129 | 	defaultProvider := restclient.NewServiceProvider("USER")
130 | 	defaultClient := restclient.NewClient()
131 | 
132 | 	svcClient := &UserClient{
133 | 		provider: defaultProvider,
134 | 		client:   defaultClient,
135 | 	}
136 | 
137 | 	for _, opt := range opts {
138 | 		opt(svcClient)
139 | 	}
140 | 
141 | 	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
142 | 		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
143 | 		return nil
144 | 	})
145 | 
146 | 	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
147 | 		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
148 | 			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
149 | 		*request = *traceReq
150 | 		return nil
151 | 	})
152 | 
153 | 	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
154 | 		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
155 | 		return nil
156 | 	})
157 | 
158 | 	return svcClient
159 | }
```

cmd/internal/openapi/v3/codegen/testdata/test/vo.go
```
```

cmd/internal/svc/codegen/testdata/transport/grpc/usersvc.proto
```
1 | /**
2 | * Generated by go-doudou v2.0.4.
3 | * Don't edit!
4 | *
5 | * Version No.: v20230115
6 | */
7 | syntax = "proto3";
8 | 
9 | package usersvc;
10 | option go_package = "testdata/transport/grpc";
11 | 
12 | import "google/protobuf/any.proto";
13 | 
14 | 
15 | message DownloadAvatarRpcRequest {
16 |   google.protobuf.Any userId = 1 [json_name="userId"];
17 |   bytes data = 2 [json_name="data"];
18 |   repeated string userAttrs = 3 [json_name="userAttrs"];
19 | }
20 | 
21 | message DownloadAvatarRpcResponse {
22 |   bytes rf = 1 [json_name="rf"];
23 | }
24 | 
25 | // DroppedTarget DroppedTarget has the information for one target that was dropped during relabelling.
26 | message DroppedTarget {
27 |   map<string, StringSliceWrapper> discoveredLabels = 1 [json_name="discoveredLabels"];
28 | }
29 | 
30 | message GetUserRpcRequest {
31 |   // 用户ID
32 |   string userId = 1 [json_name="userId"];
33 |   // 图片地址
34 |   string photo = 2 [json_name="photo"];
35 | }
36 | 
37 | message GetUserRpcResponse {
38 |   int32 code = 1 [json_name="code"];
39 |   string data = 2 [json_name="data"];
40 | }
41 | 
42 | message PageUsersRpcResponse {
43 |   int32 code = 1 [json_name="code"];
44 |   google.protobuf.Any data = 2 [json_name="data"];
45 | }
46 | 
47 | message SignUpRpcRequest {
48 |   string username = 1 [json_name="username"];
49 |   int32 password = 2 [json_name="password"];
50 |   bool actived = 3 [json_name="actived"];
51 |   repeated int32 score = 4 [json_name="score"];
52 | }
53 | 
54 | message SignUpRpcResponse {
55 |   int32 code = 1 [json_name="code"];
56 |   string data = 2 [json_name="data"];
57 | }
58 | 
59 | message StringSliceWrapper {
60 |   repeated string value = 1 [json_name="value"];
61 | }
62 | 
63 | // Target Target has the information for one target.
64 | message Target {
65 |   map<string, StringSliceWrapper> discoveredLabels = 1 [json_name="discoveredLabels"];
66 |   string globalURL = 2 [json_name="globalURL"];
67 |   google.protobuf.Any health = 3 [json_name="health"];
68 |   google.protobuf.Any labels = 4 [json_name="labels"];
69 |   string lastError = 5 [json_name="lastError"];
70 |   string lastScrape = 6 [json_name="lastScrape"];
71 |   double lastScrapeDuration = 7 [json_name="lastScrapeDuration"];
72 |   string scrapePool = 8 [json_name="scrapePool"];
73 |   string scrapeURL = 9 [json_name="scrapeURL"];
74 | }
75 | 
76 | message UploadAvatarRpcRequest {
77 |   repeated bytes pf = 1 [json_name="pf"];
78 |   string ps = 2 [json_name="ps"];
79 |   bytes pf2 = 3 [json_name="pf2"];
80 |   google.protobuf.Any pf3 = 4 [json_name="pf3"];
81 |   repeated google.protobuf.Any pf4 = 5 [json_name="pf4"];
82 | }
83 | 
84 | message UploadAvatarRpcResponse {
85 |   int32 ri = 1 [json_name="ri"];
86 |   google.protobuf.Any ri2 = 2 [json_name="ri2"];
87 | }
88 | 
89 | service UsersvcService {
90 |   // You can define your service methods as your need. Below is an example.@role(user)
91 |   rpc PageUsersRpc(google.protobuf.Any) returns (PageUsersRpcResponse);
92 |   // comment1
93 | // comment2
94 | // @role(admin)
95 |   rpc GetUserRpc(GetUserRpcRequest) returns (GetUserRpcResponse);
96 |   // comment3
97 | // @permission(create,update)@role(admin)
98 |   rpc SignUpRpc(SignUpRpcRequest) returns (SignUpRpcResponse);
99 |   // comment4
100 | // @role(user)
101 |   rpc UploadAvatarRpc(UploadAvatarRpcRequest) returns (UploadAvatarRpcResponse);
102 |   // comment5
103 |   rpc DownloadAvatarRpc(DownloadAvatarRpcRequest) returns (DownloadAvatarRpcResponse);
104 | }
```

cmd/internal/svc/codegen/testdata/transport/httpsrv/handlerimpl.go
```
1 | /**
2 | * Generated by go-doudou v1.3.8.
3 | * You can edit it as your need.
4 |  */
5 | package httpsrv
6 | 
7 | import (
8 | 	"context"
9 | 	"encoding/json"
10 | 	"fmt"
11 | 	"io"
12 | 	"mime/multipart"
13 | 	"net/http"
14 | 	"os"
15 | 	service "testdata"
16 | 	"testdata/vo"
17 | 
18 | 	"github.com/pkg/errors"
19 | 	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
20 | 	"github.com/unionj-cloud/toolkit/cast"
21 | 	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
22 | )
23 | 
24 | type UsersvcHandlerImpl struct {
25 | 	usersvc service.Usersvc
26 | }
27 | 
28 | func (receiver *UsersvcHandlerImpl) PageUsers(_writer http.ResponseWriter, _req *http.Request) {
29 | 	var (
30 | 		ctx   context.Context
31 | 		query vo.PageQuery
32 | 		code  int
33 | 		data  vo.PageRet
34 | 		msg   error
35 | 	)
36 | 	ctx = _req.Context()
37 | 	if _req.Body == nil {
38 | 		http.Error(_writer, "missing request body", http.StatusBadRequest)
39 | 		return
40 | 	} else {
41 | 		if _err := json.NewDecoder(_req.Body).Decode(&query); _err != nil {
42 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
43 | 			return
44 | 		} else {
45 | 			if _err := rest.ValidateStruct(query); _err != nil {
46 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
47 | 				return
48 | 			}
49 | 		}
50 | 	}
51 | 	code, data, msg = receiver.usersvc.PageUsers(
52 | 		ctx,
53 | 		query,
54 | 	)
55 | 	if msg != nil {
56 | 		if errors.Is(msg, context.Canceled) {
57 | 			http.Error(_writer, msg.Error(), http.StatusBadRequest)
58 | 		} else if _err, ok := msg.(*rest.BizError); ok {
59 | 			http.Error(_writer, _err.Error(), _err.StatusCode)
60 | 		} else {
61 | 			http.Error(_writer, msg.Error(), http.StatusInternalServerError)
62 | 		}
63 | 		return
64 | 	}
65 | 	if _err := json.NewEncoder(_writer).Encode(struct {
66 | 		Code int        `json:"code,omitempty"`
67 | 		Data vo.PageRet `json:"data,omitempty"`
68 | 	}{
69 | 		Code: code,
70 | 		Data: data,
71 | 	}); _err != nil {
72 | 		http.Error(_writer, _err.Error(), http.StatusInternalServerError)
73 | 		return
74 | 	}
75 | }
76 | func (receiver *UsersvcHandlerImpl) GetUser(_writer http.ResponseWriter, _req *http.Request) {
77 | 	var (
78 | 		ctx    context.Context
79 | 		userId string
80 | 		photo  string
81 | 		code   int
82 | 		data   string
83 | 		msg    error
84 | 	)
85 | 	ctx = _req.Context()
86 | 	if _err := _req.ParseForm(); _err != nil {
87 | 		http.Error(_writer, _err.Error(), http.StatusBadRequest)
88 | 		return
89 | 	}
90 | 	if _, exists := _req.Form["userId"]; exists {
91 | 		userId = _req.FormValue("userId")
92 | 		if _err := rest.ValidateVar(userId, "", "userId"); _err != nil {
93 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
94 | 			return
95 | 		}
96 | 	} else {
97 | 		http.Error(_writer, "missing parameter userId", http.StatusBadRequest)
98 | 		return
99 | 	}
100 | 	if _, exists := _req.Form["photo"]; exists {
101 | 		photo = _req.FormValue("photo")
102 | 		if _err := rest.ValidateVar(photo, "", "photo"); _err != nil {
103 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
104 | 			return
105 | 		}
106 | 	} else {
107 | 		http.Error(_writer, "missing parameter photo", http.StatusBadRequest)
108 | 		return
109 | 	}
110 | 	code, data, msg = receiver.usersvc.GetUser(
111 | 		ctx,
112 | 		userId,
113 | 		photo,
114 | 	)
115 | 	if msg != nil {
116 | 		if errors.Is(msg, context.Canceled) {
117 | 			http.Error(_writer, msg.Error(), http.StatusBadRequest)
118 | 		} else if _err, ok := msg.(*rest.BizError); ok {
119 | 			http.Error(_writer, _err.Error(), _err.StatusCode)
120 | 		} else {
121 | 			http.Error(_writer, msg.Error(), http.StatusInternalServerError)
122 | 		}
123 | 		return
124 | 	}
125 | 	if _err := json.NewEncoder(_writer).Encode(struct {
126 | 		Code int    `json:"code,omitempty"`
127 | 		Data string `json:"data,omitempty"`
128 | 	}{
129 | 		Code: code,
130 | 		Data: data,
131 | 	}); _err != nil {
132 | 		http.Error(_writer, _err.Error(), http.StatusInternalServerError)
133 | 		return
134 | 	}
135 | }
136 | func (receiver *UsersvcHandlerImpl) SignUp(_writer http.ResponseWriter, _req *http.Request) {
137 | 	var (
138 | 		ctx      context.Context
139 | 		username string
140 | 		password int
141 | 		actived  bool
142 | 		score    []int
143 | 		code     int
144 | 		data     string
145 | 		msg      error
146 | 	)
147 | 	ctx = _req.Context()
148 | 	if _err := _req.ParseForm(); _err != nil {
149 | 		http.Error(_writer, _err.Error(), http.StatusBadRequest)
150 | 		return
151 | 	}
152 | 	if _, exists := _req.Form["username"]; exists {
153 | 		username = _req.FormValue("username")
154 | 		if _err := rest.ValidateVar(username, "", "username"); _err != nil {
155 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
156 | 			return
157 | 		}
158 | 	} else {
159 | 		http.Error(_writer, "missing parameter username", http.StatusBadRequest)
160 | 		return
161 | 	}
162 | 	if _, exists := _req.Form["password"]; exists {
163 | 		if casted, _err := cast.ToIntE(_req.FormValue("password")); _err != nil {
164 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
165 | 			return
166 | 		} else {
167 | 			password = casted
168 | 		}
169 | 		if _err := rest.ValidateVar(password, "", "password"); _err != nil {
170 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
171 | 			return
172 | 		}
173 | 	} else {
174 | 		http.Error(_writer, "missing parameter password", http.StatusBadRequest)
175 | 		return
176 | 	}
177 | 	if _, exists := _req.Form["actived"]; exists {
178 | 		if casted, _err := cast.ToBoolE(_req.FormValue("actived")); _err != nil {
179 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
180 | 			return
181 | 		} else {
182 | 			actived = casted
183 | 		}
184 | 		if _err := rest.ValidateVar(actived, "", "actived"); _err != nil {
185 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
186 | 			return
187 | 		}
188 | 	} else {
189 | 		http.Error(_writer, "missing parameter actived", http.StatusBadRequest)
190 | 		return
191 | 	}
192 | 	if _, exists := _req.Form["score"]; exists {
193 | 		if casted, _err := cast.ToIntSliceE(_req.Form["score"]); _err != nil {
194 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
195 | 			return
196 | 		} else {
197 | 			score = casted
198 | 		}
199 | 		if _err := rest.ValidateVar(score, "", "score"); _err != nil {
200 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
201 | 			return
202 | 		}
203 | 	} else {
204 | 		if _, exists := _req.Form["score[]"]; exists {
205 | 			if casted, _err := cast.ToIntSliceE(_req.Form["score[]"]); _err != nil {
206 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
207 | 				return
208 | 			} else {
209 | 				score = casted
210 | 			}
211 | 			if _err := rest.ValidateVar(score, "", "score"); _err != nil {
212 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
213 | 				return
214 | 			}
215 | 		} else {
216 | 			http.Error(_writer, "missing parameter score", http.StatusBadRequest)
217 | 			return
218 | 		}
219 | 	}
220 | 	code, data, msg = receiver.usersvc.SignUp(
221 | 		ctx,
222 | 		username,
223 | 		password,
224 | 		actived,
225 | 		score,
226 | 	)
227 | 	if msg != nil {
228 | 		if errors.Is(msg, context.Canceled) {
229 | 			http.Error(_writer, msg.Error(), http.StatusBadRequest)
230 | 		} else if _err, ok := msg.(*rest.BizError); ok {
231 | 			http.Error(_writer, _err.Error(), _err.StatusCode)
232 | 		} else {
233 | 			http.Error(_writer, msg.Error(), http.StatusInternalServerError)
234 | 		}
235 | 		return
236 | 	}
237 | 	if _err := json.NewEncoder(_writer).Encode(struct {
238 | 		Code int    `json:"code,omitempty"`
239 | 		Data string `json:"data,omitempty"`
240 | 	}{
241 | 		Code: code,
242 | 		Data: data,
243 | 	}); _err != nil {
244 | 		http.Error(_writer, _err.Error(), http.StatusInternalServerError)
245 | 		return
246 | 	}
247 | }
248 | func (receiver *UsersvcHandlerImpl) UploadAvatar(_writer http.ResponseWriter, _req *http.Request) {
249 | 	var (
250 | 		pc  context.Context
251 | 		pf  []v3.FileModel
252 | 		ps  string
253 | 		pf2 v3.FileModel
254 | 		pf3 *multipart.FileHeader
255 | 		pf4 []*multipart.FileHeader
256 | 		ri  int
257 | 		ri2 interface{}
258 | 		re  error
259 | 	)
260 | 	pc = _req.Context()
261 | 	if _err := _req.ParseMultipartForm(32 << 20); _err != nil {
262 | 		http.Error(_writer, _err.Error(), http.StatusBadRequest)
263 | 		return
264 | 	}
265 | 	pfFileHeaders, exists := _req.MultipartForm.File["pf"]
266 | 	if exists {
267 | 		if len(pfFileHeaders) == 0 {
268 | 			http.Error(_writer, "no file uploaded for parameter pf", http.StatusBadRequest)
269 | 			return
270 | 		}
271 | 		for _, _fh := range pfFileHeaders {
272 | 			_f, _err := _fh.Open()
273 | 			if _err != nil {
274 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
275 | 				return
276 | 			}
277 | 			pf = append(pf, v3.FileModel{
278 | 				Filename: _fh.Filename,
279 | 				Reader:   _f,
280 | 			})
281 | 		}
282 | 	} else {
283 | 		http.Error(_writer, "missing parameter pf", http.StatusBadRequest)
284 | 		return
285 | 	}
286 | 	if _err := _req.ParseForm(); _err != nil {
287 | 		http.Error(_writer, _err.Error(), http.StatusBadRequest)
288 | 		return
289 | 	}
290 | 	if _, exists := _req.Form["ps"]; exists {
291 | 		ps = _req.FormValue("ps")
292 | 		if _err := rest.ValidateVar(ps, "", "ps"); _err != nil {
293 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
294 | 			return
295 | 		}
296 | 	} else {
297 | 		http.Error(_writer, "missing parameter ps", http.StatusBadRequest)
298 | 		return
299 | 	}
300 | 	pf2FileHeaders, exists := _req.MultipartForm.File["pf2"]
301 | 	if exists {
302 | 		if len(pf2FileHeaders) == 0 {
303 | 			http.Error(_writer, "no file uploaded for parameter pf2", http.StatusBadRequest)
304 | 			return
305 | 		}
306 | 		if len(pf2FileHeaders) > 0 {
307 | 			_fh := pf2FileHeaders[0]
308 | 			_f, _err := _fh.Open()
309 | 			if _err != nil {
310 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
311 | 				return
312 | 			}
313 | 			pf2 = v3.FileModel{
314 | 				Filename: _fh.Filename,
315 | 				Reader:   _f,
316 | 			}
317 | 		}
318 | 	} else {
319 | 		http.Error(_writer, "missing parameter pf2", http.StatusBadRequest)
320 | 		return
321 | 	}
322 | 	pf3Files := _req.MultipartForm.File["pf3"]
323 | 	if len(pf3Files) > 0 {
324 | 		pf3 = pf3Files[0]
325 | 	}
326 | 	pf4 = _req.MultipartForm.File["pf4"]
327 | 	ri, ri2, re = receiver.usersvc.UploadAvatar(
328 | 		pc,
329 | 		pf,
330 | 		ps,
331 | 		pf2,
332 | 		pf3,
333 | 		pf4,
334 | 	)
335 | 	if re != nil {
336 | 		if errors.Is(re, context.Canceled) {
337 | 			http.Error(_writer, re.Error(), http.StatusBadRequest)
338 | 		} else if _err, ok := re.(*rest.BizError); ok {
339 | 			http.Error(_writer, _err.Error(), _err.StatusCode)
340 | 		} else {
341 | 			http.Error(_writer, re.Error(), http.StatusInternalServerError)
342 | 		}
343 | 		return
344 | 	}
345 | 	if _err := json.NewEncoder(_writer).Encode(struct {
346 | 		Ri  int         `json:"ri,omitempty"`
347 | 		Ri2 interface{} `json:"ri2,omitempty"`
348 | 	}{
349 | 		Ri:  ri,
350 | 		Ri2: ri2,
351 | 	}); _err != nil {
352 | 		http.Error(_writer, _err.Error(), http.StatusInternalServerError)
353 | 		return
354 | 	}
355 | }
356 | func (receiver *UsersvcHandlerImpl) DownloadAvatar(_writer http.ResponseWriter, _req *http.Request) {
357 | 	var (
358 | 		ctx       context.Context
359 | 		userId    interface{}
360 | 		data      []byte
361 | 		userAttrs = new([]string)
362 | 		rf        *os.File
363 | 		re        error
364 | 	)
365 | 	ctx = _req.Context()
366 | 	if _req.Body == nil {
367 | 		http.Error(_writer, "missing request body", http.StatusBadRequest)
368 | 		return
369 | 	} else {
370 | 		if _err := json.NewDecoder(_req.Body).Decode(&userId); _err != nil {
371 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
372 | 			return
373 | 		} else {
374 | 			if _err := rest.ValidateVar(userId, "", ""); _err != nil {
375 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
376 | 				return
377 | 			}
378 | 		}
379 | 	}
380 | 	if _err := _req.ParseForm(); _err != nil {
381 | 		http.Error(_writer, _err.Error(), http.StatusBadRequest)
382 | 		return
383 | 	}
384 | 	if _, exists := _req.Form["data"]; exists {
385 | 		if casted, _err := cast.ToByteSliceE(_req.Form["data"]); _err != nil {
386 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
387 | 			return
388 | 		} else {
389 | 			data = casted
390 | 		}
391 | 		if _err := rest.ValidateVar(data, "", "data"); _err != nil {
392 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
393 | 			return
394 | 		}
395 | 	} else {
396 | 		if _, exists := _req.Form["data[]"]; exists {
397 | 			if casted, _err := cast.ToByteSliceE(_req.Form["data[]"]); _err != nil {
398 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
399 | 				return
400 | 			} else {
401 | 				data = casted
402 | 			}
403 | 			if _err := rest.ValidateVar(data, "", "data"); _err != nil {
404 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
405 | 				return
406 | 			}
407 | 		} else {
408 | 			http.Error(_writer, "missing parameter data", http.StatusBadRequest)
409 | 			return
410 | 		}
411 | 	}
412 | 	if _, exists := _req.Form["userAttrs"]; exists {
413 | 		_userAttrs := _req.Form["userAttrs"]
414 | 		userAttrs = &_userAttrs
415 | 		if _err := rest.ValidateVar(userAttrs, "", "userAttrs"); _err != nil {
416 | 			http.Error(_writer, _err.Error(), http.StatusBadRequest)
417 | 			return
418 | 		}
419 | 	} else {
420 | 		if _, exists := _req.Form["userAttrs[]"]; exists {
421 | 			_userAttrs := _req.Form["userAttrs[]"]
422 | 			userAttrs = &_userAttrs
423 | 			if _err := rest.ValidateVar(userAttrs, "", "userAttrs"); _err != nil {
424 | 				http.Error(_writer, _err.Error(), http.StatusBadRequest)
425 | 				return
426 | 			}
427 | 		}
428 | 	}
429 | 	rf, re = receiver.usersvc.DownloadAvatar(
430 | 		ctx,
431 | 		userId,
432 | 		data,
433 | 		*userAttrs...,
434 | 	)
435 | 	if re != nil {
436 | 		if errors.Is(re, context.Canceled) {
437 | 			http.Error(_writer, re.Error(), http.StatusBadRequest)
438 | 		} else if _err, ok := re.(*rest.BizError); ok {
439 | 			http.Error(_writer, _err.Error(), _err.StatusCode)
440 | 		} else {
441 | 			http.Error(_writer, re.Error(), http.StatusInternalServerError)
442 | 		}
443 | 		return
444 | 	}
445 | 	if rf == nil {
446 | 		http.Error(_writer, "No file returned", http.StatusInternalServerError)
447 | 		return
448 | 	}
449 | 	defer rf.Close()
450 | 	var _fi os.FileInfo
451 | 	_fi, _err := rf.Stat()
452 | 	if _err != nil {
453 | 		http.Error(_writer, _err.Error(), http.StatusInternalServerError)
454 | 		return
455 | 	}
456 | 	_writer.Header().Set("Content-Disposition", "attachment; filename="+_fi.Name())
457 | 	_writer.Header().Set("Content-Type", "application/octet-stream")
458 | 	_writer.Header().Set("Content-Length", fmt.Sprintf("%d", _fi.Size()))
459 | 	io.Copy(_writer, rf)
460 | }
461 | 
462 | func NewUsersvcHandler(usersvc service.Usersvc) UsersvcHandler {
463 | 	return &UsersvcHandlerImpl{
464 | 		usersvc,
465 | 	}
466 | }
```

cmd/internal/svc/testdata/outputanonystruct/transport/grpc/usersvc.pb.go
```
1 | //*
2 | // Generated by go-doudou v2.4.2.
3 | // Don't edit!
4 | //
5 | // Version No.: v20240926
6 | 
7 | // Code generated by protoc-gen-go. DO NOT EDIT.
8 | // versions:
9 | // 	protoc-gen-go v1.28.1
10 | // 	protoc        v3.21.7
11 | // source: transport/grpc/usersvc.proto
12 | 
13 | package grpc
14 | 
15 | import (
16 | 	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
17 | 	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
18 | 	structpb "google.golang.org/protobuf/types/known/structpb"
19 | 	reflect "reflect"
20 | 	sync "sync"
21 | )
22 | 
23 | const (
24 | 	// Verify that this generated code is sufficiently up-to-date.
25 | 	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
26 | 	// Verify that runtime/protoimpl is sufficiently up-to-date.
27 | 	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
28 | )
29 | 
30 | type KeyboardLayout int32
31 | 
32 | const (
33 | 	KeyboardLayout_UNKNOWN KeyboardLayout = 0
34 | 	KeyboardLayout_QWERTZ  KeyboardLayout = 1
35 | 	KeyboardLayout_AZERTY  KeyboardLayout = 2
36 | 	KeyboardLayout_QWERTY  KeyboardLayout = 3
37 | )
38 | 
39 | // Enum value maps for KeyboardLayout.
40 | var (
41 | 	KeyboardLayout_name = map[int32]string{
42 | 		0: "UNKNOWN",
43 | 		1: "QWERTZ",
44 | 		2: "AZERTY",
45 | 		3: "QWERTY",
46 | 	}
47 | 	KeyboardLayout_value = map[string]int32{
48 | 		"UNKNOWN": 0,
49 | 		"QWERTZ":  1,
50 | 		"AZERTY":  2,
51 | 		"QWERTY":  3,
52 | 	}
53 | )
54 | 
55 | func (x KeyboardLayout) Enum() *KeyboardLayout {
56 | 	p := new(KeyboardLayout)
57 | 	*p = x
58 | 	return p
59 | }
60 | 
61 | func (x KeyboardLayout) String() string {
62 | 	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
63 | }
64 | 
65 | func (KeyboardLayout) Descriptor() protoreflect.EnumDescriptor {
66 | 	return file_transport_grpc_usersvc_proto_enumTypes[0].Descriptor()
67 | }
68 | 
69 | func (KeyboardLayout) Type() protoreflect.EnumType {
70 | 	return &file_transport_grpc_usersvc_proto_enumTypes[0]
71 | }
72 | 
73 | func (x KeyboardLayout) Number() protoreflect.EnumNumber {
74 | 	return protoreflect.EnumNumber(x)
75 | }
76 | 
77 | // Deprecated: Use KeyboardLayout.Descriptor instead.
78 | func (KeyboardLayout) EnumDescriptor() ([]byte, []int) {
79 | 	return file_transport_grpc_usersvc_proto_rawDescGZIP(), []int{0}
80 | }
81 | 
82 | type Anonystructkfvagz8UXPWVpn5Z9XyjWS struct {
83 | 	state         protoimpl.MessageState
84 | 	sizeCache     protoimpl.SizeCache
85 | 	unknownFields protoimpl.UnknownFields
86 | 
87 | 	Label *string `protobuf:"bytes,1,opt,name=label,proto3,oneof" json:"label,omitempty"`
88 | 	Value *string `protobuf:"bytes,2,opt,name=value,proto3,oneof" json:"value,omitempty"`
89 | }
90 | 
91 | func (x *Anonystructkfvagz8UXPWVpn5Z9XyjWS) Reset() {
92 | 	*x = Anonystructkfvagz8UXPWVpn5Z9XyjWS{}
93 | 	if protoimpl.UnsafeEnabled {
94 | 		mi := &file_transport_grpc_usersvc_proto_msgTypes[0]
95 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
96 | 		ms.StoreMessageInfo(mi)
97 | 	}
98 | }
99 | 
100 | func (x *Anonystructkfvagz8UXPWVpn5Z9XyjWS) String() string {
101 | 	return protoimpl.X.MessageStringOf(x)
102 | }
103 | 
104 | func (*Anonystructkfvagz8UXPWVpn5Z9XyjWS) ProtoMessage() {}
105 | 
106 | func (x *Anonystructkfvagz8UXPWVpn5Z9XyjWS) ProtoReflect() protoreflect.Message {
107 | 	mi := &file_transport_grpc_usersvc_proto_msgTypes[0]
108 | 	if protoimpl.UnsafeEnabled && x != nil {
109 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
110 | 		if ms.LoadMessageInfo() == nil {
111 | 			ms.StoreMessageInfo(mi)
112 | 		}
113 | 		return ms
114 | 	}
115 | 	return mi.MessageOf(x)
116 | }
117 | 
118 | // Deprecated: Use Anonystructkfvagz8UXPWVpn5Z9XyjWS.ProtoReflect.Descriptor instead.
119 | func (*Anonystructkfvagz8UXPWVpn5Z9XyjWS) Descriptor() ([]byte, []int) {
120 | 	return file_transport_grpc_usersvc_proto_rawDescGZIP(), []int{0}
121 | }
122 | 
123 | func (x *Anonystructkfvagz8UXPWVpn5Z9XyjWS) GetLabel() string {
124 | 	if x != nil && x.Label != nil {
125 | 		return *x.Label
126 | 	}
127 | 	return ""
128 | }
129 | 
130 | func (x *Anonystructkfvagz8UXPWVpn5Z9XyjWS) GetValue() string {
131 | 	if x != nil && x.Value != nil {
132 | 		return *x.Value
133 | 	}
134 | 	return ""
135 | }
136 | 
137 | // 排序条件
138 | type Order struct {
139 | 	state         protoimpl.MessageState
140 | 	sizeCache     protoimpl.SizeCache
141 | 	unknownFields protoimpl.UnknownFields
142 | 
143 | 	Col  *string `protobuf:"bytes,1,opt,name=col,proto3,oneof" json:"col,omitempty"`
144 | 	Sort *string `protobuf:"bytes,2,opt,name=sort,proto3,oneof" json:"sort,omitempty"`
145 | }
146 | 
147 | func (x *Order) Reset() {
148 | 	*x = Order{}
149 | 	if protoimpl.UnsafeEnabled {
150 | 		mi := &file_transport_grpc_usersvc_proto_msgTypes[1]
151 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
152 | 		ms.StoreMessageInfo(mi)
153 | 	}
154 | }
155 | 
156 | func (x *Order) String() string {
157 | 	return protoimpl.X.MessageStringOf(x)
158 | }
159 | 
160 | func (*Order) ProtoMessage() {}
161 | 
162 | func (x *Order) ProtoReflect() protoreflect.Message {
163 | 	mi := &file_transport_grpc_usersvc_proto_msgTypes[1]
164 | 	if protoimpl.UnsafeEnabled && x != nil {
165 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
166 | 		if ms.LoadMessageInfo() == nil {
167 | 			ms.StoreMessageInfo(mi)
168 | 		}
169 | 		return ms
170 | 	}
171 | 	return mi.MessageOf(x)
172 | }
173 | 
174 | // Deprecated: Use Order.ProtoReflect.Descriptor instead.
175 | func (*Order) Descriptor() ([]byte, []int) {
176 | 	return file_transport_grpc_usersvc_proto_rawDescGZIP(), []int{1}
177 | }
178 | 
179 | func (x *Order) GetCol() string {
180 | 	if x != nil && x.Col != nil {
181 | 		return *x.Col
182 | 	}
183 | 	return ""
184 | }
185 | 
186 | func (x *Order) GetSort() string {
187 | 	if x != nil && x.Sort != nil {
188 | 		return *x.Sort
189 | 	}
190 | 	return ""
191 | }
192 | 
193 | type Page struct {
194 | 	state         protoimpl.MessageState
195 | 	sizeCache     protoimpl.SizeCache
196 | 	unknownFields protoimpl.UnknownFields
197 | 
198 | 	// 排序规则
199 | 	Orders []*Order `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty"`
200 | 	// 页码
201 | 	PageNo *int32 `protobuf:"varint,2,opt,name=page_no,proto3,oneof" json:"page_no,omitempty"`
202 | 	// 每页行数
203 | 	Size *int32  `protobuf:"varint,3,opt,name=size,json=size,omitempty,proto3,oneof" json:"size,omitempty"`
204 | 	User *UserVo `protobuf:"bytes,4,opt,name=user,proto3,oneof" json:"user,omitempty"`
205 | }
206 | 
207 | func (x *Page) Reset() {
208 | 	*x = Page{}
209 | 	if protoimpl.UnsafeEnabled {
210 | 		mi := &file_transport_grpc_usersvc_proto_msgTypes[2]
211 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
212 | 		ms.StoreMessageInfo(mi)
213 | 	}
214 | }
215 | 
216 | func (x *Page) String() string {
217 | 	return protoimpl.X.MessageStringOf(x)
218 | }
219 | 
220 | func (*Page) ProtoMessage() {}
221 | 
222 | func (x *Page) ProtoReflect() protoreflect.Message {
223 | 	mi := &file_transport_grpc_usersvc_proto_msgTypes[2]
224 | 	if protoimpl.UnsafeEnabled && x != nil {
225 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
226 | 		if ms.LoadMessageInfo() == nil {
227 | 			ms.StoreMessageInfo(mi)
228 | 		}
229 | 		return ms
230 | 	}
231 | 	return mi.MessageOf(x)
232 | }
233 | 
234 | // Deprecated: Use Page.ProtoReflect.Descriptor instead.
235 | func (*Page) Descriptor() ([]byte, []int) {
236 | 	return file_transport_grpc_usersvc_proto_rawDescGZIP(), []int{2}
237 | }
238 | 
239 | func (x *Page) GetOrders() []*Order {
240 | 	if x != nil {
241 | 		return x.Orders
242 | 	}
243 | 	return nil
244 | }
245 | 
246 | func (x *Page) GetPageNo() int32 {
247 | 	if x != nil && x.PageNo != nil {
248 | 		return *x.PageNo
249 | 	}
250 | 	return 0
251 | }
252 | 
253 | func (x *Page) GetSize() int32 {
254 | 	if x != nil && x.Size != nil {
255 | 		return *x.Size
256 | 	}
257 | 	return 0
258 | }
259 | 
260 | func (x *Page) GetUser() *UserVo {
261 | 	if x != nil {
262 | 		return x.User
263 | 	}
264 | 	return nil
265 | }
266 | 
267 | // 筛选条件
268 | type PageFilter struct {
269 | 	state         protoimpl.MessageState
270 | 	sizeCache     protoimpl.SizeCache
271 | 	unknownFields protoimpl.UnknownFields
272 | 
273 | 	// 真实姓名，前缀匹配
274 | 	Name *string `protobuf:"bytes,1,opt,name=name,proto3,oneof" json:"name,omitempty"`
275 | 	// 所属部门ID
276 | 	Dept *int32 `protobuf:"varint,2,opt,name=dept,proto3,oneof" json:"dept,omitempty"`
277 | }
278 | 
279 | func (x *PageFilter) Reset() {
280 | 	*x = PageFilter{}
281 | 	if protoimpl.UnsafeEnabled {
282 | 		mi := &file_transport_grpc_usersvc_proto_msgTypes[3]
283 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
284 | 		ms.StoreMessageInfo(mi)
285 | 	}
286 | }
287 | 
288 | func (x *PageFilter) String() string {
289 | 	return protoimpl.X.MessageStringOf(x)
290 | }
291 | 
292 | func (*PageFilter) ProtoMessage() {}
293 | 
294 | func (x *PageFilter) ProtoReflect() protoreflect.Message {
295 | 	mi := &file_transport_grpc_usersvc_proto_msgTypes[3]
296 | 	if protoimpl.UnsafeEnabled && x != nil {
297 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
298 | 		if ms.LoadMessageInfo() == nil {
299 | 			ms.StoreMessageInfo(mi)
300 | 		}
301 | 		return ms
302 | 	}
303 | 	return mi.MessageOf(x)
304 | }
305 | 
306 | // Deprecated: Use PageFilter.ProtoReflect.Descriptor instead.
307 | func (*PageFilter) Descriptor() ([]byte, []int) {
308 | 	return file_transport_grpc_usersvc_proto_rawDescGZIP(), []int{3}
309 | }
310 | 
311 | func (x *PageFilter) GetName() string {
312 | 	if x != nil && x.Name != nil {
313 | 		return *x.Name
314 | 	}
315 | 	return ""
316 | }
317 | 
318 | func (x *PageFilter) GetDept() int32 {
319 | 	if x != nil && x.Dept != nil {
320 | 		return *x.Dept
321 | 	}
322 | 	return 0
323 | }
324 | 
325 | // 分页筛选条件
326 | type PageQuery struct {
327 | 	state         protoimpl.MessageState
328 | 	sizeCache     protoimpl.SizeCache
329 | 	unknownFields protoimpl.UnknownFields
330 | 
331 | 	Filter     *PageFilter                          `protobuf:"bytes,1,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
332 | 	Page       *Page                                `protobuf:"bytes,2,opt,name=page,proto3,oneof" json:"page,omitempty"`
333 | 	Condtions  *structpb.Struct                     `protobuf:"bytes,3,opt,name=condtions,proto3,oneof" json:"condtions,omitempty"`
334 | 	ACondtions *structpb.ListValue                  `protobuf:"bytes,4,opt,name=a_condtions,proto3,oneof" json:"a_condtions,omitempty"`
335 | 	Id         *int64                               `protobuf:"varint,5,opt,name=id,json=id,string,proto3,oneof" json:"id,omitempty"`
336 | 	Options    []*Anonystructkfvagz8UXPWVpn5Z9XyjWS `protobuf:"bytes,6,rep,name=options,proto3" json:"options,omitempty"`
337 | }
338 | 
339 | func (x *PageQuery) Reset() {
340 | 	*x = PageQuery{}
341 | 	if protoimpl.UnsafeEnabled {
342 | 		mi := &file_transport_grpc_usersvc_proto_msgTypes[4]
343 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
344 | 		ms.StoreMessageInfo(mi)
345 | 	}
346 | }
347 | 
348 | func (x *PageQuery) String() string {
349 | 	return protoimpl.X.MessageStringOf(x)
350 | }
351 | 
352 | func (*PageQuery) ProtoMessage() {}
353 | 
354 | func (x *PageQuery) ProtoReflect() protoreflect.Message {
355 | 	mi := &file_transport_grpc_usersvc_proto_msgTypes[4]
356 | 	if protoimpl.UnsafeEnabled && x != nil {
357 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
358 | 		if ms.LoadMessageInfo() == nil {
359 | 			ms.StoreMessageInfo(mi)
360 | 		}
361 | 		return ms
362 | 	}
363 | 	return mi.MessageOf(x)
364 | }
365 | 
366 | // Deprecated: Use PageQuery.ProtoReflect.Descriptor instead.
367 | func (*PageQuery) Descriptor() ([]byte, []int) {
368 | 	return file_transport_grpc_usersvc_proto_rawDescGZIP(), []int{4}
369 | }
370 | 
371 | func (x *PageQuery) GetFilter() *PageFilter {
372 | 	if x != nil {
373 | 		return x.Filter
374 | 	}
375 | 	return nil
376 | }
377 | 
378 | func (x *PageQuery) GetPage() *Page {
379 | 	if x != nil {
380 | 		return x.Page
381 | 	}
382 | 	return nil
383 | }
384 | 
385 | func (x *PageQuery) GetCondtions() *structpb.Struct {
386 | 	if x != nil {
387 | 		return x.Condtions
388 | 	}
389 | 	return nil
390 | }
391 | 
392 | func (x *PageQuery) GetACondtions() *structpb.ListValue {
393 | 	if x != nil {
394 | 		return x.ACondtions
395 | 	}
396 | 	return nil
397 | }
398 | 
399 | func (x *PageQuery) GetId() int64 {
400 | 	if x != nil && x.Id != nil {
401 | 		return *x.Id
402 | 	}
403 | 	return 0
404 | }
405 | 
406 | func (x *PageQuery) GetOptions() []*Anonystructkfvagz8UXPWVpn5Z9XyjWS {
407 | 	if x != nil {
408 | 		return x.Options
409 | 	}
410 | 	return nil
411 | }
412 | 
413 | type PageRet struct {
414 | 	state         protoimpl.MessageState
415 | 	sizeCache     protoimpl.SizeCache
416 | 	unknownFields protoimpl.UnknownFields
417 | 
418 | 	Items    *structpb.Value `protobuf:"bytes,1,opt,name=items,proto3,oneof" json:"items,omitempty"`
419 | 	PageNo   *int32          `protobuf:"varint,2,opt,name=page_no,proto3,oneof" json:"page_no,omitempty"`
420 | 	PageSize *int32          `protobuf:"varint,3,opt,name=page_size,proto3,oneof" json:"page_size,omitempty"`
421 | 	Total    *int32          `protobuf:"varint,4,opt,name=total,proto3,oneof" json:"total,omitempty"`
422 | 	HasNext  *bool           `protobuf:"varint,5,opt,name=has_next,proto3,oneof" json:"has_next,omitempty"`
423 | }
424 | 
425 | func (x *PageRet) Reset() {
426 | 	*x = PageRet{}
427 | 	if protoimpl.UnsafeEnabled {
428 | 		mi := &file_transport_grpc_usersvc_proto_msgTypes[5]
429 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
430 | 		ms.StoreMessageInfo(mi)
431 | 	}
432 | }
433 | 
434 | func (x *PageRet) String() string {
435 | 	return protoimpl.X.MessageStringOf(x)
436 | }
437 | 
438 | func (*PageRet) ProtoMessage() {}
439 | 
440 | func (x *PageRet) ProtoReflect() protoreflect.Message {
441 | 	mi := &file_transport_grpc_usersvc_proto_msgTypes[5]
442 | 	if protoimpl.UnsafeEnabled && x != nil {
443 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
444 | 		if ms.LoadMessageInfo() == nil {
445 | 			ms.StoreMessageInfo(mi)
446 | 		}
447 | 		return ms
448 | 	}
449 | 	return mi.MessageOf(x)
450 | }
451 | 
452 | // Deprecated: Use PageRet.ProtoReflect.Descriptor instead.
453 | func (*PageRet) Descriptor() ([]byte, []int) {
454 | 	return file_transport_grpc_usersvc_proto_rawDescGZIP(), []int{5}
455 | }
456 | 
457 | func (x *PageRet) GetItems() *structpb.Value {
458 | 	if x != nil {
459 | 		return x.Items
460 | 	}
461 | 	return nil
462 | }
463 | 
464 | func (x *PageRet) GetPageNo() int32 {
465 | 	if x != nil && x.PageNo != nil {
466 | 		return *x.PageNo
467 | 	}
468 | 	return 0
469 | }
470 | 
471 | func (x *PageRet) GetPageSize() int32 {
472 | 	if x != nil && x.PageSize != nil {
473 | 		return *x.PageSize
474 | 	}
475 | 	return 0
476 | }
477 | 
478 | func (x *PageRet) GetTotal() int32 {
479 | 	if x != nil && x.Total != nil {
480 | 		return *x.Total
481 | 	}
482 | 	return 0
483 | }
484 | 
485 | func (x *PageRet) GetHasNext() bool {
486 | 	if x != nil && x.HasNext != nil {
487 | 		return *x.HasNext
488 | 	}
489 | 	return false
490 | }
491 | 
492 | type UserVo struct {
493 | 	state         protoimpl.MessageState
494 | 	sizeCache     protoimpl.SizeCache
495 | 	unknownFields protoimpl.UnknownFields
496 | 
497 | 	Id    *int32  `protobuf:"varint,1,opt,name=id,proto3,oneof" json:"id,omitempty"`
498 | 	Name  *string `protobuf:"bytes,2,opt,name=name,proto3,oneof" json:"name,omitempty"`
499 | 	Phone *string `protobuf:"bytes,3,opt,name=phone,proto3,oneof" json:"phone,omitempty"`
500 | 	Dept  *string `protobuf:"bytes,4,opt,name=dept,proto3,oneof" json:"dept,omitempty"`
501 | }
502 | 
503 | func (x *UserVo) Reset() {
504 | 	*x = UserVo{}
505 | 	if protoimpl.UnsafeEnabled {
506 | 		mi := &file_transport_grpc_usersvc_proto_msgTypes[6]
507 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
508 | 		ms.StoreMessageInfo(mi)
509 | 	}
510 | }
511 | 
512 | func (x *UserVo) String() string {
513 | 	return protoimpl.X.MessageStringOf(x)
514 | }
515 | 
516 | func (*UserVo) ProtoMessage() {}
517 | 
518 | func (x *UserVo) ProtoReflect() protoreflect.Message {
519 | 	mi := &file_transport_grpc_usersvc_proto_msgTypes[6]
520 | 	if protoimpl.UnsafeEnabled && x != nil {
521 | 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
522 | 		if ms.LoadMessageInfo() == nil {
523 | 			ms.StoreMessageInfo(mi)
524 | 		}
525 | 		return ms
526 | 	}
527 | 	return mi.MessageOf(x)
528 | }
529 | 
530 | // Deprecated: Use UserVo.ProtoReflect.Descriptor instead.
531 | func (*UserVo) Descriptor() ([]byte, []int) {
532 | 	return file_transport_grpc_usersvc_proto_rawDescGZIP(), []int{6}
533 | }
534 | 
535 | func (x *UserVo) GetId() int32 {
536 | 	if x != nil && x.Id != nil {
537 | 		return *x.Id
538 | 	}
539 | 	return 0
540 | }
541 | 
542 | func (x *UserVo) GetName() string {
543 | 	if x != nil && x.Name != nil {
544 | 		return *x.Name
545 | 	}
546 | 	return ""
547 | }
548 | 
549 | func (x *UserVo) GetPhone() string {
[TRUNCATED]
```

cmd/internal/svc/testdata/outputanonystruct/transport/grpc/usersvc.pb.json.go
```
1 | //*
2 | // Generated by go-doudou v2.4.2.
3 | // Don't edit!
4 | //
5 | // Version No.: v20240926
6 | 
7 | // Code generated by protoc-gen-go-json. DO NOT EDIT.
8 | // source: transport/grpc/usersvc.proto
9 | 
10 | package grpc
11 | 
12 | import (
13 | 	"google.golang.org/protobuf/encoding/protojson"
14 | )
15 | 
16 | // MarshalJSON implements json.Marshaler
17 | func (msg *Anonystructkfvagz8UXPWVpn5Z9XyjWS) MarshalJSON() ([]byte, error) {
18 | 	return protojson.MarshalOptions{}.Marshal(msg)
19 | }
20 | 
21 | // UnmarshalJSON implements json.Unmarshaler
22 | func (msg *Anonystructkfvagz8UXPWVpn5Z9XyjWS) UnmarshalJSON(b []byte) error {
23 | 	return protojson.UnmarshalOptions{}.Unmarshal(b, msg)
24 | }
25 | 
26 | // MarshalJSON implements json.Marshaler
27 | func (msg *Order) MarshalJSON() ([]byte, error) {
28 | 	return protojson.MarshalOptions{}.Marshal(msg)
29 | }
30 | 
31 | // UnmarshalJSON implements json.Unmarshaler
32 | func (msg *Order) UnmarshalJSON(b []byte) error {
33 | 	return protojson.UnmarshalOptions{}.Unmarshal(b, msg)
34 | }
35 | 
36 | // MarshalJSON implements json.Marshaler
37 | func (msg *Page) MarshalJSON() ([]byte, error) {
38 | 	return protojson.MarshalOptions{}.Marshal(msg)
39 | }
40 | 
41 | // UnmarshalJSON implements json.Unmarshaler
42 | func (msg *Page) UnmarshalJSON(b []byte) error {
43 | 	return protojson.UnmarshalOptions{}.Unmarshal(b, msg)
44 | }
45 | 
46 | // MarshalJSON implements json.Marshaler
47 | func (msg *PageFilter) MarshalJSON() ([]byte, error) {
48 | 	return protojson.MarshalOptions{}.Marshal(msg)
49 | }
50 | 
51 | // UnmarshalJSON implements json.Unmarshaler
52 | func (msg *PageFilter) UnmarshalJSON(b []byte) error {
53 | 	return protojson.UnmarshalOptions{}.Unmarshal(b, msg)
54 | }
55 | 
56 | // MarshalJSON implements json.Marshaler
57 | func (msg *PageQuery) MarshalJSON() ([]byte, error) {
58 | 	return protojson.MarshalOptions{}.Marshal(msg)
59 | }
60 | 
61 | // UnmarshalJSON implements json.Unmarshaler
62 | func (msg *PageQuery) UnmarshalJSON(b []byte) error {
63 | 	return protojson.UnmarshalOptions{}.Unmarshal(b, msg)
64 | }
65 | 
66 | // MarshalJSON implements json.Marshaler
67 | func (msg *PageRet) MarshalJSON() ([]byte, error) {
68 | 	return protojson.MarshalOptions{}.Marshal(msg)
69 | }
70 | 
71 | // UnmarshalJSON implements json.Unmarshaler
72 | func (msg *PageRet) UnmarshalJSON(b []byte) error {
73 | 	return protojson.UnmarshalOptions{}.Unmarshal(b, msg)
74 | }
75 | 
76 | // MarshalJSON implements json.Marshaler
77 | func (msg *UserVo) MarshalJSON() ([]byte, error) {
78 | 	return protojson.MarshalOptions{}.Marshal(msg)
79 | }
80 | 
81 | // UnmarshalJSON implements json.Unmarshaler
82 | func (msg *UserVo) UnmarshalJSON(b []byte) error {
83 | 	return protojson.UnmarshalOptions{}.Unmarshal(b, msg)
84 | }
```

cmd/internal/svc/testdata/outputanonystruct/transport/grpc/usersvc.proto
```
1 | /**
2 | * Generated by go-doudou v2.4.2.
3 | * Don't edit!
4 | *
5 | * Version No.: v20240926
6 | */
7 | syntax = "proto3";
8 | 
9 | package usersvc;
10 | option go_package = "github.com/unionj-cloud/go-doudou/v2/cmd/internal/svc/testdata/outputanonystruct/transport/grpc";
11 | 
12 | import "google/protobuf/struct.proto";
13 | 
14 | enum KeyboardLayout {
15 |   UNKNOWN = 0;
16 |   QWERTZ = 1;
17 |   AZERTY = 2;
18 |   QWERTY = 3;
19 | }
20 | 
21 | message Anonystructkfvagz8uXPWVpn5z9xyjWS {
22 |   optional string label = 1 [json_name="label"];
23 |   optional string value = 2 [json_name="value"];
24 | }
25 | 
26 | // 排序条件
27 | message Order {
28 |   optional string col = 1 [json_name="col"];
29 |   optional string sort = 2 [json_name="sort"];
30 | }
31 | 
32 | message Page {
33 |   // 排序规则
34 |   repeated Order orders = 1 [json_name="orders"];
35 |   // 页码
36 |   optional int32 page_no = 2 [json_name="page_no"];
37 |   // 每页行数
38 |   optional int32 size = 3 [json_name="size,omitempty"];
39 |   optional UserVo user = 4 [json_name="user"];
40 | }
41 | 
42 | // 筛选条件
43 | message PageFilter {
44 |   // 真实姓名，前缀匹配
45 |   optional string name = 1 [json_name="name"];
46 |   // 所属部门ID
47 |   optional int32 dept = 2 [json_name="dept"];
48 | }
49 | 
50 | // 分页筛选条件
51 | message PageQuery {
52 |   optional PageFilter filter = 1 [json_name="filter"];
53 |   optional Page page = 2 [json_name="page"];
54 |   optional google.protobuf.Struct condtions = 3 [json_name="condtions"];
55 |   optional google.protobuf.ListValue a_condtions = 4 [json_name="a_condtions"];
56 |   optional int64 id = 5 [json_name="id,string"];
57 |   repeated Anonystructkfvagz8uXPWVpn5z9xyjWS options = 6 [json_name="options"];
58 | }
59 | 
60 | message PageRet {
61 |   optional google.protobuf.Value items = 1 [json_name="items"];
62 |   optional int32 page_no = 2 [json_name="page_no"];
63 |   optional int32 page_size = 3 [json_name="page_size"];
64 |   optional int32 total = 4 [json_name="total"];
65 |   optional bool has_next = 5 [json_name="has_next"];
66 | }
67 | 
68 | message UserVo {
69 |   optional int32 id = 1 [json_name="id"];
70 |   optional string name = 2 [json_name="name"];
71 |   optional string phone = 3 [json_name="phone"];
72 |   optional string dept = 4 [json_name="dept"];
73 | }
74 | 
75 | service UsersvcService {
76 |   // You can define your service methods as your need. Below is an example.
77 |   rpc PageUsersRpc(PageQuery) returns (Page);
78 | }
```

cmd/internal/svc/testdata/outputanonystruct/transport/grpc/usersvc_grpc.pb.go
```
1 | // Code generated by protoc-gen-go-grpc. DO NOT EDIT.
2 | // versions:
3 | // - protoc-gen-go-grpc v1.2.0
4 | // - protoc             v3.21.7
5 | // source: transport/grpc/usersvc.proto
6 | 
7 | package grpc
8 | 
9 | import (
10 | 	context "context"
11 | 	grpc "google.golang.org/grpc"
12 | 	codes "google.golang.org/grpc/codes"
13 | 	status "google.golang.org/grpc/status"
14 | )
15 | 
16 | // This is a compile-time assertion to ensure that this generated file
17 | // is compatible with the grpc package it is being compiled against.
18 | // Requires gRPC-Go v1.32.0 or later.
19 | const _ = grpc.SupportPackageIsVersion7
20 | 
21 | // UsersvcServiceClient is the client API for UsersvcService service.
22 | //
23 | // For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
24 | type UsersvcServiceClient interface {
25 | 	// You can define your service methods as your need. Below is an example.
26 | 	PageUsersRpc(ctx context.Context, in *PageQuery, opts ...grpc.CallOption) (*Page, error)
27 | }
28 | 
29 | type usersvcServiceClient struct {
30 | 	cc grpc.ClientConnInterface
31 | }
32 | 
33 | func NewUsersvcServiceClient(cc grpc.ClientConnInterface) UsersvcServiceClient {
34 | 	return &usersvcServiceClient{cc}
35 | }
36 | 
37 | func (c *usersvcServiceClient) PageUsersRpc(ctx context.Context, in *PageQuery, opts ...grpc.CallOption) (*Page, error) {
38 | 	out := new(Page)
39 | 	err := c.cc.Invoke(ctx, "/usersvc.UsersvcService/PageUsersRpc", in, out, opts...)
40 | 	if err != nil {
41 | 		return nil, err
42 | 	}
43 | 	return out, nil
44 | }
45 | 
46 | // UsersvcServiceServer is the server API for UsersvcService service.
47 | // All implementations must embed UnimplementedUsersvcServiceServer
48 | // for forward compatibility
49 | type UsersvcServiceServer interface {
50 | 	// You can define your service methods as your need. Below is an example.
51 | 	PageUsersRpc(context.Context, *PageQuery) (*Page, error)
52 | 	mustEmbedUnimplementedUsersvcServiceServer()
53 | }
54 | 
55 | // UnimplementedUsersvcServiceServer must be embedded to have forward compatible implementations.
56 | type UnimplementedUsersvcServiceServer struct {
57 | }
58 | 
59 | func (UnimplementedUsersvcServiceServer) PageUsersRpc(context.Context, *PageQuery) (*Page, error) {
60 | 	return nil, status.Errorf(codes.Unimplemented, "method PageUsersRpc not implemented")
61 | }
62 | func (UnimplementedUsersvcServiceServer) mustEmbedUnimplementedUsersvcServiceServer() {}
63 | 
64 | // UnsafeUsersvcServiceServer may be embedded to opt out of forward compatibility for this service.
65 | // Use of this interface is not recommended, as added methods to UsersvcServiceServer will
66 | // result in compilation errors.
67 | type UnsafeUsersvcServiceServer interface {
68 | 	mustEmbedUnimplementedUsersvcServiceServer()
69 | }
70 | 
71 | func RegisterUsersvcServiceServer(s grpc.ServiceRegistrar, srv UsersvcServiceServer) {
72 | 	s.RegisterService(&UsersvcService_ServiceDesc, srv)
73 | }
74 | 
75 | func _UsersvcService_PageUsersRpc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
76 | 	in := new(PageQuery)
77 | 	if err := dec(in); err != nil {
78 | 		return nil, err
79 | 	}
80 | 	if interceptor == nil {
81 | 		return srv.(UsersvcServiceServer).PageUsersRpc(ctx, in)
82 | 	}
83 | 	info := &grpc.UnaryServerInfo{
84 | 		Server:     srv,
85 | 		FullMethod: "/usersvc.UsersvcService/PageUsersRpc",
86 | 	}
87 | 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
88 | 		return srv.(UsersvcServiceServer).PageUsersRpc(ctx, req.(*PageQuery))
89 | 	}
90 | 	return interceptor(ctx, in, info, handler)
91 | }
92 | 
93 | // UsersvcService_ServiceDesc is the grpc.ServiceDesc for UsersvcService service.
94 | // It's only intended for direct use with grpc.RegisterService,
95 | // and not to be introspected or modified (even as a copy)
96 | var UsersvcService_ServiceDesc = grpc.ServiceDesc{
97 | 	ServiceName: "usersvc.UsersvcService",
98 | 	HandlerType: (*UsersvcServiceServer)(nil),
99 | 	Methods: []grpc.MethodDesc{
100 | 		{
101 | 			MethodName: "PageUsersRpc",
102 | 			Handler:    _UsersvcService_PageUsersRpc_Handler,
103 | 		},
104 | 	},
105 | 	Streams:  []grpc.StreamDesc{},
106 | 	Metadata: "transport/grpc/usersvc.proto",
107 | }
```

</current_codebase>
